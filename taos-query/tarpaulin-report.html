<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","2.0","src","connector","odbc","examples","rust","main","src","main.rs"],"content":"extern crate odbc;\n// Use this crate and set environmet variable RUST_LOG=odbc to see ODBC warnings\nextern crate env_logger;\nuse odbc::*;\nuse odbc_safe::AutocommitOn;\nuse std::env;\n\nfn main() {\n\n    env_logger::init();\n\n    let conn_str = env::var(\"DSN\").unwrap();\n    match connect(\u0026conn_str) {\n        Ok(()) =\u003e println!(\"Success\"),\n        Err(diag) =\u003e println!(\"Error: {}\", diag),\n    }\n}\n\nfn connect(conn_str: \u0026str) -\u003e std::result::Result\u003c(), DiagnosticRecord\u003e {\n\n    let env = create_environment_v3().map_err(|e| e.unwrap())?;\n\n    let conn = env.connect_with_connection_string(conn_str)?;\n    execute_statement(\u0026conn)\n}\n\nfn execute_statement\u003c'env\u003e(conn: \u0026Connection\u003c'env, AutocommitOn\u003e) -\u003e Result\u003c()\u003e {\n    let stmt = Statement::with_parent(conn)?;\n\n    match stmt.exec_direct(\"select * from m.t\")? {\n        Data(mut stmt) =\u003e {\n            let cols = stmt.num_result_cols()?;\n            println!(\"cols: {}\", cols);\n            while let Some(mut cursor) = stmt.fetch()? {\n                for i in 1..(cols + 1) {\n                    match cursor.get_data::\u003c\u0026str\u003e(i as u16)? {\n                        Some(val) =\u003e print!(\" {}\", val),\n                        None =\u003e print!(\" NULL\"),\n                    }\n                }\n                println!(\"\");\n            }\n        }\n        NoData(_) =\u003e println!(\"Query executed, no data returned\"),\n    }\n\n    Ok(())\n}\n\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","connect.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -\u003e Result\u003cTaos, Error\u003e {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        // .db(\"log\") // remove comment if you want to connect to database log by default.\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\nfn main() {\n    #[allow(unused_variables)]\n    let taos = taos_connect().unwrap();\n    println!(\"Connected\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","stmt_example.rs"],"content":"use bstr::BString;\nuse libtaos::*;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.create_database(\"power\").await?;\n    taos.use_database(\"power\").await?;\n    taos.exec(\"CREATE STABLE meters (ts TIMESTAMP, current FLOAT, voltage INT, phase FLOAT) TAGS (location BINARY(64), groupId INT)\").await?;\n    let mut stmt = taos.stmt(\"INSERT INTO ? USING meters TAGS(?, ?) VALUES(?, ?, ?, ?)\")?;\n    // bind table name and tags\n    stmt.set_tbname_tags(\n        \"d1001\",\n        [\n            Field::Binary(BString::from(\"California.SanFrancisco\")),\n            Field::Int(2),\n        ],\n    )?;\n    // bind values.\n    let values = vec![\n        Field::Timestamp(Timestamp::new(1648432611249, TimestampPrecision::Milli)),\n        Field::Float(10.3),\n        Field::Int(219),\n        Field::Float(0.31),\n    ];\n    stmt.bind(\u0026values)?;\n    // bind one more row\n    let values2 = vec![\n        Field::Timestamp(Timestamp::new(1648432611749, TimestampPrecision::Milli)),\n        Field::Float(12.6),\n        Field::Int(218),\n        Field::Float(0.33),\n    ];\n    stmt.bind(\u0026values2)?;\n    // execute\n    stmt.execute()?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","subscribe_demo.rs"],"content":"fn main() {\n  \n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","connect.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -\u003e Result\u003cTaos, Error\u003e {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        // .db(\"log\") // remove comment if you want to connect to database log by default.\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\n#[tokio::main]\nasync fn main() {\n    #[allow(unused_variables)]\n    let taos = taos_connect().expect(\"connect error\");\n    println!(\"Connected\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","insert_example.rs"],"content":"use libtaos::*;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.create_database(\"power\").await?;\n    taos.exec(\"CREATE STABLE power.meters (ts TIMESTAMP, current FLOAT, voltage INT, phase FLOAT) TAGS (location BINARY(64), groupId INT)\").await?;\n    let sql = \"INSERT INTO power.d1001 USING power.meters TAGS(California.SanFrancisco, 2) VALUES ('2018-10-03 14:38:05.000', 10.30000, 219, 0.31000) ('2018-10-03 14:38:15.000', 12.60000, 218, 0.33000) ('2018-10-03 14:38:16.800', 12.30000, 221, 0.31000)\n    power.d1002 USING power.meters TAGS(California.SanFrancisco, 3) VALUES ('2018-10-03 14:38:16.650', 10.30000, 218, 0.25000)\n    power.d1003 USING power.meters TAGS(California.LosAngeles, 2) VALUES ('2018-10-03 14:38:05.500', 11.80000, 221, 0.28000) ('2018-10-03 14:38:16.600', 13.40000, 223, 0.29000)\n    power.d1004 USING power.meters TAGS(California.LosAngeles, 3) VALUES ('2018-10-03 14:38:05.000', 10.80000, 223, 0.29000) ('2018-10-03 14:38:06.500', 11.50000, 221, 0.35000)\";\n    let result = taos.query(sql).await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n\n// output:\n// TaosQueryData { column_meta: [ColumnMeta { name: \"affected_rows\", type_: Int, bytes: 4 }], rows: [[Int(8)]] }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","query_example.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -\u003e Result\u003cTaos, Error\u003e {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        .db(\"power\")\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    let taos = taos_connect().expect(\"connect error\");\n    let result = taos.query(\"SELECT ts, current FROM meters LIMIT 2\").await?;\n    // print column names\n    let meta: Vec\u003cColumnMeta\u003e = result.column_meta;\n    for column in meta {\n        print!(\"{}\\t\", column.name)\n    }\n    println!();\n    // print rows\n    let rows: Vec\u003cVec\u003cField\u003e\u003e = result.rows;\n    for row in rows {\n        for field in row {\n            print!(\"{}\\t\", field);\n        }\n        println!();\n    }\n    Ok(())\n}\n\n// output:\n// ts      current\n// 2022-03-28 09:56:51.249 10.3\n// 2022-03-28 09:56:51.749 12.6\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","influxdb_line_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\"meters,location=California.LosAngeles,groupid=2 current=11.8,voltage=221,phase=0.28 1648432611249\",\n    \"meters,location=California.LosAngeles,groupid=2 current=13.4,voltage=223,phase=0.29 1648432611250\",\n    \"meters,location=California.LosAngeles,groupid=3 current=10.8,voltage=223,phase=0.29 1648432611249\",\n    \"meters,location=California.LosAngeles,groupid=3 current=11.3,voltage=221,phase=0.35 1648432611250\"];\n    let affected_rows = taos\n        .schemaless_insert(\n            \u0026lines,\n            TSDB_SML_LINE_PROTOCOL,\n            TSDB_SML_TIMESTAMP_MILLISECONDS,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows);\n}\n\n// run with:  cargo run --example influxdb_line_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","opentsdb_json_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\n        r#\"[{\"metric\": \"meters.current\", \"timestamp\": 1648432611249, \"value\": 10.3, \"tags\": {\"location\": \"California.SanFrancisco\", \"groupid\": 2}},\n        {\"metric\": \"meters.voltage\", \"timestamp\": 1648432611249, \"value\": 219, \"tags\": {\"location\": \"California.LosAngeles\", \"groupid\": 1}},\n        {\"metric\": \"meters.current\", \"timestamp\": 1648432611250, \"value\": 12.6, \"tags\": {\"location\": \"California.SanFrancisco\", \"groupid\": 2}},\n        {\"metric\": \"meters.voltage\", \"timestamp\": 1648432611250, \"value\": 221, \"tags\": {\"location\": \"California.LosAngeles\", \"groupid\": 1}}]\"#,\n    ];\n\n    let affected_rows = taos\n        .schemaless_insert(\n            \u0026lines,\n            TSDB_SML_JSON_PROTOCOL,\n            TSDB_SML_TIMESTAMP_NOT_CONFIGURED,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows); // affected_rows=4\n}\n\n// run with:  cargo run --example opentsdb_json_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","opentsdb_telnet_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\n        \"meters.current 1648432611249 10.3 location=California.SanFrancisco groupid=2\",\n        \"meters.current 1648432611250 12.6 location=California.SanFrancisco groupid=2\",\n        \"meters.current 1648432611249 10.8 location=California.LosAngeles groupid=3\",\n        \"meters.current 1648432611250 11.3 location=California.LosAngeles groupid=3\",\n        \"meters.voltage 1648432611249 219 location=California.SanFrancisco groupid=2\",\n        \"meters.voltage 1648432611250 218 location=California.SanFrancisco groupid=2\",\n        \"meters.voltage 1648432611249 221 location=California.LosAngeles groupid=3\",\n        \"meters.voltage 1648432611250 217 location=California.LosAngeles groupid=3\",\n    ];\n    let affected_rows = taos\n        .schemaless_insert(\n            \u0026lines,\n            TSDB_SML_TELNET_PROTOCOL,\n            TSDB_SML_TIMESTAMP_NOT_CONFIGURED,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows); // affected_rows=8\n}\n\n// run with:  cargo run --example opentsdb_telnet_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","build.rs"],"content":"extern crate bindgen;\n\nuse std::env;\nuse std::path::PathBuf;\n\nfn main() {\n    // Tell cargo to tell rustc to link the system bzip2\n    // shared library.\n    println!(\"cargo:rustc-link-lib=taos\");\n\n    // Tell cargo to invalidate the built crate whenever the wrapper changes\n    println!(\"cargo:rerun-if-changed=wrapper.h\");\n\n    // The bindgen::Builder is the main entry point\n    // to bindgen, and lets you build up options for\n    // the resulting bindings.\n    let bindings = bindgen::Builder::default()\n        // The input header we would like to generate\n        // bindings for.\n        .header(\"wrapper.h\")\n        // Tell cargo to invalidate the built crate whenever any of the\n        // included header files changed.\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        // Finish the builder and generate the bindings.\n        .generate()\n        // Unwrap the Result and panic on failure.\n        .expect(\"Unable to generate bindings\");\n\n    // Write the bindings to the $OUT_DIR/bindings.rs file.\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","examples","demo.rs"],"content":"use libtdengine::tdengine::{clean_up, Tdengine};\nuse libtdengine::utils;\nuse std::process;\n\nfn main() {\n    let tde = Tdengine::new(\"127.0.0.1:6030\", \"root\", \"taosdata\", \"log\", 0).unwrap_or_else(|err| {\n        eprintln!(\"Can't create Tdengine: {}\", err);\n        process::exit(1)\n    });\n\n    assert_eq!(tde.query(\"drop database demo\").is_ok(), true);\n    assert_eq!(tde.query(\"create database demo\").is_ok(), true);\n    assert_eq!(tde.query(\"use demo\").is_ok(), true);\n    assert_eq!(\n        tde.query(\"create table m1 (ts timestamp, speed int)\")\n            .is_ok(),\n        true\n    );\n\n    for i in 0..10 {\n        assert_eq!(\n            tde.query(format!(\"insert into m1 values (now+{}s, {})\", i, i).as_str())\n                .is_ok(),\n            true\n        );\n    }\n    let rows = tde.query(\"select * from m1\").unwrap_or_else(|err| {\n        eprintln!(\"select error: {}\", err);\n        process::exit(1);\n    });\n    for row in rows {\n        println!(\"{}\", utils::format_row(\u0026row));\n    }\n    // drop manually before clean up\n    drop(tde);\n    // cleanup before program exit\n    clean_up();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","examples","subscribe.rs"],"content":"use libtdengine::subscriber::Subscriber;\nuse libtdengine::tdengine::{clean_up, Tdengine};\nuse std::process;\n\nfn main() {\n    let td = Tdengine::new(\"127.0.0.1\", \"root\", \"taosdata\", \"demo\", 0).unwrap_or_else(|err| {\n        eprintln!(\"Can't create Tdengine: {}\", err);\n        process::exit(1)\n    });\n\n    let mut subscriber =\n        Subscriber::subscribe(td.taos(), 0, \"topic_test\", \"select * from m1;\", 1000)\n            .unwrap_or_else(|err| {\n                eprintln!(\"Can't create Subscriber: {}\", err);\n                process::exit(1)\n            });\n\n    loop {\n        let rows = match subscriber.consume() {\n            Ok(rows) =\u003e rows,\n            Err(err) =\u003e {\n                eprintln!(\"consume exit: {}\", err);\n                break;\n            }\n        };\n\n        // example code\n        for row in rows {\n            println!(\"({}, {})\", row[0].as_i64(), row[1].as_i32());\n        }\n        println!(\"====================\");\n    }\n    drop(td);\n    clean_up();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","bindings.rs"],"content":"/* automatically generated by rust-bindgen 0.55.1 */\n\npub const _STDINT_H: u32 = 1;\npub const _FEATURES_H: u32 = 1;\npub const __USE_ANSI: u32 = 1;\npub const _BSD_SOURCE: u32 = 1;\npub const _SVID_SOURCE: u32 = 1;\npub const __USE_ISOC11: u32 = 1;\npub const __USE_ISOC99: u32 = 1;\npub const __USE_ISOC95: u32 = 1;\npub const _POSIX_SOURCE: u32 = 1;\npub const _POSIX_C_SOURCE: u32 = 200809;\npub const __USE_POSIX_IMPLICITLY: u32 = 1;\npub const __USE_POSIX: u32 = 1;\npub const __USE_POSIX2: u32 = 1;\npub const __USE_POSIX199309: u32 = 1;\npub const __USE_POSIX199506: u32 = 1;\npub const __USE_XOPEN2K: u32 = 1;\npub const __USE_XOPEN2K8: u32 = 1;\npub const _ATFILE_SOURCE: u32 = 1;\npub const __USE_MISC: u32 = 1;\npub const __USE_BSD: u32 = 1;\npub const __USE_SVID: u32 = 1;\npub const __USE_ATFILE: u32 = 1;\npub const __USE_FORTIFY_LEVEL: u32 = 0;\npub const _STDC_PREDEF_H: u32 = 1;\npub const __STDC_IEC_559__: u32 = 1;\npub const __STDC_IEC_559_COMPLEX__: u32 = 1;\npub const __STDC_ISO_10646__: u32 = 201103;\npub const __STDC_NO_THREADS__: u32 = 1;\npub const __GNU_LIBRARY__: u32 = 6;\npub const __GLIBC__: u32 = 2;\npub const __GLIBC_MINOR__: u32 = 17;\npub const __GLIBC_HAVE_LONG_LONG: u32 = 1;\npub const _SYS_CDEFS_H: u32 = 1;\npub const __WORDSIZE: u32 = 64;\npub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;\npub const __SYSCALL_WORDSIZE: u32 = 64;\npub const _BITS_WCHAR_H: u32 = 1;\npub const __WCHAR_MIN: i32 = -2147483648;\npub const __WCHAR_MAX: u32 = 2147483647;\npub const INT8_MIN: i32 = -128;\npub const INT16_MIN: i32 = -32768;\npub const INT32_MIN: i32 = -2147483648;\npub const INT8_MAX: u32 = 127;\npub const INT16_MAX: u32 = 32767;\npub const INT32_MAX: u32 = 2147483647;\npub const UINT8_MAX: u32 = 255;\npub const UINT16_MAX: u32 = 65535;\npub const UINT32_MAX: u32 = 4294967295;\npub const INT_LEAST8_MIN: i32 = -128;\npub const INT_LEAST16_MIN: i32 = -32768;\npub const INT_LEAST32_MIN: i32 = -2147483648;\npub const INT_LEAST8_MAX: u32 = 127;\npub const INT_LEAST16_MAX: u32 = 32767;\npub const INT_LEAST32_MAX: u32 = 2147483647;\npub const UINT_LEAST8_MAX: u32 = 255;\npub const UINT_LEAST16_MAX: u32 = 65535;\npub const UINT_LEAST32_MAX: u32 = 4294967295;\npub const INT_FAST8_MIN: i32 = -128;\npub const INT_FAST16_MIN: i64 = -9223372036854775808;\npub const INT_FAST32_MIN: i64 = -9223372036854775808;\npub const INT_FAST8_MAX: u32 = 127;\npub const INT_FAST16_MAX: u64 = 9223372036854775807;\npub const INT_FAST32_MAX: u64 = 9223372036854775807;\npub const UINT_FAST8_MAX: u32 = 255;\npub const UINT_FAST16_MAX: i32 = -1;\npub const UINT_FAST32_MAX: i32 = -1;\npub const INTPTR_MIN: i64 = -9223372036854775808;\npub const INTPTR_MAX: u64 = 9223372036854775807;\npub const UINTPTR_MAX: i32 = -1;\npub const PTRDIFF_MIN: i64 = -9223372036854775808;\npub const PTRDIFF_MAX: u64 = 9223372036854775807;\npub const SIG_ATOMIC_MIN: i32 = -2147483648;\npub const SIG_ATOMIC_MAX: u32 = 2147483647;\npub const SIZE_MAX: i32 = -1;\npub const WCHAR_MIN: i32 = -2147483648;\npub const WCHAR_MAX: u32 = 2147483647;\npub const WINT_MIN: u32 = 0;\npub const WINT_MAX: u32 = 4294967295;\npub const TSDB_DATA_TYPE_NULL: u32 = 0;\npub const TSDB_DATA_TYPE_BOOL: u32 = 1;\npub const TSDB_DATA_TYPE_TINYINT: u32 = 2;\npub const TSDB_DATA_TYPE_SMALLINT: u32 = 3;\npub const TSDB_DATA_TYPE_INT: u32 = 4;\npub const TSDB_DATA_TYPE_BIGINT: u32 = 5;\npub const TSDB_DATA_TYPE_FLOAT: u32 = 6;\npub const TSDB_DATA_TYPE_DOUBLE: u32 = 7;\npub const TSDB_DATA_TYPE_BINARY: u32 = 8;\npub const TSDB_DATA_TYPE_TIMESTAMP: u32 = 9;\npub const TSDB_DATA_TYPE_NCHAR: u32 = 10;\npub type int_least8_t = ::std::os::raw::c_schar;\npub type int_least16_t = ::std::os::raw::c_short;\npub type int_least32_t = ::std::os::raw::c_int;\npub type int_least64_t = ::std::os::raw::c_long;\npub type uint_least8_t = ::std::os::raw::c_uchar;\npub type uint_least16_t = ::std::os::raw::c_ushort;\npub type uint_least32_t = ::std::os::raw::c_uint;\npub type uint_least64_t = ::std::os::raw::c_ulong;\npub type int_fast8_t = ::std::os::raw::c_schar;\npub type int_fast16_t = ::std::os::raw::c_long;\npub type int_fast32_t = ::std::os::raw::c_long;\npub type int_fast64_t = ::std::os::raw::c_long;\npub type uint_fast8_t = ::std::os::raw::c_uchar;\npub type uint_fast16_t = ::std::os::raw::c_ulong;\npub type uint_fast32_t = ::std::os::raw::c_ulong;\npub type uint_fast64_t = ::std::os::raw::c_ulong;\npub type intmax_t = ::std::os::raw::c_long;\npub type uintmax_t = ::std::os::raw::c_ulong;\npub type TAOS = ::std::os::raw::c_void;\npub type TAOS_ROW = *mut *mut ::std::os::raw::c_void;\npub type TAOS_RES = ::std::os::raw::c_void;\npub type TAOS_SUB = ::std::os::raw::c_void;\npub type TAOS_STREAM = ::std::os::raw::c_void;\npub type TAOS_STMT = ::std::os::raw::c_void;\npub const TSDB_OPTION_TSDB_OPTION_LOCALE: TSDB_OPTION = 0;\npub const TSDB_OPTION_TSDB_OPTION_CHARSET: TSDB_OPTION = 1;\npub const TSDB_OPTION_TSDB_OPTION_TIMEZONE: TSDB_OPTION = 2;\npub const TSDB_OPTION_TSDB_OPTION_CONFIGDIR: TSDB_OPTION = 3;\npub const TSDB_OPTION_TSDB_OPTION_SHELL_ACTIVITY_TIMER: TSDB_OPTION = 4;\npub const TSDB_OPTION_TSDB_MAX_OPTIONS: TSDB_OPTION = 5;\npub type TSDB_OPTION = ::std::os::raw::c_uint;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct taosField {\n    pub name: [::std::os::raw::c_char; 65usize],\n    pub type_: u8,\n    pub bytes: i16,\n}\n#[test]\nfn bindgen_test_layout_taosField() {\n    assert_eq!(\n        ::std::mem::size_of::\u003ctaosField\u003e(),\n        68usize,\n        concat!(\"Size of: \", stringify!(taosField))\n    );\n    assert_eq!(\n        ::std::mem::align_of::\u003ctaosField\u003e(),\n        2usize,\n        concat!(\"Alignment of \", stringify!(taosField))\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003ctaosField\u003e())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003ctaosField\u003e())).type_ as *const _ as usize },\n        65usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003ctaosField\u003e())).bytes as *const _ as usize },\n        66usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(bytes)\n        )\n    );\n}\npub type TAOS_FIELD = taosField;\nextern \"C\" {\n    pub fn taos_init();\n}\nextern \"C\" {\n    pub fn taos_cleanup();\n}\nextern \"C\" {\n    pub fn taos_options(\n        option: TSDB_OPTION,\n        arg: *const ::std::os::raw::c_void,\n        ...\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_connect(\n        ip: *const ::std::os::raw::c_char,\n        user: *const ::std::os::raw::c_char,\n        pass: *const ::std::os::raw::c_char,\n        db: *const ::std::os::raw::c_char,\n        port: u16,\n    ) -\u003e *mut TAOS;\n}\nextern \"C\" {\n    pub fn taos_close(taos: *mut TAOS);\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct TAOS_BIND {\n    pub buffer_type: ::std::os::raw::c_int,\n    pub buffer: *mut ::std::os::raw::c_void,\n    pub buffer_length: usize,\n    pub length: *mut usize,\n    pub is_null: *mut ::std::os::raw::c_int,\n    pub is_unsigned: ::std::os::raw::c_int,\n    pub error: *mut ::std::os::raw::c_int,\n}\n#[test]\nfn bindgen_test_layout_TAOS_BIND() {\n    assert_eq!(\n        ::std::mem::size_of::\u003cTAOS_BIND\u003e(),\n        56usize,\n        concat!(\"Size of: \", stringify!(TAOS_BIND))\n    );\n    assert_eq!(\n        ::std::mem::align_of::\u003cTAOS_BIND\u003e(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(TAOS_BIND))\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).buffer_type as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer_type)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).buffer as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).buffer_length as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer_length)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).length as *const _ as usize },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(length)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).is_null as *const _ as usize },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(is_null)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).is_unsigned as *const _ as usize },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(is_unsigned)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).error as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(error)\n        )\n    );\n}\nextern \"C\" {\n    pub fn taos_stmt_init(taos: *mut TAOS) -\u003e *mut TAOS_STMT;\n}\nextern \"C\" {\n    pub fn taos_stmt_prepare(\n        stmt: *mut TAOS_STMT,\n        sql: *const ::std::os::raw::c_char,\n        length: ::std::os::raw::c_ulong,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_bind_param(\n        stmt: *mut TAOS_STMT,\n        bind: *mut TAOS_BIND,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_add_batch(stmt: *mut TAOS_STMT) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_execute(stmt: *mut TAOS_STMT) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_use_result(stmt: *mut TAOS_STMT) -\u003e *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_stmt_close(stmt: *mut TAOS_STMT) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_query(taos: *mut TAOS, sql: *const ::std::os::raw::c_char) -\u003e *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_fetch_row(res: *mut TAOS_RES) -\u003e TAOS_ROW;\n}\nextern \"C\" {\n    pub fn taos_result_precision(res: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_free_result(res: *mut TAOS_RES);\n}\nextern \"C\" {\n    pub fn taos_field_count(tres: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_num_fields(res: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_affected_rows(res: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_fetch_fields(res: *mut TAOS_RES) -\u003e *mut TAOS_FIELD;\n}\nextern \"C\" {\n    pub fn taos_select_db(\n        taos: *mut TAOS,\n        db: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_print_row(\n        str_: *mut ::std::os::raw::c_char,\n        row: TAOS_ROW,\n        fields: *mut TAOS_FIELD,\n        num_fields: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stop_query(res: *mut TAOS_RES);\n}\nextern \"C\" {\n    pub fn taos_fetch_block(res: *mut TAOS_RES, rows: *mut TAOS_ROW) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_validate_sql(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_fetch_lengths(res: *mut TAOS_RES) -\u003e *mut ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_get_server_info(taos: *mut TAOS) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_get_client_info() -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_errstr(tres: *mut TAOS_RES) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_errno(tres: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_query_a(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                code: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn taos_fetch_rows_a(\n        res: *mut TAOS_RES,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                numOfRows: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn taos_fetch_row_a(\n        res: *mut TAOS_RES,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                row: TAOS_ROW,\n            ),\n        \u003e,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\npub type TAOS_SUBSCRIBE_CALLBACK = ::std::option::Option\u003c\n    unsafe extern \"C\" fn(\n        tsub: *mut TAOS_SUB,\n        res: *mut TAOS_RES,\n        param: *mut ::std::os::raw::c_void,\n        code: ::std::os::raw::c_int,\n    ),\n\u003e;\nextern \"C\" {\n    pub fn taos_subscribe(\n        taos: *mut TAOS,\n        restart: ::std::os::raw::c_int,\n        topic: *const ::std::os::raw::c_char,\n        sql: *const ::std::os::raw::c_char,\n        fp: TAOS_SUBSCRIBE_CALLBACK,\n        param: *mut ::std::os::raw::c_void,\n        interval: ::std::os::raw::c_int,\n    ) -\u003e *mut TAOS_SUB;\n}\nextern \"C\" {\n    pub fn taos_consume(tsub: *mut TAOS_SUB) -\u003e *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_unsubscribe(tsub: *mut TAOS_SUB, keepProgress: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn taos_open_stream(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                row: TAOS_ROW,\n            ),\n        \u003e,\n        stime: i64,\n        param: *mut ::std::os::raw::c_void,\n        callback: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e *mut TAOS_STREAM;\n}\nextern \"C\" {\n    pub fn taos_close_stream(tstr: *mut TAOS_STREAM);\n}\nextern \"C\" {\n    pub fn taos_load_table_info(\n        taos: *mut TAOS,\n        tableNameList: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","lib.rs"],"content":"#![allow(unused)]\n#![allow(non_camel_case_types)]\n\n#[path = \"bindings.rs\"]\npub mod bindings;\n#[path = \"subscriber.rs\"]\npub mod subscriber;\n#[path = \"tdengine.rs\"]\npub mod tdengine;\n#[path = \"utils.rs\"]\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","subscriber.rs"],"content":"use crate::bindings::*;\nuse crate::utils;\n\nuse std::os::raw::{c_int, c_void};\nuse std::ptr;\n\npub struct Subscriber {\n    tsub: *mut c_void,\n    fields: *mut taosField,\n    fcount: c_int,\n}\n\nimpl Subscriber {\n    pub fn subscribe(\n        taos: *mut c_void,\n        restart: i32,\n        topic: \u0026str,\n        sql: \u0026str,\n        interval: i32,\n    ) -\u003e Result\u003cSubscriber, \u0026'static str\u003e {\n        unsafe {\n            let mut tsub = taos_subscribe(\n                taos,\n                restart as c_int,\n                utils::str_into_raw(topic),\n                utils::str_into_raw(sql),\n                None,\n                ptr::null_mut(),\n                interval as c_int,\n            );\n            if tsub.is_null() {\n                return Err(utils::raw_into_str(taos_errstr(tsub)));\n            }\n\n            Ok(Subscriber {\n                tsub: tsub,\n                fields: ptr::null_mut(), // init\n                fcount: 0,               // init\n            })\n        }\n    }\n\n    pub fn consume(self: \u0026mut Subscriber) -\u003e Result\u003cVec\u003cutils::Row\u003e, \u0026'static str\u003e {\n        unsafe {\n            let taos_res = taos_consume(self.tsub);\n            if taos_res.is_null() {\n                return Err(utils::raw_into_str(taos_errstr(self.tsub)));\n            }\n            if self.fields.is_null() {\n                self.fields = taos_fetch_fields(taos_res);\n                // fetch err msg\n                if self.fields.is_null() {\n                    return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                }\n            }\n\n            if self.fcount == 0 {\n                self.fcount = taos_field_count(taos_res);\n                if self.fcount == 0 {\n                    return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                }\n                println!(\"{} fields\", self.fcount);\n            }\n\n            let mut rows: Vec\u003cutils::Row\u003e = Vec::\u003cutils::Row\u003e::new();\n            loop {\n                let taos_row = taos_fetch_row(taos_res);\n                if taos_row.is_null() {\n                    // chek retcode\n                    if taos_errno(taos_res) != 0 {\n                        return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                    }\n                    break;\n                }\n\n                // example code for taos_print_row\n                //let mut buf: Vec\u003cc_char\u003e = vec![0; 4096];\n                //taos_print_row(buf.as_mut_ptr(), taos_row, self.fields, self.fcount);\n                //println!(\n                //    \"internal print {}\",\n                //    CStr::from_ptr(buf.as_ptr()).to_str().unwrap()\n                //);\n\n                let raw_row = std::slice::from_raw_parts(taos_row, self.fcount as usize);\n                let row = utils::raw_into_row(self.fields, self.fcount, raw_row);\n                rows.push(row);\n            }\n            println!(\"{} rows fetched\", rows.len());\n            Ok(rows)\n        }\n    }\n\n    pub fn unsubscribe(self: \u0026Subscriber, keep_progress: i32) {\n        unsafe { taos_unsubscribe(self.tsub, keep_progress as c_int) }\n    }\n\n    pub fn print_row(self: \u0026Subscriber, row: \u0026utils::Row) {\n        println!(\"format row: {}\", utils::format_row(row));\n    }\n}\n\nimpl Drop for Subscriber {\n    fn drop(\u0026mut self) {\n        unsafe {\n            taos_unsubscribe(self.tsub, 1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","tdengine.rs"],"content":"use crate::bindings::*;\nuse crate::utils;\n\nuse std::os::raw::c_void;\n\npub struct Tdengine {\n    conn: *mut c_void, // tdengine conn\n}\n\nimpl Tdengine {\n    pub fn new(\n        ip: \u0026str, // host ip\n        username: \u0026str,\n        passwd: \u0026str,\n        db: \u0026str,\n        port: i32, // tdengine port\n    ) -\u003e Result\u003cTdengine, \u0026'static str\u003e {\n        unsafe {\n            taos_init();\n            let mut conn = taos_connect(\n                utils::str_into_raw(ip),\n                utils::str_into_raw(username),\n                utils::str_into_raw(passwd),\n                utils::str_into_raw(db),\n                port as u16,\n            );\n            if conn.is_null() {\n                Err(utils::raw_into_str(taos_errstr(conn)))\n            } else {\n                println!(\"connected to {}:{} user:{}, db:{}\", ip, port, username, db);\n                Ok(Tdengine { conn })\n            }\n        }\n    }\n\n    pub fn query(self: \u0026Tdengine, s: \u0026str) -\u003e Result\u003cVec\u003cutils::Row\u003e, \u0026'static str\u003e {\n        unsafe {\n            let taos_res = taos_query(self.conn, utils::str_into_raw(s));\n            // check retcode\n            if taos_errno(taos_res) != 0 {\n                let err = utils::raw_into_str(taos_errstr(taos_res));\n                println!(\"query '{}' error: {}\", s, err);\n                return Err(err);\n            }\n            println!(\"query '{}' ok\", s);\n            let mut rows: Vec\u003cutils::Row\u003e = Vec::\u003cutils::Row\u003e::new();\n            let fields = taos_fetch_fields(taos_res);\n            let fcount = taos_field_count(taos_res);\n            loop {\n                let taos_row = taos_fetch_row(taos_res);\n                if taos_row.is_null() {\n                    // check retcode\n                    if taos_errno(taos_res) != 0 {\n                        return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                    }\n                    break;\n                }\n\n                let raw_row = std::slice::from_raw_parts(taos_row, fcount as usize);\n                let row = utils::raw_into_row(fields, fcount, raw_row);\n                rows.push(row);\n            }\n            taos_free_result(taos_res);\n            println!(\"{} rows fetched\", rows.len());\n            Ok(rows)\n        }\n    }\n\n    pub fn taos(self: \u0026Tdengine) -\u003e *mut c_void {\n        self.conn\n    }\n}\n\nimpl Drop for Tdengine {\n    fn drop(\u0026mut self) {\n        unsafe {\n            taos_close(self.conn);\n            // we will not do clean up here\n        }\n    }\n}\n\npub fn clean_up() {\n    unsafe {\n        taos_cleanup();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","utils.rs"],"content":"use crate::bindings;\n\nuse std::ffi::{CStr, CString};\nuse std::fmt;\nuse std::os::raw::{c_char, c_int, c_void};\n\n// #[derive(Debug)]\npub enum Field {\n    tinyInt(i8),\n    smallInt(i16),\n    normalInt(i32),\n    bigInt(i64),\n    float(f32),\n    double(f64),\n    string(String),\n    boolType(bool),\n}\n\nimpl fmt::Display for Field {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match \u0026*self {\n            Field::tinyInt(v) =\u003e write!(f, \"{}\", v),\n            Field::smallInt(v) =\u003e write!(f, \"{}\", v),\n            Field::normalInt(v) =\u003e write!(f, \"{}\", v),\n            Field::bigInt(v) =\u003e write!(f, \"{}\", v),\n            Field::float(v) =\u003e write!(f, \"{}\", v),\n            Field::double(v) =\u003e write!(f, \"{}\", v),\n            Field::tinyInt(v) =\u003e write!(f, \"{}\", v),\n            Field::boolType(v) =\u003e write!(f, \"{}\", v),\n            Field::string(v) =\u003e write!(f, \"{}\", v),\n        }\n    }\n}\n\nmacro_rules! impl_as_fields {\n    ($fn:ident, $pattern:pat =\u003e $v:expr, $type:ty) =\u003e {\n        pub fn $fn(\u0026self) -\u003e $type {\n            match *self {\n                $pattern =\u003e $v,\n                _ =\u003e {\n                    println!(\"unexpected $type value {}\", self);\n                    Default::default()\n                }\n            }\n        }\n    };\n}\n\nimpl Field {\n    impl_as_fields!(as_i8, Field::tinyInt(v) =\u003e v, i8);\n    impl_as_fields!(as_i16, Field::smallInt(v) =\u003e v, i16);\n    impl_as_fields!(as_i32, Field::normalInt(v) =\u003e v, i32);\n    impl_as_fields!(as_i64, Field::bigInt(v) =\u003e v, i64);\n    impl_as_fields!(as_f32, Field::float(v) =\u003e v, f32);\n    impl_as_fields!(as_f64, Field::double(v) =\u003e v, f64);\n    impl_as_fields!(as_bool, Field::boolType(v) =\u003e v, bool);\n\n    pub fn as_string(\u0026self) -\u003e String {\n        match \u0026*self {\n            Field::string(v) =\u003e v.to_string(),\n            _ =\u003e {\n                println!(\"unexpected string value {}\", self);\n                \"\".to_string()\n            }\n        }\n    }\n}\n\npub type Row = Vec\u003cField\u003e;\n\npub fn format_row(row: \u0026Row) -\u003e String {\n    let mut s = String::new();\n    for field in row {\n        s.push_str(format!(\"{} \", field).as_str());\n    }\n    s\n}\n\npub fn str_into_raw(s: \u0026str) -\u003e *mut c_char {\n    if s.is_empty() {\n        0 as *mut c_char\n    } else {\n        CString::new(s).unwrap().into_raw()\n    }\n}\n\npub fn raw_into_str\u003c'a\u003e(raw: *mut c_char) -\u003e \u0026'static str {\n    unsafe { CStr::from_ptr(raw).to_str().unwrap() }\n}\n\npub fn raw_into_field(raw: *mut bindings::TAOS_FIELD, fcount: c_int) -\u003e Vec\u003cbindings::taosField\u003e {\n    let mut fields: Vec\u003cbindings::taosField\u003e = Vec::new();\n\n    for i in 0..fcount as isize {\n        fields.push(bindings::taosField {\n            name: unsafe { *raw.offset(i as isize) }.name,\n            bytes: unsafe { *raw.offset(i as isize) }.bytes,\n            type_: unsafe { *raw.offset(i as isize) }.type_,\n        });\n    }\n    fields\n}\n\npub fn raw_into_row(\n    fields: *mut bindings::TAOS_FIELD,\n    fcount: c_int,\n    raw_row: \u0026[*mut c_void],\n) -\u003e Row {\n    let mut row: Row = Vec::new();\n    let fields = raw_into_field(fields, fcount);\n\n    for (i, field) in fields.iter().enumerate() {\n        unsafe {\n            match field.type_ as u32 {\n                bindings::TSDB_DATA_TYPE_TINYINT =\u003e {\n                    row.push(Field::tinyInt(*(raw_row[i] as *mut i8)));\n                }\n                bindings::TSDB_DATA_TYPE_SMALLINT =\u003e {\n                    row.push(Field::smallInt(*(raw_row[i] as *mut i16)));\n                }\n                bindings::TSDB_DATA_TYPE_INT =\u003e {\n                    row.push(Field::normalInt(*(raw_row[i] as *mut i32)));\n                }\n                bindings::TSDB_DATA_TYPE_BIGINT | bindings::TSDB_DATA_TYPE_TIMESTAMP =\u003e {\n                    row.push(Field::bigInt(*(raw_row[i] as *mut i64)));\n                }\n                bindings::TSDB_DATA_TYPE_FLOAT =\u003e {\n                    row.push(Field::float(*(raw_row[i] as *mut f32)));\n                }\n                bindings::TSDB_DATA_TYPE_DOUBLE =\u003e {\n                    row.push(Field::double(*(raw_row[i] as *mut f64)));\n                }\n                bindings::TSDB_DATA_TYPE_NCHAR =\u003e {\n                    let a = CStr::from_ptr(raw_row[i] as *const c_char)\n                        .to_string_lossy()\n                        .into_owned();\n                    row.push(Field::string(a));\n                }\n                bindings::TSDB_DATA_TYPE_BOOL =\u003e {\n                    row.push(Field::boolType(*(raw_row[i] as *mut i8) != 0));\n                }\n                _ =\u003e println!(\"\"),\n            }\n        }\n    }\n    row\n}\n","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","serde.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    types::{Record, Value},\n    Reader, Writer,\n};\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse std::time::Duration;\n\nconst RAW_SMALL_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"test\",\n  \"type\": \"record\",\n  \"name\": \"Test\",\n  \"fields\": [\n    {\n      \"type\": {\n        \"type\": \"string\"\n      },\n      \"name\": \"field\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_BIG_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"my.example\",\n  \"type\": \"record\",\n  \"name\": \"userInfo\",\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"username\"\n    },\n    {\n      \"default\": -1,\n      \"type\": \"int\",\n      \"name\": \"age\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"phone\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"housenum\"\n    },\n    {\n      \"default\": {},\n      \"type\": {\n        \"fields\": [\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"street\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"city\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"state_prov\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"country\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"zip\"\n          }\n        ],\n        \"type\": \"record\",\n        \"name\": \"mailing_address\"\n      },\n      \"name\": \"address\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_ADDRESS_SCHEMA: \u0026str = r#\"\n{\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"street\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"city\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"state_prov\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"country\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"zip\"\n    }\n  ],\n  \"type\": \"record\",\n  \"name\": \"mailing_address\"\n}\n\"#;\n\nfn make_small_record() -\u003e (Schema, Value) {\n    let small_schema = Schema::parse_str(RAW_SMALL_SCHEMA).unwrap();\n    let small_record = {\n        let mut small_record = Record::new(\u0026small_schema).unwrap();\n        small_record.put(\"field\", \"foo\");\n        small_record.into()\n    };\n    (small_schema, small_record)\n}\n\nfn make_big_record() -\u003e (Schema, Value) {\n    let big_schema = Schema::parse_str(RAW_BIG_SCHEMA).unwrap();\n    let address_schema = Schema::parse_str(RAW_ADDRESS_SCHEMA).unwrap();\n    let mut address = Record::new(\u0026address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let big_record = {\n        let mut big_record = Record::new(\u0026big_schema).unwrap();\n        big_record.put(\"username\", \"username\");\n        big_record.put(\"age\", 10i32);\n        big_record.put(\"phone\", \"000000000\");\n        big_record.put(\"housenum\", \"0000\");\n        big_record.put(\"address\", address);\n        big_record.into()\n    };\n\n    (big_schema, big_record)\n}\n\nfn make_records(record: Value, count: usize) -\u003e Vec\u003cValue\u003e {\n    std::iter::repeat(record).take(count).collect()\n}\n\nfn write(schema: \u0026Schema, records: \u0026[Value]) -\u003e Vec\u003cu8\u003e {\n    let mut writer = Writer::new(schema, Vec::new());\n    writer.extend_from_slice(records).unwrap();\n    writer.into_inner().unwrap()\n}\n\nfn read(schema: \u0026Schema, bytes: \u0026[u8]) {\n    let reader = Reader::with_schema(schema, bytes).unwrap();\n\n    for record in reader {\n        let _ = record.unwrap();\n    }\n}\n\nfn read_schemaless(bytes: \u0026[u8]) {\n    let reader = Reader::new(bytes).unwrap();\n\n    for record in reader {\n        let _ = record.unwrap();\n    }\n}\n\nfn bench_write(\n    c: \u0026mut Criterion,\n    make_record: impl Fn() -\u003e (Schema, Value),\n    n_records: usize,\n    name: \u0026str,\n) {\n    let (schema, record) = make_record();\n    let records = make_records(record, n_records);\n    c.bench_function(name, |b| b.iter(|| write(\u0026schema, \u0026records)));\n}\n\nfn bench_read(\n    c: \u0026mut Criterion,\n    make_record: impl Fn() -\u003e (Schema, Value),\n    n_records: usize,\n    name: \u0026str,\n) {\n    let (schema, record) = make_record();\n    let records = make_records(record, n_records);\n    let bytes = write(\u0026schema, \u0026records);\n    c.bench_function(name, |b| b.iter(|| read(\u0026schema, \u0026bytes)));\n}\n\nfn bench_from_file(c: \u0026mut Criterion, file_path: \u0026str, name: \u0026str) {\n    let bytes = std::fs::read(file_path).unwrap();\n    c.bench_function(name, |b| b.iter(|| read_schemaless(\u0026bytes)));\n}\n\nfn bench_small_schema_write_1_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_small_record, 1, \"small schema, write 1 record\");\n}\n\nfn bench_small_schema_write_100_record(c: \u0026mut Criterion) {\n    bench_write(\n        c,\n        \u0026make_small_record,\n        100,\n        \"small schema, write 100 records\",\n    );\n}\n\nfn bench_small_schema_write_10_000_record(c: \u0026mut Criterion) {\n    bench_write(\n        c,\n        \u0026make_small_record,\n        10_000,\n        \"small schema, write 10k records\",\n    );\n}\n\nfn bench_small_schema_read_1_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_small_record, 1, \"small schema, read 1 record\");\n}\n\nfn bench_small_schema_read_100_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_small_record, 100, \"small schema, read 100 records\");\n}\n\nfn bench_small_schema_read_10_000_record(c: \u0026mut Criterion) {\n    bench_read(\n        c,\n        \u0026make_small_record,\n        10_000,\n        \"small schema, read 10k records\",\n    );\n}\n\nfn bench_big_schema_write_1_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_big_record, 1, \"big schema, write 1 record\");\n}\n\nfn bench_big_schema_write_100_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_big_record, 100, \"big schema, write 100 records\");\n}\n\nfn bench_big_schema_write_10_000_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_big_record, 10_000, \"big schema, write 10k records\");\n}\n\nfn bench_big_schema_read_1_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_big_record, 1, \"big schema, read 1 record\");\n}\n\nfn bench_big_schema_read_100_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_big_record, 100, \"big schema, read 100 records\");\n}\n\nfn bench_big_schema_read_10_000_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_big_record, 10_000, \"big schema, read 10k records\");\n}\n\nfn bench_big_schema_read_100_000_record(c: \u0026mut Criterion) {\n    bench_read(\n        c,\n        \u0026make_big_record,\n        100_000,\n        \"big schema, read 100k records\",\n    );\n}\n\n// This benchmark reads from the `benches/quickstop-null.avro` file, which was pulled from\n// the `goavro` project benchmarks:\n// https://github.com/linkedin/goavro/blob/master/fixtures/quickstop-null.avro\n// This was done for the sake of comparing this crate against the `goavro` implementation.\nfn bench_file_quickstop_null(c: \u0026mut Criterion) {\n    bench_from_file(c, \"benches/quickstop-null.avro\", \"quickstop null file\");\n}\n\ncriterion_group!(\n    benches,\n    bench_small_schema_write_1_record,\n    bench_small_schema_write_100_record,\n    bench_small_schema_read_1_record,\n    bench_small_schema_read_100_record,\n    bench_big_schema_write_1_record,\n    bench_big_schema_write_100_record,\n    bench_big_schema_read_1_record,\n    bench_big_schema_read_100_record,\n);\n\ncriterion_group!(\n    name = long_benches;\n    config = Criterion::default().sample_size(20).measurement_time(Duration::from_secs(10));\n    targets =\n        bench_file_quickstop_null,\n        bench_small_schema_write_10_000_record,\n        bench_small_schema_read_10_000_record,\n        bench_big_schema_read_10_000_record,\n        bench_big_schema_write_10_000_record\n);\n\ncriterion_group!(\n    name = very_long_benches;\n    config = Criterion::default().sample_size(10).measurement_time(Duration::from_secs(20));\n    targets =\n        bench_big_schema_read_100_000_record,\n);\n\ncriterion_main!(benches, long_benches, very_long_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","serde_json.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse serde_json::Value;\nuse std::{collections::HashMap, iter::FromIterator};\n\nfn make_big_json_record() -\u003e Value {\n    let address = HashMap::\u003c_, _\u003e::from_iter(vec![\n        (\"street\", \"street\"),\n        (\"city\", \"city\"),\n        (\"state_prov\", \"state_prov\"),\n        (\"country\", \"country\"),\n        (\"zip\", \"zip\"),\n    ]);\n    let address_json = serde_json::to_value(address).unwrap();\n    let big_record = HashMap::\u003c_, _\u003e::from_iter(vec![\n        (\"username\", serde_json::to_value(\"username\").unwrap()),\n        (\"age\", serde_json::to_value(10i32).unwrap()),\n        (\"phone\", serde_json::to_value(\"000000000\").unwrap()),\n        (\"housenum\", serde_json::to_value(\"0000\").unwrap()),\n        (\"address\", address_json),\n    ]);\n    serde_json::to_value(big_record).unwrap()\n}\n\nfn write_json(records: \u0026[Value]) -\u003e Vec\u003cu8\u003e {\n    serde_json::to_vec(records).unwrap()\n}\n\nfn read_json(bytes: \u0026[u8]) {\n    let reader: serde_json::Value = serde_json::from_slice(bytes).unwrap();\n    for record in reader.as_array().unwrap() {\n        let _ = record;\n    }\n}\n\nfn bench_read_json(\n    c: \u0026mut Criterion,\n    make_record: impl Fn() -\u003e Value,\n    n_records: usize,\n    name: \u0026str,\n) {\n    let records = std::iter::repeat(make_record())\n        .take(n_records)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let bytes = write_json(\u0026records);\n    c.bench_function(name, |b| b.iter(|| read_json(\u0026bytes)));\n}\n\nfn bench_big_schema_json_read_10_000_record(c: \u0026mut Criterion) {\n    bench_read_json(\n        c,\n        \u0026make_big_json_record,\n        10_000,\n        \"big schema, read 10k JSON records\",\n    );\n}\n\ncriterion_group!(\n    name = benches;\n    config = Criterion::default().sample_size(10);\n    targets = bench_big_schema_json_read_10_000_record,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","single.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    to_avro_datum,\n    types::{Record, Value},\n};\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nconst RAW_SMALL_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"test\",\n  \"type\": \"record\",\n  \"name\": \"Test\",\n  \"fields\": [\n    {\n      \"type\": {\n        \"type\": \"string\"\n      },\n      \"name\": \"field\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_BIG_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"my.example\",\n  \"type\": \"record\",\n  \"name\": \"userInfo\",\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"username\"\n    },\n    {\n      \"default\": -1,\n      \"type\": \"int\",\n      \"name\": \"age\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"phone\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"housenum\"\n    },\n    {\n      \"default\": {},\n      \"type\": {\n        \"fields\": [\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"street\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"city\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"state_prov\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"country\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"zip\"\n          }\n        ],\n        \"type\": \"record\",\n        \"name\": \"mailing_address\"\n      },\n      \"name\": \"address\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_ADDRESS_SCHEMA: \u0026str = r#\"\n{\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"street\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"city\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"state_prov\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"country\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"zip\"\n    }\n  ],\n  \"type\": \"record\",\n  \"name\": \"mailing_address\"\n}\n\"#;\n\nfn make_small_record() -\u003e (Schema, Value) {\n    let small_schema = Schema::parse_str(RAW_SMALL_SCHEMA).unwrap();\n    let small_record = {\n        let mut small_record = Record::new(\u0026small_schema).unwrap();\n        small_record.put(\"field\", \"foo\");\n        small_record.into()\n    };\n\n    (small_schema, small_record)\n}\n\nfn make_big_record() -\u003e (Schema, Value) {\n    let big_schema = Schema::parse_str(RAW_BIG_SCHEMA).unwrap();\n    let address_schema = Schema::parse_str(RAW_ADDRESS_SCHEMA).unwrap();\n    let mut address = Record::new(\u0026address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let big_record = {\n        let mut big_record = Record::new(\u0026big_schema).unwrap();\n        big_record.put(\"username\", \"username\");\n        big_record.put(\"age\", 10i32);\n        big_record.put(\"phone\", \"000000000\");\n        big_record.put(\"housenum\", \"0000\");\n        big_record.put(\"address\", address);\n        big_record.into()\n    };\n\n    (big_schema, big_record)\n}\n\nfn bench_small_schema_write_record(c: \u0026mut Criterion) {\n    let (schema, record) = make_small_record();\n    c.bench_function(\"small record\", |b| {\n        b.iter(|| to_avro_datum(\u0026schema, record.clone()))\n    });\n}\n\nfn bench_big_schema_write_record(c: \u0026mut Criterion) {\n    let (schema, record) = make_big_record();\n    c.bench_function(\"big record\", |b| {\n        b.iter(|| to_avro_datum(\u0026schema, record.clone()))\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_small_schema_write_record,\n    bench_big_schema_write_record\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","examples","benchmark.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    types::{Record, Value},\n    Reader, Writer,\n};\nuse std::time::{Duration, Instant};\n\nfn nanos(duration: Duration) -\u003e u64 {\n    duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64\n}\n\nfn seconds(nanos: u64) -\u003e f64 {\n    (nanos as f64) / 1_000_000_000f64\n}\n\n/*\nfn duration(nanos: u64) -\u003e Duration {\n    Duration::new(nanos / 1_000_000_000, (nanos % 1_000_000_000) as u32)\n}\n*/\n\nfn benchmark(schema: \u0026Schema, record: \u0026Value, s: \u0026str, count: usize, runs: usize) {\n    let mut records = Vec::new();\n    for __ in 0..count {\n        records.push(record.clone());\n    }\n\n    let mut durations = Vec::with_capacity(runs);\n\n    let mut bytes = None;\n    for _ in 0..runs {\n        let records = records.clone();\n\n        let start = Instant::now();\n        let mut writer = Writer::new(schema, Vec::new());\n        writer.extend(records.into_iter()).unwrap();\n\n        let duration = Instant::now().duration_since(start);\n        durations.push(duration);\n\n        bytes = Some(writer.into_inner().unwrap());\n    }\n\n    let total_duration_write = durations.into_iter().fold(0u64, |a, b| a + nanos(b));\n\n    // println!(\"Write: {} {} {:?}\", count, runs, seconds(total_duration));\n\n    let bytes = bytes.unwrap();\n\n    let mut durations = Vec::with_capacity(runs);\n\n    for _ in 0..runs {\n        let start = Instant::now();\n        let reader = Reader::with_schema(schema, \u0026bytes[..]).unwrap();\n\n        let mut read_records = Vec::with_capacity(count);\n        for record in reader {\n            read_records.push(record);\n        }\n\n        let duration = Instant::now().duration_since(start);\n        durations.push(duration);\n\n        assert_eq!(count, read_records.len());\n    }\n\n    let total_duration_read = durations.into_iter().fold(0u64, |a, b| a + nanos(b));\n\n    // println!(\"Read: {} {} {:?}\", count, runs, seconds(total_duration));\n    let (s_w, s_r) = (seconds(total_duration_write), seconds(total_duration_read));\n\n    println!(\"{},{},{},{},{}\", count, runs, s, s_w, s_r);\n}\n\nfn main() {\n    let raw_small_schema = r#\"\n        {\"namespace\": \"test\", \"type\": \"record\", \"name\": \"Test\", \"fields\": [{\"type\": {\"type\": \"string\"}, \"name\": \"field\"}]}\n    \"#;\n\n    let raw_big_schema = r#\"\n        {\"namespace\": \"my.example\", \"type\": \"record\", \"name\": \"userInfo\", \"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"username\"}, {\"default\": -1, \"type\": \"int\", \"name\": \"age\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"phone\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"housenum\"}, {\"default\": {}, \"type\": {\"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"street\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"city\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"state_prov\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"country\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"zip\"}], \"type\": \"record\", \"name\": \"mailing_address\"}, \"name\": \"address\"}]}\n    \"#;\n\n    let small_schema = Schema::parse_str(raw_small_schema).unwrap();\n    let big_schema = Schema::parse_str(raw_big_schema).unwrap();\n\n    println!(\"{:?}\", small_schema);\n    println!(\"{:?}\", big_schema);\n\n    let mut small_record = Record::new(\u0026small_schema).unwrap();\n    small_record.put(\"field\", \"foo\");\n    let small_record = small_record.into();\n\n    let raw_address_schema = r#\"{\"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"street\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"city\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"state_prov\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"country\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"zip\"}], \"type\": \"record\", \"name\": \"mailing_address\"}\"#;\n    let address_schema = Schema::parse_str(raw_address_schema).unwrap();\n    let mut address = Record::new(\u0026address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let mut big_record = Record::new(\u0026big_schema).unwrap();\n    big_record.put(\"username\", \"username\");\n    big_record.put(\"age\", 10i32);\n    big_record.put(\"phone\", \"000000000\");\n    big_record.put(\"housenum\", \"0000\");\n    big_record.put(\"address\", address);\n    let big_record = big_record.into();\n\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 10_000, 1);\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 10_000, 1);\n\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 1, 100_000);\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 100, 1000);\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 10_000, 10);\n\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 1, 100_000);\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 100, 1000);\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 10_000, 10);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","examples","to_value.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n#[derive(Debug, serde::Serialize)]\nstruct Test {\n    a: i64,\n    b: \u0026'static str,\n}\n\nfn main() -\u003e anyhow::Result\u003c()\u003e {\n    let test = Test { a: 27, b: \"foo\" };\n    let value = avro_rs::to_value(test)?;\n    println!(\"{:?}\", value);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","codec.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for all supported compression codecs in Avro.\nuse crate::{types::Value, AvroResult, Error};\nuse libflate::deflate::{Decoder, Encoder};\nuse std::io::{Read, Write};\nuse strum_macros::{EnumString, IntoStaticStr};\n\n/// The compression codec used to compress blocks.\n#[derive(Clone, Copy, Debug, PartialEq, EnumString, IntoStaticStr)]\n#[strum(serialize_all = \"kebab_case\")]\npub enum Codec {\n    /// The `Null` codec simply passes through data uncompressed.\n    Null,\n    /// The `Deflate` codec writes the data block using the deflate algorithm\n    /// as specified in RFC 1951, and typically implemented using the zlib library.\n    /// Note that this format (unlike the \"zlib format\" in RFC 1950) does not have a checksum.\n    Deflate,\n    #[cfg(feature = \"snappy\")]\n    /// The `Snappy` codec uses Google's [Snappy](http://google.github.io/snappy/)\n    /// compression library. Each compressed block is followed by the 4-byte, big-endian\n    /// CRC32 checksum of the uncompressed data in the block.\n    Snappy,\n}\n\nimpl From\u003cCodec\u003e for Value {\n    fn from(value: Codec) -\u003e Self {\n        Self::Bytes(\u003c\u0026str\u003e::from(value).as_bytes().to_vec())\n    }\n}\n\nimpl Codec {\n    /// Compress a stream of bytes in-place.\n    pub fn compress(self, stream: \u0026mut Vec\u003cu8\u003e) -\u003e AvroResult\u003c()\u003e {\n        match self {\n            Codec::Null =\u003e (),\n            Codec::Deflate =\u003e {\n                let mut encoder = Encoder::new(Vec::new());\n                encoder.write_all(stream).map_err(Error::DeflateCompress)?;\n                // Deflate errors seem to just be io::Error\n                *stream = encoder\n                    .finish()\n                    .into_result()\n                    .map_err(Error::DeflateCompressFinish)?;\n            }\n            #[cfg(feature = \"snappy\")]\n            Codec::Snappy =\u003e {\n                use byteorder::ByteOrder;\n\n                let mut encoded: Vec\u003cu8\u003e = vec![0; snap::raw::max_compress_len(stream.len())];\n                let compressed_size = snap::raw::Encoder::new()\n                    .compress(\u0026stream[..], \u0026mut encoded[..])\n                    .map_err(Error::SnappyCompress)?;\n\n                let crc = crc::crc32::checksum_ieee(\u0026stream[..]);\n                byteorder::BigEndian::write_u32(\u0026mut encoded[compressed_size..], crc);\n                encoded.truncate(compressed_size + 4);\n\n                *stream = encoded;\n            }\n        };\n\n        Ok(())\n    }\n\n    /// Decompress a stream of bytes in-place.\n    pub fn decompress(self, stream: \u0026mut Vec\u003cu8\u003e) -\u003e AvroResult\u003c()\u003e {\n        *stream = match self {\n            Codec::Null =\u003e return Ok(()),\n            Codec::Deflate =\u003e {\n                let mut decoded = Vec::new();\n                let mut decoder = Decoder::new(\u0026stream[..]);\n                decoder\n                    .read_to_end(\u0026mut decoded)\n                    .map_err(Error::DeflateDecompress)?;\n                decoded\n            }\n            #[cfg(feature = \"snappy\")]\n            Codec::Snappy =\u003e {\n                use byteorder::ByteOrder;\n\n                let decompressed_size = snap::raw::decompress_len(\u0026stream[..stream.len() - 4])\n                    .map_err(Error::GetSnappyDecompressLen)?;\n                let mut decoded = vec![0; decompressed_size];\n                snap::raw::Decoder::new()\n                    .decompress(\u0026stream[..stream.len() - 4], \u0026mut decoded[..])\n                    .map_err(Error::SnappyDecompress)?;\n\n                let expected = byteorder::BigEndian::read_u32(\u0026stream[stream.len() - 4..]);\n                let actual = crc::crc32::checksum_ieee(\u0026decoded);\n\n                if expected != actual {\n                    return Err(Error::SnappyCrc32 { expected, actual });\n                }\n                decoded\n            }\n        };\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    const INPUT: \u0026[u8] = b\"theanswertolifetheuniverseandeverythingis42theanswertolifetheuniverseandeverythingis4theanswertolifetheuniverseandeverythingis2\";\n\n    #[test]\n    fn null_compress_and_decompress() {\n        let codec = Codec::Null;\n        let mut stream = INPUT.to_vec();\n        codec.compress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n        codec.decompress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[test]\n    fn deflate_compress_and_decompress() {\n        let codec = Codec::Deflate;\n        let mut stream = INPUT.to_vec();\n        codec.compress(\u0026mut stream).unwrap();\n        assert_ne!(INPUT, stream.as_slice());\n        assert!(INPUT.len() \u003e stream.len());\n        codec.decompress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[cfg(feature = \"snappy\")]\n    #[test]\n    fn snappy_compress_and_decompress() {\n        let codec = Codec::Snappy;\n        let mut stream = INPUT.to_vec();\n        codec.compress(\u0026mut stream).unwrap();\n        assert_ne!(INPUT, stream.as_slice());\n        assert!(INPUT.len() \u003e stream.len());\n        codec.decompress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[test]\n    fn codec_to_str() {\n        assert_eq!(\u003c\u0026str\u003e::from(Codec::Null), \"null\");\n        assert_eq!(\u003c\u0026str\u003e::from(Codec::Deflate), \"deflate\");\n\n        #[cfg(feature = \"snappy\")]\n        assert_eq!(\u003c\u0026str\u003e::from(Codec::Snappy), \"snappy\");\n    }\n\n    #[test]\n    fn codec_from_str() {\n        use std::str::FromStr;\n\n        assert_eq!(Codec::from_str(\"null\").unwrap(), Codec::Null);\n        assert_eq!(Codec::from_str(\"deflate\").unwrap(), Codec::Deflate);\n\n        #[cfg(feature = \"snappy\")]\n        assert_eq!(Codec::from_str(\"snappy\").unwrap(), Codec::Snappy);\n\n        assert!(Codec::from_str(\"not a codec\").is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","de.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for serde-compatible deserialization.\nuse crate::{types::Value, Error};\nuse serde::{\n    de::{self, DeserializeSeed, Visitor},\n    forward_to_deserialize_any, Deserialize,\n};\nuse std::{\n    collections::{\n        hash_map::{Keys, Values},\n        HashMap,\n    },\n    slice::Iter,\n};\n\npub struct Deserializer\u003c'de\u003e {\n    input: \u0026'de Value,\n}\n\nstruct SeqDeserializer\u003c'de\u003e {\n    input: Iter\u003c'de, Value\u003e,\n}\n\nstruct MapDeserializer\u003c'de\u003e {\n    input_keys: Keys\u003c'de, String, Value\u003e,\n    input_values: Values\u003c'de, String, Value\u003e,\n}\n\nstruct StructDeserializer\u003c'de\u003e {\n    input: Iter\u003c'de, (String, Value)\u003e,\n    value: Option\u003c\u0026'de Value\u003e,\n}\n\npub struct EnumUnitDeserializer\u003c'a\u003e {\n    input: \u0026'a str,\n}\n\npub struct EnumDeserializer\u003c'de\u003e {\n    input: \u0026'de [(String, Value)],\n}\n\nimpl\u003c'de\u003e Deserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de Value) -\u003e Self {\n        Deserializer { input }\n    }\n}\n\nimpl\u003c'de\u003e SeqDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de [Value]) -\u003e Self {\n        SeqDeserializer {\n            input: input.iter(),\n        }\n    }\n}\n\nimpl\u003c'de\u003e MapDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de HashMap\u003cString, Value\u003e) -\u003e Self {\n        MapDeserializer {\n            input_keys: input.keys(), // input.keys().map(|k| Value::String(k.clone())).collect::\u003cVec\u003c_\u003e\u003e().iter(),\n            input_values: input.values(),\n            // keys: input.keys().map(|s| Value::String(s.to_owned())).collect::\u003cVec\u003cValue\u003e\u003e(),\n            // values: input.values().map(|s| s.to_owned()).collect::\u003cVec\u003cValue\u003e\u003e(),\n        }\n    }\n}\n\nimpl\u003c'de\u003e StructDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de [(String, Value)]) -\u003e Self {\n        StructDeserializer {\n            input: input.iter(),\n            value: None,\n        }\n    }\n}\n\nimpl\u003c'a\u003e EnumUnitDeserializer\u003c'a\u003e {\n    pub fn new(input: \u0026'a str) -\u003e Self {\n        EnumUnitDeserializer { input }\n    }\n}\n\nimpl\u003c'de\u003e EnumDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de [(String, Value)]) -\u003e Self {\n        EnumDeserializer { input }\n    }\n}\n\nimpl\u003c'de\u003e de::EnumAccess\u003c'de\u003e for EnumUnitDeserializer\u003c'de\u003e {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: self.input.to_owned(),\n            })?,\n            self,\n        ))\n    }\n}\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for EnumUnitDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"Unexpected Newtype variant\"))\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"Unexpected tuple variant\"))\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"Unexpected struct variant\"))\n    }\n}\n\nimpl\u003c'de\u003e de::EnumAccess\u003c'de\u003e for EnumDeserializer\u003c'de\u003e {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        self.input.first().map_or(\n            Err(de::Error::custom(\"A record must have a least one field\")),\n            |item| match (item.0.as_ref(), \u0026item.1) {\n                (\"type\", Value::String(x)) =\u003e Ok((\n                    seed.deserialize(StringDeserializer {\n                        input: x.to_owned(),\n                    })?,\n                    self,\n                )),\n                (field, Value::String(_)) =\u003e Err(de::Error::custom(format!(\n                    \"Expected first field named 'type': got '{}' instead\",\n                    field\n                ))),\n                (_, _) =\u003e Err(de::Error::custom(\n                    \"Expected first field of type String for the type name\".to_string(),\n                )),\n            },\n        )\n    }\n}\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for EnumDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\n                \"Expected a newtype variant, got nothing instead.\",\n            )),\n            |item| seed.deserialize(\u0026Deserializer::new(\u0026item.1)),\n        )\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\n                \"Expected a tuple variant, got nothing instead.\",\n            )),\n            |item| de::Deserializer::deserialize_seq(\u0026Deserializer::new(\u0026item.1), visitor),\n        )\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\"Expected a struct variant, got nothing\")),\n            |item| {\n                de::Deserializer::deserialize_struct(\n                    \u0026Deserializer::new(\u0026item.1),\n                    \"\",\n                    fields,\n                    visitor,\n                )\n            },\n        )\n    }\n}\n\nimpl\u003c'a, 'de\u003e de::Deserializer\u003c'de\u003e for \u0026'a Deserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.input {\n            Value::Null =\u003e visitor.visit_unit(),\n            \u0026Value::Boolean(b) =\u003e visitor.visit_bool(b),\n            Value::Int(i) | Value::Date(i) | Value::TimeMillis(i) =\u003e visitor.visit_i32(*i),\n            Value::Long(i)\n            | Value::TimeMicros(i)\n            | Value::TimestampMillis(i)\n            | Value::TimestampMicros(i) =\u003e visitor.visit_i64(*i),\n            \u0026Value::Float(f) =\u003e visitor.visit_f32(f),\n            \u0026Value::Double(d) =\u003e visitor.visit_f64(d),\n            Value::Union(u) =\u003e match **u {\n                Value::Null =\u003e visitor.visit_unit(),\n                Value::Boolean(b) =\u003e visitor.visit_bool(b),\n                Value::Int(i) =\u003e visitor.visit_i32(i),\n                Value::Long(i) =\u003e visitor.visit_i64(i),\n                Value::Float(f) =\u003e visitor.visit_f32(f),\n                Value::Double(d) =\u003e visitor.visit_f64(d),\n                _ =\u003e Err(de::Error::custom(\"Unsupported union\")),\n            },\n            Value::Record(ref fields) =\u003e visitor.visit_map(StructDeserializer::new(fields)),\n            Value::Array(ref fields) =\u003e visitor.visit_seq(SeqDeserializer::new(fields)),\n            value =\u003e Err(de::Error::custom(format!(\n                \"incorrect value of type: {:?}\",\n                crate::schema::SchemaKind::from(value)\n            ))),\n        }\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64\n    }\n\n    fn deserialize_char\u003cV\u003e(self, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"avro does not support char\"))\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_str(s),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e ::std::str::from_utf8(bytes)\n                .map_err(|e| de::Error::custom(e.to_string()))\n                .and_then(|s| visitor.visit_str(s)),\n            Value::Uuid(ref u) =\u003e visitor.visit_str(\u0026u.to_string()),\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_string(s.to_owned()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e {\n                String::from_utf8(bytes.to_owned())\n                    .map_err(|e| de::Error::custom(e.to_string()))\n                    .and_then(|s| visitor.visit_string(s))\n            }\n            Value::Union(ref x) =\u003e match **x {\n                Value::String(ref s) =\u003e visitor.visit_string(s.to_owned()),\n                _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n            },\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_bytes(s.as_bytes()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e visitor.visit_bytes(bytes),\n            Value::Uuid(ref u) =\u003e visitor.visit_bytes(u.as_bytes()),\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_byte_buf(s.clone().into_bytes()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e {\n                visitor.visit_byte_buf(bytes.to_owned())\n            }\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Union(ref inner) if inner.as_ref() == \u0026Value::Null =\u003e visitor.visit_none(),\n            Value::Union(ref inner) =\u003e visitor.visit_some(\u0026Deserializer::new(inner)),\n            _ =\u003e Err(de::Error::custom(\"not a union\")),\n        }\n    }\n\n    fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Null =\u003e visitor.visit_unit(),\n            _ =\u003e Err(de::Error::custom(\"not a null\")),\n        }\n    }\n\n    fn deserialize_unit_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Array(ref items) =\u003e visitor.visit_seq(SeqDeserializer::new(items)),\n            Value::Union(ref inner) =\u003e match **inner {\n                Value::Array(ref items) =\u003e visitor.visit_seq(SeqDeserializer::new(items)),\n                _ =\u003e Err(de::Error::custom(\"not an array\")),\n            },\n            _ =\u003e Err(de::Error::custom(\"not an array\")),\n        }\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, _: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        _: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Map(ref items) =\u003e visitor.visit_map(MapDeserializer::new(items)),\n            _ =\u003e Err(de::Error::custom(\"not a map\")),\n        }\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        _: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Record(ref fields) =\u003e visitor.visit_map(StructDeserializer::new(fields)),\n            Value::Union(ref inner) =\u003e match **inner {\n                Value::Record(ref fields) =\u003e visitor.visit_map(StructDeserializer::new(fields)),\n                _ =\u003e Err(de::Error::custom(\"not a record\")),\n            },\n            _ =\u003e Err(de::Error::custom(\"not a record\")),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        _variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            // This branch can be anything...\n            Value::Record(ref fields) =\u003e visitor.visit_enum(EnumDeserializer::new(fields)),\n            // This has to be a unit Enum\n            Value::Enum(_index, ref field) =\u003e visitor.visit_enum(EnumUnitDeserializer::new(field)),\n            _ =\u003e Err(de::Error::custom(\"not an enum\")),\n        }\n    }\n\n    fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_any(visitor)\n    }\n}\n\nimpl\u003c'de\u003e de::SeqAccess\u003c'de\u003e for SeqDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input.next() {\n            Some(item) =\u003e seed.deserialize(\u0026Deserializer::new(item)).map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n}\n\nimpl\u003c'de\u003e de::MapAccess\u003c'de\u003e for MapDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input_keys.next() {\n            Some(key) =\u003e seed\n                .deserialize(StringDeserializer {\n                    input: (*key).clone(),\n                })\n                .map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input_values.next() {\n            Some(value) =\u003e seed.deserialize(\u0026Deserializer::new(value)),\n            None =\u003e Err(de::Error::custom(\"should not happen - too many values\")),\n        }\n    }\n}\n\nimpl\u003c'de\u003e de::MapAccess\u003c'de\u003e for StructDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input.next() {\n            Some(item) =\u003e {\n                let (ref field, ref value) = *item;\n                self.value = Some(value);\n                seed.deserialize(StringDeserializer {\n                    input: field.clone(),\n                })\n                .map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.value.take() {\n            Some(value) =\u003e seed.deserialize(\u0026Deserializer::new(value)),\n            None =\u003e Err(de::Error::custom(\"should not happen - too many values\")),\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\n\n/// Interpret a `Value` as an instance of type `D`.\n///\n/// This conversion can fail if the structure of the `Value` does not match the\n/// structure expected by `D`.\npub fn from_value\u003c'de, D: Deserialize\u003c'de\u003e\u003e(value: \u0026'de Value) -\u003e Result\u003cD, Error\u003e {\n    let de = Deserializer::new(value);\n    D::deserialize(\u0026de)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::Serialize;\n    use uuid::Uuid;\n\n    use super::*;\n\n    #[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n    struct Test {\n        a: i64,\n        b: String,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestInner {\n        a: Test,\n        b: i32,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitExternalEnum {\n        a: UnitExternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    enum UnitExternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitInternalEnum {\n        a: UnitInternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(tag = \"t\")]\n    enum UnitInternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitAdjacentEnum {\n        a: UnitAdjacentEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum UnitAdjacentEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitUntaggedEnum {\n        a: UnitUntaggedEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(untagged)]\n    enum UnitUntaggedEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestSingleValueExternalEnum {\n        a: SingleValueExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum SingleValueExternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestStructExternalEnum {\n        a: StructExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum StructExternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestTupleExternalEnum {\n        a: TupleExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum TupleExternalEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[test]\n    fn test_from_value() {\n        let test = Value::Record(vec![\n            (\"a\".to_owned(), Value::Long(27)),\n            (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n        ]);\n        let expected = Test {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let final_value: Test = from_value(\u0026test).unwrap();\n        assert_eq!(final_value, expected);\n\n        let test_inner = Value::Record(vec![\n            (\n                \"a\".to_owned(),\n                Value::Record(vec![\n                    (\"a\".to_owned(), Value::Long(27)),\n                    (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n                ]),\n            ),\n            (\"b\".to_owned(), Value::Int(35)),\n        ]);\n\n        let expected_inner = TestInner { a: expected, b: 35 };\n        let final_value: TestInner = from_value(\u0026test_inner).unwrap();\n        assert_eq!(final_value, expected_inner)\n    }\n    #[test]\n    fn test_from_value_unit_enum() {\n        let expected = TestUnitExternalEnum {\n            a: UnitExternalEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\"a\".to_owned(), Value::Enum(0, \"Val1\".to_owned()))]);\n        let final_value: TestUnitExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit external enum\"\n        );\n\n        let expected = TestUnitInternalEnum {\n            a: UnitInternalEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n        let final_value: TestUnitInternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit internal enum\"\n        );\n        let expected = TestUnitAdjacentEnum {\n            a: UnitAdjacentEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n        let final_value: TestUnitAdjacentEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit adjacent enum\"\n        );\n        let expected = TestUnitUntaggedEnum {\n            a: UnitUntaggedEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\"a\".to_owned(), Value::Null)]);\n        let final_value: TestUnitUntaggedEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_single_value_enum() {\n        let expected = TestSingleValueExternalEnum {\n            a: SingleValueExternalEnum::Double(64.0),\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Double\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Double(64.0))),\n                ),\n            ]),\n        )]);\n        let final_value: TestSingleValueExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing single value external enum(union)\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_struct_enum() {\n        let expected = TestStructExternalEnum {\n            a: StructExternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]))),\n                ),\n            ]),\n        )]);\n        let final_value: TestStructExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"error deserializing struct external enum(union)\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_tuple_enum() {\n        let expected = TestTupleExternalEnum {\n            a: TupleExternalEnum::Val1(1.0, 2.0),\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Array(vec![\n                        Value::Float(1.0),\n                        Value::Float(2.0),\n                    ]))),\n                ),\n            ]),\n        )]);\n        let final_value: TestTupleExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"error serializing tuple external enum(union)\"\n        );\n    }\n\n    type TestResult\u003cT\u003e = Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n    #[test]\n    fn test_date() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::Date(raw_value);\n        let result = crate::from_value::\u003ci32\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_time_millis() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimeMillis(raw_value);\n        let result = crate::from_value::\u003ci32\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_time_micros() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimeMicros(raw_value);\n        let result = crate::from_value::\u003ci64\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_timestamp_millis() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimestampMillis(raw_value);\n        let result = crate::from_value::\u003ci64\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_timestamp_micros() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimestampMicros(raw_value);\n        let result = crate::from_value::\u003ci64\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_from_value_uuid_str() -\u003e TestResult\u003c()\u003e {\n        let raw_value = \"9ec535ff-3e2a-45bd-91d3-0a01321b5a49\";\n        let value = Value::Uuid(Uuid::parse_str(raw_value).unwrap());\n        let result = crate::from_value::\u003cUuid\u003e(\u0026value)?;\n        assert_eq!(result.to_string(), raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_from_value_uuid_slice() -\u003e TestResult\u003c()\u003e {\n        let raw_value = \u0026[4, 54, 67, 12, 43, 2, 2, 76, 32, 50, 87, 5, 1, 33, 43, 87];\n        let value = Value::Uuid(Uuid::from_slice(raw_value)?);\n        let result = crate::from_value::\u003cUuid\u003e(\u0026value)?;\n        assert_eq!(result.as_bytes(), raw_value);\n        Ok(())\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":158},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","decimal.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{AvroResult, Error};\nuse num_bigint::{BigInt, Sign};\n\n#[derive(Debug, Clone)]\npub struct Decimal {\n    value: BigInt,\n    len: usize,\n}\n\n// We only care about value equality, not byte length. Can two equal `BigInt`s have two different\n// byte lengths?\nimpl PartialEq for Decimal {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.value == other.value\n    }\n}\n\nimpl Decimal {\n    pub(crate) fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    fn to_vec(\u0026self) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        self.to_sign_extended_bytes_with_len(self.len)\n    }\n\n    pub(crate) fn to_sign_extended_bytes_with_len(\u0026self, len: usize) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        let sign_byte = 0xFF * u8::from(self.value.sign() == Sign::Minus);\n        let mut decimal_bytes = vec![sign_byte; len];\n        let raw_bytes = self.value.to_signed_bytes_be();\n        let num_raw_bytes = raw_bytes.len();\n        let start_byte_index = len.checked_sub(num_raw_bytes).ok_or(Error::SignExtend {\n            requested: len,\n            needed: num_raw_bytes,\n        })?;\n        decimal_bytes[start_byte_index..].copy_from_slice(\u0026raw_bytes);\n        Ok(decimal_bytes)\n    }\n}\n\nimpl std::convert::TryFrom\u003c\u0026Decimal\u003e for Vec\u003cu8\u003e {\n    type Error = Error;\n\n    fn try_from(decimal: \u0026Decimal) -\u003e Result\u003cSelf, Self::Error\u003e {\n        decimal.to_vec()\n    }\n}\n\nimpl\u003cT: AsRef\u003c[u8]\u003e\u003e From\u003cT\u003e for Decimal {\n    fn from(bytes: T) -\u003e Self {\n        let bytes_ref = bytes.as_ref();\n        Self {\n            value: BigInt::from_signed_bytes_be(bytes_ref),\n            len: bytes_ref.len(),\n        }\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","decode.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{\n    decimal::Decimal,\n    duration::Duration,\n    schema::Schema,\n    types::Value,\n    util::{safe_len, zag_i32, zag_i64},\n    AvroResult, Error,\n};\nuse std::{collections::HashMap, convert::TryFrom, io::Read, str::FromStr};\nuse uuid::Uuid;\n\n#[inline]\nfn decode_long\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cValue\u003e {\n    zag_i64(reader).map(Value::Long)\n}\n\n#[inline]\nfn decode_int\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cValue\u003e {\n    zag_i32(reader).map(Value::Int)\n}\n\n#[inline]\nfn decode_len\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cusize\u003e {\n    let len = zag_i64(reader)?;\n    safe_len(usize::try_from(len).map_err(|e| Error::ConvertI64ToUsize(e, len))?)\n}\n\n/// Decode the length of a sequence.\n///\n/// Maps and arrays are 0-terminated, 0i64 is also encoded as 0 in Avro reading a length of 0 means\n/// the end of the map or array.\nfn decode_seq_len\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cusize\u003e {\n    let raw_len = zag_i64(reader)?;\n    safe_len(\n        usize::try_from(match raw_len.cmp(\u00260) {\n            std::cmp::Ordering::Equal =\u003e return Ok(0),\n            std::cmp::Ordering::Less =\u003e {\n                let _size = zag_i64(reader)?;\n                -raw_len\n            }\n            std::cmp::Ordering::Greater =\u003e raw_len,\n        })\n        .map_err(|e| Error::ConvertI64ToUsize(e, raw_len))?,\n    )\n}\n\n/// Decode a `Value` from avro format given its `Schema`.\npub fn decode\u003cR: Read\u003e(schema: \u0026Schema, reader: \u0026mut R) -\u003e AvroResult\u003cValue\u003e {\n    match *schema {\n        Schema::Null =\u003e Ok(Value::Null),\n        Schema::Boolean =\u003e {\n            let mut buf = [0u8; 1];\n            reader\n                .read_exact(\u0026mut buf[..])\n                .map_err(Error::ReadBoolean)?;\n\n            match buf[0] {\n                0u8 =\u003e Ok(Value::Boolean(false)),\n                1u8 =\u003e Ok(Value::Boolean(true)),\n                _ =\u003e Err(Error::BoolValue(buf[0])),\n            }\n        }\n        Schema::Decimal { ref inner, .. } =\u003e match \u0026**inner {\n            Schema::Fixed { .. } =\u003e match decode(inner, reader)? {\n                Value::Fixed(_, bytes) =\u003e Ok(Value::Decimal(Decimal::from(bytes))),\n                value =\u003e Err(Error::FixedValue(value.into())),\n            },\n            Schema::Bytes =\u003e match decode(inner, reader)? {\n                Value::Bytes(bytes) =\u003e Ok(Value::Decimal(Decimal::from(bytes))),\n                value =\u003e Err(Error::BytesValue(value.into())),\n            },\n            schema =\u003e Err(Error::ResolveDecimalSchema(schema.into())),\n        },\n        Schema::Uuid =\u003e Ok(Value::Uuid(\n            Uuid::from_str(match decode(\u0026Schema::String, reader)? {\n                Value::String(ref s) =\u003e s,\n                value =\u003e return Err(Error::GetUuidFromStringValue(value.into())),\n            })\n            .map_err(Error::ConvertStrToUuid)?,\n        )),\n        Schema::Int =\u003e decode_int(reader),\n        Schema::Date =\u003e zag_i32(reader).map(Value::Date),\n        Schema::TimeMillis =\u003e zag_i32(reader).map(Value::TimeMillis),\n        Schema::Long =\u003e decode_long(reader),\n        Schema::TimeMicros =\u003e zag_i64(reader).map(Value::TimeMicros),\n        Schema::TimestampMillis =\u003e zag_i64(reader).map(Value::TimestampMillis),\n        Schema::TimestampMicros =\u003e zag_i64(reader).map(Value::TimestampMicros),\n        Schema::Duration =\u003e {\n            let mut buf = [0u8; 12];\n            reader.read_exact(\u0026mut buf).map_err(Error::ReadDuration)?;\n            Ok(Value::Duration(Duration::from(buf)))\n        }\n        Schema::Float =\u003e {\n            let mut buf = [0u8; std::mem::size_of::\u003cf32\u003e()];\n            reader.read_exact(\u0026mut buf[..]).map_err(Error::ReadFloat)?;\n            Ok(Value::Float(f32::from_le_bytes(buf)))\n        }\n        Schema::Double =\u003e {\n            let mut buf = [0u8; std::mem::size_of::\u003cf64\u003e()];\n            reader.read_exact(\u0026mut buf[..]).map_err(Error::ReadDouble)?;\n            Ok(Value::Double(f64::from_le_bytes(buf)))\n        }\n        Schema::Bytes =\u003e {\n            let len = decode_len(reader)?;\n            let mut buf = vec![0u8; len];\n            reader.read_exact(\u0026mut buf).map_err(Error::ReadBytes)?;\n            Ok(Value::Bytes(buf))\n        }\n        Schema::String =\u003e {\n            let len = decode_len(reader)?;\n            let mut buf = vec![0u8; len];\n            reader.read_exact(\u0026mut buf).map_err(Error::ReadString)?;\n\n            Ok(Value::String(\n                String::from_utf8(buf).map_err(Error::ConvertToUtf8)?,\n            ))\n        }\n        Schema::Fixed { size, .. } =\u003e {\n            let mut buf = vec![0u8; size];\n            reader\n                .read_exact(\u0026mut buf)\n                .map_err(|e| Error::ReadFixed(e, size))?;\n            Ok(Value::Fixed(size, buf))\n        }\n        Schema::Array(ref inner) =\u003e {\n            let mut items = Vec::new();\n\n            loop {\n                let len = decode_seq_len(reader)?;\n                if len == 0 {\n                    break;\n                }\n\n                items.reserve(len);\n                for _ in 0..len {\n                    items.push(decode(inner, reader)?);\n                }\n            }\n\n            Ok(Value::Array(items))\n        }\n        Schema::Map(ref inner) =\u003e {\n            let mut items = HashMap::new();\n\n            loop {\n                let len = decode_seq_len(reader)?;\n                if len == 0 {\n                    break;\n                }\n\n                items.reserve(len);\n                for _ in 0..len {\n                    match decode(\u0026Schema::String, reader)? {\n                        Value::String(key) =\u003e {\n                            let value = decode(inner, reader)?;\n                            items.insert(key, value);\n                        }\n                        value =\u003e return Err(Error::MapKeyType(value.into())),\n                    }\n                }\n            }\n\n            Ok(Value::Map(items))\n        }\n        Schema::Union(ref inner) =\u003e {\n            let index = zag_i64(reader)?;\n            let variants = inner.variants();\n            let variant = variants\n                .get(usize::try_from(index).map_err(|e| Error::ConvertI64ToUsize(e, index))?)\n                .ok_or_else(|| Error::GetUnionVariant {\n                    index,\n                    num_variants: variants.len(),\n                })?;\n            let value = decode(variant, reader)?;\n            Ok(Value::Union(Box::new(value)))\n        }\n        Schema::Record { ref fields, .. } =\u003e {\n            // Benchmarks indicate ~10% improvement using this method.\n            let mut items = Vec::with_capacity(fields.len());\n            for field in fields {\n                // TODO: This clone is also expensive. See if we can do away with it...\n                items.push((field.name.clone(), decode(\u0026field.schema, reader)?));\n            }\n            Ok(Value::Record(items))\n        }\n        Schema::Enum { ref symbols, .. } =\u003e {\n            Ok(if let Value::Int(raw_index) = decode_int(reader)? {\n                let index = usize::try_from(raw_index)\n                    .map_err(|e| Error::ConvertI32ToUsize(e, raw_index))?;\n                if (0..=symbols.len()).contains(\u0026index) {\n                    let symbol = symbols[index].clone();\n                    Value::Enum(raw_index, symbol)\n                } else {\n                    return Err(Error::GetEnumValue {\n                        index,\n                        nsymbols: symbols.len(),\n                    });\n                }\n            } else {\n                return Err(Error::GetEnumSymbol);\n            })\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        decode::decode,\n        schema::Schema,\n        types::{\n            Value,\n            Value::{Array, Int, Map},\n        },\n        Decimal,\n    };\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_decode_array_without_size() {\n        let mut input: \u0026[u8] = \u0026[6, 2, 4, 6, 0];\n        let result = decode(\u0026Schema::Array(Box::new(Schema::Int)), \u0026mut input);\n        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_array_with_size() {\n        let mut input: \u0026[u8] = \u0026[5, 6, 2, 4, 6, 0];\n        let result = decode(\u0026Schema::Array(Box::new(Schema::Int)), \u0026mut input);\n        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_map_without_size() {\n        let mut input: \u0026[u8] = \u0026[0x02, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];\n        let result = decode(\u0026Schema::Map(Box::new(Schema::Int)), \u0026mut input);\n        let mut expected = HashMap::new();\n        expected.insert(String::from(\"test\"), Int(1));\n        assert_eq!(Map(expected), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_map_with_size() {\n        let mut input: \u0026[u8] = \u0026[0x01, 0x0C, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];\n        let result = decode(\u0026Schema::Map(Box::new(Schema::Int)), \u0026mut input);\n        let mut expected = HashMap::new();\n        expected.insert(String::from(\"test\"), Int(1));\n        assert_eq!(Map(expected), result.unwrap());\n    }\n\n    #[test]\n    fn test_negative_decimal_value() {\n        use crate::{encode::encode, schema::Name};\n        use num_bigint::ToBigInt;\n        let inner = Box::new(Schema::Fixed {\n            size: 2,\n            name: Name::new(\"decimal\"),\n        });\n        let schema = Schema::Decimal {\n            inner,\n            precision: 4,\n            scale: 2,\n        };\n        let bigint = (-423).to_bigint().unwrap();\n        let value = Value::Decimal(Decimal::from(bigint.to_signed_bytes_be()));\n\n        let mut buffer = Vec::new();\n        encode(\u0026value, \u0026schema, \u0026mut buffer);\n\n        let mut bytes = \u0026buffer[..];\n        let result = decode(\u0026schema, \u0026mut bytes).unwrap();\n        assert_eq!(result, value);\n    }\n\n    #[test]\n    fn test_decode_decimal_with_bigger_than_necessary_size() {\n        use crate::{encode::encode, schema::Name};\n        use num_bigint::ToBigInt;\n        let inner = Box::new(Schema::Fixed {\n            size: 13,\n            name: Name::new(\"decimal\"),\n        });\n        let schema = Schema::Decimal {\n            inner,\n            precision: 4,\n            scale: 2,\n        };\n        let value = Value::Decimal(Decimal::from(\n            ((-423).to_bigint().unwrap()).to_signed_bytes_be(),\n        ));\n        let mut buffer = Vec::\u003cu8\u003e::new();\n\n        encode(\u0026value, \u0026schema, \u0026mut buffer);\n        let mut bytes: \u0026[u8] = \u0026buffer[..];\n        let result = decode(\u0026schema, \u0026mut bytes).unwrap();\n        assert_eq!(result, value);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":127},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","duration.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse byteorder::LittleEndian;\nuse zerocopy::U32;\n\n/// A struct representing duration that hides the details of endianness and conversion between\n/// platform-native u32 and byte arrays.\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Duration {\n    months: Months,\n    days: Days,\n    millis: Millis,\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Months(U32\u003cLittleEndian\u003e);\n\nimpl Months {\n    pub fn new(months: u32) -\u003e Self {\n        Self(U32::new(months))\n    }\n}\n\nimpl From\u003cMonths\u003e for u32 {\n    fn from(days: Months) -\u003e Self {\n        days.0.get()\n    }\n}\n\nimpl From\u003c[u8; 4]\u003e for Months {\n    fn from(bytes: [u8; 4]) -\u003e Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef\u003c[u8; 4]\u003e for Months {\n    fn as_ref(\u0026self) -\u003e \u0026[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Days(U32\u003cLittleEndian\u003e);\n\nimpl Days {\n    pub fn new(days: u32) -\u003e Self {\n        Self(U32::new(days))\n    }\n}\n\nimpl From\u003cDays\u003e for u32 {\n    fn from(days: Days) -\u003e Self {\n        days.0.get()\n    }\n}\n\nimpl From\u003c[u8; 4]\u003e for Days {\n    fn from(bytes: [u8; 4]) -\u003e Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef\u003c[u8; 4]\u003e for Days {\n    fn as_ref(\u0026self) -\u003e \u0026[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Millis(U32\u003cLittleEndian\u003e);\n\nimpl Millis {\n    pub fn new(millis: u32) -\u003e Self {\n        Self(U32::new(millis))\n    }\n}\n\nimpl From\u003cMillis\u003e for u32 {\n    fn from(days: Millis) -\u003e Self {\n        days.0.get()\n    }\n}\n\nimpl From\u003c[u8; 4]\u003e for Millis {\n    fn from(bytes: [u8; 4]) -\u003e Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef\u003c[u8; 4]\u003e for Millis {\n    fn as_ref(\u0026self) -\u003e \u0026[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\nimpl Duration {\n    /// Construct a new `Duration`.\n    pub fn new(months: Months, days: Days, millis: Millis) -\u003e Self {\n        Self {\n            months,\n            days,\n            millis,\n        }\n    }\n\n    /// Return the number of months in this duration.\n    pub fn months(\u0026self) -\u003e Months {\n        self.months\n    }\n\n    /// Return the number of days in this duration.\n    pub fn days(\u0026self) -\u003e Days {\n        self.days\n    }\n\n    /// Return the number of milliseconds in this duration.\n    pub fn millis(\u0026self) -\u003e Millis {\n        self.millis\n    }\n}\n\nimpl From\u003cDuration\u003e for [u8; 12] {\n    fn from(duration: Duration) -\u003e Self {\n        let mut bytes = [0u8; 12];\n        bytes[0..4].copy_from_slice(duration.months.as_ref());\n        bytes[4..8].copy_from_slice(duration.days.as_ref());\n        bytes[8..12].copy_from_slice(duration.millis.as_ref());\n        bytes\n    }\n}\n\nimpl From\u003c[u8; 12]\u003e for Duration {\n    fn from(bytes: [u8; 12]) -\u003e Self {\n        Self {\n            months: Months::from([bytes[0], bytes[1], bytes[2], bytes[3]]),\n            days: Days::from([bytes[4], bytes[5], bytes[6], bytes[7]]),\n            millis: Millis::from([bytes[8], bytes[9], bytes[10], bytes[11]]),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","encode.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{\n    schema::Schema,\n    types::Value,\n    util::{zig_i32, zig_i64},\n};\nuse std::convert::TryInto;\n\n/// Encode a `Value` into avro format.\n///\n/// **NOTE** This will not perform schema validation. The value is assumed to\n/// be valid with regards to the schema. Schema are needed only to guide the\n/// encoding for complex type values.\npub fn encode(value: \u0026Value, schema: \u0026Schema, buffer: \u0026mut Vec\u003cu8\u003e) {\n    encode_ref(value, schema, buffer)\n}\n\nfn encode_bytes\u003cB: AsRef\u003c[u8]\u003e + ?Sized\u003e(s: \u0026B, buffer: \u0026mut Vec\u003cu8\u003e) {\n    let bytes = s.as_ref();\n    encode(\u0026Value::Long(bytes.len() as i64), \u0026Schema::Long, buffer);\n    buffer.extend_from_slice(bytes);\n}\n\nfn encode_long(i: i64, buffer: \u0026mut Vec\u003cu8\u003e) {\n    zig_i64(i, buffer)\n}\n\nfn encode_int(i: i32, buffer: \u0026mut Vec\u003cu8\u003e) {\n    zig_i32(i, buffer)\n}\n\n/// Encode a `Value` into avro format.\n///\n/// **NOTE** This will not perform schema validation. The value is assumed to\n/// be valid with regards to the schema. Schema are needed only to guide the\n/// encoding for complex type values.\npub fn encode_ref(value: \u0026Value, schema: \u0026Schema, buffer: \u0026mut Vec\u003cu8\u003e) {\n    match value {\n        Value::Null =\u003e (),\n        Value::Boolean(b) =\u003e buffer.push(if *b { 1u8 } else { 0u8 }),\n        // Pattern | Pattern here to signify that these _must_ have the same encoding.\n        Value::Int(i) | Value::Date(i) | Value::TimeMillis(i) =\u003e encode_int(*i, buffer),\n        Value::Long(i)\n        | Value::TimestampMillis(i)\n        | Value::TimestampMicros(i)\n        | Value::TimeMicros(i) =\u003e encode_long(*i, buffer),\n        Value::Float(x) =\u003e buffer.extend_from_slice(\u0026x.to_le_bytes()),\n        Value::Double(x) =\u003e buffer.extend_from_slice(\u0026x.to_le_bytes()),\n        Value::Decimal(decimal) =\u003e match schema {\n            Schema::Decimal { inner, .. } =\u003e match *inner.clone() {\n                Schema::Fixed { size, .. } =\u003e {\n                    let bytes = decimal.to_sign_extended_bytes_with_len(size).unwrap();\n                    let num_bytes = bytes.len();\n                    if num_bytes != size {\n                        panic!(\n                            \"signed decimal bytes length {} not equal to fixed schema size {}\",\n                            num_bytes, size\n                        );\n                    }\n                    encode(\u0026Value::Fixed(size, bytes), inner, buffer)\n                }\n                Schema::Bytes =\u003e encode(\u0026Value::Bytes(decimal.try_into().unwrap()), inner, buffer),\n                _ =\u003e panic!(\"invalid inner type for decimal: {:?}\", inner),\n            },\n            _ =\u003e panic!(\"invalid type for decimal: {:?}\", schema),\n        },\n        \u0026Value::Duration(duration) =\u003e {\n            let slice: [u8; 12] = duration.into();\n            buffer.extend_from_slice(\u0026slice);\n        }\n        Value::Uuid(uuid) =\u003e encode_bytes(\u0026uuid.to_string(), buffer),\n        Value::Bytes(bytes) =\u003e match *schema {\n            Schema::Bytes =\u003e encode_bytes(bytes, buffer),\n            Schema::Fixed { .. } =\u003e buffer.extend(bytes),\n            _ =\u003e (),\n        },\n        Value::String(s) =\u003e match *schema {\n            Schema::String =\u003e {\n                encode_bytes(s, buffer);\n            }\n            Schema::Enum { ref symbols, .. } =\u003e {\n                if let Some(index) = symbols.iter().position(|item| item == s) {\n                    encode_int(index as i32, buffer);\n                }\n            }\n            _ =\u003e (),\n        },\n        Value::Fixed(_, bytes) =\u003e buffer.extend(bytes),\n        Value::Enum(i, _) =\u003e encode_int(*i, buffer),\n        Value::Union(item) =\u003e {\n            if let Schema::Union(ref inner) = *schema {\n                // Find the schema that is matched here. Due to validation, this should always\n                // return a value.\n                let (idx, inner_schema) = inner\n                    .find_schema(item)\n                    .expect(\"Invalid Union validation occurred\");\n                encode_long(idx as i64, buffer);\n                encode_ref(\u0026*item, inner_schema, buffer);\n            }\n        }\n        Value::Array(items) =\u003e {\n            if let Schema::Array(ref inner) = *schema {\n                if !items.is_empty() {\n                    encode_long(items.len() as i64, buffer);\n                    for item in items.iter() {\n                        encode_ref(item, inner, buffer);\n                    }\n                }\n                buffer.push(0u8);\n            }\n        }\n        Value::Map(items) =\u003e {\n            if let Schema::Map(ref inner) = *schema {\n                if !items.is_empty() {\n                    encode_long(items.len() as i64, buffer);\n                    for (key, value) in items {\n                        encode_bytes(key, buffer);\n                        encode_ref(value, inner, buffer);\n                    }\n                }\n                buffer.push(0u8);\n            }\n        }\n        Value::Record(fields) =\u003e {\n            if let Schema::Record {\n                fields: ref schema_fields,\n                ..\n            } = *schema\n            {\n                for (i, \u0026(_, ref value)) in fields.iter().enumerate() {\n                    encode_ref(value, \u0026schema_fields[i].schema, buffer);\n                }\n            }\n        }\n    }\n}\n\npub fn encode_to_vec(value: \u0026Value, schema: \u0026Schema) -\u003e Vec\u003cu8\u003e {\n    let mut buffer = Vec::new();\n    encode(value, schema, \u0026mut buffer);\n    buffer\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_encode_empty_array() {\n        let mut buf = Vec::new();\n        let empty: Vec\u003cValue\u003e = Vec::new();\n        encode(\n            \u0026Value::Array(empty),\n            \u0026Schema::Array(Box::new(Schema::Int)),\n            \u0026mut buf,\n        );\n        assert_eq!(vec![0u8], buf);\n    }\n\n    #[test]\n    fn test_encode_empty_map() {\n        let mut buf = Vec::new();\n        let empty: HashMap\u003cString, Value\u003e = HashMap::new();\n        encode(\n            \u0026Value::Map(empty),\n            \u0026Schema::Map(Box::new(Schema::Int)),\n            \u0026mut buf,\n        );\n        assert_eq!(vec![0u8], buf);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","error.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{schema::SchemaKind, types::ValueKind};\nuse std::fmt;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"Bad Snappy CRC32; expected {expected:x} but got {actual:x}\")]\n    SnappyCrc32 { expected: u32, actual: u32 },\n\n    #[error(\"Invalid u8 for bool: {0}\")]\n    BoolValue(u8),\n\n    #[error(\"Not a fixed value, required for decimal with fixed schema: {0:?}\")]\n    FixedValue(ValueKind),\n\n    #[error(\"Not a bytes value, required for decimal with bytes schema: {0:?}\")]\n    BytesValue(ValueKind),\n\n    #[error(\"Not a string value, required for uuid: {0:?}\")]\n    GetUuidFromStringValue(ValueKind),\n\n    #[error(\"Two schemas with the same fullname were given: {0:?}\")]\n    NameCollision(String),\n\n    #[error(\"Not a fixed or bytes type, required for decimal schema, got: {0:?}\")]\n    ResolveDecimalSchema(SchemaKind),\n\n    #[error(\"Invalid utf-8 string\")]\n    ConvertToUtf8(#[source] std::string::FromUtf8Error),\n\n    /// Describes errors happened while validating Avro data.\n    #[error(\"Value does not match schema\")]\n    Validation,\n\n    #[error(\"Unable to allocate {desired} bytes (maximum allowed: {maximum})\")]\n    MemoryAllocation { desired: usize, maximum: usize },\n\n    /// Describe a specific error happening with decimal representation\n    #[error(\"Number of bytes requested for decimal sign extension {requested} is less than the number of bytes needed to decode {needed}\")]\n    SignExtend { requested: usize, needed: usize },\n\n    #[error(\"Failed to read boolean bytes\")]\n    ReadBoolean(#[source] std::io::Error),\n\n    #[error(\"Failed to read bytes\")]\n    ReadBytes(#[source] std::io::Error),\n\n    #[error(\"Failed to read string\")]\n    ReadString(#[source] std::io::Error),\n\n    #[error(\"Failed to read double\")]\n    ReadDouble(#[source] std::io::Error),\n\n    #[error(\"Failed to read float\")]\n    ReadFloat(#[source] std::io::Error),\n\n    #[error(\"Failed to read duration\")]\n    ReadDuration(#[source] std::io::Error),\n\n    #[error(\"Failed to read fixed number of bytes: {1}\")]\n    ReadFixed(#[source] std::io::Error, usize),\n\n    #[error(\"Failed to convert \u0026str to UUID\")]\n    ConvertStrToUuid(#[source] uuid::Error),\n\n    #[error(\"Map key is not a string; key type is {0:?}\")]\n    MapKeyType(ValueKind),\n\n    #[error(\"Union index {index} out of bounds: {num_variants}\")]\n    GetUnionVariant { index: i64, num_variants: usize },\n\n    #[error(\"Enum symbol index out of bounds: {num_variants}\")]\n    EnumSymbolIndex { index: usize, num_variants: usize },\n\n    #[error(\"Enum symbol not found\")]\n    GetEnumSymbol,\n\n    #[error(\"Scale {scale} is greater than precision {precision}\")]\n    GetScaleAndPrecision { scale: usize, precision: usize },\n\n    #[error(\n        \"Fixed type number of bytes {size} is not large enough to hold decimal values of precision {precision}\"\n    )]\n    GetScaleWithFixedSize { size: usize, precision: usize },\n\n    #[error(\"expected UUID, got: {0:?}\")]\n    GetUuid(ValueKind),\n\n    #[error(\"Fixed bytes of size 12 expected, got Fixed of size {0}\")]\n    GetDecimalFixedBytes(usize),\n\n    #[error(\"Duration expected, got {0:?}\")]\n    ResolveDuration(ValueKind),\n\n    #[error(\"Decimal expected, got {0:?}\")]\n    ResolveDecimal(ValueKind),\n\n    #[error(\"Missing field in record: {0:?}\")]\n    GetField(String),\n\n    #[error(\"Unable to convert to u8, got {0:?}\")]\n    GetU8(ValueKind),\n\n    #[error(\"Precision {precision} too small to hold decimal values with {num_bytes} bytes\")]\n    ComparePrecisionAndSize { precision: usize, num_bytes: usize },\n\n    #[error(\"Cannot convert length to i32: {1}\")]\n    ConvertLengthToI32(#[source] std::num::TryFromIntError, usize),\n\n    #[error(\"Date expected, got {0:?}\")]\n    GetDate(ValueKind),\n\n    #[error(\"TimeMillis expected, got {0:?}\")]\n    GetTimeMillis(ValueKind),\n\n    #[error(\"TimeMicros expected, got {0:?}\")]\n    GetTimeMicros(ValueKind),\n\n    #[error(\"TimestampMillis expected, got {0:?}\")]\n    GetTimestampMillis(ValueKind),\n\n    #[error(\"TimestampMicros expected, got {0:?}\")]\n    GetTimestampMicros(ValueKind),\n\n    #[error(\"Null expected, got {0:?}\")]\n    GetNull(ValueKind),\n\n    #[error(\"Boolean expected, got {0:?}\")]\n    GetBoolean(ValueKind),\n\n    #[error(\"Int expected, got {0:?}\")]\n    GetInt(ValueKind),\n\n    #[error(\"Long expected, got {0:?}\")]\n    GetLong(ValueKind),\n\n    #[error(\"Double expected, got {0:?}\")]\n    GetDouble(ValueKind),\n\n    #[error(\"Float expected, got {0:?}\")]\n    GetFloat(ValueKind),\n\n    #[error(\"Bytes expected, got {0:?}\")]\n    GetBytes(ValueKind),\n\n    #[error(\"String expected, got {0:?}\")]\n    GetString(ValueKind),\n\n    #[error(\"Enum expected, got {0:?}\")]\n    GetEnum(ValueKind),\n\n    #[error(\"Fixed size mismatch, {size} expected, got {n}\")]\n    CompareFixedSizes { size: usize, n: usize },\n\n    #[error(\"String expected for fixed, got {0:?}\")]\n    GetStringForFixed(ValueKind),\n\n    #[error(\"Enum default {symbol:?} is not among allowed symbols {symbols:?}\")]\n    GetEnumDefault {\n        symbol: String,\n        symbols: Vec\u003cString\u003e,\n    },\n\n    #[error(\"Enum value index {index} is out of bounds {nsymbols}\")]\n    GetEnumValue { index: usize, nsymbols: usize },\n\n    #[error(\"Key {0} not found in decimal metadata JSON\")]\n    GetDecimalMetadataFromJson(\u0026'static str),\n\n    #[error(\"Could not find matching type in union\")]\n    FindUnionVariant,\n\n    #[error(\"Array({expected:?}) expected, got {other:?}\")]\n    GetArray {\n        expected: SchemaKind,\n        other: ValueKind,\n    },\n\n    #[error(\"Map({expected:?}) expected, got {other:?}\")]\n    GetMap {\n        expected: SchemaKind,\n        other: ValueKind,\n    },\n\n    #[error(\"Record with fields {expected:?} expected, got {other:?}\")]\n    GetRecord {\n        expected: Vec\u003c(String, SchemaKind)\u003e,\n        other: ValueKind,\n    },\n\n    #[error(\"No `name` field\")]\n    GetNameField,\n\n    #[error(\"No `name` in record field\")]\n    GetNameFieldFromRecord,\n\n    #[error(\"Unions may not directly contain a union\")]\n    GetNestedUnion,\n\n    #[error(\"Unions cannot contain duplicate types\")]\n    GetUnionDuplicate,\n\n    #[error(\"JSON value {0} claims to be u64 but cannot be converted\")]\n    GetU64FromJson(serde_json::Number),\n\n    #[error(\"JSON value {0} claims to be i64 but cannot be converted\")]\n    GetI64FromJson(serde_json::Number),\n\n    #[error(\"Cannot convert u64 to usize: {1}\")]\n    ConvertU64ToUsize(#[source] std::num::TryFromIntError, u64),\n\n    #[error(\"Cannot convert i64 to usize: {1}\")]\n    ConvertI64ToUsize(#[source] std::num::TryFromIntError, i64),\n\n    #[error(\"Cannot convert i32 to usize: {1}\")]\n    ConvertI32ToUsize(#[source] std::num::TryFromIntError, i32),\n\n    #[error(\"Invalid JSON value for decimal precision/scale integer: {0}\")]\n    GetPrecisionOrScaleFromJson(serde_json::Number),\n\n    #[error(\"Failed to parse schema from JSON\")]\n    ParseSchemaJson(#[source] serde_json::Error),\n\n    #[error(\"Must be a JSON string, object or array\")]\n    ParseSchemaFromValidJson,\n\n    #[error(\"Unknown primitiive type: {0}\")]\n    ParsePrimitive(String),\n\n    #[error(\"invalid JSON for {key:?}: {precision:?}\")]\n    GetDecimalPrecisionFromJson {\n        key: String,\n        precision: serde_json::Value,\n    },\n\n    #[error(\"Unexpected `type` {0} variant for `logicalType`\")]\n    GetLogicalTypeVariant(serde_json::Value),\n\n    #[error(\"No `type` field found for `logicalType`\")]\n    GetLogicalTypeField,\n\n    #[error(\"logicalType must be a string\")]\n    GetLogicalTypeFieldType,\n\n    #[error(\"Unknown complex type: {0}\")]\n    GetComplexType(serde_json::Value),\n\n    #[error(\"No `type` in complex type\")]\n    GetComplexTypeField,\n\n    #[error(\"No `fields` in record\")]\n    GetRecordFieldsJson,\n\n    #[error(\"No `symbols` field in enum\")]\n    GetEnumSymbolsField,\n\n    #[error(\"Unable to parse `symbols` in enum\")]\n    GetEnumSymbols,\n\n    #[error(\"Invalid enum symbol name {0}\")]\n    EnumSymbolName(String),\n\n    #[error(\"Duplicate enum symbol {0}\")]\n    EnumSymbolDuplicate(String),\n\n    #[error(\"No `items` in array\")]\n    GetArrayItemsField,\n\n    #[error(\"No `values` in map\")]\n    GetMapValuesField,\n\n    #[error(\"No `size` in fixed\")]\n    GetFixedSizeField,\n\n    #[error(\"Failed to compress with flate\")]\n    DeflateCompress(#[source] std::io::Error),\n\n    #[error(\"Failed to finish flate compressor\")]\n    DeflateCompressFinish(std::io::Error),\n\n    #[error(\"Failed to decompress with flate\")]\n    DeflateDecompress(#[source] std::io::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to compress with snappy\")]\n    SnappyCompress(#[source] snap::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to get snappy decompression length\")]\n    GetSnappyDecompressLen(#[source] snap::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to decompress with snappy\")]\n    SnappyDecompress(#[source] snap::Error),\n\n    #[error(\"Failed to read header\")]\n    ReadHeader(#[source] std::io::Error),\n\n    #[error(\"wrong magic in header\")]\n    HeaderMagic,\n\n    #[error(\"Failed to get JSON from avro.schema key in map\")]\n    GetAvroSchemaFromMap,\n\n    #[error(\"no metadata in header\")]\n    GetHeaderMetadata,\n\n    #[error(\"Failed to read marker bytes\")]\n    ReadMarker(#[source] std::io::Error),\n\n    #[error(\"Failed to read block marker bytes\")]\n    ReadBlockMarker(#[source] std::io::Error),\n\n    #[error(\"Read into buffer failed\")]\n    ReadIntoBuf(#[source] std::io::Error),\n\n    #[error(\"block marker does not match header marker\")]\n    GetBlockMarker,\n\n    #[error(\"Overflow when decoding integer value\")]\n    IntegerOverflow,\n\n    #[error(\"Failed to read bytes for decoding variable length integer\")]\n    ReadVariableIntegerBytes(#[source] std::io::Error),\n\n    #[error(\"Decoded integer out of range for i32: {1}\")]\n    ZagI32(#[source] std::num::TryFromIntError, i64),\n\n    #[error(\"unable to read block\")]\n    ReadBlock,\n\n    #[error(\"Failed to serialize value into Avro value: {0}\")]\n    SerializeValue(String),\n\n    #[error(\"Failed to deserialize Avro value into value: {0}\")]\n    DeserializeValue(String),\n\n    #[error(\"Failed to write buffer bytes during flush\")]\n    WriteBytes(#[source] std::io::Error),\n\n    #[error(\"Failed to write marker\")]\n    WriteMarker(#[source] std::io::Error),\n\n    #[error(\"Failed to convert JSON to string\")]\n    ConvertJsonToString(#[source] serde_json::Error),\n\n    /// Error while converting float to json value\n    #[error(\"failed to convert avro float to json: {0}\")]\n    ConvertF64ToJson(f64),\n}\n\nimpl serde::ser::Error for Error {\n    fn custom\u003cT: fmt::Display\u003e(msg: T) -\u003e Self {\n        Error::SerializeValue(msg.to_string())\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom\u003cT: fmt::Display\u003e(msg: T) -\u003e Self {\n        Error::DeserializeValue(msg.to_string())\n    }\n}\n","traces":[{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","lib.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! A library for working with [Apache Avro](https://avro.apache.org/) in Rust.\n//!\n//! Please check our [documentation](https://docs.rs/avro-rs) for examples, tutorials and API reference.\n//!\n//! **[Apache Avro](https://avro.apache.org/)** is a data serialization system which provides rich\n//! data structures and a compact, fast, binary data format.\n//!\n//! All data in Avro is schematized, as in the following example:\n//!\n//! ```text\n//! {\n//!     \"type\": \"record\",\n//!     \"name\": \"test\",\n//!     \"fields\": [\n//!         {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!         {\"name\": \"b\", \"type\": \"string\"}\n//!     ]\n//! }\n//! ```\n//!\n//! There are basically two ways of handling Avro data in Rust:\n//!\n//! * **as Avro-specialized data types** based on an Avro schema;\n//! * **as generic Rust serde-compatible types** implementing/deriving `Serialize` and\n//! `Deserialize`;\n//!\n//! **avro-rs** provides a way to read and write both these data representations easily and\n//! efficiently.\n//!\n//! # Installing the library\n//!\n//!\n//! Add to your `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! avro-rs = \"x.y\"\n//! ```\n//!\n//! Or in case you want to leverage the **Snappy** codec:\n//!\n//! ```toml\n//! [dependencies.avro-rs]\n//! version = \"x.y\"\n//! features = [\"snappy\"]\n//! ```\n//!\n//! # Upgrading to a newer minor version\n//!\n//! The library is still in beta, so there might be backward-incompatible changes between minor\n//! versions. If you have troubles upgrading, check the [version upgrade guide](migration_guide.md).\n//!\n//! # Defining a schema\n//!\n//! An Avro data cannot exist without an Avro schema. Schemas **must** be used while writing and\n//! **can** be used while reading and they carry the information regarding the type of data we are\n//! handling. Avro schemas are used for both schema validation and resolution of Avro data.\n//!\n//! Avro schemas are defined in **JSON** format and can just be parsed out of a raw string:\n//!\n//! ```\n//! use avro_rs::Schema;\n//!\n//! let raw_schema = r#\"\n//!     {\n//!         \"type\": \"record\",\n//!         \"name\": \"test\",\n//!         \"fields\": [\n//!             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!             {\"name\": \"b\", \"type\": \"string\"}\n//!         ]\n//!     }\n//! \"#;\n//!\n//! // if the schema is not valid, this function will return an error\n//! let schema = Schema::parse_str(raw_schema).unwrap();\n//!\n//! // schemas can be printed for debugging\n//! println!(\"{:?}\", schema);\n//! ```\n//!\n//! Additionally, a list of of definitions (which may depend on each other) can be given and all of\n//! them will be parsed into the corresponding schemas.\n//!\n//! ```\n//! use avro_rs::Schema;\n//!\n//! let raw_schema_1 = r#\"{\n//!         \"name\": \"A\",\n//!         \"type\": \"record\",\n//!         \"fields\": [\n//!             {\"name\": \"field_one\", \"type\": \"float\"}\n//!         ]\n//!     }\"#;\n//!\n//! // This definition depends on the definition of A above\n//! let raw_schema_2 = r#\"{\n//!         \"name\": \"B\",\n//!         \"type\": \"record\",\n//!         \"fields\": [\n//!             {\"name\": \"field_one\", \"type\": \"A\"}\n//!         ]\n//!     }\"#;\n//!\n//! // if the schemas are not valid, this function will return an error\n//! let schemas = Schema::parse_list(\u0026[raw_schema_1, raw_schema_2]).unwrap();\n//!\n//! // schemas can be printed for debugging\n//! println!(\"{:?}\", schemas);\n//! ```\n//! *N.B.* It is important to note that the composition of schema definitions requires schemas with names.\n//! For this reason, only schemas of type Record, Enum, and Fixed should be input into this function.\n//!\n//! The library provides also a programmatic interface to define schemas without encoding them in\n//! JSON (for advanced use), but we highly recommend the JSON interface. Please read the API\n//! reference in case you are interested.\n//!\n//! For more information about schemas and what kind of information you can encapsulate in them,\n//! please refer to the appropriate section of the\n//! [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas).\n//!\n//! # Writing data\n//!\n//! Once we have defined a schema, we are ready to serialize data in Avro, validating them against\n//! the provided schema in the process. As mentioned before, there are two ways of handling Avro\n//! data in Rust.\n//!\n//! **NOTE:** The library also provides a low-level interface for encoding a single datum in Avro\n//! bytecode without generating markers and headers (for advanced use), but we highly recommend the\n//! `Writer` interface to be totally Avro-compatible. Please read the API reference in case you are\n//! interested.\n//!\n//! ## The avro way\n//!\n//! Given that the schema we defined above is that of an Avro *Record*, we are going to use the\n//! associated type provided by the library to specify the data we want to serialize:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! use avro_rs::types::Record;\n//! use avro_rs::Writer;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! // a writer needs a schema and something to write to\n//! let mut writer = Writer::new(\u0026schema, Vec::new());\n//!\n//! // the Record type models our Record schema\n//! let mut record = Record::new(writer.schema()).unwrap();\n//! record.put(\"a\", 27i64);\n//! record.put(\"b\", \"foo\");\n//!\n//! // schema validation happens here\n//! writer.append(record).unwrap();\n//!\n//! // this is how to get back the resulting avro bytecode\n//! // this performs a flush operation to make sure data has been written, so it can fail\n//! // you can also call `writer.flush()` yourself without consuming the writer\n//! let encoded = writer.into_inner().unwrap();\n//! ```\n//!\n//! The vast majority of the times, schemas tend to define a record as a top-level container\n//! encapsulating all the values to convert as fields and providing documentation for them, but in\n//! case we want to directly define an Avro value, the library offers that capability via the\n//! `Value` interface.\n//!\n//! ```\n//! use avro_rs::types::Value;\n//!\n//! let mut value = Value::String(\"foo\".to_string());\n//! ```\n//!\n//! ## The serde way\n//!\n//! Given that the schema we defined above is an Avro *Record*, we can directly use a Rust struct\n//! deriving `Serialize` to model our data:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use serde::Serialize;\n//! use avro_rs::Writer;\n//!\n//! #[derive(Debug, Serialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! // a writer needs a schema and something to write to\n//! let mut writer = Writer::new(\u0026schema, Vec::new());\n//!\n//! // the structure models our Record schema\n//! let test = Test {\n//!     a: 27,\n//!     b: \"foo\".to_owned(),\n//! };\n//!\n//! // schema validation happens here\n//! writer.append_ser(test).unwrap();\n//!\n//! // this is how to get back the resulting avro bytecode\n//! // this performs a flush operation to make sure data is written, so it can fail\n//! // you can also call `writer.flush()` yourself without consuming the writer\n//! let encoded = writer.into_inner();\n//! ```\n//!\n//! The vast majority of the times, schemas tend to define a record as a top-level container\n//! encapsulating all the values to convert as fields and providing documentation for them, but in\n//! case we want to directly define an Avro value, any type implementing `Serialize` should work.\n//!\n//! ```\n//! let mut value = \"foo\".to_string();\n//! ```\n//!\n//! ## Using codecs to compress data\n//!\n//! Avro supports three different compression codecs when encoding data:\n//!\n//! * **Null**: leaves data uncompressed;\n//! * **Deflate**: writes the data block using the deflate algorithm as specified in RFC 1951, and\n//! typically implemented using the zlib library. Note that this format (unlike the \"zlib format\" in\n//! RFC 1950) does not have a checksum.\n//! * **Snappy**: uses Google's [Snappy](http://google.github.io/snappy/) compression library. Each\n//! compressed block is followed by the 4-byte, big-endianCRC32 checksum of the uncompressed data in\n//! the block. You must enable the `snappy` feature to use this codec.\n//!\n//! To specify a codec to use to compress data, just specify it while creating a `Writer`:\n//! ```\n//! # use avro_rs::Schema;\n//! use avro_rs::Writer;\n//! use avro_rs::Codec;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Deflate);\n//! ```\n//!\n//! # Reading data\n//!\n//! As far as reading Avro encoded data goes, we can just use the schema encoded with the data to\n//! read them. The library will do it automatically for us, as it already does for the compression\n//! codec:\n//!\n//! ```\n//! use avro_rs::Reader;\n//! # use avro_rs::Schema;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! // reader creation can fail in case the input to read from is not Avro-compatible or malformed\n//! let reader = Reader::new(\u0026input[..]).unwrap();\n//! ```\n//!\n//! In case, instead, we want to specify a different (but compatible) reader schema from the schema\n//! the data has been written with, we can just do as the following:\n//! ```\n//! use avro_rs::Schema;\n//! use avro_rs::Reader;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! #\n//! # let writer_raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026writer_schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//!\n//! let reader_raw_schema = r#\"\n//!     {\n//!         \"type\": \"record\",\n//!         \"name\": \"test\",\n//!         \"fields\": [\n//!             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!             {\"name\": \"b\", \"type\": \"string\"},\n//!             {\"name\": \"c\", \"type\": \"long\", \"default\": 43}\n//!         ]\n//!     }\n//! \"#;\n//!\n//! let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n//!\n//! // reader creation can fail in case the input to read from is not Avro-compatible or malformed\n//! let reader = Reader::with_schema(\u0026reader_schema, \u0026input[..]).unwrap();\n//! ```\n//!\n//! The library will also automatically perform schema resolution while reading the data.\n//!\n//! For more information about schema compatibility and resolution, please refer to the\n//! [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas).\n//!\n//! As usual, there are two ways to handle Avro data in Rust, as you can see below.\n//!\n//! **NOTE:** The library also provides a low-level interface for decoding a single datum in Avro\n//! bytecode without markers and header (for advanced use), but we highly recommend the `Reader`\n//! interface to leverage all Avro features. Please read the API reference in case you are\n//! interested.\n//!\n//!\n//! ## The avro way\n//!\n//! We can just read directly instances of `Value` out of the `Reader` iterator:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! use avro_rs::Reader;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! let reader = Reader::new(\u0026input[..]).unwrap();\n//!\n//! // value is a Result  of an Avro Value in case the read operation fails\n//! for value in reader {\n//!     println!(\"{:?}\", value.unwrap());\n//! }\n//!\n//! ```\n//!\n//! ## The serde way\n//!\n//! Alternatively, we can use a Rust type implementing `Deserialize` and representing our schema to\n//! read the data into:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use avro_rs::Writer;\n//! # use serde::{Deserialize, Serialize};\n//! use avro_rs::Reader;\n//! use avro_rs::from_value;\n//!\n//! # #[derive(Serialize)]\n//! #[derive(Debug, Deserialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026schema, Vec::new());\n//! # let test = Test {\n//! #     a: 27,\n//! #     b: \"foo\".to_owned(),\n//! # };\n//! # writer.append_ser(test).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! let reader = Reader::new(\u0026input[..]).unwrap();\n//!\n//! // value is a Result in case the read operation fails\n//! for value in reader {\n//!     println!(\"{:?}\", from_value::\u003cTest\u003e(\u0026value.unwrap()));\n//! }\n//! ```\n//!\n//! # Putting everything together\n//!\n//! The following is an example of how to combine everything showed so far and it is meant to be a\n//! quick reference of the library interface:\n//!\n//! ```\n//! use avro_rs::{Codec, Reader, Schema, Writer, from_value, types::Record, Error};\n//! use serde::{Deserialize, Serialize};\n//!\n//! #[derive(Debug, Deserialize, Serialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     let raw_schema = r#\"\n//!         {\n//!             \"type\": \"record\",\n//!             \"name\": \"test\",\n//!             \"fields\": [\n//!                 {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!                 {\"name\": \"b\", \"type\": \"string\"}\n//!             ]\n//!         }\n//!     \"#;\n//!\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!\n//!     println!(\"{:?}\", schema);\n//!\n//!     let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Deflate);\n//!\n//!     let mut record = Record::new(writer.schema()).unwrap();\n//!     record.put(\"a\", 27i64);\n//!     record.put(\"b\", \"foo\");\n//!\n//!     writer.append(record)?;\n//!\n//!     let test = Test {\n//!         a: 27,\n//!         b: \"foo\".to_owned(),\n//!     };\n//!\n//!     writer.append_ser(test)?;\n//!\n//!     let input = writer.into_inner()?;\n//!     let reader = Reader::with_schema(\u0026schema, \u0026input[..])?;\n//!\n//!     for record in reader {\n//!         println!(\"{:?}\", from_value::\u003cTest\u003e(\u0026record?));\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! `avro-rs` also supports the logical types listed in the [Avro specification](https://avro.apache.org/docs/current/spec.html#Logical+Types):\n//!\n//! 1. `Decimal` using the [`num_bigint`](https://docs.rs/num-bigint/0.2.6/num_bigint) crate\n//! 1. UUID using the [`uuid`](https://docs.rs/uuid/0.8.1/uuid) crate\n//! 1. Date, Time (milli) as `i32` and Time (micro) as `i64`\n//! 1. Timestamp (milli and micro) as `i64`\n//! 1. Duration as a custom type with `months`, `days` and `millis` accessor methods each of which returns an `i32`\n//!\n//! Note that the on-disk representation is identical to the underlying primitive/complex type.\n//!\n//! ### Read and write logical types\n//!\n//! ```rust\n//! use avro_rs::{\n//!     types::Record, types::Value, Codec, Days, Decimal, Duration, Millis, Months, Reader, Schema,\n//!     Writer, Error,\n//! };\n//! use num_bigint::ToBigInt;\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     let raw_schema = r#\"\n//!     {\n//!       \"type\": \"record\",\n//!       \"name\": \"test\",\n//!       \"fields\": [\n//!         {\n//!           \"name\": \"decimal_fixed\",\n//!           \"type\": {\n//!             \"type\": \"fixed\",\n//!             \"size\": 2,\n//!             \"name\": \"decimal\"\n//!           },\n//!           \"logicalType\": \"decimal\",\n//!           \"precision\": 4,\n//!           \"scale\": 2\n//!         },\n//!         {\n//!           \"name\": \"decimal_var\",\n//!           \"type\": \"bytes\",\n//!           \"logicalType\": \"decimal\",\n//!           \"precision\": 10,\n//!           \"scale\": 3\n//!         },\n//!         {\n//!           \"name\": \"uuid\",\n//!           \"type\": \"string\",\n//!           \"logicalType\": \"uuid\"\n//!         },\n//!         {\n//!           \"name\": \"date\",\n//!           \"type\": \"int\",\n//!           \"logicalType\": \"date\"\n//!         },\n//!         {\n//!           \"name\": \"time_millis\",\n//!           \"type\": \"int\",\n//!           \"logicalType\": \"time-millis\"\n//!         },\n//!         {\n//!           \"name\": \"time_micros\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"time-micros\"\n//!         },\n//!         {\n//!           \"name\": \"timestamp_millis\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"timestamp-millis\"\n//!         },\n//!         {\n//!           \"name\": \"timestamp_micros\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"timestamp-micros\"\n//!         },\n//!         {\n//!           \"name\": \"duration\",\n//!           \"type\": {\n//!             \"type\": \"fixed\",\n//!             \"size\": 12,\n//!             \"name\": \"duration\"\n//!           },\n//!           \"logicalType\": \"duration\"\n//!         }\n//!       ]\n//!     }\n//!     \"#;\n//!\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!\n//!     println!(\"{:?}\", schema);\n//!\n//!     let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Deflate);\n//!\n//!     let mut record = Record::new(writer.schema()).unwrap();\n//!     record.put(\"decimal_fixed\", Decimal::from(9936.to_bigint().unwrap().to_signed_bytes_be()));\n//!     record.put(\"decimal_var\", Decimal::from((-32442.to_bigint().unwrap()).to_signed_bytes_be()));\n//!     record.put(\"uuid\", uuid::Uuid::new_v4());\n//!     record.put(\"date\", Value::Date(1));\n//!     record.put(\"time_millis\", Value::TimeMillis(2));\n//!     record.put(\"time_micros\", Value::TimeMicros(3));\n//!     record.put(\"timestamp_millis\", Value::TimestampMillis(4));\n//!     record.put(\"timestamp_micros\", Value::TimestampMicros(5));\n//!     record.put(\"duration\", Duration::new(Months::new(6), Days::new(7), Millis::new(8)));\n//!\n//!     writer.append(record)?;\n//!\n//!     let input = writer.into_inner()?;\n//!     let reader = Reader::with_schema(\u0026schema, \u0026input[..])?;\n//!\n//!     for record in reader {\n//!         println!(\"{:?}\", record?);\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Calculate Avro schema fingerprint\n//!\n//! This library supports calculating the following fingerprints:\n//!\n//!  - SHA-256\n//!  - MD5\n//!  - Rabin\n//!\n//! An example of fingerprinting for the supported fingerprints:\n//!\n//! ```rust\n//! use avro_rs::rabin::Rabin;\n//! use avro_rs::{Schema, Error};\n//! use md5::Md5;\n//! use sha2::Sha256;\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     let raw_schema = r#\"\n//!         {\n//!             \"type\": \"record\",\n//!             \"name\": \"test\",\n//!             \"fields\": [\n//!                 {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!                 {\"name\": \"b\", \"type\": \"string\"}\n//!             ]\n//!         }\n//!     \"#;\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!     println!(\"{}\", schema.fingerprint::\u003cSha256\u003e());\n//!     println!(\"{}\", schema.fingerprint::\u003cMd5\u003e());\n//!     println!(\"{}\", schema.fingerprint::\u003cRabin\u003e());\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Ill-formed data\n//!\n//! In order to ease decoding, the Binary Encoding specification of Avro data\n//! requires some fields to have their length encoded alongside the data.\n//!\n//! If encoded data passed to a `Reader` has been ill-formed, it can happen that\n//! the bytes meant to contain the length of data are bogus and could result\n//! in extravagant memory allocation.\n//!\n//! To shield users from ill-formed data, `avro-rs` sets a limit (default: 512MB)\n//! to any allocation it will perform when decoding data.\n//!\n//! If you expect some of your data fields to be larger than this limit, be sure\n//! to make use of the `max_allocation_bytes` function before reading **any** data\n//! (we leverage Rust's [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html)\n//! mechanism to initialize this value, if\n//! any call to decode is made before a call to `max_allocation_bytes`, the limit\n//! will be 512MB throughout the lifetime of the program).\n//!\n//!\n//! ```rust\n//! use avro_rs::max_allocation_bytes;\n//!\n//! max_allocation_bytes(2 * 1024 * 1024 * 1024);  // 2GB\n//!\n//! // ... happily decode large data\n//!\n//! ```\n//!\n//! ## Check schemas compatibility\n//!\n//! This library supports checking for schemas compatibility.\n//!\n//! Note: It does not yet support named schemas (more on\n//! https://github.com/flavray/avro-rs/pull/76).\n//!\n//! Examples of checking for compatibility:\n//!\n//! 1. Compatible schemas\n//!\n//! Explanation: an int array schema can be read by a long array schema- an int\n//! (32bit signed integer) fits into a long (64bit signed integer)\n//!\n//! ```rust\n//! use avro_rs::{Schema, schema_compatibility::SchemaCompatibility};\n//!\n//! let writers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"int\"}\"#).unwrap();\n//! let readers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"long\"}\"#).unwrap();\n//! assert_eq!(true, SchemaCompatibility::can_read(\u0026writers_schema, \u0026readers_schema));\n//! ```\n//!\n//! 2. Incompatible schemas (a long array schema cannot be read by an int array schema)\n//!\n//! Explanation: a long array schema cannot be read by an int array schema- a\n//! long (64bit signed integer) does not fit into an int (32bit signed integer)\n//!\n//! ```rust\n//! use avro_rs::{Schema, schema_compatibility::SchemaCompatibility};\n//!\n//! let writers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"long\"}\"#).unwrap();\n//! let readers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"int\"}\"#).unwrap();\n//! assert_eq!(false, SchemaCompatibility::can_read(\u0026writers_schema, \u0026readers_schema));\n//! ```\n\nmod codec;\nmod de;\nmod decimal;\nmod decode;\nmod duration;\nmod encode;\nmod error;\nmod reader;\nmod ser;\nmod util;\nmod writer;\n\npub mod rabin;\npub mod schema;\npub mod schema_compatibility;\npub mod types;\n\npub use codec::Codec;\npub use de::from_value;\npub use decimal::Decimal;\npub use duration::{Days, Duration, Millis, Months};\npub use error::{Error, Error as DeError, Error as SerError};\npub use reader::{from_avro_datum, Reader};\npub use schema::Schema;\npub use ser::to_value;\npub use util::max_allocation_bytes;\npub use writer::{to_avro_datum, Writer};\n\n/// A convenience type alias for `Result`s with `Error`s.\npub type AvroResult\u003cT\u003e = Result\u003cT, Error\u003e;\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        from_avro_datum,\n        types::{Record, Value},\n        Codec, Reader, Schema, Writer,\n    };\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_default() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#;\n        let reader_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(\u0026reader_schema, \u0026input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(1, \"spades\".to_string())),\n            ])\n        );\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_string_value() {\n        let raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(\u0026schema, \u0026input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(2, \"clubs\".to_string())),\n            ])\n        );\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_resolution() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let reader_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"ninja\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(\u0026reader_schema, \u0026input[..]).unwrap();\n        assert!(reader.next().unwrap().is_err());\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_no_reader_schema() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::new(\u0026input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(2, \"clubs\".to_string())),\n            ])\n        );\n    }\n\n    #[test]\n    fn test_illformed_length() {\n        let raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#;\n\n        let schema = Schema::parse_str(raw_schema).unwrap();\n\n        // Would allocated 18446744073709551605 bytes\n        let illformed: \u0026[u8] = \u0026[0x3e, 0x15, 0xff, 0x1f, 0x15, 0xff];\n\n        let value = from_avro_datum(\u0026schema, \u0026mut \u0026*illformed, None);\n        assert!(value.is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","rabin.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Implementation of the Rabin fingerprint algorithm\nuse byteorder::{ByteOrder, LittleEndian};\nuse digest::{consts::U8, generic_array::GenericArray, FixedOutput, Reset, Update};\nuse lazy_static::lazy_static;\n\nconst EMPTY: i64 = -4513414715797952619;\n\nlazy_static! {\n    static ref FPTABLE: [i64; 256] = {\n        let mut fp_table: [i64; 256] = [0; 256];\n        for i in 0..256 {\n            let mut fp = i;\n            for _ in 0..8 {\n                fp = (fp as u64 \u003e\u003e 1) as i64 ^ (EMPTY \u0026 -(fp \u0026 1));\n            }\n            fp_table[i as usize] = fp\n        }\n        fp_table\n    };\n}\n\n/// Implementation of the Rabin fingerprint algorithm using the Digest trait as described in [schema_fingerprints](https://avro.apache.org/docs/current/spec.html#schema_fingerprints).\n///\n/// The digest is returned as the 8-byte little-endian encoding of the Rabin hash.\n/// This is what is used for avro [single object encoding](https://avro.apache.org/docs/current/spec.html#single_object_encoding)\n///\n/// ```rust\n/// use avro_rs::rabin::Rabin;\n/// use digest::Digest;\n/// use hex_literal::hex;\n///\n/// // create the Rabin hasher\n/// let mut hasher = Rabin::new();\n///\n/// // add the data\n/// hasher.update(b\"hello world\");\n///\n/// // read hash digest and consume hasher\n/// let result = hasher.finalize();\n///\n/// assert_eq!(result[..], hex!(\"60335ba6d0415528\"));\n/// ```\n///\n/// To convert the digest to the commonly used 64-bit integer value, you can use the byteorder crate:\n///\n/// ```rust\n/// # use avro_rs::rabin::Rabin;\n/// # use digest::Digest;\n/// # use hex_literal::hex;\n///\n/// # let mut hasher = Rabin::new();\n///\n/// # hasher.update(b\"hello world\");\n///\n/// # let result = hasher.finalize();\n///\n/// # assert_eq!(result[..], hex!(\"60335ba6d0415528\"));\n/// use byteorder::{ByteOrder, LittleEndian};\n///\n/// let i = LittleEndian::read_i64(\u0026result.to_vec());\n///\n/// assert_eq!(i, 2906301498937520992)\n/// ```\n#[derive(Clone)]\npub struct Rabin {\n    result: i64,\n}\n\nimpl Default for Rabin {\n    fn default() -\u003e Self {\n        Rabin { result: EMPTY }\n    }\n}\n\nimpl Update for Rabin {\n    fn update(\u0026mut self, input: impl AsRef\u003c[u8]\u003e) {\n        for b in input.as_ref() {\n            self.result = (self.result as u64 \u003e\u003e 8) as i64\n                ^ FPTABLE[((self.result ^ *b as i64) \u0026 0xff) as usize];\n        }\n    }\n}\n\nimpl FixedOutput for Rabin {\n    // 8-byte little-endian form of the i64\n    // See: https://avro.apache.org/docs/current/spec.html#single_object_encoding\n    type OutputSize = U8;\n\n    fn finalize_into(self, out: \u0026mut GenericArray\u003cu8, Self::OutputSize\u003e) {\n        LittleEndian::write_i64(out, self.result);\n    }\n\n    fn finalize_into_reset(\u0026mut self, out: \u0026mut GenericArray\u003cu8, Self::OutputSize\u003e) {\n        LittleEndian::write_i64(out, self.result);\n        self.result = EMPTY;\n    }\n}\n\nimpl Reset for Rabin {\n    fn reset(\u0026mut self) {\n        self.result = EMPTY;\n    }\n}\n\ndigest::impl_write!(Rabin);\n\n#[cfg(test)]\nmod tests {\n    use super::Rabin;\n    use byteorder::{ByteOrder, LittleEndian};\n    use digest::Digest;\n\n    // See: https://github.com/apache/avro/blob/master/share/test/data/schema-tests.txt\n    #[test]\n    fn test1() {\n        let data: \u0026[(\u0026str, i64)] = \u0026[\n            (r#\"\"null\"\"#, 7195948357588979594),\n            (r#\"\"boolean\"\"#, -6970731678124411036),\n            (\n                r#\"{\"name\":\"foo\",\"type\":\"fixed\",\"size\":15}\"#,\n                1756455273707447556,\n            ),\n            (\n                r#\"{\"name\":\"PigValue\",\"type\":\"record\",\"fields\":[{\"name\":\"value\",\"type\":[\"null\",\"int\",\"long\",\"PigValue\"]}]}\"#,\n                -1759257747318642341,\n            ),\n        ];\n\n        let mut hasher = Rabin::new();\n\n        for (s, fp) in data {\n            hasher.update(s.as_bytes());\n            let result = LittleEndian::read_i64(\u0026hasher.finalize_reset().to_vec());\n            assert_eq!(*fp, result);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","reader.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling reading from Avro format at user level.\nuse crate::{decode::decode, schema::Schema, types::Value, util, AvroResult, Codec, Error};\nuse serde_json::from_slice;\nuse std::{\n    io::{ErrorKind, Read},\n    str::FromStr,\n};\n\n// Internal Block reader.\n#[derive(Debug, Clone)]\nstruct Block\u003cR\u003e {\n    reader: R,\n    // Internal buffering to reduce allocation.\n    buf: Vec\u003cu8\u003e,\n    buf_idx: usize,\n    // Number of elements expected to exist within this block.\n    message_count: usize,\n    marker: [u8; 16],\n    codec: Codec,\n    writer_schema: Schema,\n}\n\nimpl\u003cR: Read\u003e Block\u003cR\u003e {\n    fn new(reader: R) -\u003e AvroResult\u003cBlock\u003cR\u003e\u003e {\n        let mut block = Block {\n            reader,\n            codec: Codec::Null,\n            writer_schema: Schema::Null,\n            buf: vec![],\n            buf_idx: 0,\n            message_count: 0,\n            marker: [0; 16],\n        };\n\n        block.read_header()?;\n        Ok(block)\n    }\n\n    /// Try to read the header and to set the writer `Schema`, the `Codec` and the marker based on\n    /// its content.\n    fn read_header(\u0026mut self) -\u003e AvroResult\u003c()\u003e {\n        let meta_schema = Schema::Map(Box::new(Schema::Bytes));\n\n        let mut buf = [0u8; 4];\n        self.reader\n            .read_exact(\u0026mut buf)\n            .map_err(Error::ReadHeader)?;\n\n        if buf != [b'O', b'b', b'j', 1u8] {\n            return Err(Error::HeaderMagic);\n        }\n\n        if let Value::Map(meta) = decode(\u0026meta_schema, \u0026mut self.reader)? {\n            // TODO: surface original parse schema errors instead of coalescing them here\n            let json = meta\n                .get(\"avro.schema\")\n                .and_then(|bytes| {\n                    if let Value::Bytes(ref bytes) = *bytes {\n                        from_slice(bytes.as_ref()).ok()\n                    } else {\n                        None\n                    }\n                })\n                .ok_or(Error::GetAvroSchemaFromMap)?;\n            self.writer_schema = Schema::parse(\u0026json)?;\n\n            if let Some(codec) = meta\n                .get(\"avro.codec\")\n                .and_then(|codec| {\n                    if let Value::Bytes(ref bytes) = *codec {\n                        std::str::from_utf8(bytes.as_ref()).ok()\n                    } else {\n                        None\n                    }\n                })\n                .and_then(|codec| Codec::from_str(codec).ok())\n            {\n                self.codec = codec;\n            }\n        } else {\n            return Err(Error::GetHeaderMetadata);\n        }\n\n        self.reader\n            .read_exact(\u0026mut self.marker)\n            .map_err(Error::ReadMarker)\n    }\n\n    fn fill_buf(\u0026mut self, n: usize) -\u003e AvroResult\u003c()\u003e {\n        // The buffer needs to contain exactly `n` elements, otherwise codecs will potentially read\n        // invalid bytes.\n        //\n        // The are two cases to handle here:\n        //\n        // 1. `n \u003e self.buf.len()`:\n        //    In this case we call `Vec::resize`, which guarantees that `self.buf.len() == n`.\n        // 2. `n \u003c self.buf.len()`:\n        //    We need to resize to ensure that the buffer len is safe to read `n` elements.\n        //\n        // TODO: Figure out a way to avoid having to truncate for the second case.\n        self.buf.resize(n, 0);\n        self.reader\n            .read_exact(\u0026mut self.buf)\n            .map_err(Error::ReadIntoBuf)?;\n        self.buf_idx = 0;\n        Ok(())\n    }\n\n    /// Try to read a data block, also performing schema resolution for the objects contained in\n    /// the block. The objects are stored in an internal buffer to the `Reader`.\n    fn read_block_next(\u0026mut self) -\u003e AvroResult\u003c()\u003e {\n        assert!(self.is_empty(), \"Expected self to be empty!\");\n        match util::read_long(\u0026mut self.reader) {\n            Ok(block_len) =\u003e {\n                self.message_count = block_len as usize;\n                let block_bytes = util::read_long(\u0026mut self.reader)?;\n                self.fill_buf(block_bytes as usize)?;\n                let mut marker = [0u8; 16];\n                self.reader\n                    .read_exact(\u0026mut marker)\n                    .map_err(Error::ReadBlockMarker)?;\n\n                if marker != self.marker {\n                    return Err(Error::GetBlockMarker);\n                }\n\n                // NOTE (JAB): This doesn't fit this Reader pattern very well.\n                // `self.buf` is a growable buffer that is reused as the reader is iterated.\n                // For non `Codec::Null` variants, `decompress` will allocate a new `Vec`\n                // and replace `buf` with the new one, instead of reusing the same buffer.\n                // We can address this by using some \"limited read\" type to decode directly\n                // into the buffer. But this is fine, for now.\n                self.codec.decompress(\u0026mut self.buf)\n            }\n            Err(Error::ReadVariableIntegerBytes(io_err)) =\u003e {\n                if let ErrorKind::UnexpectedEof = io_err.kind() {\n                    // to not return any error in case we only finished to read cleanly from the stream\n                    Ok(())\n                } else {\n                    Err(Error::ReadVariableIntegerBytes(io_err))\n                }\n            }\n            Err(e) =\u003e Err(e),\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.message_count\n    }\n\n    fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    fn read_next(\u0026mut self, read_schema: Option\u003c\u0026Schema\u003e) -\u003e AvroResult\u003cOption\u003cValue\u003e\u003e {\n        if self.is_empty() {\n            self.read_block_next()?;\n            if self.is_empty() {\n                return Ok(None);\n            }\n        }\n\n        let mut block_bytes = \u0026self.buf[self.buf_idx..];\n        let b_original = block_bytes.len();\n        let item = from_avro_datum(\u0026self.writer_schema, \u0026mut block_bytes, read_schema)?;\n        self.buf_idx += b_original - block_bytes.len();\n        self.message_count -= 1;\n        Ok(Some(item))\n    }\n}\n\n/// Main interface for reading Avro formatted values.\n///\n/// To be used as an iterator:\n///\n/// ```no_run\n/// # use avro_rs::Reader;\n/// # use std::io::Cursor;\n/// # let input = Cursor::new(Vec::\u003cu8\u003e::new());\n/// for value in Reader::new(input).unwrap() {\n///     match value {\n///         Ok(v) =\u003e println!(\"{:?}\", v),\n///         Err(e) =\u003e println!(\"Error: {}\", e),\n///     };\n/// }\n/// ```\npub struct Reader\u003c'a, R\u003e {\n    block: Block\u003cR\u003e,\n    reader_schema: Option\u003c\u0026'a Schema\u003e,\n    errored: bool,\n    should_resolve_schema: bool,\n}\n\nimpl\u003c'a, R: Read\u003e Reader\u003c'a, R\u003e {\n    /// Creates a `Reader` given something implementing the `io::Read` trait to read from.\n    /// No reader `Schema` will be set.\n    ///\n    /// **NOTE** The avro header is going to be read automatically upon creation of the `Reader`.\n    pub fn new(reader: R) -\u003e AvroResult\u003cReader\u003c'a, R\u003e\u003e {\n        let block = Block::new(reader)?;\n        let reader = Reader {\n            block,\n            reader_schema: None,\n            errored: false,\n            should_resolve_schema: false,\n        };\n        Ok(reader)\n    }\n\n    /// Creates a `Reader` given a reader `Schema` and something implementing the `io::Read` trait\n    /// to read from.\n    ///\n    /// **NOTE** The avro header is going to be read automatically upon creation of the `Reader`.\n    pub fn with_schema(schema: \u0026'a Schema, reader: R) -\u003e AvroResult\u003cReader\u003c'a, R\u003e\u003e {\n        let block = Block::new(reader)?;\n        let mut reader = Reader {\n            block,\n            reader_schema: Some(schema),\n            errored: false,\n            should_resolve_schema: false,\n        };\n        // Check if the reader and writer schemas disagree.\n        reader.should_resolve_schema = reader.writer_schema() != schema;\n        Ok(reader)\n    }\n\n    /// Get a reference to the writer `Schema`.\n    pub fn writer_schema(\u0026self) -\u003e \u0026Schema {\n        \u0026self.block.writer_schema\n    }\n\n    /// Get a reference to the optional reader `Schema`.\n    pub fn reader_schema(\u0026self) -\u003e Option\u003c\u0026Schema\u003e {\n        self.reader_schema\n    }\n\n    #[inline]\n    fn read_next(\u0026mut self) -\u003e AvroResult\u003cOption\u003cValue\u003e\u003e {\n        let read_schema = if self.should_resolve_schema {\n            self.reader_schema\n        } else {\n            None\n        };\n\n        self.block.read_next(read_schema)\n    }\n}\n\nimpl\u003c'a, R: Read\u003e Iterator for Reader\u003c'a, R\u003e {\n    type Item = AvroResult\u003cValue\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // to prevent keep on reading after the first error occurs\n        if self.errored {\n            return None;\n        };\n        match self.read_next() {\n            Ok(opt) =\u003e opt.map(Ok),\n            Err(e) =\u003e {\n                self.errored = true;\n                Some(Err(e))\n            }\n        }\n    }\n}\n\n/// Decode a `Value` encoded in Avro format given its `Schema` and anything implementing `io::Read`\n/// to read from.\n///\n/// In case a reader `Schema` is provided, schema resolution will also be performed.\n///\n/// **NOTE** This function has a quite small niche of usage and does NOT take care of reading the\n/// header and consecutive data blocks; use [`Reader`](struct.Reader.html) if you don't know what\n/// you are doing, instead.\npub fn from_avro_datum\u003cR: Read\u003e(\n    writer_schema: \u0026Schema,\n    reader: \u0026mut R,\n    reader_schema: Option\u003c\u0026Schema\u003e,\n) -\u003e AvroResult\u003cValue\u003e {\n    let value = decode(writer_schema, reader)?;\n    match reader_schema {\n        Some(schema) =\u003e value.resolve(schema),\n        None =\u003e Ok(value),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{types::Record, Reader};\n    use std::io::Cursor;\n\n    const SCHEMA: \u0026str = r#\"\n    {\n      \"type\": \"record\",\n      \"name\": \"test\",\n      \"fields\": [\n        {\n          \"name\": \"a\",\n          \"type\": \"long\",\n          \"default\": 42\n        },\n        {\n          \"name\": \"b\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n    \"#;\n    const UNION_SCHEMA: \u0026str = r#\"[\"null\", \"long\"]\"#;\n    const ENCODED: \u0026[u8] = \u0026[\n        79u8, 98u8, 106u8, 1u8, 4u8, 22u8, 97u8, 118u8, 114u8, 111u8, 46u8, 115u8, 99u8, 104u8,\n        101u8, 109u8, 97u8, 222u8, 1u8, 123u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8,\n        114u8, 101u8, 99u8, 111u8, 114u8, 100u8, 34u8, 44u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8,\n        58u8, 34u8, 116u8, 101u8, 115u8, 116u8, 34u8, 44u8, 34u8, 102u8, 105u8, 101u8, 108u8,\n        100u8, 115u8, 34u8, 58u8, 91u8, 123u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8, 58u8, 34u8,\n        97u8, 34u8, 44u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8, 108u8, 111u8, 110u8,\n        103u8, 34u8, 44u8, 34u8, 100u8, 101u8, 102u8, 97u8, 117u8, 108u8, 116u8, 34u8, 58u8, 52u8,\n        50u8, 125u8, 44u8, 123u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8, 58u8, 34u8, 98u8, 34u8,\n        44u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8, 115u8, 116u8, 114u8, 105u8,\n        110u8, 103u8, 34u8, 125u8, 93u8, 125u8, 20u8, 97u8, 118u8, 114u8, 111u8, 46u8, 99u8, 111u8,\n        100u8, 101u8, 99u8, 8u8, 110u8, 117u8, 108u8, 108u8, 0u8, 94u8, 61u8, 54u8, 221u8, 190u8,\n        207u8, 108u8, 180u8, 158u8, 57u8, 114u8, 40u8, 173u8, 199u8, 228u8, 239u8, 4u8, 20u8, 54u8,\n        6u8, 102u8, 111u8, 111u8, 84u8, 6u8, 98u8, 97u8, 114u8, 94u8, 61u8, 54u8, 221u8, 190u8,\n        207u8, 108u8, 180u8, 158u8, 57u8, 114u8, 40u8, 173u8, 199u8, 228u8, 239u8,\n    ];\n\n    #[test]\n    fn test_from_avro_datum() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut encoded: \u0026'static [u8] = \u0026[54, 6, 102, 111, 111];\n\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        let expected = record.into();\n\n        assert_eq!(\n            from_avro_datum(\u0026schema, \u0026mut encoded, None).unwrap(),\n            expected\n        );\n    }\n\n    #[test]\n    fn test_null_union() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let mut encoded: \u0026'static [u8] = \u0026[2, 0];\n\n        assert_eq!(\n            from_avro_datum(\u0026schema, \u0026mut encoded, None).unwrap(),\n            Value::Union(Box::new(Value::Long(0)))\n        );\n    }\n\n    #[test]\n    fn test_reader_iterator() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let reader = Reader::with_schema(\u0026schema, ENCODED).unwrap();\n\n        let mut record1 = Record::new(\u0026schema).unwrap();\n        record1.put(\"a\", 27i64);\n        record1.put(\"b\", \"foo\");\n\n        let mut record2 = Record::new(\u0026schema).unwrap();\n        record2.put(\"a\", 42i64);\n        record2.put(\"b\", \"bar\");\n\n        let expected = vec![record1.into(), record2.into()];\n\n        for (i, value) in reader.enumerate() {\n            assert_eq!(value.unwrap(), expected[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_invalid_header() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let invalid = ENCODED.to_owned().into_iter().skip(1).collect::\u003cVec\u003cu8\u003e\u003e();\n        assert!(Reader::with_schema(\u0026schema, \u0026invalid[..]).is_err());\n    }\n\n    #[test]\n    fn test_reader_invalid_block() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let invalid = ENCODED\n            .to_owned()\n            .into_iter()\n            .rev()\n            .skip(19)\n            .collect::\u003cVec\u003cu8\u003e\u003e()\n            .into_iter()\n            .rev()\n            .collect::\u003cVec\u003cu8\u003e\u003e();\n        let reader = Reader::with_schema(\u0026schema, \u0026invalid[..]).unwrap();\n        for value in reader {\n            assert!(value.is_err());\n        }\n    }\n\n    #[test]\n    fn test_reader_empty_buffer() {\n        let empty = Cursor::new(Vec::new());\n        assert!(Reader::new(empty).is_err());\n    }\n\n    #[test]\n    fn test_reader_only_header() {\n        let invalid = ENCODED\n            .to_owned()\n            .into_iter()\n            .take(165)\n            .collect::\u003cVec\u003cu8\u003e\u003e();\n        let reader = Reader::new(\u0026invalid[..]).unwrap();\n        for value in reader {\n            assert!(value.is_err());\n        }\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":102},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","schema.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for parsing and interacting with schemas in Avro format.\nuse crate::{error::Error, types, util::MapHelper, AvroResult};\nuse digest::Digest;\nuse lazy_static::lazy_static;\nuse regex::Regex;\nuse serde::{\n    ser::{SerializeMap, SerializeSeq},\n    Deserialize, Serialize, Serializer,\n};\nuse serde_json::{Map, Value};\nuse std::{\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    convert::TryInto,\n    fmt,\n    str::FromStr,\n};\nuse strum_macros::{EnumDiscriminants, EnumString};\n\nlazy_static! {\n    static ref ENUM_SYMBOL_NAME: Regex = Regex::new(r\"[A-Za-z_][A-Za-z0-9_]*\").unwrap();\n}\n\n/// Represents an Avro schema fingerprint\n/// More information about Avro schema fingerprints can be found in the\n/// [Avro Schema Fingerprint documentation](https://avro.apache.org/docs/current/spec.html#schema_fingerprints)\npub struct SchemaFingerprint {\n    pub bytes: Vec\u003cu8\u003e,\n}\n\nimpl fmt::Display for SchemaFingerprint {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            self.bytes\n                .iter()\n                .map(|byte| format!(\"{:02x}\", byte))\n                .collect::\u003cVec\u003cString\u003e\u003e()\n                .join(\"\")\n        )\n    }\n}\n\n/// Represents any valid Avro schema\n/// More information about Avro schemas can be found in the\n/// [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas)\n#[derive(Clone, Debug, EnumDiscriminants)]\n#[strum_discriminants(name(SchemaKind), derive(Hash))]\npub enum Schema {\n    /// A `null` Avro schema.\n    Null,\n    /// A `boolean` Avro schema.\n    Boolean,\n    /// An `int` Avro schema.\n    Int,\n    /// A `long` Avro schema.\n    Long,\n    /// A `float` Avro schema.\n    Float,\n    /// A `double` Avro schema.\n    Double,\n    /// A `bytes` Avro schema.\n    /// `Bytes` represents a sequence of 8-bit unsigned bytes.\n    Bytes,\n    /// A `string` Avro schema.\n    /// `String` represents a unicode character sequence.\n    String,\n    /// A `array` Avro schema. Avro arrays are required to have the same type for each element.\n    /// This variant holds the `Schema` for the array element type.\n    Array(Box\u003cSchema\u003e),\n    /// A `map` Avro schema.\n    /// `Map` holds a pointer to the `Schema` of its values, which must all be the same schema.\n    /// `Map` keys are assumed to be `string`.\n    Map(Box\u003cSchema\u003e),\n    /// A `union` Avro schema.\n    Union(UnionSchema),\n    /// A `record` Avro schema.\n    ///\n    /// The `lookup` table maps field names to their position in the `Vec`\n    /// of `fields`.\n    Record {\n        name: Name,\n        doc: Documentation,\n        fields: Vec\u003cRecordField\u003e,\n        lookup: HashMap\u003cString, usize\u003e,\n    },\n    /// An `enum` Avro schema.\n    Enum {\n        name: Name,\n        doc: Documentation,\n        symbols: Vec\u003cString\u003e,\n    },\n    /// A `fixed` Avro schema.\n    Fixed { name: Name, size: usize },\n    /// Logical type which represents `Decimal` values. The underlying type is serialized and\n    /// deserialized as `Schema::Bytes` or `Schema::Fixed`.\n    ///\n    /// `scale` defaults to 0 and is an integer greater than or equal to 0 and `precision` is an\n    /// integer greater than 0.\n    Decimal {\n        precision: DecimalMetadata,\n        scale: DecimalMetadata,\n        inner: Box\u003cSchema\u003e,\n    },\n    /// A universally unique identifier, annotating a string.\n    Uuid,\n    /// Logical type which represents the number of days since the unix epoch.\n    /// Serialization format is `Schema::Int`.\n    Date,\n    /// The time of day in number of milliseconds after midnight with no reference any calendar,\n    /// time zone or date in particular.\n    TimeMillis,\n    /// The time of day in number of microseconds after midnight with no reference any calendar,\n    /// time zone or date in particular.\n    TimeMicros,\n    /// An instant in time represented as the number of milliseconds after the UNIX epoch.\n    TimestampMillis,\n    /// An instant in time represented as the number of microseconds after the UNIX epoch.\n    TimestampMicros,\n    /// An amount of time defined by a number of months, days and milliseconds.\n    Duration,\n}\n\nimpl PartialEq for Schema {\n    /// Assess equality of two `Schema` based on [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.canonical_form() == other.canonical_form()\n    }\n}\n\nimpl SchemaKind {\n    pub fn is_primitive(self) -\u003e bool {\n        matches!(\n            self,\n            SchemaKind::Null\n                | SchemaKind::Boolean\n                | SchemaKind::Int\n                | SchemaKind::Long\n                | SchemaKind::Double\n                | SchemaKind::Float\n                | SchemaKind::Bytes\n                | SchemaKind::String,\n        )\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a types::Value\u003e for SchemaKind {\n    fn from(value: \u0026'a types::Value) -\u003e Self {\n        use crate::types::Value;\n        match value {\n            Value::Null =\u003e Self::Null,\n            Value::Boolean(_) =\u003e Self::Boolean,\n            Value::Int(_) =\u003e Self::Int,\n            Value::Long(_) =\u003e Self::Long,\n            Value::Float(_) =\u003e Self::Float,\n            Value::Double(_) =\u003e Self::Double,\n            Value::Bytes(_) =\u003e Self::Bytes,\n            Value::String(_) =\u003e Self::String,\n            Value::Array(_) =\u003e Self::Array,\n            Value::Map(_) =\u003e Self::Map,\n            Value::Union(_) =\u003e Self::Union,\n            Value::Record(_) =\u003e Self::Record,\n            Value::Enum(_, _) =\u003e Self::Enum,\n            Value::Fixed(_, _) =\u003e Self::Fixed,\n            Value::Decimal { .. } =\u003e Self::Decimal,\n            Value::Uuid(_) =\u003e Self::Uuid,\n            Value::Date(_) =\u003e Self::Date,\n            Value::TimeMillis(_) =\u003e Self::TimeMillis,\n            Value::TimeMicros(_) =\u003e Self::TimeMicros,\n            Value::TimestampMillis(_) =\u003e Self::TimestampMillis,\n            Value::TimestampMicros(_) =\u003e Self::TimestampMicros,\n            Value::Duration { .. } =\u003e Self::Duration,\n        }\n    }\n}\n\n/// Represents names for `record`, `enum` and `fixed` Avro schemas.\n///\n/// Each of these `Schema`s have a `fullname` composed of two parts:\n///   * a name\n///   * a namespace\n///\n/// `aliases` can also be defined, to facilitate schema evolution.\n///\n/// More information about schema names can be found in the\n/// [Avro specification](https://avro.apache.org/docs/current/spec.html#names)\n#[derive(Clone, Debug, PartialEq, Deserialize)]\npub struct Name {\n    pub name: String,\n    pub namespace: Option\u003cString\u003e,\n    pub aliases: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Represents documentation for complex Avro schemas.\npub type Documentation = Option\u003cString\u003e;\n\nimpl Name {\n    /// Create a new `Name`.\n    /// No `namespace` nor `aliases` will be defined.\n    pub fn new(name: \u0026str) -\u003e Name {\n        Name {\n            name: name.to_owned(),\n            namespace: None,\n            aliases: None,\n        }\n    }\n\n    /// Parse a `serde_json::Value` into a `Name`.\n    fn parse(complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSelf\u003e {\n        let name = complex.name().ok_or(Error::GetNameField)?;\n\n        let namespace = complex.string(\"namespace\");\n\n        let aliases: Option\u003cVec\u003cString\u003e\u003e = complex\n            .get(\"aliases\")\n            .and_then(|aliases| aliases.as_array())\n            .and_then(|aliases| {\n                aliases\n                    .iter()\n                    .map(|alias| alias.as_str())\n                    .map(|alias| alias.map(|a| a.to_string()))\n                    .collect::\u003cOption\u003c_\u003e\u003e()\n            });\n\n        Ok(Name {\n            name,\n            namespace,\n            aliases,\n        })\n    }\n\n    /// Return the `fullname` of this `Name`\n    ///\n    /// More information about fullnames can be found in the\n    /// [Avro specification](https://avro.apache.org/docs/current/spec.html#names)\n    pub fn fullname(\u0026self, default_namespace: Option\u003c\u0026str\u003e) -\u003e String {\n        if self.name.contains('.') {\n            self.name.clone()\n        } else {\n            let namespace = self\n                .namespace\n                .as_ref()\n                .map(|s| s.as_ref())\n                .or(default_namespace);\n\n            match namespace {\n                Some(ref namespace) =\u003e format!(\"{}.{}\", namespace, self.name),\n                None =\u003e self.name.clone(),\n            }\n        }\n    }\n}\n\n/// Represents a `field` in a `record` Avro schema.\n#[derive(Clone, Debug, PartialEq)]\npub struct RecordField {\n    /// Name of the field.\n    pub name: String,\n    /// Documentation of the field.\n    pub doc: Documentation,\n    /// Default value of the field.\n    /// This value will be used when reading Avro datum if schema resolution\n    /// is enabled.\n    pub default: Option\u003cValue\u003e,\n    /// Schema of the field.\n    pub schema: Schema,\n    /// Order of the field.\n    ///\n    /// **NOTE** This currently has no effect.\n    pub order: RecordFieldOrder,\n    /// Position of the field in the list of `field` of its parent `Schema`\n    pub position: usize,\n}\n\n/// Represents any valid order for a `field` in a `record` Avro schema.\n#[derive(Clone, Debug, PartialEq, EnumString)]\n#[strum(serialize_all = \"kebab_case\")]\npub enum RecordFieldOrder {\n    Ascending,\n    Descending,\n    Ignore,\n}\n\nimpl RecordField {\n    /// Parse a `serde_json::Value` into a `RecordField`.\n    fn parse(field: \u0026Map\u003cString, Value\u003e, position: usize, parser: \u0026mut Parser) -\u003e AvroResult\u003cSelf\u003e {\n        let name = field.name().ok_or(Error::GetNameFieldFromRecord)?;\n\n        // TODO: \"type\" = \"\u003crecord name\u003e\"\n        let schema = parser.parse_complex(field)?;\n\n        let default = field.get(\"default\").cloned();\n\n        let order = field\n            .get(\"order\")\n            .and_then(|order| order.as_str())\n            .and_then(|order| RecordFieldOrder::from_str(order).ok())\n            .unwrap_or(RecordFieldOrder::Ascending);\n\n        Ok(RecordField {\n            name,\n            doc: field.doc(),\n            default,\n            schema,\n            order,\n            position,\n        })\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct UnionSchema {\n    pub(crate) schemas: Vec\u003cSchema\u003e,\n    // Used to ensure uniqueness of schema inputs, and provide constant time finding of the\n    // schema index given a value.\n    // **NOTE** that this approach does not work for named types, and will have to be modified\n    // to support that. A simple solution is to also keep a mapping of the names used.\n    variant_index: HashMap\u003cSchemaKind, usize\u003e,\n}\n\nimpl UnionSchema {\n    pub(crate) fn new(schemas: Vec\u003cSchema\u003e) -\u003e AvroResult\u003cSelf\u003e {\n        let mut vindex = HashMap::new();\n        for (i, schema) in schemas.iter().enumerate() {\n            if let Schema::Union(_) = schema {\n                return Err(Error::GetNestedUnion);\n            }\n            let kind = SchemaKind::from(schema);\n            if vindex.insert(kind, i).is_some() {\n                return Err(Error::GetUnionDuplicate);\n            }\n        }\n        Ok(UnionSchema {\n            schemas,\n            variant_index: vindex,\n        })\n    }\n\n    /// Returns a slice to all variants of this schema.\n    pub fn variants(\u0026self) -\u003e \u0026[Schema] {\n        \u0026self.schemas\n    }\n\n    /// Returns true if the first variant of this `UnionSchema` is `Null`.\n    pub fn is_nullable(\u0026self) -\u003e bool {\n        !self.schemas.is_empty() \u0026\u0026 self.schemas[0] == Schema::Null\n    }\n\n    /// Optionally returns a reference to the schema matched by this value, as well as its position\n    /// within this union.\n    pub fn find_schema(\u0026self, value: \u0026types::Value) -\u003e Option\u003c(usize, \u0026Schema)\u003e {\n        let type_index = \u0026SchemaKind::from(value);\n        if let Some(\u0026i) = self.variant_index.get(type_index) {\n            // fast path\n            Some((i, \u0026self.schemas[i]))\n        } else {\n            // slow path (required for matching logical types)\n            self.schemas\n                .iter()\n                .enumerate()\n                .find(|(_, schema)| value.validate(schema))\n        }\n    }\n}\n\n// No need to compare variant_index, it is derivative of schemas.\nimpl PartialEq for UnionSchema {\n    fn eq(\u0026self, other: \u0026UnionSchema) -\u003e bool {\n        self.schemas.eq(\u0026other.schemas)\n    }\n}\n\ntype DecimalMetadata = usize;\npub(crate) type Precision = DecimalMetadata;\npub(crate) type Scale = DecimalMetadata;\n\nfn parse_json_integer_for_decimal(value: \u0026serde_json::Number) -\u003e Result\u003cDecimalMetadata, Error\u003e {\n    Ok(if value.is_u64() {\n        let num = value\n            .as_u64()\n            .ok_or_else(|| Error::GetU64FromJson(value.clone()))?;\n        num.try_into()\n            .map_err(|e| Error::ConvertU64ToUsize(e, num))?\n    } else if value.is_i64() {\n        let num = value\n            .as_i64()\n            .ok_or_else(|| Error::GetI64FromJson(value.clone()))?;\n        num.try_into()\n            .map_err(|e| Error::ConvertI64ToUsize(e, num))?\n    } else {\n        return Err(Error::GetPrecisionOrScaleFromJson(value.clone()));\n    })\n}\n\n#[derive(Default)]\nstruct Parser {\n    input_schemas: HashMap\u003cString, Value\u003e,\n    input_order: Vec\u003cString\u003e,\n    parsed_schemas: HashMap\u003cString, Schema\u003e,\n}\n\nimpl Schema {\n    /// Converts `self` into its [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    pub fn canonical_form(\u0026self) -\u003e String {\n        let json = serde_json::to_value(self)\n            .unwrap_or_else(|e| panic!(\"cannot parse Schema from JSON: {0}\", e));\n        parsing_canonical_form(\u0026json)\n    }\n\n    /// Generate [fingerprint] of Schema's [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    /// [fingerprint]:\n    /// https://avro.apache.org/docs/current/spec.html#schema_fingerprints\n    pub fn fingerprint\u003cD: Digest\u003e(\u0026self) -\u003e SchemaFingerprint {\n        let mut d = D::new();\n        d.update(self.canonical_form());\n        SchemaFingerprint {\n            bytes: d.finalize().to_vec(),\n        }\n    }\n\n    /// Create a `Schema` from a string representing a JSON Avro schema.\n    pub fn parse_str(input: \u0026str) -\u003e Result\u003cSchema, Error\u003e {\n        let mut parser = Parser::default();\n        parser.parse_str(input)\n    }\n\n    /// Create a array of `Schema`'s from a list of named JSON Avro schemas (Record, Enum, and\n    /// Fixed).\n    ///\n    /// It is allowed that the schemas have cross-dependencies; these will be resolved\n    /// during parsing.\n    ///\n    /// If two of the input schemas have the same fullname, an Error will be returned.\n    pub fn parse_list(input: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cSchema\u003e, Error\u003e {\n        let mut input_schemas: HashMap\u003cString, Value\u003e = HashMap::with_capacity(input.len());\n        let mut input_order: Vec\u003cString\u003e = Vec::with_capacity(input.len());\n        for js in input {\n            let schema: Value = serde_json::from_str(js).map_err(Error::ParseSchemaJson)?;\n            if let Value::Object(inner) = \u0026schema {\n                let fullname = Name::parse(inner)?.fullname(None);\n                let previous_value = input_schemas.insert(fullname.clone(), schema);\n                if previous_value.is_some() {\n                    return Err(Error::NameCollision(fullname));\n                }\n                input_order.push(fullname);\n            } else {\n                return Err(Error::GetNameField);\n            }\n        }\n        let mut parser = Parser {\n            input_schemas,\n            input_order,\n            parsed_schemas: HashMap::with_capacity(input.len()),\n        };\n        parser.parse_list()\n    }\n\n    pub fn parse(value: \u0026Value) -\u003e AvroResult\u003cSchema\u003e {\n        let mut parser = Parser::default();\n        parser.parse(value)\n    }\n}\n\nimpl Parser {\n    /// Create a `Schema` from a string representing a JSON Avro schema.\n    fn parse_str(\u0026mut self, input: \u0026str) -\u003e Result\u003cSchema, Error\u003e {\n        // TODO: (#82) this should be a ParseSchemaError wrapping the JSON error\n        let value = serde_json::from_str(input).map_err(Error::ParseSchemaJson)?;\n        self.parse(\u0026value)\n    }\n\n    /// Create an array of `Schema`'s from an iterator of JSON Avro schemas. It is allowed that\n    /// the schemas have cross-dependencies; these will be resolved during parsing.\n    fn parse_list(\u0026mut self) -\u003e Result\u003cVec\u003cSchema\u003e, Error\u003e {\n        while !self.input_schemas.is_empty() {\n            let next_name = self\n                .input_schemas\n                .keys()\n                .next()\n                .expect(\"Input schemas unexpectedly empty\")\n                .to_owned();\n            let (name, value) = self\n                .input_schemas\n                .remove_entry(\u0026next_name)\n                .expect(\"Key unexpectedly missing\");\n            let parsed = self.parse(\u0026value)?;\n            self.parsed_schemas.insert(name, parsed);\n        }\n\n        let mut parsed_schemas = Vec::with_capacity(self.parsed_schemas.len());\n        for name in self.input_order.drain(0..) {\n            let parsed = self\n                .parsed_schemas\n                .remove(\u0026name)\n                .expect(\"One of the input schemas was unexpectedly not parsed\");\n            parsed_schemas.push(parsed);\n        }\n        Ok(parsed_schemas)\n    }\n\n    /// Create a `Schema` from a `serde_json::Value` representing a JSON Avro\n    /// schema.\n    fn parse(\u0026mut self, value: \u0026Value) -\u003e AvroResult\u003cSchema\u003e {\n        match *value {\n            Value::String(ref t) =\u003e self.parse_known_schema(t.as_str()),\n            Value::Object(ref data) =\u003e self.parse_complex(data),\n            Value::Array(ref data) =\u003e self.parse_union(data),\n            _ =\u003e Err(Error::ParseSchemaFromValidJson),\n        }\n    }\n\n    /// Parse a `serde_json::Value` representing an Avro type whose Schema is known into a\n    /// `Schema`. A Schema for a `serde_json::Value` is known if it is primitive or has\n    /// been parsed previously by the parsed and stored in its map of parsed_schemas.\n    fn parse_known_schema(\u0026mut self, name: \u0026str) -\u003e AvroResult\u003cSchema\u003e {\n        match name {\n            \"null\" =\u003e Ok(Schema::Null),\n            \"boolean\" =\u003e Ok(Schema::Boolean),\n            \"int\" =\u003e Ok(Schema::Int),\n            \"long\" =\u003e Ok(Schema::Long),\n            \"double\" =\u003e Ok(Schema::Double),\n            \"float\" =\u003e Ok(Schema::Float),\n            \"bytes\" =\u003e Ok(Schema::Bytes),\n            \"string\" =\u003e Ok(Schema::String),\n            _ =\u003e self.fetch_schema(name),\n        }\n    }\n\n    /// Given a name, tries to retrieve the parsed schema from `parsed_schemas`.\n    /// If a parsed schema is not found, it checks if a json  with that name exists\n    /// in `input_schemas` and then parses it  (removing it from `input_schemas`)\n    /// and adds the parsed schema to `parsed_schemas`\n    ///\n    /// This method allows schemas definitions that depend on other types to\n    /// parse their dependencies (or look them up if already parsed).\n    fn fetch_schema(\u0026mut self, name: \u0026str) -\u003e AvroResult\u003cSchema\u003e {\n        if let Some(parsed) = self.parsed_schemas.get(name) {\n            return Ok(parsed.clone());\n        }\n        let value = self\n            .input_schemas\n            .remove(name)\n            .ok_or_else(|| Error::ParsePrimitive(name.into()))?;\n        let parsed = self.parse(\u0026value)?;\n        self.parsed_schemas.insert(name.to_string(), parsed.clone());\n        Ok(parsed)\n    }\n\n    fn parse_precision_and_scale(\n        complex: \u0026Map\u003cString, Value\u003e,\n    ) -\u003e Result\u003c(Precision, Scale), Error\u003e {\n        fn get_decimal_integer(\n            complex: \u0026Map\u003cString, Value\u003e,\n            key: \u0026'static str,\n        ) -\u003e Result\u003cDecimalMetadata, Error\u003e {\n            match complex.get(key) {\n                Some(\u0026Value::Number(ref value)) =\u003e parse_json_integer_for_decimal(value),\n                None =\u003e Err(Error::GetDecimalMetadataFromJson(key)),\n                Some(precision) =\u003e Err(Error::GetDecimalPrecisionFromJson {\n                    key: key.into(),\n                    precision: precision.clone(),\n                }),\n            }\n        }\n        let precision = get_decimal_integer(complex, \"precision\")?;\n        let scale = get_decimal_integer(complex, \"scale\")?;\n        Ok((precision, scale))\n    }\n\n    /// Parse a `serde_json::Value` representing a complex Avro type into a\n    /// `Schema`.\n    ///\n    /// Avro supports \"recursive\" definition of types.\n    /// e.g: {\"type\": {\"type\": \"string\"}}\n    fn parse_complex(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        fn logical_verify_type(\n            complex: \u0026Map\u003cString, Value\u003e,\n            kinds: \u0026[SchemaKind],\n            parser: \u0026mut Parser,\n        ) -\u003e AvroResult\u003cSchema\u003e {\n            match complex.get(\"type\") {\n                Some(value) =\u003e {\n                    let ty = parser.parse(value)?;\n                    if kinds\n                        .iter()\n                        .any(|\u0026kind| SchemaKind::from(ty.clone()) == kind)\n                    {\n                        Ok(ty)\n                    } else {\n                        Err(Error::GetLogicalTypeVariant(value.clone()))\n                    }\n                }\n                None =\u003e Err(Error::GetLogicalTypeField),\n            }\n        }\n        match complex.get(\"logicalType\") {\n            Some(\u0026Value::String(ref t)) =\u003e match t.as_str() {\n                \"decimal\" =\u003e {\n                    let inner = Box::new(logical_verify_type(\n                        complex,\n                        \u0026[SchemaKind::Fixed, SchemaKind::Bytes],\n                        self,\n                    )?);\n\n                    let (precision, scale) = Self::parse_precision_and_scale(complex)?;\n\n                    return Ok(Schema::Decimal {\n                        precision,\n                        scale,\n                        inner,\n                    });\n                }\n                \"uuid\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::String], self)?;\n                    return Ok(Schema::Uuid);\n                }\n                \"date\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Int], self)?;\n                    return Ok(Schema::Date);\n                }\n                \"time-millis\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Int], self)?;\n                    return Ok(Schema::TimeMillis);\n                }\n                \"time-micros\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimeMicros);\n                }\n                \"timestamp-millis\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimestampMillis);\n                }\n                \"timestamp-micros\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimestampMicros);\n                }\n                \"duration\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Fixed], self)?;\n                    return Ok(Schema::Duration);\n                }\n                // In this case, of an unknown logical type, we just pass through to the underlying\n                // type.\n                _ =\u003e {}\n            },\n            // The spec says to ignore invalid logical types and just continue through to the\n            // underlying type - It is unclear whether that applies to this case or not, where the\n            // `logicalType` is not a string.\n            Some(_) =\u003e return Err(Error::GetLogicalTypeFieldType),\n            _ =\u003e {}\n        }\n        match complex.get(\"type\") {\n            Some(\u0026Value::String(ref t)) =\u003e match t.as_str() {\n                \"record\" =\u003e self.parse_record(complex),\n                \"enum\" =\u003e Self::parse_enum(complex),\n                \"array\" =\u003e self.parse_array(complex),\n                \"map\" =\u003e self.parse_map(complex),\n                \"fixed\" =\u003e Self::parse_fixed(complex),\n                other =\u003e self.parse_known_schema(other),\n            },\n            Some(\u0026Value::Object(ref data)) =\u003e self.parse_complex(data),\n            Some(\u0026Value::Array(ref variants)) =\u003e self.parse_union(variants),\n            Some(unknown) =\u003e Err(Error::GetComplexType(unknown.clone())),\n            None =\u003e Err(Error::GetComplexTypeField),\n        }\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro record type into a\n    /// `Schema`.\n    fn parse_record(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        let name = Name::parse(complex)?;\n\n        let mut lookup = HashMap::new();\n\n        let fields: Vec\u003cRecordField\u003e = complex\n            .get(\"fields\")\n            .and_then(|fields| fields.as_array())\n            .ok_or(Error::GetRecordFieldsJson)\n            .and_then(|fields| {\n                fields\n                    .iter()\n                    .filter_map(|field| field.as_object())\n                    .enumerate()\n                    .map(|(position, field)| RecordField::parse(field, position, self))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()\n            })?;\n\n        for field in \u0026fields {\n            lookup.insert(field.name.clone(), field.position);\n        }\n\n        Ok(Schema::Record {\n            name,\n            doc: complex.doc(),\n            fields,\n            lookup,\n        })\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro enum type into a\n    /// `Schema`.\n    fn parse_enum(complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        let name = Name::parse(complex)?;\n\n        let symbols: Vec\u003cString\u003e = complex\n            .get(\"symbols\")\n            .and_then(|v| v.as_array())\n            .ok_or(Error::GetEnumSymbolsField)\n            .and_then(|symbols| {\n                symbols\n                    .iter()\n                    .map(|symbol| symbol.as_str().map(|s| s.to_string()))\n                    .collect::\u003cOption\u003c_\u003e\u003e()\n                    .ok_or(Error::GetEnumSymbols)\n            })?;\n\n        let mut existing_symbols: HashSet\u003c\u0026String\u003e = HashSet::with_capacity(symbols.len());\n        for symbol in symbols.iter() {\n            // Ensure enum symbol names match [A-Za-z_][A-Za-z0-9_]*\n            if !ENUM_SYMBOL_NAME.is_match(symbol) {\n                return Err(Error::EnumSymbolName(symbol.to_string()));\n            }\n\n            // Ensure there are no duplicate symbols\n            if existing_symbols.contains(\u0026symbol) {\n                return Err(Error::EnumSymbolDuplicate(symbol.to_string()));\n            }\n\n            existing_symbols.insert(symbol);\n        }\n\n        Ok(Schema::Enum {\n            name,\n            doc: complex.doc(),\n            symbols,\n        })\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro array type into a\n    /// `Schema`.\n    fn parse_array(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        complex\n            .get(\"items\")\n            .ok_or(Error::GetArrayItemsField)\n            .and_then(|items| self.parse(items))\n            .map(|schema| Schema::Array(Box::new(schema)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro map type into a\n    /// `Schema`.\n    fn parse_map(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        complex\n            .get(\"values\")\n            .ok_or(Error::GetMapValuesField)\n            .and_then(|items| self.parse(items))\n            .map(|schema| Schema::Map(Box::new(schema)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro union type into a\n    /// `Schema`.\n    fn parse_union(\u0026mut self, items: \u0026[Value]) -\u003e AvroResult\u003cSchema\u003e {\n        items\n            .iter()\n            .map(|v| self.parse(v))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .and_then(|schemas| Ok(Schema::Union(UnionSchema::new(schemas)?)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro fixed type into a\n    /// `Schema`.\n    fn parse_fixed(complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        let name = Name::parse(complex)?;\n\n        let size = complex\n            .get(\"size\")\n            .and_then(|v| v.as_i64())\n            .ok_or(Error::GetFixedSizeField)?;\n\n        Ok(Schema::Fixed {\n            name,\n            size: size as usize,\n        })\n    }\n}\n\nimpl Serialize for Schema {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Schema::Null =\u003e serializer.serialize_str(\"null\"),\n            Schema::Boolean =\u003e serializer.serialize_str(\"boolean\"),\n            Schema::Int =\u003e serializer.serialize_str(\"int\"),\n            Schema::Long =\u003e serializer.serialize_str(\"long\"),\n            Schema::Float =\u003e serializer.serialize_str(\"float\"),\n            Schema::Double =\u003e serializer.serialize_str(\"double\"),\n            Schema::Bytes =\u003e serializer.serialize_str(\"bytes\"),\n            Schema::String =\u003e serializer.serialize_str(\"string\"),\n            Schema::Array(ref inner) =\u003e {\n                let mut map = serializer.serialize_map(Some(2))?;\n                map.serialize_entry(\"type\", \"array\")?;\n                map.serialize_entry(\"items\", \u0026*inner.clone())?;\n                map.end()\n            }\n            Schema::Map(ref inner) =\u003e {\n                let mut map = serializer.serialize_map(Some(2))?;\n                map.serialize_entry(\"type\", \"map\")?;\n                map.serialize_entry(\"values\", \u0026*inner.clone())?;\n                map.end()\n            }\n            Schema::Union(ref inner) =\u003e {\n                let variants = inner.variants();\n                let mut seq = serializer.serialize_seq(Some(variants.len()))?;\n                for v in variants {\n                    seq.serialize_element(v)?;\n                }\n                seq.end()\n            }\n            Schema::Record {\n                ref name,\n                ref doc,\n                ref fields,\n                ..\n            } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"record\")?;\n                if let Some(ref n) = name.namespace {\n                    map.serialize_entry(\"namespace\", n)?;\n                }\n                map.serialize_entry(\"name\", \u0026name.name)?;\n                if let Some(ref docstr) = doc {\n                    map.serialize_entry(\"doc\", docstr)?;\n                }\n                if let Some(ref aliases) = name.aliases {\n                    map.serialize_entry(\"aliases\", aliases)?;\n                }\n                map.serialize_entry(\"fields\", fields)?;\n                map.end()\n            }\n            Schema::Enum {\n                ref name,\n                ref symbols,\n                ..\n            } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"enum\")?;\n                map.serialize_entry(\"name\", \u0026name.name)?;\n                map.serialize_entry(\"symbols\", symbols)?;\n                map.end()\n            }\n            Schema::Fixed { ref name, ref size } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"fixed\")?;\n                map.serialize_entry(\"name\", \u0026name.name)?;\n                map.serialize_entry(\"size\", size)?;\n                map.end()\n            }\n            Schema::Decimal {\n                ref scale,\n                ref precision,\n                ref inner,\n            } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \u0026*inner.clone())?;\n                map.serialize_entry(\"logicalType\", \"decimal\")?;\n                map.serialize_entry(\"scale\", scale)?;\n                map.serialize_entry(\"precision\", precision)?;\n                map.end()\n            }\n            Schema::Uuid =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"string\")?;\n                map.serialize_entry(\"logicalType\", \"uuid\")?;\n                map.end()\n            }\n            Schema::Date =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"int\")?;\n                map.serialize_entry(\"logicalType\", \"date\")?;\n                map.end()\n            }\n            Schema::TimeMillis =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"int\")?;\n                map.serialize_entry(\"logicalType\", \"time-millis\")?;\n                map.end()\n            }\n            Schema::TimeMicros =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"time-micros\")?;\n                map.end()\n            }\n            Schema::TimestampMillis =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"timestamp-millis\")?;\n                map.end()\n            }\n            Schema::TimestampMicros =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"timestamp-micros\")?;\n                map.end()\n            }\n            Schema::Duration =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n\n                // the Avro doesn't indicate what the name of the underlying fixed type of a\n                // duration should be or typically is.\n                let inner = Schema::Fixed {\n                    name: Name::new(\"duration\"),\n                    size: 12,\n                };\n                map.serialize_entry(\"type\", \u0026inner)?;\n                map.serialize_entry(\"logicalType\", \"duration\")?;\n                map.end()\n            }\n        }\n    }\n}\n\nimpl Serialize for RecordField {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let mut map = serializer.serialize_map(None)?;\n        map.serialize_entry(\"name\", \u0026self.name)?;\n        map.serialize_entry(\"type\", \u0026self.schema)?;\n\n        if let Some(ref default) = self.default {\n            map.serialize_entry(\"default\", default)?;\n        }\n\n        map.end()\n    }\n}\n\n/// Parses a **valid** avro schema into the Parsing Canonical Form.\n/// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\nfn parsing_canonical_form(schema: \u0026serde_json::Value) -\u003e String {\n    match schema {\n        serde_json::Value::Object(map) =\u003e pcf_map(map),\n        serde_json::Value::String(s) =\u003e pcf_string(s),\n        serde_json::Value::Array(v) =\u003e pcf_array(v),\n        json =\u003e panic!(\n            \"got invalid JSON value for canonical form of schema: {0}\",\n            json\n        ),\n    }\n}\n\nfn pcf_map(schema: \u0026Map\u003cString, serde_json::Value\u003e) -\u003e String {\n    // Look for the namespace variant up front.\n    let ns = schema.get(\"namespace\").and_then(|v| v.as_str());\n    let mut fields = Vec::new();\n    for (k, v) in schema {\n        // Reduce primitive types to their simple form. ([PRIMITIVE] rule)\n        if schema.len() == 1 \u0026\u0026 k == \"type\" {\n            // Invariant: function is only callable from a valid schema, so this is acceptable.\n            if let serde_json::Value::String(s) = v {\n                return pcf_string(s);\n            }\n        }\n\n        // Strip out unused fields ([STRIP] rule)\n        if field_ordering_position(k).is_none() || k == \"default\" || k == \"doc\" || k == \"aliases\" {\n            continue;\n        }\n\n        // Fully qualify the name, if it isn't already ([FULLNAMES] rule).\n        if k == \"name\" {\n            // Invariant: Only valid schemas. Must be a string.\n            let name = v.as_str().unwrap();\n            let n = match ns {\n                Some(namespace) if !name.contains('.') =\u003e {\n                    Cow::Owned(format!(\"{}.{}\", namespace, name))\n                }\n                _ =\u003e Cow::Borrowed(name),\n            };\n\n            fields.push((k, format!(\"{}:{}\", pcf_string(k), pcf_string(\u0026*n))));\n            continue;\n        }\n\n        // Strip off quotes surrounding \"size\" type, if they exist ([INTEGERS] rule).\n        if k == \"size\" {\n            let i = match v.as_str() {\n                Some(s) =\u003e s.parse::\u003ci64\u003e().expect(\"Only valid schemas are accepted!\"),\n                None =\u003e v.as_i64().unwrap(),\n            };\n            fields.push((k, format!(\"{}:{}\", pcf_string(k), i)));\n            continue;\n        }\n\n        // For anything else, recursively process the result.\n        fields.push((\n            k,\n            format!(\"{}:{}\", pcf_string(k), parsing_canonical_form(v)),\n        ));\n    }\n\n    // Sort the fields by their canonical ordering ([ORDER] rule).\n    fields.sort_unstable_by_key(|(k, _)| field_ordering_position(k).unwrap());\n    let inter = fields\n        .into_iter()\n        .map(|(_, v)| v)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\",\");\n    format!(\"{{{}}}\", inter)\n}\n\nfn pcf_array(arr: \u0026[serde_json::Value]) -\u003e String {\n    let inter = arr\n        .iter()\n        .map(parsing_canonical_form)\n        .collect::\u003cVec\u003cString\u003e\u003e()\n        .join(\",\");\n    format!(\"[{}]\", inter)\n}\n\nfn pcf_string(s: \u0026str) -\u003e String {\n    format!(\"\\\"{}\\\"\", s)\n}\n\nconst RESERVED_FIELDS: \u0026[\u0026str] = \u0026[\n    \"name\",\n    \"type\",\n    \"fields\",\n    \"symbols\",\n    \"items\",\n    \"values\",\n    \"logicalType\",\n    \"size\",\n    \"order\",\n    \"doc\",\n    \"aliases\",\n    \"default\",\n];\n\n// Used to define the ordering and inclusion of fields.\nfn field_ordering_position(field: \u0026str) -\u003e Option\u003cusize\u003e {\n    RESERVED_FIELDS\n        .iter()\n        .position(|\u0026f| f == field)\n        .map(|pos| pos + 1)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_invalid_schema() {\n        assert!(Schema::parse_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_primitive_schema() {\n        assert_eq!(Schema::Null, Schema::parse_str(\"\\\"null\\\"\").unwrap());\n        assert_eq!(Schema::Int, Schema::parse_str(\"\\\"int\\\"\").unwrap());\n        assert_eq!(Schema::Double, Schema::parse_str(\"\\\"double\\\"\").unwrap());\n    }\n\n    #[test]\n    fn test_array_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\": \"string\"}\"#).unwrap();\n        assert_eq!(Schema::Array(Box::new(Schema::String)), schema);\n    }\n\n    #[test]\n    fn test_map_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"map\", \"values\": \"double\"}\"#).unwrap();\n        assert_eq!(Schema::Map(Box::new(Schema::Double)), schema);\n    }\n\n    #[test]\n    fn test_union_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", \"int\"]\"#).unwrap();\n        assert_eq!(\n            Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n            schema\n        );\n    }\n\n    #[test]\n    fn test_union_unsupported_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", [\"null\", \"int\"], \"string\"]\"#);\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_multi_union_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", \"int\", \"float\", \"string\", \"bytes\"]\"#);\n        assert!(schema.is_ok());\n        let schema = schema.unwrap();\n        assert_eq!(SchemaKind::from(\u0026schema), SchemaKind::Union);\n        let union_schema = match schema {\n            Schema::Union(u) =\u003e u,\n            _ =\u003e unreachable!(),\n        };\n        assert_eq!(union_schema.variants().len(), 5);\n        let mut variants = union_schema.variants().iter();\n        assert_eq!(SchemaKind::from(variants.next().unwrap()), SchemaKind::Null);\n        assert_eq!(SchemaKind::from(variants.next().unwrap()), SchemaKind::Int);\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::Float\n        );\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::String\n        );\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::Bytes\n        );\n        assert_eq!(variants.next(), None);\n    }\n\n    #[test]\n    fn test_record_schema() {\n        let schema = Schema::parse_str(\n            r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let mut lookup = HashMap::new();\n        lookup.insert(\"a\".to_owned(), 0);\n        lookup.insert(\"b\".to_owned(), 1);\n\n        let expected = Schema::Record {\n            name: Name::new(\"test\"),\n            doc: None,\n            fields: vec![\n                RecordField {\n                    name: \"a\".to_string(),\n                    doc: None,\n                    default: Some(Value::Number(42i64.into())),\n                    schema: Schema::Long,\n                    order: RecordFieldOrder::Ascending,\n                    position: 0,\n                },\n                RecordField {\n                    name: \"b\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::String,\n                    order: RecordFieldOrder::Ascending,\n                    position: 1,\n                },\n            ],\n            lookup,\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_enum_schema() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Suit\", \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]}\"#,\n        ).unwrap();\n\n        let expected = Schema::Enum {\n            name: Name::new(\"Suit\"),\n            doc: None,\n            symbols: vec![\n                \"diamonds\".to_owned(),\n                \"spades\".to_owned(),\n                \"clubs\".to_owned(),\n                \"hearts\".to_owned(),\n            ],\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_enum_schema_duplicate() {\n        // Duplicate \"diamonds\"\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Suit\", \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"diamonds\"]}\"#,\n        );\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_enum_schema_name() {\n        // Invalid name \"0000\" does not match [A-Za-z_][A-Za-z0-9_]*\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Enum\", \"symbols\": [\"0000\", \"variant\"]}\"#,\n        );\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_fixed_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"fixed\", \"name\": \"test\", \"size\": 16}\"#).unwrap();\n\n        let expected = Schema::Fixed {\n            name: Name::new(\"test\"),\n            size: 16usize,\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_no_documentation() {\n        let schema =\n            Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Coin\", \"symbols\": [\"heads\", \"tails\"]}\"#)\n                .unwrap();\n\n        let doc = match schema {\n            Schema::Enum { doc, .. } =\u003e doc,\n            _ =\u003e return,\n        };\n\n        assert!(doc.is_none());\n    }\n\n    #[test]\n    fn test_documentation() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Coin\", \"doc\": \"Some documentation\", \"symbols\": [\"heads\", \"tails\"]}\"#\n        ).unwrap();\n\n        let doc = match schema {\n            Schema::Enum { doc, .. } =\u003e doc,\n            _ =\u003e None,\n        };\n\n        assert_eq!(\"Some documentation\".to_owned(), doc.unwrap());\n    }\n\n    // Tests to ensure Schema is Send + Sync. These tests don't need to _do_ anything, if they can\n    // compile, they pass.\n    #[test]\n    fn test_schema_is_send() {\n        fn send\u003cS: Send\u003e(_s: S) {}\n\n        let schema = Schema::Null;\n        send(schema);\n    }\n\n    #[test]\n    fn test_schema_is_sync() {\n        fn sync\u003cS: Sync\u003e(_s: S) {}\n\n        let schema = Schema::Null;\n        sync(\u0026schema);\n        sync(schema);\n    }\n\n    #[test]\n    fn test_schema_fingerprint() {\n        use crate::rabin::Rabin;\n        use md5::Md5;\n        use sha2::Sha256;\n\n        let raw_schema = r#\"\n    {\n        \"type\": \"record\",\n        \"name\": \"test\",\n        \"fields\": [\n            {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n            {\"name\": \"b\", \"type\": \"string\"},\n            {\"name\": \"c\", \"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\n        ]\n    }\n\"#;\n\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        assert_eq!(\n            \"abf662f831715ff78f88545a05a9262af75d6406b54e1a8a174ff1d2b75affc4\",\n            format!(\"{}\", schema.fingerprint::\u003cSha256\u003e())\n        );\n\n        assert_eq!(\n            \"6e21c350f71b1a34e9efe90970f1bc69\",\n            format!(\"{}\", schema.fingerprint::\u003cMd5\u003e())\n        );\n        assert_eq!(\n            \"28cf0a67d9937bb3\",\n            format!(\"{}\", schema.fingerprint::\u003cRabin\u003e())\n        )\n    }\n\n    #[test]\n    fn test_logical_types() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#).unwrap();\n        assert_eq!(schema, Schema::Date);\n\n        let schema =\n            Schema::parse_str(r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#).unwrap();\n        assert_eq!(schema, Schema::TimestampMicros);\n    }\n\n    #[test]\n    fn test_nullable_logical_type() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": [\"null\", {\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}]}\"#,\n        )\n        .unwrap();\n        assert_eq!(\n            schema,\n            Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::TimestampMicros]).unwrap())\n        );\n    }\n\n    #[test]\n    fn record_field_order_from_str() {\n        use std::str::FromStr;\n\n        assert_eq!(\n            RecordFieldOrder::from_str(\"ascending\").unwrap(),\n            RecordFieldOrder::Ascending\n        );\n        assert_eq!(\n            RecordFieldOrder::from_str(\"descending\").unwrap(),\n            RecordFieldOrder::Descending\n        );\n        assert_eq!(\n            RecordFieldOrder::from_str(\"ignore\").unwrap(),\n            RecordFieldOrder::Ignore\n        );\n        assert!(RecordFieldOrder::from_str(\"not an ordering\").is_err());\n    }\n}\n","traces":[{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":139},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","schema_compatibility.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for checking schema compatibility\nuse crate::schema::{Schema, SchemaKind};\nuse std::{\n    collections::{hash_map::DefaultHasher, HashSet},\n    hash::Hasher,\n    ptr,\n};\n\npub struct SchemaCompatibility;\n\nstruct Checker {\n    recursion: HashSet\u003c(u64, u64)\u003e,\n}\n\nimpl Checker {\n    /// Create a new checker, with recursion set to an empty set.\n    pub(crate) fn new() -\u003e Self {\n        Self {\n            recursion: HashSet::new(),\n        }\n    }\n\n    pub(crate) fn can_read(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        self.full_match_schemas(writers_schema, readers_schema)\n    }\n\n    pub(crate) fn full_match_schemas(\n        \u0026mut self,\n        writers_schema: \u0026Schema,\n        readers_schema: \u0026Schema,\n    ) -\u003e bool {\n        if self.recursion_in_progress(writers_schema, readers_schema) {\n            return true;\n        }\n\n        if !SchemaCompatibility::match_schemas(writers_schema, readers_schema) {\n            return false;\n        }\n\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        if w_type != SchemaKind::Union \u0026\u0026 (r_type.is_primitive() || r_type == SchemaKind::Fixed) {\n            return true;\n        }\n\n        match r_type {\n            SchemaKind::Record =\u003e self.match_record_schemas(writers_schema, readers_schema),\n            SchemaKind::Map =\u003e {\n                if let Schema::Map(w_m) = writers_schema {\n                    if let Schema::Map(r_m) = readers_schema {\n                        self.full_match_schemas(w_m, r_m)\n                    } else {\n                        unreachable!(\"readers_schema should have been Schema::Map\")\n                    }\n                } else {\n                    unreachable!(\"writers_schema should have been Schema::Map\")\n                }\n            }\n            SchemaKind::Array =\u003e {\n                if let Schema::Array(w_a) = writers_schema {\n                    if let Schema::Array(r_a) = readers_schema {\n                        self.full_match_schemas(w_a, r_a)\n                    } else {\n                        unreachable!(\"readers_schema should have been Schema::Array\")\n                    }\n                } else {\n                    unreachable!(\"writers_schema should have been Schema::Array\")\n                }\n            }\n            SchemaKind::Union =\u003e self.match_union_schemas(writers_schema, readers_schema),\n            SchemaKind::Enum =\u003e {\n                // reader's symbols must contain all writer's symbols\n                if let Schema::Enum {\n                    symbols: w_symbols, ..\n                } = writers_schema\n                {\n                    if let Schema::Enum {\n                        symbols: r_symbols, ..\n                    } = readers_schema\n                    {\n                        return !w_symbols.iter().any(|e| !r_symbols.contains(e));\n                    }\n                }\n                false\n            }\n            _ =\u003e {\n                if w_type == SchemaKind::Union {\n                    if let Schema::Union(r) = writers_schema {\n                        if r.schemas.len() == 1 {\n                            return self.full_match_schemas(\u0026r.schemas[0], readers_schema);\n                        }\n                    }\n                }\n                false\n            }\n        }\n    }\n\n    fn match_record_schemas(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let w_type = SchemaKind::from(writers_schema);\n\n        if w_type == SchemaKind::Union {\n            return false;\n        }\n\n        if let Schema::Record {\n            fields: w_fields,\n            lookup: w_lookup,\n            ..\n        } = writers_schema\n        {\n            if let Schema::Record {\n                fields: r_fields, ..\n            } = readers_schema\n            {\n                for field in r_fields.iter() {\n                    if let Some(pos) = w_lookup.get(\u0026field.name) {\n                        if !self.full_match_schemas(\u0026w_fields[*pos].schema, \u0026field.schema) {\n                            return false;\n                        }\n                    } else if field.default.is_none() {\n                        return false;\n                    }\n                }\n            }\n        }\n        true\n    }\n\n    fn match_union_schemas(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        assert_eq!(r_type, SchemaKind::Union);\n\n        if w_type == SchemaKind::Union {\n            if let Schema::Union(u) = writers_schema {\n                u.schemas\n                    .iter()\n                    .all(|schema| self.full_match_schemas(schema, readers_schema))\n            } else {\n                unreachable!(\"writers_schema should have been Schema::Union\")\n            }\n        } else if let Schema::Union(u) = readers_schema {\n            u.schemas\n                .iter()\n                .any(|schema| self.full_match_schemas(writers_schema, schema))\n        } else {\n            unreachable!(\"readers_schema should have been Schema::Union\")\n        }\n    }\n\n    fn recursion_in_progress(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let mut hasher = DefaultHasher::new();\n        ptr::hash(writers_schema, \u0026mut hasher);\n        let w_hash = hasher.finish();\n\n        hasher = DefaultHasher::new();\n        ptr::hash(readers_schema, \u0026mut hasher);\n        let r_hash = hasher.finish();\n\n        let key = (w_hash, r_hash);\n        // This is a shortcut to add if not exists *and* return false. It will return true\n        // if it was able to insert.\n        !self.recursion.insert(key)\n    }\n}\n\nimpl SchemaCompatibility {\n    /// `can_read` performs a full, recursive check that a datum written using the\n    /// writers_schema can be read using the readers_schema.\n    pub fn can_read(writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let mut c = Checker::new();\n        c.can_read(writers_schema, readers_schema)\n    }\n\n    /// `mutual_read` performs a full, recursive check that a datum written using either\n    /// the writers_schema or the readers_schema can be read using the other schema.\n    pub fn mutual_read(writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        SchemaCompatibility::can_read(writers_schema, readers_schema)\n            \u0026\u0026 SchemaCompatibility::can_read(readers_schema, writers_schema)\n    }\n\n    ///  `match_schemas` performs a basic check that a datum written with the\n    ///  writers_schema could be read using the readers_schema. This check only includes\n    ///  matching the types, including schema promotion, and matching the full name for\n    ///  named types. Aliases for named types are not supported here, and the rust\n    ///  implementation of Avro in general does not include support for aliases (I think).\n    pub(crate) fn match_schemas(writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        if w_type == SchemaKind::Union || r_type == SchemaKind::Union {\n            return true;\n        }\n\n        if w_type == r_type {\n            if r_type.is_primitive() {\n                return true;\n            }\n\n            match r_type {\n                SchemaKind::Record =\u003e {\n                    if let Schema::Record { name: w_name, .. } = writers_schema {\n                        if let Schema::Record { name: r_name, .. } = readers_schema {\n                            return w_name.fullname(None) == r_name.fullname(None);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Record\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Record\")\n                    }\n                }\n                SchemaKind::Fixed =\u003e {\n                    if let Schema::Fixed {\n                        name: w_name,\n                        size: w_size,\n                    } = writers_schema\n                    {\n                        if let Schema::Fixed {\n                            name: r_name,\n                            size: r_size,\n                        } = readers_schema\n                        {\n                            return w_name.fullname(None) == r_name.fullname(None)\n                                \u0026\u0026 w_size == r_size;\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Fixed\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Fixed\")\n                    }\n                }\n                SchemaKind::Enum =\u003e {\n                    if let Schema::Enum { name: w_name, .. } = writers_schema {\n                        if let Schema::Enum { name: r_name, .. } = readers_schema {\n                            return w_name.fullname(None) == r_name.fullname(None);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Enum\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Enum\")\n                    }\n                }\n                SchemaKind::Map =\u003e {\n                    if let Schema::Map(w_m) = writers_schema {\n                        if let Schema::Map(r_m) = readers_schema {\n                            return SchemaCompatibility::match_schemas(w_m, r_m);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Map\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Map\")\n                    }\n                }\n                SchemaKind::Array =\u003e {\n                    if let Schema::Array(w_a) = writers_schema {\n                        if let Schema::Array(r_a) = readers_schema {\n                            return SchemaCompatibility::match_schemas(w_a, r_a);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Array\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Array\")\n                    }\n                }\n                _ =\u003e (),\n            };\n        }\n\n        if w_type == SchemaKind::Int\n            \u0026\u0026 vec![SchemaKind::Long, SchemaKind::Float, SchemaKind::Double]\n                .iter()\n                .any(|\u0026t| t == r_type)\n        {\n            return true;\n        }\n\n        if w_type == SchemaKind::Long\n            \u0026\u0026 vec![SchemaKind::Float, SchemaKind::Double]\n                .iter()\n                .any(|\u0026t| t == r_type)\n        {\n            return true;\n        }\n\n        if w_type == SchemaKind::Float \u0026\u0026 r_type == SchemaKind::Double {\n            return true;\n        }\n\n        if w_type == SchemaKind::String \u0026\u0026 r_type == SchemaKind::Bytes {\n            return true;\n        }\n\n        if w_type == SchemaKind::Bytes \u0026\u0026 r_type == SchemaKind::String {\n            return true;\n        }\n\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn int_array_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"int\"}\"#).unwrap()\n    }\n\n    fn long_array_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"long\"}\"#).unwrap()\n    }\n\n    fn string_array_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"string\"}\"#).unwrap()\n    }\n\n    fn int_map_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"int\"}\"#).unwrap()\n    }\n\n    fn long_map_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"long\"}\"#).unwrap()\n    }\n\n    fn string_map_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"string\"}\"#).unwrap()\n    }\n\n    fn enum1_ab_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"A\",\"B\"]}\"#).unwrap()\n    }\n\n    fn enum1_abc_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"A\",\"B\",\"C\"]}\"#).unwrap()\n    }\n\n    fn enum1_bc_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"B\",\"C\"]}\"#).unwrap()\n    }\n\n    fn enum2_ab_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum2\", \"symbols\":[\"A\",\"B\"]}\"#).unwrap()\n    }\n\n    fn empty_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[]}\"#).unwrap()\n    }\n\n    fn empty_record2_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record2\", \"fields\": []}\"#).unwrap()\n    }\n\n    fn a_int_record1_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}]}\"#,\n        )\n        .unwrap()\n    }\n\n    fn a_long_record1_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"long\"}]}\"#,\n        )\n        .unwrap()\n    }\n\n    fn a_int_b_int_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}, {\"name\":\"b\", \"type\":\"int\"}]}\"#).unwrap()\n    }\n\n    fn a_dint_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn a_int_b_dint_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}, {\"name\":\"b\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn a_dint_b_dint_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\", \"default\":0}, {\"name\":\"b\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn nested_record() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\",\"name\":\"parent\",\"fields\":[{\"name\":\"attribute\",\"type\":{\"type\":\"record\",\"name\":\"child\",\"fields\":[{\"name\":\"id\",\"type\":\"string\"}]}}]}\"#).unwrap()\n    }\n\n    fn nested_optional_record() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\",\"name\":\"parent\",\"fields\":[{\"name\":\"attribute\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"child\",\"fields\":[{\"name\":\"id\",\"type\":\"string\"}]}],\"default\":null}]}\"#).unwrap()\n    }\n\n    fn int_list_record_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"List\", \"fields\": [{\"name\": \"head\", \"type\": \"int\"},{\"name\": \"tail\", \"type\": \"array\", \"items\": \"int\"}]}\"#).unwrap()\n    }\n\n    fn long_list_record_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\n        \"type\":\"record\", \"name\":\"List\", \"fields\": [\n          {\"name\": \"head\", \"type\": \"long\"},\n          {\"name\": \"tail\", \"type\": \"array\", \"items\": \"long\"}\n      ]}\n\"#,\n        )\n        .unwrap()\n    }\n\n    fn union_schema(schemas: Vec\u003cSchema\u003e) -\u003e Schema {\n        let schema_string = schemas\n            .iter()\n            .map(|s| s.canonical_form())\n            .collect::\u003cVec\u003cString\u003e\u003e()\n            .join(\",\");\n        dbg!(\u0026schema_string);\n        Schema::parse_str(\u0026format!(\"[{}]\", schema_string)).unwrap()\n    }\n\n    fn empty_union_schema() -\u003e Schema {\n        union_schema(vec![])\n    }\n\n    // unused\n    // fn null_union_schema() -\u003e Schema { union_schema(vec![Schema::Null]) }\n\n    fn int_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::Int])\n    }\n\n    fn long_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::Long])\n    }\n\n    fn string_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::String])\n    }\n\n    fn int_string_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::Int, Schema::String])\n    }\n\n    fn string_int_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::String, Schema::Int])\n    }\n\n    #[test]\n    fn test_broken() {\n        assert!(!SchemaCompatibility::can_read(\n            \u0026int_string_union_schema(),\n            \u0026int_union_schema()\n        ))\n    }\n\n    #[test]\n    fn test_incompatible_reader_writer_pairs() {\n        let incompatible_schemas = vec![\n            // null\n            (Schema::Null, Schema::Int),\n            (Schema::Null, Schema::Long),\n            // boolean\n            (Schema::Boolean, Schema::Int),\n            // int\n            (Schema::Int, Schema::Null),\n            (Schema::Int, Schema::Boolean),\n            (Schema::Int, Schema::Long),\n            (Schema::Int, Schema::Float),\n            (Schema::Int, Schema::Double),\n            // long\n            (Schema::Long, Schema::Float),\n            (Schema::Long, Schema::Double),\n            // float\n            (Schema::Float, Schema::Double),\n            // string\n            (Schema::String, Schema::Boolean),\n            (Schema::String, Schema::Int),\n            // bytes\n            (Schema::Bytes, Schema::Null),\n            (Schema::Bytes, Schema::Int),\n            // array and maps\n            (int_array_schema(), long_array_schema()),\n            (int_map_schema(), int_array_schema()),\n            (int_array_schema(), int_map_schema()),\n            (int_map_schema(), long_map_schema()),\n            // enum\n            (enum1_ab_schema(), enum1_abc_schema()),\n            (enum1_bc_schema(), enum1_abc_schema()),\n            (enum1_ab_schema(), enum2_ab_schema()),\n            (Schema::Int, enum2_ab_schema()),\n            (enum2_ab_schema(), Schema::Int),\n            //union\n            (int_union_schema(), int_string_union_schema()),\n            (string_union_schema(), int_string_union_schema()),\n            //record\n            (empty_record2_schema(), empty_record1_schema()),\n            (a_int_record1_schema(), empty_record1_schema()),\n            (a_int_b_dint_record1_schema(), empty_record1_schema()),\n            (int_list_record_schema(), long_list_record_schema()),\n            (nested_record(), nested_optional_record()),\n        ];\n\n        assert!(!incompatible_schemas\n            .iter()\n            .any(|(reader, writer)| SchemaCompatibility::can_read(writer, reader)));\n    }\n\n    #[test]\n    fn test_compatible_reader_writer_pairs() {\n        let compatible_schemas = vec![\n            (Schema::Null, Schema::Null),\n            (Schema::Long, Schema::Int),\n            (Schema::Float, Schema::Int),\n            (Schema::Float, Schema::Long),\n            (Schema::Double, Schema::Long),\n            (Schema::Double, Schema::Int),\n            (Schema::Double, Schema::Float),\n            (Schema::String, Schema::Bytes),\n            (Schema::Bytes, Schema::String),\n            (int_array_schema(), int_array_schema()),\n            (long_array_schema(), int_array_schema()),\n            (int_map_schema(), int_map_schema()),\n            (long_map_schema(), int_map_schema()),\n            (enum1_ab_schema(), enum1_ab_schema()),\n            (enum1_abc_schema(), enum1_ab_schema()),\n            (empty_union_schema(), empty_union_schema()),\n            (int_union_schema(), int_union_schema()),\n            (int_string_union_schema(), string_int_union_schema()),\n            (int_union_schema(), empty_union_schema()),\n            (long_union_schema(), int_union_schema()),\n            (int_union_schema(), Schema::Int),\n            (Schema::Int, int_union_schema()),\n            (empty_record1_schema(), empty_record1_schema()),\n            (empty_record1_schema(), a_int_record1_schema()),\n            (a_int_record1_schema(), a_int_record1_schema()),\n            (a_dint_record1_schema(), a_int_record1_schema()),\n            (a_dint_record1_schema(), a_dint_record1_schema()),\n            (a_int_record1_schema(), a_dint_record1_schema()),\n            (a_long_record1_schema(), a_int_record1_schema()),\n            (a_int_record1_schema(), a_int_b_int_record1_schema()),\n            (a_dint_record1_schema(), a_int_b_int_record1_schema()),\n            (a_int_b_dint_record1_schema(), a_int_record1_schema()),\n            (a_dint_b_dint_record1_schema(), empty_record1_schema()),\n            (a_dint_b_dint_record1_schema(), a_int_record1_schema()),\n            (a_int_b_int_record1_schema(), a_dint_b_dint_record1_schema()),\n            (int_list_record_schema(), int_list_record_schema()),\n            (long_list_record_schema(), long_list_record_schema()),\n            (long_list_record_schema(), int_list_record_schema()),\n            (nested_optional_record(), nested_record()),\n        ];\n\n        assert!(compatible_schemas\n            .iter()\n            .all(|(reader, writer)| SchemaCompatibility::can_read(writer, reader)));\n    }\n\n    fn writer_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n        {\"name\":\"oldfield1\", \"type\":\"int\"},\n        {\"name\":\"oldfield2\", \"type\":\"string\"}\n      ]}\n\"#,\n        )\n        .unwrap()\n    }\n\n    #[test]\n    fn test_missing_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n        {\"name\":\"oldfield1\", \"type\":\"int\"}\n      ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema,\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_missing_second_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield2\", \"type\":\"string\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_all_fields() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"oldfield2\", \"type\":\"string\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_new_field_with_default() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"newfield1\", \"type\":\"int\", \"default\":42}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_new_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"newfield1\", \"type\":\"int\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(!SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_array_writer_schema() {\n        let valid_reader = string_array_schema();\n        let invalid_reader = string_map_schema();\n\n        assert!(SchemaCompatibility::can_read(\n            \u0026string_array_schema(),\n            \u0026valid_reader\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026string_array_schema(),\n            \u0026invalid_reader\n        ));\n    }\n\n    #[test]\n    fn test_primitive_writer_schema() {\n        let valid_reader = Schema::String;\n        assert!(SchemaCompatibility::can_read(\n            \u0026Schema::String,\n            \u0026valid_reader\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026Schema::Int,\n            \u0026Schema::String\n        ));\n    }\n\n    #[test]\n    fn test_union_reader_writer_subset_incompatiblity() {\n        // reader union schema must contain all writer union branches\n        let union_writer = union_schema(vec![Schema::Int, Schema::String]);\n        let union_reader = union_schema(vec![Schema::String]);\n\n        assert!(!SchemaCompatibility::can_read(\u0026union_writer, \u0026union_reader));\n        assert!(SchemaCompatibility::can_read(\u0026union_reader, \u0026union_writer));\n    }\n\n    #[test]\n    fn test_incompatible_record_field() {\n        let string_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"MyRecord\", \"namespace\":\"ns\", \"fields\": [\n            {\"name\":\"field1\", \"type\":\"string\"}\n        ]}\n        \"#,\n        )\n        .unwrap();\n\n        let int_schema = Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"MyRecord\", \"namespace\":\"ns\", \"fields\": [\n        {\"name\":\"field1\", \"type\":\"int\"}\n      ]}\n\"#,\n        )\n        .unwrap();\n\n        assert!(!SchemaCompatibility::can_read(\u0026string_schema, \u0026int_schema));\n    }\n\n    #[test]\n    fn test_enum_symbols() {\n        let enum_schema1 = Schema::parse_str(\n            r#\"\n      {\"type\":\"enum\", \"name\":\"MyEnum\", \"symbols\":[\"A\",\"B\"]}\n\"#,\n        )\n        .unwrap();\n        let enum_schema2 =\n            Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"MyEnum\", \"symbols\":[\"A\",\"B\",\"C\"]}\"#)\n                .unwrap();\n        assert!(!SchemaCompatibility::can_read(\u0026enum_schema2, \u0026enum_schema1));\n        assert!(SchemaCompatibility::can_read(\u0026enum_schema1, \u0026enum_schema2));\n    }\n\n    // unused\n    /*\n        fn point_2d_schema() -\u003e Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point2D\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n    */\n\n    fn point_2d_fullname_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Point\", \"namespace\":\"written\", \"fields\":[\n        {\"name\":\"x\", \"type\":\"double\"},\n        {\"name\":\"y\", \"type\":\"double\"}\n      ]}\n    \"#,\n        )\n        .unwrap()\n    }\n\n    fn point_3d_no_default_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Point\", \"fields\":[\n        {\"name\":\"x\", \"type\":\"double\"},\n        {\"name\":\"y\", \"type\":\"double\"},\n        {\"name\":\"z\", \"type\":\"double\"}\n      ]}\n    \"#,\n        )\n        .unwrap()\n    }\n\n    // unused\n    /*\n        fn point_3d_schema() -\u003e Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point3D\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"},\n            {\"name\":\"z\", \"type\":\"double\", \"default\": 0.0}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n\n        fn point_3d_match_name_schema() -\u003e Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"},\n            {\"name\":\"z\", \"type\":\"double\", \"default\": 0.0}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n    */\n\n    #[test]\n    fn test_union_resolution_no_structure_match() {\n        // short name match, but no structure match\n        let read_schema = union_schema(vec![Schema::Null, point_3d_no_default_schema()]);\n        assert!(!SchemaCompatibility::can_read(\n            \u0026point_2d_fullname_schema(),\n            \u0026read_schema\n        ));\n    }\n\n    // TODO(nlopes): the below require named schemas to be fully supported. See:\n    // https://github.com/flavray/avro-rs/pull/76\n    //\n    // #[test]\n    // fn test_union_resolution_first_structure_match_2d() {\n    //     // multiple structure matches with no name matches\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_3d_no_default_schema(),\n    //         point_2d_schema(),\n    //         point_3d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(\u0026point_2d_fullname_schema(), \u0026read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_first_structure_match_3d() {\n    //     // multiple structure matches with no name matches\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_3d_no_default_schema(),\n    //         point_3d_schema(),\n    //         point_2d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(\u0026point_2d_fullname_schema(), \u0026read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_named_structure_match() {\n    //     // multiple structure matches with a short name match\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_2d_schema(),\n    //         point_3d_match_name_schema(),\n    //         point_3d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(\u0026point_2d_fullname_schema(), \u0026read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_full_name_match() {\n    //     // there is a full name match that should be chosen\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_2d_schema(),\n    //         point_3d_match_name_schema(),\n    //         point_3d_schema(),\n    //         point_2d_fullname_schema(),\n    //     ]);\n    //     assert!(SchemaCompatibility::can_read(\n    //         \u0026point_2d_fullname_schema(),\n    //         \u0026read_schema\n    //     ));\n    // }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","ser.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for serde-compatible serialization.\nuse crate::{types::Value, Error};\nuse serde::{ser, Serialize};\nuse std::{collections::HashMap, iter::once};\n\n#[derive(Clone, Default)]\npub struct Serializer {}\n\npub struct SeqSerializer {\n    items: Vec\u003cValue\u003e,\n}\n\npub struct SeqVariantSerializer\u003c'a\u003e {\n    index: u32,\n    variant: \u0026'a str,\n    items: Vec\u003cValue\u003e,\n}\n\npub struct MapSerializer {\n    indices: HashMap\u003cString, usize\u003e,\n    values: Vec\u003cValue\u003e,\n}\n\npub struct StructSerializer {\n    fields: Vec\u003c(String, Value)\u003e,\n}\n\npub struct StructVariantSerializer\u003c'a\u003e {\n    index: u32,\n    variant: \u0026'a str,\n    fields: Vec\u003c(String, Value)\u003e,\n}\n\nimpl SeqSerializer {\n    pub fn new(len: Option\u003cusize\u003e) -\u003e SeqSerializer {\n        let items = match len {\n            Some(len) =\u003e Vec::with_capacity(len),\n            None =\u003e Vec::new(),\n        };\n\n        SeqSerializer { items }\n    }\n}\n\nimpl\u003c'a\u003e SeqVariantSerializer\u003c'a\u003e {\n    pub fn new(index: u32, variant: \u0026'a str, len: Option\u003cusize\u003e) -\u003e SeqVariantSerializer {\n        let items = match len {\n            Some(len) =\u003e Vec::with_capacity(len),\n            None =\u003e Vec::new(),\n        };\n        SeqVariantSerializer {\n            index,\n            variant,\n            items,\n        }\n    }\n}\n\nimpl MapSerializer {\n    pub fn new(len: Option\u003cusize\u003e) -\u003e MapSerializer {\n        let (indices, values) = match len {\n            Some(len) =\u003e (HashMap::with_capacity(len), Vec::with_capacity(len)),\n            None =\u003e (HashMap::new(), Vec::new()),\n        };\n\n        MapSerializer { indices, values }\n    }\n}\n\nimpl StructSerializer {\n    pub fn new(len: usize) -\u003e StructSerializer {\n        StructSerializer {\n            fields: Vec::with_capacity(len),\n        }\n    }\n}\n\nimpl\u003c'a\u003e StructVariantSerializer\u003c'a\u003e {\n    pub fn new(index: u32, variant: \u0026'a str, len: usize) -\u003e StructVariantSerializer {\n        StructVariantSerializer {\n            index,\n            variant,\n            fields: Vec::with_capacity(len),\n        }\n    }\n}\n\nimpl\u003c'b\u003e ser::Serializer for \u0026'b mut Serializer {\n    type Ok = Value;\n    type Error = Error;\n    type SerializeSeq = SeqSerializer;\n    type SerializeTuple = SeqSerializer;\n    type SerializeTupleStruct = SeqSerializer;\n    type SerializeTupleVariant = SeqVariantSerializer\u003c'b\u003e;\n    type SerializeMap = MapSerializer;\n    type SerializeStruct = StructSerializer;\n    type SerializeStructVariant = StructVariantSerializer\u003c'b\u003e;\n\n    fn serialize_bool(self, v: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Boolean(v))\n    }\n\n    fn serialize_i8(self, v: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_i16(self, v: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_i32(self, v: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Int(v))\n    }\n\n    fn serialize_i64(self, v: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Long(v))\n    }\n\n    fn serialize_u8(self, v: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_u16(self, v: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_u32(self, v: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        if v \u003c= i32::max_value() as u32 {\n            self.serialize_i32(v as i32)\n        } else {\n            self.serialize_i64(i64::from(v))\n        }\n    }\n\n    fn serialize_u64(self, v: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        if v \u003c= i64::max_value() as u64 {\n            self.serialize_i64(v as i64)\n        } else {\n            Err(ser::Error::custom(\"u64 is too large\"))\n        }\n    }\n\n    fn serialize_f32(self, v: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Float(v))\n    }\n\n    fn serialize_f64(self, v: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Double(v))\n    }\n\n    fn serialize_char(self, v: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_str(\u0026once(v).collect::\u003cString\u003e())\n    }\n\n    fn serialize_str(self, v: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::String(v.to_owned()))\n    }\n\n    fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Bytes(v.to_owned()))\n    }\n\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::from(None::\u003cSelf::Ok\u003e))\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let v = value.serialize(\u0026mut Serializer::default())?;\n        Ok(Value::from(Some(v)))\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Null)\n    }\n\n    fn serialize_unit_struct(self, _: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_unit()\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Enum(index as i32, variant.to_string()))\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(index as i32, variant.to_owned()),\n            ),\n            (\n                \"value\".to_owned(),\n                Value::Union(Box::new(value.serialize(self)?)),\n            ),\n        ]))\n    }\n\n    fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n        Ok(SeqSerializer::new(len))\n    }\n\n    fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        Ok(SeqVariantSerializer::new(index, variant, Some(len)))\n    }\n\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n        Ok(MapSerializer::new(len))\n    }\n\n    fn serialize_struct(\n        self,\n        _: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n        Ok(StructSerializer::new(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        Ok(StructVariantSerializer::new(index, variant, len))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeSeq for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.items\n            .push(value.serialize(\u0026mut Serializer::default())?);\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Array(self.items))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeTuple for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeTupleStruct for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeSeq for SeqVariantSerializer\u003c'a\u003e {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.items.push(Value::Union(Box::new(\n            value.serialize(\u0026mut Serializer::default())?,\n        )));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(self.index as i32, self.variant.to_owned()),\n            ),\n            (\"value\".to_owned(), Value::Array(self.items)),\n        ]))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeTupleVariant for SeqVariantSerializer\u003c'a\u003e {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeMap for MapSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let key = key.serialize(\u0026mut Serializer::default())?;\n\n        if let Value::String(key) = key {\n            self.indices.insert(key, self.values.len());\n            Ok(())\n        } else {\n            Err(ser::Error::custom(\"map key is not a string\"))\n        }\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.values\n            .push(value.serialize(\u0026mut Serializer::default())?);\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        let mut items = HashMap::new();\n        for (key, index) in self.indices {\n            if let Some(value) = self.values.get(index) {\n                items.insert(key, value.clone());\n            }\n        }\n\n        Ok(Value::Map(items))\n    }\n}\n\nimpl ser::SerializeStruct for StructSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        name: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.fields.push((\n            name.to_owned(),\n            value.serialize(\u0026mut Serializer::default())?,\n        ));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Record(self.fields))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeStructVariant for StructVariantSerializer\u003c'a\u003e {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        name: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.fields.push((\n            name.to_owned(),\n            value.serialize(\u0026mut Serializer::default())?,\n        ));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(self.index as i32, self.variant.to_owned()),\n            ),\n            (\n                \"value\".to_owned(),\n                Value::Union(Box::new(Value::Record(self.fields))),\n            ),\n        ]))\n    }\n}\n\n/// Interpret a serializeable instance as a `Value`.\n///\n/// This conversion can fail if the value is not valid as per the Avro specification.\n/// e.g: HashMap with non-string keys\npub fn to_value\u003cS: Serialize\u003e(value: S) -\u003e Result\u003cValue, Error\u003e {\n    let mut serializer = Serializer::default();\n    value.serialize(\u0026mut serializer)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Debug, Deserialize, Serialize, Clone)]\n    struct Test {\n        a: i64,\n        b: String,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestInner {\n        a: Test,\n        b: i32,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitExternalEnum {\n        a: UnitExternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    enum UnitExternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitInternalEnum {\n        a: UnitInternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(tag = \"t\")]\n    enum UnitInternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitAdjacentEnum {\n        a: UnitAdjacentEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum UnitAdjacentEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitUntaggedEnum {\n        a: UnitUntaggedEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    enum UnitUntaggedEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueExternalEnum {\n        a: SingleValueExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum SingleValueExternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueInternalEnum {\n        a: SingleValueInternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\")]\n    enum SingleValueInternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueAdjacentEnum {\n        a: SingleValueAdjacentEnum,\n    }\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum SingleValueAdjacentEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueUntaggedEnum {\n        a: SingleValueUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum SingleValueUntaggedEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructExternalEnum {\n        a: StructExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum StructExternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructInternalEnum {\n        a: StructInternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum StructInternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructAdjacentEnum {\n        a: StructAdjacentEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum StructAdjacentEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructUntaggedEnum {\n        a: StructUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum StructUntaggedEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32, z: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleExternalEnum {\n        a: TupleExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum TupleExternalEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    // Tuple Internal Enum cannot be instantiated\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleAdjacentEnum {\n        a: TupleAdjacentEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum TupleAdjacentEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleUntaggedEnum {\n        a: TupleUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum TupleUntaggedEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[test]\n    fn test_to_value() {\n        let test = Test {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let expected = Value::Record(vec![\n            (\"a\".to_owned(), Value::Long(27)),\n            (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n        ]);\n\n        assert_eq!(to_value(test.clone()).unwrap(), expected);\n\n        let test_inner = TestInner { a: test, b: 35 };\n\n        let expected_inner = Value::Record(vec![\n            (\n                \"a\".to_owned(),\n                Value::Record(vec![\n                    (\"a\".to_owned(), Value::Long(27)),\n                    (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n                ]),\n            ),\n            (\"b\".to_owned(), Value::Int(35)),\n        ]);\n\n        assert_eq!(to_value(test_inner).unwrap(), expected_inner);\n    }\n\n    #[test]\n    fn test_to_value_unit_enum() {\n        let test = TestUnitExternalEnum {\n            a: UnitExternalEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Enum(0, \"Val1\".to_owned()))]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit external enum\"\n        );\n\n        let test = TestUnitInternalEnum {\n            a: UnitInternalEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit internal enum\"\n        );\n\n        let test = TestUnitAdjacentEnum {\n            a: UnitAdjacentEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit adjacent enum\"\n        );\n\n        let test = TestUnitUntaggedEnum {\n            a: UnitUntaggedEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Null)]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_single_value_enum() {\n        let test = TestSingleValueExternalEnum {\n            a: SingleValueExternalEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(0, \"Double\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Double(64.0))),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value external enum\"\n        );\n\n        // It is not possible to serialize an internal Single Value enum...\n        let test = TestSingleValueInternalEnum {\n            a: SingleValueInternalEnum::Double(64.0),\n        };\n\n        assert!(to_value(test).is_err(), \"{}\", true);\n\n        let test = TestSingleValueAdjacentEnum {\n            a: SingleValueAdjacentEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Double\".to_owned())),\n                (\"v\".to_owned(), Value::Double(64.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value adjacent enum\"\n        );\n\n        let test = TestSingleValueUntaggedEnum {\n            a: SingleValueUntaggedEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Double(64.0))]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_struct_enum() {\n        let test = TestStructExternalEnum {\n            a: StructExternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(0, \"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]))),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct external enum\"\n        );\n\n        // I don't think that this is feasible in avro\n\n        let test = TestStructInternalEnum {\n            a: StructInternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct internal enum\"\n        );\n\n        let test = TestStructAdjacentEnum {\n            a: StructAdjacentEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"v\".to_owned(),\n                    Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct adjacent enum\"\n        );\n\n        let test = TestStructUntaggedEnum {\n            a: StructUntaggedEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct untagged enum\"\n        );\n\n        let test = TestStructUntaggedEnum {\n            a: StructUntaggedEnum::Val2 {\n                x: 1.0,\n                y: 2.0,\n                z: 3.0,\n            },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n                (\"z\".to_owned(), Value::Float(3.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct untagged enum variant\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_tuple_enum() {\n        let test = TestTupleExternalEnum {\n            a: TupleExternalEnum::Val2(1.0, 2.0, 3.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(1, \"Val2\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Array(vec![\n                        Value::Union(Box::new(Value::Float(1.0))),\n                        Value::Union(Box::new(Value::Float(2.0))),\n                        Value::Union(Box::new(Value::Float(3.0))),\n                    ]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple external enum\"\n        );\n\n        let test = TestTupleAdjacentEnum {\n            a: TupleAdjacentEnum::Val1(1.0, 2.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"v\".to_owned(),\n                    Value::Array(vec![Value::Float(1.0), Value::Float(2.0)]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple adjacent enum\"\n        );\n\n        let test = TestTupleUntaggedEnum {\n            a: TupleUntaggedEnum::Val1(1.0, 2.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Array(vec![Value::Float(1.0), Value::Float(2.0)]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple untagged enum\"\n        );\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":108},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","types.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling the intermediate representation of Avro values.\nuse crate::{\n    decimal::Decimal,\n    duration::Duration,\n    schema::{Precision, RecordField, Scale, Schema, SchemaKind, UnionSchema},\n    AvroResult, Error,\n};\nuse serde_json::{Number, Value as JsonValue};\nuse std::{collections::HashMap, convert::TryFrom, hash::BuildHasher, str::FromStr, u8};\nuse uuid::Uuid;\n\n/// Compute the maximum decimal value precision of a byte array of length `len` could hold.\nfn max_prec_for_len(len: usize) -\u003e Result\u003cusize, Error\u003e {\n    let len = i32::try_from(len).map_err(|e| Error::ConvertLengthToI32(e, len))?;\n    Ok((2.0_f64.powi(8 * len - 1) - 1.0).log10().floor() as usize)\n}\n\n/// A valid Avro value.\n///\n/// More information about Avro values can be found in the [Avro\n/// Specification](https://avro.apache.org/docs/current/spec.html#schemas)\n#[derive(Clone, Debug, PartialEq, strum_macros::EnumDiscriminants)]\n#[strum_discriminants(name(ValueKind))]\npub enum Value {\n    /// A `null` Avro value.\n    Null,\n    /// A `boolean` Avro value.\n    Boolean(bool),\n    /// A `int` Avro value.\n    Int(i32),\n    /// A `long` Avro value.\n    Long(i64),\n    /// A `float` Avro value.\n    Float(f32),\n    /// A `double` Avro value.\n    Double(f64),\n    /// A `bytes` Avro value.\n    Bytes(Vec\u003cu8\u003e),\n    /// A `string` Avro value.\n    String(String),\n    /// A `fixed` Avro value.\n    /// The size of the fixed value is represented as a `usize`.\n    Fixed(usize, Vec\u003cu8\u003e),\n    /// An `enum` Avro value.\n    ///\n    /// An Enum is represented by a symbol and its position in the symbols list\n    /// of its corresponding schema.\n    /// This allows schema-less encoding, as well as schema resolution while\n    /// reading values.\n    Enum(i32, String),\n    /// An `union` Avro value.\n    Union(Box\u003cValue\u003e),\n    /// An `array` Avro value.\n    Array(Vec\u003cValue\u003e),\n    /// A `map` Avro value.\n    Map(HashMap\u003cString, Value\u003e),\n    /// A `record` Avro value.\n    ///\n    /// A Record is represented by a vector of (`\u003crecord name\u003e`, `value`).\n    /// This allows schema-less encoding.\n    ///\n    /// See [Record](types.Record) for a more user-friendly support.\n    Record(Vec\u003c(String, Value)\u003e),\n    /// A date value.\n    ///\n    /// Serialized and deserialized as `i32` directly. Can only be deserialized properly with a\n    /// schema.\n    Date(i32),\n    /// An Avro Decimal value. Bytes are in big-endian order, per the Avro spec.\n    Decimal(Decimal),\n    /// Time in milliseconds.\n    TimeMillis(i32),\n    /// Time in microseconds.\n    TimeMicros(i64),\n    /// Timestamp in milliseconds.\n    TimestampMillis(i64),\n    /// Timestamp in microseconds.\n    TimestampMicros(i64),\n    /// Avro Duration. An amount of time defined by months, days and milliseconds.\n    Duration(Duration),\n    /// Universally unique identifier.\n    /// Universally unique identifier.\n    Uuid(Uuid),\n}\n/// Any structure implementing the [ToAvro](trait.ToAvro.html) trait will be usable\n/// from a [Writer](../writer/struct.Writer.html).\n#[deprecated(\n    since = \"0.11.0\",\n    note = \"Please use Value::from, Into::into or value.into() instead\"\n)]\npub trait ToAvro {\n    /// Transforms this value into an Avro-compatible [Value](enum.Value.html).\n    fn avro(self) -\u003e Value;\n}\n\n#[allow(deprecated)]\nimpl\u003cT: Into\u003cValue\u003e\u003e ToAvro for T {\n    fn avro(self) -\u003e Value {\n        self.into()\n    }\n}\n\nmacro_rules! to_value(\n    ($type:ty, $variant_constructor:expr) =\u003e (\n        impl From\u003c$type\u003e for Value {\n            fn from(value: $type) -\u003e Self {\n                $variant_constructor(value)\n            }\n        }\n    );\n);\n\nto_value!(bool, Value::Boolean);\nto_value!(i32, Value::Int);\nto_value!(i64, Value::Long);\nto_value!(f32, Value::Float);\nto_value!(f64, Value::Double);\nto_value!(String, Value::String);\nto_value!(Vec\u003cu8\u003e, Value::Bytes);\nto_value!(uuid::Uuid, Value::Uuid);\nto_value!(Decimal, Value::Decimal);\nto_value!(Duration, Value::Duration);\n\nimpl From\u003c()\u003e for Value {\n    fn from(_: ()) -\u003e Self {\n        Self::Null\n    }\n}\n\nimpl From\u003cusize\u003e for Value {\n    fn from(value: usize) -\u003e Self {\n        i64::try_from(value)\n            .expect(\"cannot convert usize to i64\")\n            .into()\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Value {\n    fn from(value: \u0026str) -\u003e Self {\n        Self::String(value.to_owned())\n    }\n}\n\nimpl From\u003c\u0026[u8]\u003e for Value {\n    fn from(value: \u0026[u8]) -\u003e Self {\n        Self::Bytes(value.to_owned())\n    }\n}\n\nimpl\u003cT\u003e From\u003cOption\u003cT\u003e\u003e for Value\nwhere\n    T: Into\u003cSelf\u003e,\n{\n    fn from(value: Option\u003cT\u003e) -\u003e Self {\n        Self::Union(Box::new(value.map_or_else(|| Self::Null, Into::into)))\n    }\n}\n\nimpl\u003cK, V, S\u003e From\u003cHashMap\u003cK, V, S\u003e\u003e for Value\nwhere\n    K: Into\u003cString\u003e,\n    V: Into\u003cSelf\u003e,\n    S: BuildHasher,\n{\n    fn from(value: HashMap\u003cK, V, S\u003e) -\u003e Self {\n        Self::Map(\n            value\n                .into_iter()\n                .map(|(key, value)| (key.into(), value.into()))\n                .collect(),\n        )\n    }\n}\n\n/// Utility interface to build `Value::Record` objects.\n#[derive(Debug, Clone)]\npub struct Record\u003c'a\u003e {\n    /// List of fields contained in the record.\n    /// Ordered according to the fields in the schema given to create this\n    /// `Record` object. Any unset field defaults to `Value::Null`.\n    pub fields: Vec\u003c(String, Value)\u003e,\n    schema_lookup: \u0026'a HashMap\u003cString, usize\u003e,\n}\n\nimpl\u003c'a\u003e Record\u003c'a\u003e {\n    /// Create a `Record` given a `Schema`.\n    ///\n    /// If the `Schema` is not a `Schema::Record` variant, `None` will be returned.\n    pub fn new(schema: \u0026Schema) -\u003e Option\u003cRecord\u003e {\n        match *schema {\n            Schema::Record {\n                fields: ref schema_fields,\n                lookup: ref schema_lookup,\n                ..\n            } =\u003e {\n                let mut fields = Vec::with_capacity(schema_fields.len());\n                for schema_field in schema_fields.iter() {\n                    fields.push((schema_field.name.clone(), Value::Null));\n                }\n\n                Some(Record {\n                    fields,\n                    schema_lookup,\n                })\n            }\n            _ =\u003e None,\n        }\n    }\n\n    /// Put a compatible value (implementing the `ToAvro` trait) in the\n    /// `Record` for a given `field` name.\n    ///\n    /// **NOTE** Only ensure that the field name is present in the `Schema` given when creating\n    /// this `Record`. Does not perform any schema validation.\n    pub fn put\u003cV\u003e(\u0026mut self, field: \u0026str, value: V)\n    where\n        V: Into\u003cValue\u003e,\n    {\n        if let Some(\u0026position) = self.schema_lookup.get(field) {\n            self.fields[position].1 = value.into()\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cRecord\u003c'a\u003e\u003e for Value {\n    fn from(value: Record\u003c'a\u003e) -\u003e Self {\n        Self::Record(value.fields)\n    }\n}\n\nimpl From\u003cJsonValue\u003e for Value {\n    fn from(value: JsonValue) -\u003e Self {\n        match value {\n            JsonValue::Null =\u003e Self::Null,\n            JsonValue::Bool(b) =\u003e b.into(),\n            JsonValue::Number(ref n) if n.is_i64() =\u003e Value::Long(n.as_i64().unwrap()),\n            JsonValue::Number(ref n) if n.is_f64() =\u003e Value::Double(n.as_f64().unwrap()),\n            JsonValue::Number(n) =\u003e Value::Long(n.as_u64().unwrap() as i64), // TODO: Not so great\n            JsonValue::String(s) =\u003e s.into(),\n            JsonValue::Array(items) =\u003e Value::Array(items.into_iter().map(Value::from).collect()),\n            JsonValue::Object(items) =\u003e Value::Map(\n                items\n                    .into_iter()\n                    .map(|(key, value)| (key, value.into()))\n                    .collect(),\n            ),\n        }\n    }\n}\n\n/// Convert Avro values to Json values\nimpl std::convert::TryFrom\u003cValue\u003e for JsonValue {\n    type Error = crate::error::Error;\n    fn try_from(value: Value) -\u003e AvroResult\u003cSelf\u003e {\n        match value {\n            Value::Null =\u003e Ok(Self::Null),\n            Value::Boolean(b) =\u003e Ok(Self::Bool(b)),\n            Value::Int(i) =\u003e Ok(Self::Number(i.into())),\n            Value::Long(l) =\u003e Ok(Self::Number(l.into())),\n            Value::Float(f) =\u003e Number::from_f64(f.into())\n                .map(Self::Number)\n                .ok_or_else(|| Error::ConvertF64ToJson(f.into())),\n            Value::Double(d) =\u003e Number::from_f64(d)\n                .map(Self::Number)\n                .ok_or(Error::ConvertF64ToJson(d)),\n            Value::Bytes(bytes) =\u003e Ok(Self::Array(bytes.into_iter().map(|b| b.into()).collect())),\n            Value::String(s) =\u003e Ok(Self::String(s)),\n            Value::Fixed(_size, items) =\u003e {\n                Ok(Self::Array(items.into_iter().map(|v| v.into()).collect()))\n            }\n            Value::Enum(_i, s) =\u003e Ok(Self::String(s)),\n            Value::Union(b) =\u003e Self::try_from(*b),\n            Value::Array(items) =\u003e items\n                .into_iter()\n                .map(Self::try_from)\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n                .map(Self::Array),\n            Value::Map(items) =\u003e items\n                .into_iter()\n                .map(|(key, value)| Self::try_from(value).map(|v| (key, v)))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n                .map(|v| Self::Object(v.into_iter().collect())),\n            Value::Record(items) =\u003e items\n                .into_iter()\n                .map(|(key, value)| Self::try_from(value).map(|v| (key, v)))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n                .map(|v| Self::Object(v.into_iter().collect())),\n            Value::Date(d) =\u003e Ok(Self::Number(d.into())),\n            Value::Decimal(ref d) =\u003e \u003cVec\u003cu8\u003e\u003e::try_from(d)\n                .map(|vec| Self::Array(vec.into_iter().map(|v| v.into()).collect())),\n            Value::TimeMillis(t) =\u003e Ok(Self::Number(t.into())),\n            Value::TimeMicros(t) =\u003e Ok(Self::Number(t.into())),\n            Value::TimestampMillis(t) =\u003e Ok(Self::Number(t.into())),\n            Value::TimestampMicros(t) =\u003e Ok(Self::Number(t.into())),\n            Value::Duration(d) =\u003e Ok(Self::Array(\n                \u003c[u8; 12]\u003e::from(d).iter().map(|\u0026v| v.into()).collect(),\n            )),\n            Value::Uuid(uuid) =\u003e Ok(Self::String(uuid.to_hyphenated().to_string())),\n        }\n    }\n}\n\nimpl Value {\n    /// Validate the value against the given [Schema](../schema/enum.Schema.html).\n    ///\n    /// See the [Avro specification](https://avro.apache.org/docs/current/spec.html)\n    /// for the full set of rules of schema validation.\n    pub fn validate(\u0026self, schema: \u0026Schema) -\u003e bool {\n        match (self, schema) {\n            (\u0026Value::Null, \u0026Schema::Null) =\u003e true,\n            (\u0026Value::Boolean(_), \u0026Schema::Boolean) =\u003e true,\n            (\u0026Value::Int(_), \u0026Schema::Int) =\u003e true,\n            (\u0026Value::Int(_), \u0026Schema::Date) =\u003e true,\n            (\u0026Value::Int(_), \u0026Schema::TimeMillis) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::Long) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::TimeMicros) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::TimestampMillis) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::TimestampMicros) =\u003e true,\n            (\u0026Value::TimestampMicros(_), \u0026Schema::TimestampMicros) =\u003e true,\n            (\u0026Value::TimestampMillis(_), \u0026Schema::TimestampMillis) =\u003e true,\n            (\u0026Value::TimeMicros(_), \u0026Schema::TimeMicros) =\u003e true,\n            (\u0026Value::TimeMillis(_), \u0026Schema::TimeMillis) =\u003e true,\n            (\u0026Value::Date(_), \u0026Schema::Date) =\u003e true,\n            (\u0026Value::Decimal(_), \u0026Schema::Decimal { .. }) =\u003e true,\n            (\u0026Value::Duration(_), \u0026Schema::Duration) =\u003e true,\n            (\u0026Value::Uuid(_), \u0026Schema::Uuid) =\u003e true,\n            (\u0026Value::Float(_), \u0026Schema::Float) =\u003e true,\n            (\u0026Value::Double(_), \u0026Schema::Double) =\u003e true,\n            (\u0026Value::Bytes(_), \u0026Schema::Bytes) =\u003e true,\n            (\u0026Value::Bytes(_), \u0026Schema::Decimal { .. }) =\u003e true,\n            (\u0026Value::String(_), \u0026Schema::String) =\u003e true,\n            (\u0026Value::String(_), \u0026Schema::Uuid) =\u003e true,\n            (\u0026Value::Fixed(n, _), \u0026Schema::Fixed { size, .. }) =\u003e n == size,\n            (\u0026Value::Bytes(ref b), \u0026Schema::Fixed { size, .. }) =\u003e b.len() == size,\n            (\u0026Value::Fixed(n, _), \u0026Schema::Duration) =\u003e n == 12,\n            // TODO: check precision against n\n            (\u0026Value::Fixed(_n, _), \u0026Schema::Decimal { .. }) =\u003e true,\n            (\u0026Value::String(ref s), \u0026Schema::Enum { ref symbols, .. }) =\u003e symbols.contains(s),\n            (\u0026Value::Enum(i, ref s), \u0026Schema::Enum { ref symbols, .. }) =\u003e symbols\n                .get(i as usize)\n                .map(|ref symbol| symbol == \u0026s)\n                .unwrap_or(false),\n            // (\u0026Value::Union(None), \u0026Schema::Union(_)) =\u003e true,\n            (\u0026Value::Union(ref value), \u0026Schema::Union(ref inner)) =\u003e {\n                inner.find_schema(value).is_some()\n            }\n            (\u0026Value::Array(ref items), \u0026Schema::Array(ref inner)) =\u003e {\n                items.iter().all(|item| item.validate(inner))\n            }\n            (\u0026Value::Map(ref items), \u0026Schema::Map(ref inner)) =\u003e {\n                items.iter().all(|(_, value)| value.validate(inner))\n            }\n            (\u0026Value::Record(ref record_fields), \u0026Schema::Record { ref fields, .. }) =\u003e {\n                fields.len() == record_fields.len()\n                    \u0026\u0026 fields.iter().zip(record_fields.iter()).all(\n                        |(field, \u0026(ref name, ref value))| {\n                            field.name == *name \u0026\u0026 value.validate(\u0026field.schema)\n                        },\n                    )\n            }\n            (\u0026Value::Map(ref items), \u0026Schema::Record { ref fields, .. }) =\u003e {\n                fields.iter().all(|field| {\n                    if let Some(item) = items.get(\u0026field.name) {\n                        item.validate(\u0026field.schema)\n                    } else {\n                        false\n                    }\n                })\n            }\n            _ =\u003e false,\n        }\n    }\n\n    /// Attempt to perform schema resolution on the value, with the given\n    /// [Schema](../schema/enum.Schema.html).\n    ///\n    /// See [Schema Resolution](https://avro.apache.org/docs/current/spec.html#Schema+Resolution)\n    /// in the Avro specification for the full set of rules of schema\n    /// resolution.\n    pub fn resolve(mut self, schema: \u0026Schema) -\u003e AvroResult\u003cSelf\u003e {\n        // Check if this schema is a union, and if the reader schema is not.\n        if SchemaKind::from(\u0026self) == SchemaKind::Union\n            \u0026\u0026 SchemaKind::from(schema) != SchemaKind::Union\n        {\n            // Pull out the Union, and attempt to resolve against it.\n            let v = match self {\n                Value::Union(b) =\u003e *b,\n                _ =\u003e unreachable!(),\n            };\n            self = v;\n        }\n        match *schema {\n            Schema::Null =\u003e self.resolve_null(),\n            Schema::Boolean =\u003e self.resolve_boolean(),\n            Schema::Int =\u003e self.resolve_int(),\n            Schema::Long =\u003e self.resolve_long(),\n            Schema::Float =\u003e self.resolve_float(),\n            Schema::Double =\u003e self.resolve_double(),\n            Schema::Bytes =\u003e self.resolve_bytes(),\n            Schema::String =\u003e self.resolve_string(),\n            Schema::Fixed { size, .. } =\u003e self.resolve_fixed(size),\n            Schema::Union(ref inner) =\u003e self.resolve_union(inner),\n            Schema::Enum { ref symbols, .. } =\u003e self.resolve_enum(symbols),\n            Schema::Array(ref inner) =\u003e self.resolve_array(inner),\n            Schema::Map(ref inner) =\u003e self.resolve_map(inner),\n            Schema::Record { ref fields, .. } =\u003e self.resolve_record(fields),\n            Schema::Decimal {\n                scale,\n                precision,\n                ref inner,\n            } =\u003e self.resolve_decimal(precision, scale, inner),\n            Schema::Date =\u003e self.resolve_date(),\n            Schema::TimeMillis =\u003e self.resolve_time_millis(),\n            Schema::TimeMicros =\u003e self.resolve_time_micros(),\n            Schema::TimestampMillis =\u003e self.resolve_timestamp_millis(),\n            Schema::TimestampMicros =\u003e self.resolve_timestamp_micros(),\n            Schema::Duration =\u003e self.resolve_duration(),\n            Schema::Uuid =\u003e self.resolve_uuid(),\n        }\n    }\n\n    fn resolve_uuid(self) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(match self {\n            uuid @ Value::Uuid(_) =\u003e uuid,\n            Value::String(ref string) =\u003e {\n                Value::Uuid(Uuid::from_str(string).map_err(Error::ConvertStrToUuid)?)\n            }\n            other =\u003e return Err(Error::GetUuid(other.into())),\n        })\n    }\n\n    fn resolve_duration(self) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(match self {\n            duration @ Value::Duration { .. } =\u003e duration,\n            Value::Fixed(size, bytes) =\u003e {\n                if size != 12 {\n                    return Err(Error::GetDecimalFixedBytes(size));\n                }\n                Value::Duration(Duration::from([\n                    bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],\n                    bytes[8], bytes[9], bytes[10], bytes[11],\n                ]))\n            }\n            other =\u003e return Err(Error::ResolveDuration(other.into())),\n        })\n    }\n\n    fn resolve_decimal(\n        self,\n        precision: Precision,\n        scale: Scale,\n        inner: \u0026Schema,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        if scale \u003e precision {\n            return Err(Error::GetScaleAndPrecision { scale, precision });\n        }\n        match inner {\n            \u0026Schema::Fixed { size, .. } =\u003e {\n                if max_prec_for_len(size)? \u003c precision {\n                    return Err(Error::GetScaleWithFixedSize { size, precision });\n                }\n            }\n            Schema::Bytes =\u003e (),\n            _ =\u003e return Err(Error::ResolveDecimalSchema(inner.into())),\n        };\n        match self {\n            Value::Decimal(num) =\u003e {\n                let num_bytes = num.len();\n                if max_prec_for_len(num_bytes)? \u003e precision {\n                    Err(Error::ComparePrecisionAndSize {\n                        precision,\n                        num_bytes,\n                    })\n                } else {\n                    Ok(Value::Decimal(num))\n                }\n                // check num.bits() here\n            }\n            Value::Fixed(_, bytes) | Value::Bytes(bytes) =\u003e {\n                if max_prec_for_len(bytes.len())? \u003e precision {\n                    Err(Error::ComparePrecisionAndSize {\n                        precision,\n                        num_bytes: bytes.len(),\n                    })\n                } else {\n                    // precision and scale match, can we assume the underlying type can hold the data?\n                    Ok(Value::Decimal(Decimal::from(bytes)))\n                }\n            }\n            other =\u003e Err(Error::ResolveDecimal(other.into())),\n        }\n    }\n\n    fn resolve_date(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Date(d) | Value::Int(d) =\u003e Ok(Value::Date(d)),\n            other =\u003e Err(Error::GetDate(other.into())),\n        }\n    }\n\n    fn resolve_time_millis(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimeMillis(t) | Value::Int(t) =\u003e Ok(Value::TimeMillis(t)),\n            other =\u003e Err(Error::GetTimeMillis(other.into())),\n        }\n    }\n\n    fn resolve_time_micros(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimeMicros(t) | Value::Long(t) =\u003e Ok(Value::TimeMicros(t)),\n            Value::Int(t) =\u003e Ok(Value::TimeMicros(i64::from(t))),\n            other =\u003e Err(Error::GetTimeMicros(other.into())),\n        }\n    }\n\n    fn resolve_timestamp_millis(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimestampMillis(ts) | Value::Long(ts) =\u003e Ok(Value::TimestampMillis(ts)),\n            Value::Int(ts) =\u003e Ok(Value::TimestampMillis(i64::from(ts))),\n            other =\u003e Err(Error::GetTimestampMillis(other.into())),\n        }\n    }\n\n    fn resolve_timestamp_micros(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimestampMicros(ts) | Value::Long(ts) =\u003e Ok(Value::TimestampMicros(ts)),\n            Value::Int(ts) =\u003e Ok(Value::TimestampMicros(i64::from(ts))),\n            other =\u003e Err(Error::GetTimestampMicros(other.into())),\n        }\n    }\n\n    fn resolve_null(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Null =\u003e Ok(Value::Null),\n            other =\u003e Err(Error::GetNull(other.into())),\n        }\n    }\n\n    fn resolve_boolean(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Boolean(b) =\u003e Ok(Value::Boolean(b)),\n            other =\u003e Err(Error::GetBoolean(other.into())),\n        }\n    }\n\n    fn resolve_int(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Int(n)),\n            Value::Long(n) =\u003e Ok(Value::Int(n as i32)),\n            other =\u003e Err(Error::GetInt(other.into())),\n        }\n    }\n\n    fn resolve_long(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Long(i64::from(n))),\n            Value::Long(n) =\u003e Ok(Value::Long(n)),\n            other =\u003e Err(Error::GetLong(other.into())),\n        }\n    }\n\n    fn resolve_float(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Float(n as f32)),\n            Value::Long(n) =\u003e Ok(Value::Float(n as f32)),\n            Value::Float(x) =\u003e Ok(Value::Float(x)),\n            Value::Double(x) =\u003e Ok(Value::Float(x as f32)),\n            other =\u003e Err(Error::GetFloat(other.into())),\n        }\n    }\n\n    fn resolve_double(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Double(f64::from(n))),\n            Value::Long(n) =\u003e Ok(Value::Double(n as f64)),\n            Value::Float(x) =\u003e Ok(Value::Double(f64::from(x))),\n            Value::Double(x) =\u003e Ok(Value::Double(x)),\n            other =\u003e Err(Error::GetDouble(other.into())),\n        }\n    }\n\n    fn resolve_bytes(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Bytes(bytes) =\u003e Ok(Value::Bytes(bytes)),\n            Value::String(s) =\u003e Ok(Value::Bytes(s.into_bytes())),\n            Value::Array(items) =\u003e Ok(Value::Bytes(\n                items\n                    .into_iter()\n                    .map(Value::try_u8)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?,\n            )),\n            other =\u003e Err(Error::GetBytes(other.into())),\n        }\n    }\n\n    fn resolve_string(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::String(s) =\u003e Ok(Value::String(s)),\n            Value::Bytes(bytes) =\u003e Ok(Value::String(\n                String::from_utf8(bytes).map_err(Error::ConvertToUtf8)?,\n            )),\n            other =\u003e Err(Error::GetString(other.into())),\n        }\n    }\n\n    fn resolve_fixed(self, size: usize) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Fixed(n, bytes) =\u003e {\n                if n == size {\n                    Ok(Value::Fixed(n, bytes))\n                } else {\n                    Err(Error::CompareFixedSizes { size, n })\n                }\n            }\n            other =\u003e Err(Error::GetStringForFixed(other.into())),\n        }\n    }\n\n    fn resolve_enum(self, symbols: \u0026[String]) -\u003e Result\u003cSelf, Error\u003e {\n        let validate_symbol = |symbol: String, symbols: \u0026[String]| {\n            if let Some(index) = symbols.iter().position(|item| item == \u0026symbol) {\n                Ok(Value::Enum(index as i32, symbol))\n            } else {\n                Err(Error::GetEnumDefault {\n                    symbol,\n                    symbols: symbols.into(),\n                })\n            }\n        };\n\n        match self {\n            Value::Enum(raw_index, s) =\u003e {\n                let index = usize::try_from(raw_index)\n                    .map_err(|e| Error::ConvertI32ToUsize(e, raw_index))?;\n                if (0..=symbols.len()).contains(\u0026index) {\n                    validate_symbol(s, symbols)\n                } else {\n                    Err(Error::GetEnumValue {\n                        index,\n                        nsymbols: symbols.len(),\n                    })\n                }\n            }\n            Value::String(s) =\u003e validate_symbol(s, symbols),\n            other =\u003e Err(Error::GetEnum(other.into())),\n        }\n    }\n\n    fn resolve_union(self, schema: \u0026UnionSchema) -\u003e Result\u003cSelf, Error\u003e {\n        let v = match self {\n            // Both are unions case.\n            Value::Union(v) =\u003e *v,\n            // Reader is a union, but writer is not.\n            v =\u003e v,\n        };\n        // Find the first match in the reader schema.\n        let (_, inner) = schema.find_schema(\u0026v).ok_or(Error::FindUnionVariant)?;\n        Ok(Value::Union(Box::new(v.resolve(inner)?)))\n    }\n\n    fn resolve_array(self, schema: \u0026Schema) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Array(items) =\u003e Ok(Value::Array(\n                items\n                    .into_iter()\n                    .map(|item| item.resolve(schema))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()?,\n            )),\n            other =\u003e Err(Error::GetArray {\n                expected: schema.into(),\n                other: other.into(),\n            }),\n        }\n    }\n\n    fn resolve_map(self, schema: \u0026Schema) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Map(items) =\u003e Ok(Value::Map(\n                items\n                    .into_iter()\n                    .map(|(key, value)| value.resolve(schema).map(|value| (key, value)))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()?,\n            )),\n            other =\u003e Err(Error::GetMap {\n                expected: schema.into(),\n                other: other.into(),\n            }),\n        }\n    }\n\n    fn resolve_record(self, fields: \u0026[RecordField]) -\u003e Result\u003cSelf, Error\u003e {\n        let mut items = match self {\n            Value::Map(items) =\u003e Ok(items),\n            Value::Record(fields) =\u003e Ok(fields.into_iter().collect::\u003cHashMap\u003c_, _\u003e\u003e()),\n            other =\u003e Err(Error::GetRecord {\n                expected: fields\n                    .iter()\n                    .map(|field| (field.name.clone(), field.schema.clone().into()))\n                    .collect(),\n                other: other.into(),\n            }),\n        }?;\n\n        let new_fields = fields\n            .iter()\n            .map(|field| {\n                let value = match items.remove(\u0026field.name) {\n                    Some(value) =\u003e value,\n                    None =\u003e match field.default {\n                        Some(ref value) =\u003e match field.schema {\n                            Schema::Enum { ref symbols, .. } =\u003e {\n                                Value::from(value.clone()).resolve_enum(symbols)?\n                            }\n                            Schema::Union(ref union_schema) =\u003e {\n                                let first = \u0026union_schema.variants()[0];\n                                // NOTE: this match exists only to optimize null defaults for large\n                                // backward-compatible schemas with many nullable fields\n                                match first {\n                                    Schema::Null =\u003e Value::Union(Box::new(Value::Null)),\n                                    _ =\u003e Value::Union(Box::new(\n                                        Value::from(value.clone()).resolve(first)?,\n                                    )),\n                                }\n                            }\n                            _ =\u003e Value::from(value.clone()),\n                        },\n                        None =\u003e {\n                            return Err(Error::GetField(field.name.clone()));\n                        }\n                    },\n                };\n                value\n                    .resolve(\u0026field.schema)\n                    .map(|value| (field.name.clone(), value))\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        Ok(Value::Record(new_fields))\n    }\n\n    fn try_u8(self) -\u003e AvroResult\u003cu8\u003e {\n        let int = self.resolve(\u0026Schema::Int)?;\n        if let Value::Int(n) = int {\n            if n \u003e= 0 \u0026\u0026 n \u003c= i32::from(u8::MAX) {\n                return Ok(n as u8);\n            }\n        }\n\n        Err(Error::GetU8(int.into()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        decimal::Decimal,\n        duration::{Days, Duration, Millis, Months},\n        schema::{Name, RecordField, RecordFieldOrder, Schema, UnionSchema},\n        types::Value,\n    };\n    use uuid::Uuid;\n\n    #[test]\n    fn validate() {\n        let value_schema_valid = vec![\n            (Value::Int(42), Schema::Int, true),\n            (Value::Int(42), Schema::Boolean, false),\n            (\n                Value::Union(Box::new(Value::Null)),\n                Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Int(42))),\n                Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Null)),\n                Schema::Union(UnionSchema::new(vec![Schema::Double, Schema::Int]).unwrap()),\n                false,\n            ),\n            (\n                Value::Union(Box::new(Value::Int(42))),\n                Schema::Union(\n                    UnionSchema::new(vec![\n                        Schema::Null,\n                        Schema::Double,\n                        Schema::String,\n                        Schema::Int,\n                    ])\n                    .unwrap(),\n                ),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Long(42i64))),\n                Schema::Union(\n                    UnionSchema::new(vec![Schema::Null, Schema::TimestampMillis]).unwrap(),\n                ),\n                true,\n            ),\n            (\n                Value::Array(vec![Value::Long(42i64)]),\n                Schema::Array(Box::new(Schema::Long)),\n                true,\n            ),\n            (\n                Value::Array(vec![Value::Boolean(true)]),\n                Schema::Array(Box::new(Schema::Long)),\n                false,\n            ),\n            (Value::Record(vec![]), Schema::Null, false),\n        ];\n\n        for (value, schema, valid) in value_schema_valid.into_iter() {\n            assert_eq!(valid, value.validate(\u0026schema));\n        }\n    }\n\n    #[test]\n    fn validate_fixed() {\n        let schema = Schema::Fixed {\n            size: 4,\n            name: Name::new(\"some_fixed\"),\n        };\n\n        assert!(Value::Fixed(4, vec![0, 0, 0, 0]).validate(\u0026schema));\n        assert!(!Value::Fixed(5, vec![0, 0, 0, 0, 0]).validate(\u0026schema));\n        assert!(Value::Bytes(vec![0, 0, 0, 0]).validate(\u0026schema));\n        assert!(!Value::Bytes(vec![0, 0, 0, 0, 0]).validate(\u0026schema));\n    }\n\n    #[test]\n    fn validate_enum() {\n        let schema = Schema::Enum {\n            name: Name::new(\"some_enum\"),\n            doc: None,\n            symbols: vec![\n                \"spades\".to_string(),\n                \"hearts\".to_string(),\n                \"diamonds\".to_string(),\n                \"clubs\".to_string(),\n            ],\n        };\n\n        assert!(Value::Enum(0, \"spades\".to_string()).validate(\u0026schema));\n        assert!(Value::String(\"spades\".to_string()).validate(\u0026schema));\n\n        assert!(!Value::Enum(1, \"spades\".to_string()).validate(\u0026schema));\n        assert!(!Value::String(\"lorem\".to_string()).validate(\u0026schema));\n\n        let other_schema = Schema::Enum {\n            name: Name::new(\"some_other_enum\"),\n            doc: None,\n            symbols: vec![\n                \"hearts\".to_string(),\n                \"diamonds\".to_string(),\n                \"clubs\".to_string(),\n                \"spades\".to_string(),\n            ],\n        };\n\n        assert!(!Value::Enum(0, \"spades\".to_string()).validate(\u0026other_schema));\n    }\n\n    #[test]\n    fn validate_record() {\n        use std::collections::HashMap;\n        // {\n        //    \"type\": \"record\",\n        //    \"fields\": [\n        //      {\"type\": \"long\", \"name\": \"a\"},\n        //      {\"type\": \"string\", \"name\": \"b\"}\n        //    ]\n        // }\n        let schema = Schema::Record {\n            name: Name::new(\"some_record\"),\n            doc: None,\n            fields: vec![\n                RecordField {\n                    name: \"a\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::Long,\n                    order: RecordFieldOrder::Ascending,\n                    position: 0,\n                },\n                RecordField {\n                    name: \"b\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::String,\n                    order: RecordFieldOrder::Ascending,\n                    position: 1,\n                },\n            ],\n            lookup: HashMap::new(),\n        };\n\n        assert!(Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            (\"a\".to_string(), Value::Long(42i64)),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Boolean(false)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"c\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            (\"c\".to_string(), Value::Null),\n        ])\n        .validate(\u0026schema));\n\n        assert!(Value::Map(\n            vec![\n                (\"a\".to_string(), Value::Long(42i64)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            ]\n            .into_iter()\n            .collect()\n        )\n        .validate(\u0026schema));\n\n        let union_schema = Schema::Union(UnionSchema::new(vec![Schema::Null, schema]).unwrap());\n\n        assert!(Value::Union(Box::new(Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])))\n        .validate(\u0026union_schema));\n\n        assert!(Value::Union(Box::new(Value::Map(\n            vec![\n                (\"a\".to_string(), Value::Long(42i64)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            ]\n            .into_iter()\n            .collect()\n        )))\n        .validate(\u0026union_schema));\n    }\n\n    #[test]\n    fn resolve_bytes_ok() {\n        let value = Value::Array(vec![Value::Int(0), Value::Int(42)]);\n        assert_eq!(\n            value.resolve(\u0026Schema::Bytes).unwrap(),\n            Value::Bytes(vec![0u8, 42u8])\n        );\n    }\n\n    #[test]\n    fn resolve_bytes_failure() {\n        let value = Value::Array(vec![Value::Int(2000), Value::Int(-42)]);\n        assert!(value.resolve(\u0026Schema::Bytes).is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_bytes() {\n        let value = Value::Decimal(Decimal::from(vec![1, 2]));\n        value\n            .clone()\n            .resolve(\u0026Schema::Decimal {\n                precision: 10,\n                scale: 4,\n                inner: Box::new(Schema::Bytes),\n            })\n            .unwrap();\n        assert!(value.resolve(\u0026Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_invalid_scale() {\n        let value = Value::Decimal(Decimal::from(vec![1]));\n        assert!(value\n            .resolve(\u0026Schema::Decimal {\n                precision: 2,\n                scale: 3,\n                inner: Box::new(Schema::Bytes),\n            })\n            .is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_invalid_precision_for_length() {\n        let value = Value::Decimal(Decimal::from((1u8..=8u8).rev().collect::\u003cVec\u003c_\u003e\u003e()));\n        assert!(value\n            .resolve(\u0026Schema::Decimal {\n                precision: 1,\n                scale: 0,\n                inner: Box::new(Schema::Bytes),\n            })\n            .is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_fixed() {\n        let value = Value::Decimal(Decimal::from(vec![1, 2]));\n        assert!(value\n            .clone()\n            .resolve(\u0026Schema::Decimal {\n                precision: 10,\n                scale: 1,\n                inner: Box::new(Schema::Fixed {\n                    name: Name::new(\"decimal\"),\n                    size: 20\n                })\n            })\n            .is_ok());\n        assert!(value.resolve(\u0026Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_date() {\n        let value = Value::Date(2345);\n        assert!(value.clone().resolve(\u0026Schema::Date).is_ok());\n        assert!(value.resolve(\u0026Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_time_millis() {\n        let value = Value::TimeMillis(10);\n        assert!(value.clone().resolve(\u0026Schema::TimeMillis).is_ok());\n        assert!(value.resolve(\u0026Schema::TimeMicros).is_err());\n    }\n\n    #[test]\n    fn resolve_time_micros() {\n        let value = Value::TimeMicros(10);\n        assert!(value.clone().resolve(\u0026Schema::TimeMicros).is_ok());\n        assert!(value.resolve(\u0026Schema::TimeMillis).is_err());\n    }\n\n    #[test]\n    fn resolve_timestamp_millis() {\n        let value = Value::TimestampMillis(10);\n        assert!(value.clone().resolve(\u0026Schema::TimestampMillis).is_ok());\n        assert!(value.resolve(\u0026Schema::Float).is_err());\n\n        let value = Value::Float(10.0f32);\n        assert!(value.resolve(\u0026Schema::TimestampMillis).is_err());\n    }\n\n    #[test]\n    fn resolve_timestamp_micros() {\n        let value = Value::TimestampMicros(10);\n        assert!(value.clone().resolve(\u0026Schema::TimestampMicros).is_ok());\n        assert!(value.resolve(\u0026Schema::Int).is_err());\n\n        let value = Value::Double(10.0);\n        assert!(value.resolve(\u0026Schema::TimestampMicros).is_err());\n    }\n\n    #[test]\n    fn resolve_duration() {\n        let value = Value::Duration(Duration::new(\n            Months::new(10),\n            Days::new(5),\n            Millis::new(3000),\n        ));\n        assert!(value.clone().resolve(\u0026Schema::Duration).is_ok());\n        assert!(value.resolve(\u0026Schema::TimestampMicros).is_err());\n        assert!(Value::Long(1i64).resolve(\u0026Schema::Duration).is_err());\n    }\n\n    #[test]\n    fn resolve_uuid() {\n        let value = Value::Uuid(Uuid::parse_str(\"1481531d-ccc9-46d9-a56f-5b67459c0537\").unwrap());\n        assert!(value.clone().resolve(\u0026Schema::Uuid).is_ok());\n        assert!(value.resolve(\u0026Schema::TimestampMicros).is_err());\n    }\n\n    #[test]\n    fn json_from_avro() {\n        assert_eq!(JsonValue::try_from(Value::Null).unwrap(), JsonValue::Null);\n        assert_eq!(\n            JsonValue::try_from(Value::Boolean(true)).unwrap(),\n            JsonValue::Bool(true)\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Int(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Long(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Float(1.0)).unwrap(),\n            JsonValue::Number(Number::from_f64(1.0).unwrap())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Double(1.0)).unwrap(),\n            JsonValue::Number(Number::from_f64(1.0).unwrap())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Bytes(vec![1, 2, 3])).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::String(\"test\".into())).unwrap(),\n            JsonValue::String(\"test\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Fixed(3, vec![1, 2, 3])).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Enum(1, \"test_enum\".into())).unwrap(),\n            JsonValue::String(\"test_enum\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Union(Box::new(Value::String(\"test_enum\".into())))).unwrap(),\n            JsonValue::String(\"test_enum\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Array(vec![\n                Value::Int(1),\n                Value::Int(2),\n                Value::Int(3)\n            ]))\n            .unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Map(\n                vec![\n                    (\"v1\".to_string(), Value::Int(1)),\n                    (\"v2\".to_string(), Value::Int(2)),\n                    (\"v3\".to_string(), Value::Int(3))\n                ]\n                .into_iter()\n                .collect()\n            ))\n            .unwrap(),\n            JsonValue::Object(\n                vec![\n                    (\"v1\".to_string(), JsonValue::Number(1.into())),\n                    (\"v2\".to_string(), JsonValue::Number(2.into())),\n                    (\"v3\".to_string(), JsonValue::Number(3.into()))\n                ]\n                .into_iter()\n                .collect()\n            )\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Record(vec![\n                (\"v1\".to_string(), Value::Int(1)),\n                (\"v2\".to_string(), Value::Int(2)),\n                (\"v3\".to_string(), Value::Int(3))\n            ]))\n            .unwrap(),\n            JsonValue::Object(\n                vec![\n                    (\"v1\".to_string(), JsonValue::Number(1.into())),\n                    (\"v2\".to_string(), JsonValue::Number(2.into())),\n                    (\"v3\".to_string(), JsonValue::Number(3.into()))\n                ]\n                .into_iter()\n                .collect()\n            )\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Date(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Decimal(vec![1, 2, 3].into())).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimeMillis(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimeMicros(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimestampMillis(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimestampMicros(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Duration(\n                [1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8].into()\n            ))\n            .unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into()),\n                JsonValue::Number(4.into()),\n                JsonValue::Number(5.into()),\n                JsonValue::Number(6.into()),\n                JsonValue::Number(7.into()),\n                JsonValue::Number(8.into()),\n                JsonValue::Number(9.into()),\n                JsonValue::Number(10.into()),\n                JsonValue::Number(11.into()),\n                JsonValue::Number(12.into()),\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Uuid(\n                Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap()\n            ))\n            .unwrap(),\n            JsonValue::String(\"936da01f-9abd-4d9d-80c7-02af85c822a8\".into())\n        );\n    }\n}\n","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","util.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{AvroResult, Error};\nuse serde_json::{Map, Value};\nuse std::{convert::TryFrom, i64, io::Read, sync::Once};\n\n/// Maximum number of bytes that can be allocated when decoding\n/// Avro-encoded values. This is a protection against ill-formed\n/// data, whose length field might be interpreted as enourmous.\n/// See max_allocation_bytes to change this limit.\npub static mut MAX_ALLOCATION_BYTES: usize = 512 * 1024 * 1024;\nstatic MAX_ALLOCATION_BYTES_ONCE: Once = Once::new();\n\npub trait MapHelper {\n    fn string(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e;\n\n    fn name(\u0026self) -\u003e Option\u003cString\u003e {\n        self.string(\"name\")\n    }\n\n    fn doc(\u0026self) -\u003e Option\u003cString\u003e {\n        self.string(\"doc\")\n    }\n}\n\nimpl MapHelper for Map\u003cString, Value\u003e {\n    fn string(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.get(key)\n            .and_then(|v| v.as_str())\n            .map(|v| v.to_string())\n    }\n}\n\npub fn read_long\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003ci64\u003e {\n    zag_i64(reader)\n}\n\npub fn zig_i32(n: i32, buffer: \u0026mut Vec\u003cu8\u003e) {\n    zig_i64(n as i64, buffer)\n}\n\npub fn zig_i64(n: i64, buffer: \u0026mut Vec\u003cu8\u003e) {\n    encode_variable(((n \u003c\u003c 1) ^ (n \u003e\u003e 63)) as u64, buffer)\n}\n\npub fn zag_i32\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003ci32\u003e {\n    let i = zag_i64(reader)?;\n    i32::try_from(i).map_err(|e| Error::ZagI32(e, i))\n}\n\npub fn zag_i64\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003ci64\u003e {\n    let z = decode_variable(reader)?;\n    Ok(if z \u0026 0x1 == 0 {\n        (z \u003e\u003e 1) as i64\n    } else {\n        !(z \u003e\u003e 1) as i64\n    })\n}\n\nfn encode_variable(mut z: u64, buffer: \u0026mut Vec\u003cu8\u003e) {\n    loop {\n        if z \u003c= 0x7F {\n            buffer.push((z \u0026 0x7F) as u8);\n            break;\n        } else {\n            buffer.push((0x80 | (z \u0026 0x7F)) as u8);\n            z \u003e\u003e= 7;\n        }\n    }\n}\n\nfn decode_variable\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cu64\u003e {\n    let mut i = 0u64;\n    let mut buf = [0u8; 1];\n\n    let mut j = 0;\n    loop {\n        if j \u003e 9 {\n            // if j * 7 \u003e 64\n            return Err(Error::IntegerOverflow);\n        }\n        reader\n            .read_exact(\u0026mut buf[..])\n            .map_err(Error::ReadVariableIntegerBytes)?;\n        i |= (u64::from(buf[0] \u0026 0x7F)) \u003c\u003c (j * 7);\n        if (buf[0] \u003e\u003e 7) == 0 {\n            break;\n        } else {\n            j += 1;\n        }\n    }\n\n    Ok(i)\n}\n\n/// Set a new maximum number of bytes that can be allocated when decoding data.\n/// Once called, the limit cannot be changed.\n///\n/// **NOTE** This function must be called before decoding **any** data. The\n/// library leverages [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html)\n/// to set the limit either when calling this method, or when decoding for\n/// the first time.\npub fn max_allocation_bytes(num_bytes: usize) -\u003e usize {\n    unsafe {\n        MAX_ALLOCATION_BYTES_ONCE.call_once(|| {\n            MAX_ALLOCATION_BYTES = num_bytes;\n        });\n        MAX_ALLOCATION_BYTES\n    }\n}\n\npub fn safe_len(len: usize) -\u003e AvroResult\u003cusize\u003e {\n    let max_bytes = max_allocation_bytes(512 * 1024 * 1024);\n\n    if len \u003c= max_bytes {\n        Ok(len)\n    } else {\n        Err(Error::MemoryAllocation {\n            desired: len,\n            maximum: max_bytes,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_zigzag() {\n        let mut a = Vec::new();\n        let mut b = Vec::new();\n        zig_i32(42i32, \u0026mut a);\n        zig_i64(42i64, \u0026mut b);\n        assert_eq!(a, b);\n    }\n\n    #[test]\n    fn test_zig_i64() {\n        let mut s = Vec::new();\n        zig_i64(std::i32::MAX as i64, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i64(std::i32::MAX as i64 + 1, \u0026mut s);\n        assert_eq!(s, [128, 128, 128, 128, 16]);\n\n        s.clear();\n        zig_i64(std::i32::MIN as i64, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i64(std::i32::MIN as i64 - 1, \u0026mut s);\n        assert_eq!(s, [129, 128, 128, 128, 16]);\n\n        s.clear();\n        zig_i64(i64::MAX, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 255, 255, 255, 255, 255, 1]);\n\n        s.clear();\n        zig_i64(i64::MIN, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 255, 255, 255, 255, 255, 1]);\n    }\n\n    #[test]\n    fn test_zig_i32() {\n        let mut s = Vec::new();\n        zig_i32(std::i32::MAX / 2, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 7]);\n\n        s.clear();\n        zig_i32(std::i32::MIN / 2, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 7]);\n\n        s.clear();\n        zig_i32(-(std::i32::MIN / 2), \u0026mut s);\n        assert_eq!(s, [128, 128, 128, 128, 8]);\n\n        s.clear();\n        zig_i32(std::i32::MIN / 2 - 1, \u0026mut s);\n        assert_eq!(s, [129, 128, 128, 128, 8]);\n\n        s.clear();\n        zig_i32(std::i32::MAX, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i32(std::i32::MIN, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 15]);\n    }\n\n    #[test]\n    fn test_overflow() {\n        let causes_left_shift_overflow: \u0026[u8] = \u0026[0xe1, 0xe1, 0xe1, 0xe1, 0xe1];\n        assert!(decode_variable(\u0026mut \u0026*causes_left_shift_overflow).is_err());\n    }\n\n    #[test]\n    fn test_safe_len() {\n        assert_eq!(42usize, safe_len(42usize).unwrap());\n        assert!(safe_len(1024 * 1024 * 1024).is_err());\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","writer.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling writing in Avro format at user level.\nuse crate::{\n    encode::{encode, encode_ref, encode_to_vec},\n    schema::Schema,\n    ser::Serializer,\n    types::Value,\n    AvroResult, Codec, Error,\n};\nuse rand::random;\nuse serde::Serialize;\nuse std::{collections::HashMap, io::Write};\n\nconst DEFAULT_BLOCK_SIZE: usize = 16000;\nconst AVRO_OBJECT_HEADER: \u0026[u8] = b\"Obj\\x01\";\n\n/// Main interface for writing Avro formatted values.\n#[derive(typed_builder::TypedBuilder)]\npub struct Writer\u003c'a, W\u003e {\n    schema: \u0026'a Schema,\n    writer: W,\n    #[builder(default = Codec::Null)]\n    codec: Codec,\n    #[builder(default = DEFAULT_BLOCK_SIZE)]\n    block_size: usize,\n    #[builder(default = Vec::with_capacity(block_size), setter(skip))]\n    buffer: Vec\u003cu8\u003e,\n    #[builder(default, setter(skip))]\n    serializer: Serializer,\n    #[builder(default = 0, setter(skip))]\n    num_values: usize,\n    #[builder(default = std::iter::repeat_with(random).take(16).collect(), setter(skip))]\n    marker: Vec\u003cu8\u003e,\n    #[builder(default = false, setter(skip))]\n    has_header: bool,\n}\n\nimpl\u003c'a, W: Write\u003e Writer\u003c'a, W\u003e {\n    /// Creates a `Writer` given a `Schema` and something implementing the `io::Write` trait to write\n    /// to.\n    /// No compression `Codec` will be used.\n    pub fn new(schema: \u0026'a Schema, writer: W) -\u003e Self {\n        Self::builder().schema(schema).writer(writer).build()\n    }\n\n    /// Creates a `Writer` with a specific `Codec` given a `Schema` and something implementing the\n    /// `io::Write` trait to write to.\n    pub fn with_codec(schema: \u0026'a Schema, writer: W, codec: Codec) -\u003e Self {\n        Self::builder()\n            .schema(schema)\n            .writer(writer)\n            .codec(codec)\n            .build()\n    }\n\n    /// Get a reference to the `Schema` associated to a `Writer`.\n    pub fn schema(\u0026self) -\u003e \u0026'a Schema {\n        self.schema\n    }\n\n    /// Append a compatible value (implementing the `ToAvro` trait) to a `Writer`, also performing\n    /// schema validation.\n    ///\n    /// Return the number of bytes written (it might be 0, see below).\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append\u003cT: Into\u003cValue\u003e\u003e(\u0026mut self, value: T) -\u003e AvroResult\u003cusize\u003e {\n        let n = if !self.has_header {\n            let header = self.header()?;\n            let n = self.append_bytes(header.as_ref())?;\n            self.has_header = true;\n            n\n        } else {\n            0\n        };\n\n        let avro = value.into();\n        write_value_ref(self.schema, \u0026avro, \u0026mut self.buffer)?;\n\n        self.num_values += 1;\n\n        if self.buffer.len() \u003e= self.block_size {\n            return self.flush().map(|b| b + n);\n        }\n\n        Ok(n)\n    }\n\n    /// Append a compatible value to a `Writer`, also performing schema validation.\n    ///\n    /// Return the number of bytes written (it might be 0, see below).\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append_value_ref(\u0026mut self, value: \u0026Value) -\u003e AvroResult\u003cusize\u003e {\n        let n = if !self.has_header {\n            let header = self.header()?;\n            let n = self.append_bytes(header.as_ref())?;\n            self.has_header = true;\n            n\n        } else {\n            0\n        };\n\n        write_value_ref(self.schema, value, \u0026mut self.buffer)?;\n\n        self.num_values += 1;\n\n        if self.buffer.len() \u003e= self.block_size {\n            return self.flush().map(|b| b + n);\n        }\n\n        Ok(n)\n    }\n\n    /// Append anything implementing the `Serialize` trait to a `Writer` for\n    /// [`serde`](https://docs.serde.rs/serde/index.html) compatibility, also performing schema\n    /// validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append_ser\u003cS: Serialize\u003e(\u0026mut self, value: S) -\u003e AvroResult\u003cusize\u003e {\n        let avro_value = value.serialize(\u0026mut self.serializer)?;\n        self.append(avro_value)\n    }\n\n    /// Extend a `Writer` with an `Iterator` of compatible values (implementing the `ToAvro`\n    /// trait), also performing schema validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend\u003cI, T: Into\u003cValue\u003e\u003e(\u0026mut self, values: I) -\u003e AvroResult\u003cusize\u003e\n    where\n        I: IntoIterator\u003cItem = T\u003e,\n    {\n        /*\n        https://github.com/rust-lang/rfcs/issues/811 :(\n        let mut stream = values\n            .filter_map(|value| value.serialize(\u0026mut self.serializer).ok())\n            .map(|value| value.encode(self.schema))\n            .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n            .ok_or_else(|| err_msg(\"value does not match given schema\"))?\n            .into_iter()\n            .fold(Vec::new(), |mut acc, stream| {\n                num_values += 1;\n                acc.extend(stream); acc\n            });\n        */\n\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Extend a `Writer` with an `Iterator` of anything implementing the `Serialize` trait for\n    /// [`serde`](https://docs.serde.rs/serde/index.html) compatibility, also performing schema\n    /// validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend_ser\u003cI, T: Serialize\u003e(\u0026mut self, values: I) -\u003e AvroResult\u003cusize\u003e\n    where\n        I: IntoIterator\u003cItem = T\u003e,\n    {\n        /*\n        https://github.com/rust-lang/rfcs/issues/811 :(\n        let mut stream = values\n            .filter_map(|value| value.serialize(\u0026mut self.serializer).ok())\n            .map(|value| value.encode(self.schema))\n            .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n            .ok_or_else(|| err_msg(\"value does not match given schema\"))?\n            .into_iter()\n            .fold(Vec::new(), |mut acc, stream| {\n                num_values += 1;\n                acc.extend(stream); acc\n            });\n        */\n\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append_ser(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Extend a `Writer` by appending each `Value` from a slice, while also performing schema\n    /// validation on each value appended.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend_from_slice(\u0026mut self, values: \u0026[Value]) -\u003e AvroResult\u003cusize\u003e {\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append_value_ref(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Flush the content appended to a `Writer`. Call this function to make sure all the content\n    /// has been written before releasing the `Writer`.\n    ///\n    /// Return the number of bytes written.\n    pub fn flush(\u0026mut self) -\u003e AvroResult\u003cusize\u003e {\n        if self.num_values == 0 {\n            return Ok(0);\n        }\n\n        self.codec.compress(\u0026mut self.buffer)?;\n\n        let num_values = self.num_values;\n        let stream_len = self.buffer.len();\n\n        let num_bytes = self.append_raw(\u0026num_values.into(), \u0026Schema::Long)?\n            + self.append_raw(\u0026stream_len.into(), \u0026Schema::Long)?\n            + self\n                .writer\n                .write(self.buffer.as_ref())\n                .map_err(Error::WriteBytes)?\n            + self.append_marker()?;\n\n        self.buffer.clear();\n        self.num_values = 0;\n\n        Ok(num_bytes)\n    }\n\n    /// Return what the `Writer` is writing to, consuming the `Writer` itself.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn into_inner(mut self) -\u003e AvroResult\u003cW\u003e {\n        self.flush()?;\n        Ok(self.writer)\n    }\n\n    /// Generate and append synchronization marker to the payload.\n    fn append_marker(\u0026mut self) -\u003e AvroResult\u003cusize\u003e {\n        // using .writer.write directly to avoid mutable borrow of self\n        // with ref borrowing of self.marker\n        self.writer.write(\u0026self.marker).map_err(Error::WriteMarker)\n    }\n\n    /// Append a raw Avro Value to the payload avoiding to encode it again.\n    fn append_raw(\u0026mut self, value: \u0026Value, schema: \u0026Schema) -\u003e AvroResult\u003cusize\u003e {\n        self.append_bytes(encode_to_vec(value, schema).as_ref())\n    }\n\n    /// Append pure bytes to the payload.\n    fn append_bytes(\u0026mut self, bytes: \u0026[u8]) -\u003e AvroResult\u003cusize\u003e {\n        self.writer.write(bytes).map_err(Error::WriteBytes)\n    }\n\n    /// Create an Avro header based on schema, codec and sync marker.\n    fn header(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n        let schema_bytes = serde_json::to_string(self.schema)\n            .map_err(Error::ConvertJsonToString)?\n            .into_bytes();\n\n        let mut metadata = HashMap::with_capacity(2);\n        metadata.insert(\"avro.schema\", Value::Bytes(schema_bytes));\n        metadata.insert(\"avro.codec\", self.codec.into());\n\n        let mut header = Vec::new();\n        header.extend_from_slice(AVRO_OBJECT_HEADER);\n        encode(\n            \u0026metadata.into(),\n            \u0026Schema::Map(Box::new(Schema::Bytes)),\n            \u0026mut header,\n        );\n        header.extend_from_slice(\u0026self.marker);\n\n        Ok(header)\n    }\n}\n\n/// Encode a compatible value (implementing the `ToAvro` trait) into Avro format, also performing\n/// schema validation.\n///\n/// This is an internal function which gets the bytes buffer where to write as parameter instead of\n/// creating a new one like `to_avro_datum`.\nfn write_avro_datum\u003cT: Into\u003cValue\u003e\u003e(\n    schema: \u0026Schema,\n    value: T,\n    buffer: \u0026mut Vec\u003cu8\u003e,\n) -\u003e Result\u003c(), Error\u003e {\n    let avro = value.into();\n    if !avro.validate(schema) {\n        return Err(Error::Validation);\n    }\n    encode(\u0026avro, schema, buffer);\n    Ok(())\n}\n\nfn write_value_ref(schema: \u0026Schema, value: \u0026Value, buffer: \u0026mut Vec\u003cu8\u003e) -\u003e AvroResult\u003c()\u003e {\n    if !value.validate(schema) {\n        return Err(Error::Validation);\n    }\n    encode_ref(value, schema, buffer);\n    Ok(())\n}\n\n/// Encode a compatible value (implementing the `ToAvro` trait) into Avro format, also\n/// performing schema validation.\n///\n/// **NOTE** This function has a quite small niche of usage and does NOT generate headers and sync\n/// markers; use [`Writer`](struct.Writer.html) to be fully Avro-compatible if you don't know what\n/// you are doing, instead.\npub fn to_avro_datum\u003cT: Into\u003cValue\u003e\u003e(schema: \u0026Schema, value: T) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n    let mut buffer = Vec::new();\n    write_avro_datum(schema, value, \u0026mut buffer)?;\n    Ok(buffer)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        decimal::Decimal,\n        duration::{Days, Duration, Millis, Months},\n        schema::Name,\n        types::Record,\n        util::zig_i64,\n    };\n    use serde::{Deserialize, Serialize};\n\n    const AVRO_OBJECT_HEADER_LEN: usize = AVRO_OBJECT_HEADER.len();\n\n    const SCHEMA: \u0026str = r#\"\n    {\n      \"type\": \"record\",\n      \"name\": \"test\",\n      \"fields\": [\n        {\n          \"name\": \"a\",\n          \"type\": \"long\",\n          \"default\": 42\n        },\n        {\n          \"name\": \"b\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n    \"#;\n    const UNION_SCHEMA: \u0026str = r#\"[\"null\", \"long\"]\"#;\n\n    #[test]\n    fn test_to_avro_datum() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let mut expected = Vec::new();\n        zig_i64(27, \u0026mut expected);\n        zig_i64(3, \u0026mut expected);\n        expected.extend(vec![b'f', b'o', b'o'].into_iter());\n\n        assert_eq!(to_avro_datum(\u0026schema, record).unwrap(), expected);\n    }\n\n    #[test]\n    fn test_union_not_null() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let union = Value::Union(Box::new(Value::Long(3)));\n\n        let mut expected = Vec::new();\n        zig_i64(1, \u0026mut expected);\n        zig_i64(3, \u0026mut expected);\n\n        assert_eq!(to_avro_datum(\u0026schema, union).unwrap(), expected);\n    }\n\n    #[test]\n    fn test_union_null() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let union = Value::Union(Box::new(Value::Null));\n\n        let mut expected = Vec::new();\n        zig_i64(0, \u0026mut expected);\n\n        assert_eq!(to_avro_datum(\u0026schema, union).unwrap(), expected);\n    }\n\n    type TestResult\u003cT\u003e = Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n    fn logical_type_test\u003cT: Into\u003cValue\u003e + Clone\u003e(\n        schema_str: \u0026'static str,\n\n        expected_schema: \u0026Schema,\n        value: Value,\n\n        raw_schema: \u0026Schema,\n        raw_value: T,\n    ) -\u003e TestResult\u003c()\u003e {\n        let schema = Schema::parse_str(schema_str)?;\n        assert_eq!(\u0026schema, expected_schema);\n        // The serialized format should be the same as the schema.\n        let ser = to_avro_datum(\u0026schema, value.clone())?;\n        let raw_ser = to_avro_datum(raw_schema, raw_value)?;\n        assert_eq!(ser, raw_ser);\n\n        // Should deserialize from the schema into the logical type.\n        let mut r = ser.as_slice();\n        let de = crate::from_avro_datum(\u0026schema, \u0026mut r, None).unwrap();\n        assert_eq!(de, value);\n        Ok(())\n    }\n\n    #[test]\n    fn date() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#,\n            \u0026Schema::Date,\n            Value::Date(1_i32),\n            \u0026Schema::Int,\n            1_i32,\n        )\n    }\n\n    #[test]\n    fn time_millis() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"int\", \"logicalType\": \"time-millis\"}\"#,\n            \u0026Schema::TimeMillis,\n            Value::TimeMillis(1_i32),\n            \u0026Schema::Int,\n            1_i32,\n        )\n    }\n\n    #[test]\n    fn time_micros() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"time-micros\"}\"#,\n            \u0026Schema::TimeMicros,\n            Value::TimeMicros(1_i64),\n            \u0026Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn timestamp_millis() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\"#,\n            \u0026Schema::TimestampMillis,\n            Value::TimestampMillis(1_i64),\n            \u0026Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn timestamp_micros() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#,\n            \u0026Schema::TimestampMicros,\n            Value::TimestampMicros(1_i64),\n            \u0026Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn decimal_fixed() -\u003e TestResult\u003c()\u003e {\n        let size = 30;\n        let inner = Schema::Fixed {\n            name: Name::new(\"decimal\"),\n            size,\n        };\n        let value = vec![0u8; size];\n        logical_type_test(\n            r#\"{\"type\": {\"type\": \"fixed\", \"size\": 30, \"name\": \"decimal\"}, \"logicalType\": \"decimal\", \"precision\": 20, \"scale\": 5}\"#,\n            \u0026Schema::Decimal {\n                precision: 20,\n                scale: 5,\n                inner: Box::new(inner.clone()),\n            },\n            Value::Decimal(Decimal::from(value.clone())),\n            \u0026inner,\n            Value::Fixed(size, value),\n        )\n    }\n\n    #[test]\n    fn decimal_bytes() -\u003e TestResult\u003c()\u003e {\n        let inner = Schema::Bytes;\n        let value = vec![0u8; 10];\n        logical_type_test(\n            r#\"{\"type\": \"bytes\", \"logicalType\": \"decimal\", \"precision\": 4, \"scale\": 3}\"#,\n            \u0026Schema::Decimal {\n                precision: 4,\n                scale: 3,\n                inner: Box::new(inner.clone()),\n            },\n            Value::Decimal(Decimal::from(value.clone())),\n            \u0026inner,\n            value,\n        )\n    }\n\n    #[test]\n    fn duration() -\u003e TestResult\u003c()\u003e {\n        let inner = Schema::Fixed {\n            name: Name::new(\"duration\"),\n            size: 12,\n        };\n        let value = Value::Duration(Duration::new(\n            Months::new(256),\n            Days::new(512),\n            Millis::new(1024),\n        ));\n        logical_type_test(\n            r#\"{\"type\": {\"type\": \"fixed\", \"name\": \"duration\", \"size\": 12}, \"logicalType\": \"duration\"}\"#,\n            \u0026Schema::Duration,\n            value,\n            \u0026inner,\n            Value::Fixed(12, vec![0, 1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0]),\n        )\n    }\n\n    #[test]\n    fn test_writer_append() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let n1 = writer.append(record.clone()).unwrap();\n        let n2 = writer.append(record.clone()).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_extend() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        let record_copy = record.clone();\n        let records = vec![record, record_copy];\n\n        let n1 = writer.extend(records.into_iter()).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[derive(Debug, Clone, Deserialize, Serialize)]\n    struct TestSerdeSerialize {\n        a: i64,\n        b: String,\n    }\n\n    #[test]\n    fn test_writer_append_ser() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let record = TestSerdeSerialize {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n\n        let n1 = writer.append_ser(record).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_extend_ser() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let record = TestSerdeSerialize {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let record_copy = record.clone();\n        let records = vec![record, record_copy];\n\n        let n1 = writer.extend_ser(records.into_iter()).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    fn make_writer_with_codec(schema: \u0026Schema) -\u003e Writer\u003c'_, Vec\u003cu8\u003e\u003e {\n        Writer::with_codec(schema, Vec::new(), Codec::Deflate)\n    }\n\n    fn make_writer_with_builder(schema: \u0026Schema) -\u003e Writer\u003c'_, Vec\u003cu8\u003e\u003e {\n        Writer::builder()\n            .writer(Vec::new())\n            .schema(schema)\n            .codec(Codec::Deflate)\n            .block_size(100)\n            .build()\n    }\n\n    fn check_writer(mut writer: Writer\u003c'_, Vec\u003cu8\u003e\u003e, schema: \u0026Schema) {\n        let mut record = Record::new(schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let n1 = writer.append(record.clone()).unwrap();\n        let n2 = writer.append(record.clone()).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n        Codec::Deflate.compress(\u0026mut data).unwrap();\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_with_codec() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let writer = make_writer_with_codec(\u0026schema);\n        check_writer(writer, \u0026schema);\n    }\n\n    #[test]\n    fn test_writer_with_builder() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let writer = make_writer_with_builder(\u0026schema);\n        check_writer(writer, \u0026schema);\n    }\n\n    #[test]\n    fn test_logical_writer() {\n        const LOGICAL_TYPE_SCHEMA: \u0026str = r#\"\n        {\n          \"type\": \"record\",\n          \"name\": \"logical_type_test\",\n          \"fields\": [\n            {\n              \"name\": \"a\",\n              \"type\": [\n                \"null\",\n                {\n                  \"type\": \"long\",\n                  \"logicalType\": \"timestamp-micros\"\n                }\n              ]\n            }\n          ]\n        }\n        \"#;\n        let codec = Codec::Deflate;\n        let schema = Schema::parse_str(LOGICAL_TYPE_SCHEMA).unwrap();\n        let mut writer = Writer::builder()\n            .schema(\u0026schema)\n            .codec(codec)\n            .writer(Vec::new())\n            .build();\n\n        let mut record1 = Record::new(\u0026schema).unwrap();\n        record1.put(\n            \"a\",\n            Value::Union(Box::new(Value::TimestampMicros(1234_i64))),\n        );\n\n        let mut record2 = Record::new(\u0026schema).unwrap();\n        record2.put(\"a\", Value::Union(Box::new(Value::Null)));\n\n        let n1 = writer.append(record1).unwrap();\n        let n2 = writer.append(record2).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        // byte indicating not null\n        zig_i64(1, \u0026mut data);\n        zig_i64(1234, \u0026mut data);\n\n        // byte indicating null\n        zig_i64(0, \u0026mut data);\n        codec.compress(\u0026mut data).unwrap();\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":109},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","tests","io.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Port of https://github.com/apache/avro/blob/release-1.9.1/lang/py/test/test_io.py\nuse avro_rs::{from_avro_datum, to_avro_datum, types::Value, Error, Schema};\nuse lazy_static::lazy_static;\nuse std::io::Cursor;\n\nlazy_static! {\n    static ref SCHEMAS_TO_VALIDATE: Vec\u003c(\u0026'static str, Value)\u003e = vec![\n        (r#\"\"null\"\"#, Value::Null),\n        (r#\"\"boolean\"\"#, Value::Boolean(true)),\n        (r#\"\"string\"\"#, Value::String(\"adsfasdf09809dsf-=adsf\".to_string())),\n        (r#\"\"bytes\"\"#, Value::Bytes(\"12345abcd\".to_string().into_bytes())),\n        (r#\"\"int\"\"#, Value::Int(1234)),\n        (r#\"\"long\"\"#, Value::Long(1234)),\n        (r#\"\"float\"\"#, Value::Float(1234.0)),\n        (r#\"\"double\"\"#, Value::Double(1234.0)),\n        (r#\"{\"type\": \"fixed\", \"name\": \"Test\", \"size\": 1}\"#, Value::Fixed(1, vec![b'B'])),\n        (r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\"#, Value::Enum(1, \"B\".to_string())),\n        (r#\"{\"type\": \"array\", \"items\": \"long\"}\"#, Value::Array(vec![Value::Long(1), Value::Long(3), Value::Long(2)])),\n        (r#\"{\"type\": \"map\", \"values\": \"long\"}\"#, Value::Map([(\"a\".to_string(), Value::Long(1i64)), (\"b\".to_string(), Value::Long(3i64)), (\"c\".to_string(), Value::Long(2i64))].iter().cloned().collect())),\n        (r#\"[\"string\", \"null\", \"long\"]\"#, Value::Union(Box::new(Value::Null))),\n        (r#\"{\"type\": \"record\", \"name\": \"Test\", \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]}\"#, Value::Record(vec![(\"f\".to_string(), Value::Long(1))]))\n    ];\n\n    static ref BINARY_ENCODINGS: Vec\u003c(i64, Vec\u003cu8\u003e)\u003e = vec![\n        (0, vec![0x00]),\n        (-1, vec![0x01]),\n        (1, vec![0x02]),\n        (-2, vec![0x03]),\n        (2, vec![0x04]),\n        (-64, vec![0x7f]),\n        (64, vec![0x80, 0x01]),\n        (8192, vec![0x80, 0x80, 0x01]),\n        (-8193, vec![0x81, 0x80, 0x01]),\n    ];\n\n    static ref DEFAULT_VALUE_EXAMPLES: Vec\u003c(\u0026'static str, \u0026'static str, Value)\u003e = vec![\n        (r#\"\"null\"\"#, \"null\", Value::Null),\n        (r#\"\"boolean\"\"#, \"true\", Value::Boolean(true)),\n        (r#\"\"string\"\"#, r#\"\"foo\"\"#, Value::String(\"foo\".to_string())),\n        // TODO: (#96) investigate why this is failing\n        //(r#\"\"bytes\"\"#, r#\"\"\\u00FF\\u00FF\"\"#, Value::Bytes(vec![0xff, 0xff])),\n        (r#\"\"int\"\"#, \"5\", Value::Int(5)),\n        (r#\"\"long\"\"#, \"5\", Value::Long(5)),\n        (r#\"\"float\"\"#, \"1.1\", Value::Float(1.1)),\n        (r#\"\"double\"\"#, \"1.1\", Value::Double(1.1)),\n        // TODO: (#96) investigate why this is failing\n        //(r#\"{\"type\": \"fixed\", \"name\": \"F\", \"size\": 2}\"#, r#\"\"\\u00FF\\u00FF\"\"#, Value::Bytes(vec![0xff, 0xff])),\n        (r#\"{\"type\": \"enum\", \"name\": \"F\", \"symbols\": [\"FOO\", \"BAR\"]}\"#, r#\"\"FOO\"\"#, Value::Enum(0, \"FOO\".to_string())),\n        (r#\"{\"type\": \"array\", \"items\": \"int\"}\"#, \"[1, 2, 3]\", Value::Array(vec![Value::Int(1), Value::Int(2), Value::Int(3)])),\n        (r#\"{\"type\": \"map\", \"values\": \"int\"}\"#, r#\"{\"a\": 1, \"b\": 2}\"#, Value::Map([(\"a\".to_string(), Value::Int(1)), (\"b\".to_string(), Value::Int(2))].iter().cloned().collect())),\n        (r#\"[\"int\", \"null\"]\"#, \"5\", Value::Union(Box::new(Value::Int(5)))),\n        (r#\"{\"type\": \"record\", \"name\": \"F\", \"fields\": [{\"name\": \"A\", \"type\": \"int\"}]}\"#, r#\"{\"A\": 5}\"#,Value::Record(vec![(\"A\".to_string(), Value::Int(5))])),\n    ];\n\n    static ref LONG_RECORD_SCHEMA: Schema = Schema::parse_str(r#\"\n    {\n        \"type\": \"record\",\n        \"name\": \"Test\",\n        \"fields\": [\n            {\"name\": \"A\", \"type\": \"int\"},\n            {\"name\": \"B\", \"type\": \"int\"},\n            {\"name\": \"C\", \"type\": \"int\"},\n            {\"name\": \"D\", \"type\": \"int\"},\n            {\"name\": \"E\", \"type\": \"int\"},\n            {\"name\": \"F\", \"type\": \"int\"},\n            {\"name\": \"G\", \"type\": \"int\"}\n        ]\n    }\n    \"#).unwrap();\n\n    static ref LONG_RECORD_DATUM: Value = Value::Record(vec![\n        (\"A\".to_string(), Value::Int(1)),\n        (\"B\".to_string(), Value::Int(2)),\n        (\"C\".to_string(), Value::Int(3)),\n        (\"D\".to_string(), Value::Int(4)),\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::Int(6)),\n        (\"G\".to_string(), Value::Int(7)),\n    ]);\n}\n\n#[test]\nfn test_validate() {\n    for (raw_schema, value) in SCHEMAS_TO_VALIDATE.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        assert!(\n            value.validate(\u0026schema),\n            \"value {:?} does not validate schema: {}\",\n            value,\n            raw_schema\n        );\n    }\n}\n\n#[test]\nfn test_round_trip() {\n    for (raw_schema, value) in SCHEMAS_TO_VALIDATE.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        let encoded = to_avro_datum(\u0026schema, value.clone()).unwrap();\n        let decoded = from_avro_datum(\u0026schema, \u0026mut Cursor::new(encoded), None).unwrap();\n        assert_eq!(value, \u0026decoded);\n    }\n}\n\n#[test]\nfn test_binary_int_encoding() {\n    for (number, hex_encoding) in BINARY_ENCODINGS.iter() {\n        let encoded = to_avro_datum(\u0026Schema::Int, Value::Int(*number as i32)).unwrap();\n        assert_eq!(\u0026encoded, hex_encoding);\n    }\n}\n\n#[test]\nfn test_binary_long_encoding() {\n    for (number, hex_encoding) in BINARY_ENCODINGS.iter() {\n        let encoded = to_avro_datum(\u0026Schema::Long, Value::Long(*number as i64)).unwrap();\n        assert_eq!(\u0026encoded, hex_encoding);\n    }\n}\n\n#[test]\nfn test_schema_promotion() {\n    // Each schema is present in order of promotion (int -\u003e long, long -\u003e float, float -\u003e double)\n    // Each value represents the expected decoded value when promoting a value previously encoded with a promotable schema\n    let promotable_schemas = vec![r#\"\"int\"\"#, r#\"\"long\"\"#, r#\"\"float\"\"#, r#\"\"double\"\"#];\n    let promotable_values = vec![\n        Value::Int(219),\n        Value::Long(219),\n        Value::Float(219.0),\n        Value::Double(219.0),\n    ];\n    for (i, writer_raw_schema) in promotable_schemas.iter().enumerate() {\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let original_value = \u0026promotable_values[i];\n        for (j, reader_raw_schema) in promotable_schemas.iter().enumerate().skip(i + 1) {\n            let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n            let encoded = to_avro_datum(\u0026writer_schema, original_value.clone()).unwrap();\n            let decoded = from_avro_datum(\n                \u0026writer_schema,\n                \u0026mut Cursor::new(encoded),\n                Some(\u0026reader_schema),\n            )\n            .unwrap_or_else(|_| {\n                panic!(\n                    \"failed to decode {:?} with schema: {:?}\",\n                    original_value, reader_raw_schema,\n                )\n            });\n            assert_eq!(decoded, promotable_values[j]);\n        }\n    }\n}\n\n#[test]\nfn test_unknown_symbol() {\n    let writer_schema =\n        Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"FOO\", \"BAR\"]}\"#)\n            .unwrap();\n    let reader_schema =\n        Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"BAR\", \"BAZ\"]}\"#)\n            .unwrap();\n    let original_value = Value::Enum(0, \"FOO\".to_string());\n    let encoded = to_avro_datum(\u0026writer_schema, original_value).unwrap();\n    let decoded = from_avro_datum(\n        \u0026writer_schema,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    );\n    assert!(decoded.is_err());\n}\n\n#[test]\nfn test_default_value() {\n    for (field_type, default_json, default_datum) in DEFAULT_VALUE_EXAMPLES.iter() {\n        let reader_schema = Schema::parse_str(\u0026format!(\n            r#\"{{\n                \"type\": \"record\",\n                \"name\": \"Test\",\n                \"fields\": [\n                    {{\"name\": \"H\", \"type\": {}, \"default\": {}}}\n                ]\n            }}\"#,\n            field_type, default_json\n        ))\n        .unwrap();\n        let datum_to_read = Value::Record(vec![(\"H\".to_string(), default_datum.clone())]);\n        let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n        let datum_read = from_avro_datum(\n            \u0026LONG_RECORD_SCHEMA,\n            \u0026mut Cursor::new(encoded),\n            Some(\u0026reader_schema),\n        )\n        .unwrap();\n        assert_eq!(\n            datum_read, datum_to_read,\n            \"{} -\u003e {}\",\n            *field_type, *default_json\n        );\n    }\n}\n\n#[test]\nfn test_no_default_value() -\u003e Result\u003c(), Error\u003e {\n    let reader_schema = Schema::parse_str(\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"H\", \"type\": \"int\"}\n            ]\n        }\"#,\n    )\n    .unwrap();\n    let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let result = from_avro_datum(\n        \u0026LONG_RECORD_SCHEMA,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    );\n    assert!(result.is_err());\n    Ok(())\n}\n\n#[test]\nfn test_projection() {\n    let reader_schema = Schema::parse_str(\n        r#\"\n        {\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"E\", \"type\": \"int\"},\n                {\"name\": \"F\", \"type\": \"int\"}\n            ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_read = Value::Record(vec![\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::Int(6)),\n    ]);\n    let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let datum_read = from_avro_datum(\n        \u0026LONG_RECORD_SCHEMA,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    )\n    .unwrap();\n    assert_eq!(datum_to_read, datum_read);\n}\n\n#[test]\nfn test_field_order() {\n    let reader_schema = Schema::parse_str(\n        r#\"\n        {\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"F\", \"type\": \"int\"},\n                {\"name\": \"E\", \"type\": \"int\"}\n            ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_read = Value::Record(vec![\n        (\"F\".to_string(), Value::Int(6)),\n        (\"E\".to_string(), Value::Int(5)),\n    ]);\n    let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let datum_read = from_avro_datum(\n        \u0026LONG_RECORD_SCHEMA,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    )\n    .unwrap();\n    assert_eq!(datum_to_read, datum_read);\n}\n\n#[test]\nfn test_type_exception() -\u003e Result\u003c(), String\u003e {\n    let writer_schema = Schema::parse_str(\n        r#\"\n        {\n             \"type\": \"record\",\n             \"name\": \"Test\",\n             \"fields\": [\n                {\"name\": \"F\", \"type\": \"int\"},\n                {\"name\": \"E\", \"type\": \"int\"}\n             ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_write = Value::Record(vec![\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::String(String::from(\"Bad\"))),\n    ]);\n    let encoded = to_avro_datum(\u0026writer_schema, datum_to_write);\n    match encoded {\n        Ok(_) =\u003e Err(String::from(\"Expected ValidationError, got Ok\")),\n        Err(Error::Validation) =\u003e Ok(()),\n        Err(ref e) =\u003e Err(format!(\"Expected ValidationError, got {}\", e)),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","tests","schema.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Port of https://github.com/apache/avro/blob/release-1.9.1/lang/py/test/test_schema.py\nuse avro_rs::{schema::Name, Error, Schema};\nuse lazy_static::lazy_static;\n\nconst PRIMITIVE_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"\"null\"\"#, true),\n    (r#\"{\"type\": \"null\"}\"#, true),\n    (r#\"\"boolean\"\"#, true),\n    (r#\"{\"type\": \"boolean\"}\"#, true),\n    (r#\"\"string\"\"#, true),\n    (r#\"{\"type\": \"string\"}\"#, true),\n    (r#\"\"bytes\"\"#, true),\n    (r#\"{\"type\": \"bytes\"}\"#, true),\n    (r#\"\"int\"\"#, true),\n    (r#\"{\"type\": \"int\"}\"#, true),\n    (r#\"\"long\"\"#, true),\n    (r#\"{\"type\": \"long\"}\"#, true),\n    (r#\"\"float\"\"#, true),\n    (r#\"{\"type\": \"float\"}\"#, true),\n    (r#\"\"double\"\"#, true),\n    (r#\"{\"type\": \"double\"}\"#, true),\n    (r#\"\"true\"\"#, false),\n    (r#\"true\"#, false),\n    (r#\"{\"no_type\": \"test\"}\"#, false),\n    (r#\"{\"type\": \"panther\"}\"#, false),\n];\n\nconst FIXED_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"fixed\", \"name\": \"Test\", \"size\": 1}\"#, true),\n    (\n        r#\"{\n                \"type\": \"fixed\",\n                \"name\": \"MyFixed\",\n                \"namespace\": \"org.apache.hadoop.avro\",\n                \"size\": 1\n            }\"#,\n        true,\n    ),\n    (r#\"{\"type\": \"fixed\", \"name\": \"Missing size\"}\"#, false),\n    (r#\"{\"type\": \"fixed\", \"size\": 314}\"#, false),\n];\n\nconst ENUM_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"name\": \"Status\",\n                \"symbols\": \"Normal Caution Critical\"\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"name\": [ 0, 1, 1, 2, 3, 5, 8 ],\n                \"symbols\": [\"Golden\", \"Mean\"]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"symbols\" : [\"I\", \"will\", \"fail\", \"no\", \"name\"]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                 \"name\": \"Test\"\n                 \"symbols\" : [\"AA\", \"AA\"]\n            }\"#,\n        false,\n    ),\n];\n\nconst ARRAY_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"array\", \"items\": \"long\"}\"#, true),\n    (\n        r#\"{\n                \"type\": \"array\",\n                 \"items\": {\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\n            }\"#,\n        true,\n    ),\n];\n\nconst MAP_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"map\", \"values\": \"long\"}\"#, true),\n    (\n        r#\"{\n                \"type\": \"map\",\n                \"values\": {\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\n            }\"#,\n        true,\n    ),\n];\n\nconst UNION_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"[\"string\", \"null\", \"long\"]\"#, true),\n    (r#\"[\"null\", \"null\"]\"#, false),\n    (r#\"[\"long\", \"long\"]\"#, false),\n    (\n        r#\"[\n                {\"type\": \"array\", \"items\": \"long\"}\n                {\"type\": \"array\", \"items\": \"string\"}\n            ]\"#,\n        false,\n    ),\n];\n\nconst RECORD_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Test\",\n                \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]\n            }\"#,\n        true,\n    ),\n    /*\n    // TODO: (#91) figure out why \"type\": \"error\" seems to be valid (search in spec) and uncomment\n    (\n        r#\"{\n            \"type\": \"error\",\n            \"name\": \"Test\",\n            \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]\n        }\"#,\n        true\n    ),\n    */\n    /*\n    // TODO: (#92) properly support recursive types and uncomment\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Node\",\n            \"fields\": [\n                {\"name\": \"label\", \"type\": \"string\"},\n                {\"name\": \"children\", \"type\": {\"type\": \"array\", \"items\": \"Node\"}}\n            ]\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Lisp\",\n            \"fields\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": [\n                        \"null\", \"string\",\n                        {\n                            \"type\": \"record\",\n                            \"name\": \"Cons\",\n                            \"fields\": [\n                                {\"name\": \"car\", \"type\": \"Lisp\"},\n                                {\"name\": \"cdr\", \"type\": \"Lisp\"}\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"HandshakeRequest\",\n            \"namespace\": \"org.apache.avro.ipc\",\n            \"fields\": [\n                {\"name\": \"clientHash\", \"type\": {\"type\": \"fixed\", \"name\": \"MD5\", \"size\": 16}},\n                {\"name\": \"clientProtocol\", \"type\": [\"null\", \"string\"]},\n                {\"name\": \"serverHash\", \"type\": \"MD5\"},\n                {\"name\": \"meta\", \"type\": [\"null\", {\"type\": \"map\", \"values\": \"bytes\"}]}\n            ]\n        }\"#, true\n    ),\n    */\n    (\n        r#\"{\n                \"type\":\"record\",\n                \"name\":\"HandshakeResponse\",\n                \"namespace\":\"org.apache.avro.ipc\",\n                \"fields\":[\n                    {\n                        \"name\":\"match\",\n                        \"type\":{\n                           \"type\":\"enum\",\n                           \"name\":\"HandshakeMatch\",\n                           \"symbols\":[\"BOTH\", \"CLIENT\", \"NONE\"]\n                        }\n                    },\n                    {\"name\":\"serverProtocol\", \"type\":[\"null\", \"string\"]},\n                    {\n                        \"name\":\"serverHash\",\n                        \"type\":[\"null\", {\"name\":\"MD5\", \"size\":16, \"type\":\"fixed\"}]\n                    },\n                    {\n                        \"name\":\"meta\",\n                        \"type\":[\"null\", {\"type\":\"map\", \"values\":\"bytes\"}]\n                    }\n                ]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\":\"record\",\n                \"name\":\"HandshakeResponse\",\n                \"namespace\":\"org.apache.avro.ipc\",\n                \"fields\":[\n                    {\n                        \"name\":\"match\",\n                        \"type\":{\n                            \"type\":\"enum\",\n                            \"name\":\"HandshakeMatch\",\n                            \"symbols\":[\"BOTH\", \"CLIENT\", \"NONE\"]\n                        }\n                    },\n                    {\"name\":\"serverProtocol\", \"type\":[\"null\", \"string\"]},\n                    {\n                        \"name\":\"serverHash\",\n                        \"type\":[\"null\", { \"name\":\"MD5\", \"size\":16, \"type\":\"fixed\"}]\n                    },\n                    {\"name\":\"meta\", \"type\":[\"null\", { \"type\":\"map\", \"values\":\"bytes\"}]}\n                ]\n            }\"#,\n        true,\n    ),\n    /*\n    // TODO: (#95) support same types but with different names in unions and uncomment (below the explanation)\n\n    // Unions may not contain more than one schema with the same type, except for the named\n    // types record, fixed and enum. For example, unions containing two array types or two map\n    // types are not permitted, but two types with different names are permitted.\n    // (Names permit efficient resolution when reading and writing unions.)\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"ipAddr\",\n            \"fields\": [\n                {\n                    \"name\": \"addr\",\n                    \"type\": [\n                        {\"name\": \"IPv6\", \"type\": \"fixed\", \"size\": 16},\n                        {\"name\": \"IPv4\", \"type\": \"fixed\", \"size\": 4}\n                    ]\n                }\n            ]\n        }\"#,\n        true\n    ),\n    */\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Address\",\n                \"fields\": [\n                    {\"type\": \"string\"},\n                    {\"type\": \"string\", \"name\": \"City\"}\n                ]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Event\",\n                \"fields\": [{\"name\": \"Sponsor\"}, {\"name\": \"City\", \"type\": \"string\"}]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"fields\": \"His vision, from the constantly passing bars,\"\n                \"name\",\n                \"Rainer\"\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"name\": [\"Tom\", \"Jerry\"],\n                \"type\": \"record\",\n                \"fields\": [{\"name\": \"name\", \"type\": \"string\"}]\n            }\"#,\n        false,\n    ),\n];\n\nconst DOC_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"TestDoc\",\n                \"doc\":  \"Doc string\",\n                \"fields\": [{\"name\": \"name\", \"type\": \"string\", \"doc\" : \"Doc String\"}]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"], \"doc\": \"Doc String\"}\"#,\n        true,\n    ),\n];\n\nconst OTHER_ATTRIBUTES_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"TestRecord\",\n                \"cp_string\": \"string\",\n                \"cp_int\": 1,\n                \"cp_array\": [ 1, 2, 3, 4],\n                \"fields\": [\n                    {\"name\": \"f1\", \"type\": \"string\", \"cp_object\": {\"a\":1,\"b\":2}},\n                    {\"name\": \"f2\", \"type\": \"long\", \"cp_null\": null}\n                ]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"map\", \"values\": \"long\", \"cp_boolean\": true}\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                 \"name\": \"TestEnum\",\n                 \"symbols\": [ \"one\", \"two\", \"three\" ],\n                 \"cp_float\" : 1.0\n            }\"#,\n        true,\n    ),\n    (r#\"{\"type\": \"long\", \"date\": \"true\"}\"#, true),\n];\n\nconst DECIMAL_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    /*\n    // TODO: (#93) support logical types and uncomment\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 4,\n            \"size\": 10,\n            \"scale\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 4,\n            \"scale\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 2,\n            \"scale\": -2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": -2,\n            \"scale\": 2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 2,\n            \"scale\": 3\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": -10,\n            \"scale\": 2,\n            \"size\": 5\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 2,\n            \"scale\": 3,\n            \"size\": 2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 2,\n            \"scale\": 2,\n            \"size\": -2\n        }\"#,\n        false\n    ),\n    */\n];\n\nconst DECIMAL_LOGICAL_TYPE_ATTRIBUTES: \u0026[(\u0026str, bool)] = \u0026[\n    /*\n    // TODO: (#93) support logical types and attributes and uncomment\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 4,\n            \"scale\": 2,\n            \"size\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 4\n        }\"#,\n        true\n    ),\n    */\n];\n\nconst DATE_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#, true),\n    // this is valid even though its logical type is \"date1\", because unknown logical types are\n    // ignored\n    (r#\"{\"type\": \"int\", \"logicalType\": \"date1\"}\"#, true),\n    (r#\"{\"type\": \"long\", \"logicalType\": \"date\"}\"#, false),\n];\n\nconst TIMEMILLIS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-millis\"}\"#, true),\n    // this is valid even though its logical type is \"time-milis\" (missing the second \"l\"),\n    // because unknown logical types are ignored\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-milis\"}\"#, true),\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-millis\"}\"#, false),\n];\n\nconst TIMEMICROS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-micros\"}\"#, true),\n    // this is valid even though its logical type is \"time-micro\" (missing the last \"s\"), because\n    // unknown logical types are ignored\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-micro\"}\"#, true),\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-micros\"}\"#, false),\n];\n\nconst TIMESTAMPMILLIS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\"#,\n        true,\n    ),\n    // this is valid even though its logical type is \"timestamp-milis\" (missing the second \"l\"), because\n    // unknown logical types are ignored\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-milis\"}\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"int\", \"logicalType\": \"timestamp-millis\"}\"#,\n        false,\n    ),\n];\n\nconst TIMESTAMPMICROS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#,\n        true,\n    ),\n    // this is valid even though its logical type is \"timestamp-micro\" (missing the last \"s\"), because\n    // unknown logical types are ignored\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micro\"}\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"int\", \"logicalType\": \"timestamp-micros\"}\"#,\n        false,\n    ),\n];\n\nlazy_static! {\n    static ref EXAMPLES: Vec\u003c(\u0026'static str, bool)\u003e = Vec::new()\n        .iter()\n        .copied()\n        .chain(PRIMITIVE_EXAMPLES.iter().copied())\n        .chain(FIXED_EXAMPLES.iter().copied())\n        .chain(ENUM_EXAMPLES.iter().copied())\n        .chain(ARRAY_EXAMPLES.iter().copied())\n        .chain(MAP_EXAMPLES.iter().copied())\n        .chain(UNION_EXAMPLES.iter().copied())\n        .chain(RECORD_EXAMPLES.iter().copied())\n        .chain(DOC_EXAMPLES.iter().copied())\n        .chain(OTHER_ATTRIBUTES_EXAMPLES.iter().copied())\n        .chain(DECIMAL_LOGICAL_TYPE.iter().copied())\n        .chain(DECIMAL_LOGICAL_TYPE_ATTRIBUTES.iter().copied())\n        .chain(DATE_LOGICAL_TYPE.iter().copied())\n        .chain(TIMEMILLIS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMEMICROS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMESTAMPMILLIS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMESTAMPMICROS_LOGICAL_TYPE.iter().copied())\n        .collect();\n    static ref VALID_EXAMPLES: Vec\u003c(\u0026'static str, bool)\u003e =\n        EXAMPLES.iter().copied().filter(|s| s.1).collect();\n}\n\n/*\n// TODO: (#92) properly support recursive types and uncomment\n\nThis test is failing unwrapping the outer schema with ParseSchemaError(\"Unknown type: X\"). It seems\nthat recursive types are not properly supported.\n\n#[test]\nfn test_correct_recursive_extraction() {\n    let raw_outer_schema = r#\"{\n        \"type\": \"record\",\n        \"name\": \"X\",\n        \"fields\": [\n            {\n                \"name\": \"y\",\n                \"type\": {\n                    \"type\": \"record\",\n                    \"name\": \"Y\",\n                    \"fields\": [\n                        {\n                            \"name\": \"Z\",\n                            \"type\": \"X\"\n                        }\n                    ]\n                }\n            }\n        ]\n    }\"#;\n    let outer_schema = Schema::parse_str(raw_outer_schema).unwrap();\n    if let Schema::Record { fields: outer_fields, .. } = outer_schema {\n        let raw_inner_schema = outer_fields[0].schema.canonical_form();\n        let inner_schema = Schema::parse_str(raw_inner_schema.as_str()).unwrap();\n        if let Schema::Record { fields: inner_fields, .. } = inner_schema {\n            if let Schema::Record {name: recursive_type, .. } = \u0026inner_fields[0].schema {\n                assert_eq!(\"X\", recursive_type.name.as_str());\n            }\n        } else {\n            panic!(\"inner schema {} should have been a record\", raw_inner_schema)\n        }\n    } else {\n        panic!(\"outer schema {} should have been a record\", raw_outer_schema)\n    }\n}\n*/\n\n#[test]\nfn test_parse() {\n    for (raw_schema, valid) in EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema);\n        if *valid {\n            assert!(\n                schema.is_ok(),\n                \"schema {} was supposed to be valid; error: {:?}\",\n                raw_schema,\n                schema,\n            )\n        } else {\n            assert!(\n                schema.is_err(),\n                \"schema {} was supposed to be invalid\",\n                raw_schema\n            )\n        }\n    }\n}\n\n#[test]\n/// Test that the string generated by an Avro Schema object is, in fact, a valid Avro schema.\nfn test_valid_cast_to_string_after_parse() {\n    for (raw_schema, _) in VALID_EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        Schema::parse_str(schema.canonical_form().as_str()).unwrap();\n    }\n}\n\n#[test]\n/// 1. Given a string, parse it to get Avro schema \"original\".\n/// 2. Serialize \"original\" to a string and parse that string to generate Avro schema \"round trip\".\n/// 3. Ensure \"original\" and \"round trip\" schemas are equivalent.\nfn test_equivalence_after_round_trip() {\n    for (raw_schema, _) in VALID_EXAMPLES.iter() {\n        let original_schema = Schema::parse_str(raw_schema).unwrap();\n        let round_trip_schema =\n            Schema::parse_str(original_schema.canonical_form().as_str()).unwrap();\n        assert_eq!(original_schema, round_trip_schema);\n    }\n}\n\n#[test]\n/// Test that a list of schemas whose definitions do not depend on each other produces the same\n/// result as parsing each element of the list individually\nfn test_parse_list_without_cross_deps() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"fixed\",\n        \"size\": 16\n    }\"#;\n    let schema_strs = [schema_str_1, schema_str_2];\n    let schemas = Schema::parse_list(\u0026schema_strs).expect(\"Test failed\");\n\n    for schema_str in \u0026schema_strs {\n        let parsed = Schema::parse_str(schema_str).expect(\"Test failed\");\n        assert!(schemas.contains(\u0026parsed));\n    }\n}\n\n#[test]\n/// Test that the parsing of a list of schemas, whose definitions do depend on each other, can\n/// perform the necessary schema composition. This should work regardless of the order in which\n/// the schemas are input.\n/// However, the output order is guaranteed to be the same as the input order.\nfn test_parse_list_with_cross_deps_basic() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n            \"type\": {\n                \"name\": \"A\",\n                \"type\": \"record\",\n                \"fields\": [\n                    {\"name\": \"field_one\", \"type\": \"float\"}\n                    ]\n                }\n            }\n        ]\n\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let schemas_first = Schema::parse_list(\u0026schema_strs_first).expect(\"Test failed\");\n    let schemas_second = Schema::parse_list(\u0026schema_strs_second).expect(\"Test failed\");\n\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_composite).expect(\"Test failed\");\n    assert_eq!(schemas_first, vec!(parsed_1.clone(), parsed_2.clone()));\n    assert_eq!(schemas_second, vec!(parsed_2, parsed_1));\n}\n\n#[test]\n/// Test that if a cycle of dependencies occurs in the input schema jsons, the algorithm terminates\n/// and returns an error. N.B. In the future, when recursive types are supported, this should be\n/// revisited.\nfn test_parse_list_recursive_type_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"B\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let _ = Schema::parse_list(\u0026schema_strs_first).expect_err(\"Test failed\");\n    let _ = Schema::parse_list(\u0026schema_strs_second).expect_err(\"Test failed\");\n}\n\n#[test]\n/// Test that schema composition resolves namespaces.\nfn test_parse_list_with_cross_deps_and_namespaces() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"namespace\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"namespace.A\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n            \"type\": {\n                \"name\": \"A\",\n                \"type\": \"record\",\n                \"namespace\": \"namespace\",\n                \"fields\": [\n                    {\"name\": \"field_one\", \"type\": \"float\"}\n                    ]\n                }\n            }\n        ]\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let schemas_first = Schema::parse_list(\u0026schema_strs_first).expect(\"Test failed\");\n    let schemas_second = Schema::parse_list(\u0026schema_strs_second).expect(\"Test failed\");\n\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_composite).expect(\"Test failed\");\n    assert_eq!(schemas_first, vec!(parsed_1.clone(), parsed_2.clone()));\n    assert_eq!(schemas_second, vec!(parsed_2, parsed_1));\n}\n\n#[test]\n/// Test that schema composition fails on namespace errors.\nfn test_parse_list_with_cross_deps_and_namespaces_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"namespace\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let _ = Schema::parse_list(\u0026schema_strs_first).expect_err(\"Test failed\");\n    let _ = Schema::parse_list(\u0026schema_strs_second).expect_err(\"Test failed\");\n}\n\n/// Return all permutations of an input slice\nfn permutations\u003cT\u003e(list: \u0026[T]) -\u003e Vec\u003cVec\u003c\u0026T\u003e\u003e {\n    let size = list.len();\n    let indices = permutation_indices((0..size).collect());\n    let mut perms = Vec::new();\n    for perm_map in \u0026indices {\n        let mut perm = Vec::new();\n        for ix in perm_map {\n            perm.push(\u0026list[*ix]);\n        }\n        perms.push(perm)\n    }\n    perms\n}\n\n/// Return all permutations of the indices of a vector\nfn permutation_indices(indices: Vec\u003cusize\u003e) -\u003e Vec\u003cVec\u003cusize\u003e\u003e {\n    let size = indices.len();\n    let mut perms: Vec\u003cVec\u003cusize\u003e\u003e = Vec::new();\n    if size == 1 {\n        perms.push(indices);\n        return perms;\n    }\n    for index in 0..size {\n        let (head, tail) = indices.split_at(index);\n        let (first, rest) = tail.split_at(1);\n        let mut head = head.to_vec();\n        head.extend_from_slice(rest);\n        for mut sub_index in permutation_indices(head) {\n            sub_index.insert(0, first[0]);\n            perms.push(sub_index);\n        }\n    }\n\n    perms\n}\n\n#[test]\n/// Test that a type that depends on more than one other type is parsed correctly when all\n/// definitions are passed in as a list. This should work regardless of the ordering of the list.\nfn test_parse_list_multiple_dependencies() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": [\"null\", \"B\", \"C\"]}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"fixed\",\n        \"size\": 16\n    }\"#;\n    let schema_str_3 = r#\"{\n        \"name\": \"C\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"string\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\n                \"name\": \"field_one\",\n                \"type\":  [\n                    \"null\",\n                    {\n                        \"name\": \"B\",\n                        \"type\": \"fixed\",\n                        \"size\": 16\n                    },\n                    {\n                        \"name\": \"C\",\n                        \"type\": \"record\",\n                        \"fields\": [\n                            {\"name\": \"field_one\", \"type\": \"string\"}\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\"#;\n\n    let parsed = vec![\n        Schema::parse_str(schema_str_2).expect(\"Test failed\"),\n        Schema::parse_str(schema_str_3).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite).expect(\"Test failed\"),\n    ];\n    let schema_strs = vec![schema_str_1, schema_str_2, schema_str_3];\n    for schema_str_perm in permutations(\u0026schema_strs) {\n        let schema_str_perm: Vec\u003c\u0026str\u003e = schema_str_perm.iter().map(|s| **s).collect();\n        let schemas = Schema::parse_list(\u0026schema_str_perm).expect(\"Test failed\");\n        assert_eq!(schemas.len(), 3);\n        for parsed_schema in \u0026parsed {\n            assert!(schemas.contains(parsed_schema));\n        }\n    }\n}\n\n#[test]\n/// Test that a type that is depended on by more than one other type is parsed correctly when all\n/// definitions are passed in as a list. This should work regardless of the ordering of the list.\nfn test_parse_list_shared_dependency() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": {\"type\": \"array\", \"items\": \"C\"}}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": {\"type\": \"map\", \"values\": \"C\"}}\n        ]\n    }\"#;\n    let schema_str_3 = r#\"{\n        \"name\": \"C\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"string\"}\n        ]\n    }\"#;\n    let schema_composite_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n              \"type\": {\"type\": \"array\",\n                       \"items\": {\n                            \"name\": \"C\",\n                            \"type\": \"record\",\n                            \"fields\": [\n                                {\"name\": \"field_one\", \"type\": \"string\"}\n                                ]\n                            }\n                      }\n            }\n        ]\n    }\"#;\n    let schema_composite_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n              \"type\": {\"type\": \"map\",\n                       \"values\": {\n                            \"name\": \"C\",\n                            \"type\":  \"record\",\n                            \"fields\": [\n                                {\"name\": \"field_one\", \"type\": \"string\"}\n                                ]\n                            }\n                      }\n                 }\n            ]\n    }\"#;\n\n    let parsed = vec![\n        Schema::parse_str(schema_str_3).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite_1).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite_2).expect(\"Test failed\"),\n    ];\n    let schema_strs = vec![schema_str_1, schema_str_2, schema_str_3];\n    for schema_str_perm in permutations(\u0026schema_strs) {\n        let schema_str_perm: Vec\u003c\u0026str\u003e = schema_str_perm.iter().map(|s| **s).collect();\n        let schemas = Schema::parse_list(\u0026schema_str_perm).expect(\"Test failed\");\n        assert_eq!(schemas.len(), 3);\n        for parsed_schema in \u0026parsed {\n            assert!(schemas.contains(parsed_schema));\n        }\n    }\n}\n\n#[test]\n/// Test that trying to parse two schemas with the same fullname returns an Error\nfn test_name_collision_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"foo.A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"double\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"foo\",\n        \"fields\": [\n            {\"name\": \"field_two\", \"type\": \"string\"}\n        ]\n    }\"#;\n\n    let _ = Schema::parse_list(\u0026[schema_str_1, schema_str_2]).expect_err(\"Test failed\");\n}\n\n#[test]\n/// Test that having the same name but different fullnames does not return an error\nfn test_namespace_prevents_collisions() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"double\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"foo\",\n        \"fields\": [\n            {\"name\": \"field_two\", \"type\": \"string\"}\n        ]\n    }\"#;\n\n    let parsed = Schema::parse_list(\u0026[schema_str_1, schema_str_2]).expect(\"Test failed\");\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_str_2).expect(\"Test failed\");\n    assert_eq!(parsed, vec!(parsed_1, parsed_2));\n}\n\n// The fullname is determined in one of the following ways:\n//  * A name and namespace are both specified.  For example,\n//    one might use \"name\": \"X\", \"namespace\": \"org.foo\"\n//    to indicate the fullname \"org.foo.X\".\n//  * A fullname is specified.  If the name specified contains\n//    a dot, then it is assumed to be a fullname, and any\n//    namespace also specified is ignored.  For example,\n//    use \"name\": \"org.foo.X\" to indicate the\n//    fullname \"org.foo.X\".\n//  * A name only is specified, i.e., a name that contains no\n//    dots.  In this case the namespace is taken from the most\n//    tightly enclosing schema or protocol.  For example,\n//    if \"name\": \"X\" is specified, and this occurs\n//    within a field of the record definition ///    of \"org.foo.Y\", then the fullname is \"org.foo.X\".\n\n// References to previously defined names are as in the latter\n// two cases above: if they contain a dot they are a fullname, if\n// they do not contain a dot, the namespace is the namespace of\n// the enclosing definition.\n\n// Primitive type names have no namespace and their names may\n// not be defined in any namespace. A schema may only contain\n// multiple definitions of a fullname if the definitions are\n// equivalent.\n\n#[test]\nfn test_fullname_name_and_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": \"o.a.h\", \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(None);\n    assert_eq!(\"o.a.h.a\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_and_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": \"o.a.h\", \"aliases\": null}\"#)\n            .unwrap();\n    let fullname = name.fullname(None);\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_name_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": null, \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"b.c.d\"));\n    assert_eq!(\"b.c.d.a\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": null, \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_namespace_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": \"o.a.a\", \"aliases\": null}\"#)\n            .unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_name_namespace_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": \"o.a.a\", \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"o.a.a.a\", fullname);\n}\n\n#[test]\nfn test_doc_attributes() {\n    fn assert_doc(schema: \u0026Schema) {\n        match schema {\n            Schema::Enum { doc, .. } =\u003e assert!(doc.is_some()),\n            Schema::Record { doc, .. } =\u003e assert!(doc.is_some()),\n            _ =\u003e (),\n        }\n    }\n\n    for (raw_schema, _) in DOC_EXAMPLES.iter() {\n        let original_schema = Schema::parse_str(raw_schema).unwrap();\n        assert_doc(\u0026original_schema);\n        if let Schema::Record { fields, .. } = original_schema {\n            for f in fields {\n                assert_doc(\u0026f.schema)\n            }\n        }\n    }\n}\n\n/*\nTODO: (#94) add support for user-defined attributes and uncomment (may need some tweaks to compile)\n#[test]\nfn test_other_attributes() {\n    fn assert_attribute_type(attribute: (String, serde_json::Value)) {\n        match attribute.1.as_ref() {\n            \"cp_boolean\" =\u003e assert!(attribute.2.is_bool()),\n            \"cp_int\" =\u003e assert!(attribute.2.is_i64()),\n            \"cp_object\" =\u003e assert!(attribute.2.is_object()),\n            \"cp_float\" =\u003e assert!(attribute.2.is_f64()),\n            \"cp_array\" =\u003e assert!(attribute.2.is_array()),\n        }\n    }\n\n    for (raw_schema, _) in OTHER_ATTRIBUTES_EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        // all inputs have at least some user-defined attributes\n        assert!(schema.other_attributes.is_some());\n        for prop in schema.other_attributes.unwrap().iter() {\n            assert_attribute_type(prop);\n        }\n        if let Schema::Record { fields, .. } = schema {\n           for f in fields {\n               // all fields in the record have at least some user-defined attributes\n               assert!(f.schema.other_attributes.is_some());\n               for prop in f.schema.other_attributes.unwrap().iter() {\n                   assert_attribute_type(prop);\n               }\n           }\n        }\n    }\n}\n*/\n\n#[test]\nfn test_root_error_is_not_swallowed_on_parse_error() -\u003e Result\u003c(), String\u003e {\n    let raw_schema = r#\"/not/a/real/file\"#;\n    let error = Schema::parse_str(raw_schema).unwrap_err();\n\n    if let Error::ParseSchemaJson(e) = error {\n        assert!(\n            e.to_string().contains(\"expected value at line 1 column 1\"),\n            \"{}\",\n            e\n        );\n        Ok(())\n    } else {\n        Err(format!(\n            \"Expected serde_json::error::Error, got {:?}\",\n            error\n        ))\n    }\n}\n\n/*\n// TODO: (#93) add support for logical type and attributes and uncomment (may need some tweaks to compile)\n#[test]\nfn test_decimal_valid_type_attributes() {\n    let fixed_decimal = Schema::parse_str(DECIMAL_LOGICAL_TYPE_ATTRIBUTES[0]).unwrap();\n    assert_eq!(4, fixed_decimal.get_attribute(\"precision\"));\n    assert_eq!(2, fixed_decimal.get_attribute(\"scale\"));\n    assert_eq!(2, fixed_decimal.get_attribute(\"size\"));\n\n    let bytes_decimal = Schema::parse_str(DECIMAL_LOGICAL_TYPE_ATTRIBUTES[1]).unwrap();\n    assert_eq!(4, bytes_decimal.get_attribute(\"precision\"));\n    assert_eq!(0, bytes_decimal.get_attribute(\"scale\"));\n}\n*/\n","traces":[{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","huolinhe","Projects","taosdata","taosx","mdsn","src","lib.rs"],"content":"//! M-DSN: A Multi-address DSN(Data Source Name) parser.\n//!\n//! M-DSN support two kind of DSN format:\n//!\n//! 1. `\u003cdriver\u003e[+\u003cprotocol\u003e]://\u003cusername\u003e:\u003cpassword\u003e@\u003caddresses\u003e/\u003cdatabase\u003e?\u003cparams\u003e`\n//! 2. `\u003cdriver\u003e[+\u003cprotocol\u003e]://\u003cusername\u003e:\u003cpassword\u003e@\u003cfragment\u003e?\u003cparams\u003e`\n//! 3. `\u003cdriver\u003e://\u003cusername\u003e:\u003cpassword\u003e@\u003cprotocol\u003e(\u003caddresses\u003e)/\u003cdatabase\u003e?\u003cparams\u003e`\n//!\n//! All the items will be parsed into struct [Dsn](crate::Dsn).\n//!\n//! ## Parser\n//!\n//! ```rust\n//! use mdsn::Dsn;\n//!\n//! # fn main() -\u003e Result\u003c(), mdsn::DsnError\u003e {\n//! // The two styles are equivalent.\n//! let dsn = Dsn::parse(\"taos://root:taosdata@host1:6030,host2:6030/db\")?;\n//! let dsn: Dsn = \"taos://root:taosdata@host1:6030,host2:6030/db\".parse()?;\n//!\n//! assert_eq!(dsn.driver, \"taos\");\n//! assert_eq!(dsn.username.unwrap(), \"root\");\n//! assert_eq!(dsn.password.unwrap(), \"taosdata\");\n//! assert_eq!(dsn.database.unwrap(), \"db\");\n//! assert_eq!(dsn.addresses.len(), 2);\n//! assert_eq!(dsn.addresses, vec![\n//!     mdsn::Address::new(\"host1\", 6030),\n//!     mdsn::Address::new(\"host2\", 6030),\n//! ]);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## DSN Examples\n//!\n//! A DSN for [TDengine](https://taosdata.com) driver [taos](https://docs.rs/taos).\n//!\n//! ```dsn\n//! taos://root:taosdata@localhost:6030/db?timezone=Asia/Shanghai\u0026asyncLog=1\n//! ```\n//!\n//! With multi-address:\n//!\n//! ```dsn\n//! taos://root:taosdata@host1:6030,host2:6030/db?timezone=Asia/Shanghai\n//! ```\n//!\n//! A DSN for unix socket:\n//!\n//! ```dsn\n//! unix:///path/to/unix.sock?param1=value\n//! ```\n//!\n//! A DSN for postgresql with url-encoded socket directory path.\n//!\n//! ```dsn\n//! postgresql://%2Fvar%2Flib%2Fpostgresql/db\n//! ```\n//!\n//! A DSN for sqlite db file, note that you must use prefix `./` for a relative path file.\n//!\n//! ```dsn\n//! sqlite://./file.db\n//! ```\n//!\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\nuse itertools::Itertools;\nuse pest;\nuse pest::Parser;\nuse pest_derive::Parser;\nuse thiserror::Error;\n\n#[derive(Parser)]\n#[grammar = \"dsn.pest\"]\nstruct DsnParser;\n\n/// Error caused by [pest] DSN parser.\n#[derive(Debug, Error)]\npub enum DsnError {\n    #[error(\"{0}\")]\n    ParseErr(#[from] pest::error::Error\u003cRule\u003e),\n    #[error(\"unable to parse port from {0}\")]\n    PortErr(#[from] ParseIntError),\n    #[error(\"invalid driver {0}\")]\n    InvalidDriver(String),\n    #[error(\"invalid connection {0}\")]\n    InvalidConnection(String),\n    #[error(\"invalid addresses {0:?}\")]\n    InvalidAddresses(Vec\u003cAddress\u003e),\n    #[error(\"requires database: {0}\")]\n    RequireDatabase(String),\n}\n\n/// A simple struct to represent a server address, with host:port or socket path.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct Address {\n    /// Host or ip address of the server.\n    pub host: Option\u003cString\u003e,\n    /// Port to connect to the server.\n    pub port: Option\u003cu16\u003e,\n    /// Use unix socket path to connect.\n    pub path: Option\u003cString\u003e,\n}\n\nimpl Address {\n    /// Construct server address with host and port.\n    #[inline]\n    pub fn new(host: impl Into\u003cString\u003e, port: u16) -\u003e Self {\n        Self {\n            host: Some(host.into()),\n            port: Some(port),\n            ..Default::default()\n        }\n    }\n    /// Construct server address with host or ip address only.\n    #[inline]\n    pub fn from_host(host: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            host: Some(host.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Construct server address with unix socket path.\n    #[inline]\n    pub fn from_path(path: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            path: Some(path.into()),\n            ..Default::default()\n        }\n    }\n\n    #[inline]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.host.is_none() \u0026\u0026 self.port.is_none() \u0026\u0026 self.path.is_none()\n    }\n}\n\nimpl FromStr for Address {\n    type Err = DsnError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut addr = Self::default();\n        if let Some(dsn) = DsnParser::parse(Rule::address, \u0026s)?.next() {\n            for inner in dsn.into_inner() {\n                match inner.as_rule() {\n                    Rule::host =\u003e addr.host = Some(inner.as_str().to_string()),\n                    Rule::port =\u003e addr.port = Some(inner.as_str().parse()?),\n                    Rule::path =\u003e {\n                        addr.path = Some(\n                            urlencoding::decode(inner.as_str())\n                                .expect(\"UTF-8\")\n                                .to_string(),\n                        )\n                    }\n                    _ =\u003e unreachable!(),\n                }\n            }\n        }\n        Ok(addr)\n    }\n}\n\nimpl Display for Address {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match (\u0026self.host, self.port, \u0026self.path) {\n            (Some(host), None, None) =\u003e write!(f, \"{host}\"),\n            (Some(host), Some(port), None) =\u003e write!(f, \"{host}:{port}\"),\n            (None, Some(port), None) =\u003e write!(f, \":{port}\"),\n            (None, None, Some(path)) =\u003e write!(f, \"{}\", urlencoding::encode(path)),\n            (None, None, None) =\u003e Ok(()),\n            _ =\u003e unreachable!(\"path will be conflict with host/port\"),\n        }\n    }\n}\n\n#[test]\nfn addr_parse() {\n    let s = \"taosdata:6030\";\n    let addr = Address::from_str(s).unwrap();\n    assert_eq!(addr.to_string(), s);\n\n    let s = \"/var/lib/taos\";\n    let addr = Address::from_str(\u0026urlencoding::encode(s)).unwrap();\n    assert_eq!(addr.path.as_ref().unwrap(), s);\n    assert_eq!(addr.to_string(), urlencoding::encode(s));\n}\n\n/// A DSN(**Data Source Name**) parser.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct Dsn {\n    pub driver: String,\n    pub protocol: Option\u003cString\u003e,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n    pub addresses: Vec\u003cAddress\u003e,\n    pub fragment: Option\u003cString\u003e,\n    pub database: Option\u003cString\u003e,\n    pub params: BTreeMap\u003cString, String\u003e,\n}\n\npub trait IntoDsn {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e;\n}\n\nimpl IntoDsn for \u0026str {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        self.parse()\n    }\n}\n\nimpl IntoDsn for String {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        self.as_str().into_dsn()\n    }\n}\n\nimpl IntoDsn for \u0026String {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        self.as_str().into_dsn()\n    }\n}\n\nimpl IntoDsn for \u0026Dsn {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        Ok(self.clone())\n    }\n}\nimpl IntoDsn for Dsn {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        Ok(self)\n    }\n}\n\nimpl Display for Dsn {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.driver)?;\n        if let Some(protocol) = \u0026self.protocol {\n            write!(f, \"+{protocol}\")?;\n        }\n        write!(f, \"://\")?;\n        match (\u0026self.username, \u0026self.password) {\n            (Some(username), Some(password)) =\u003e write!(f, \"{username}:{password}@\")?,\n            (Some(username), None) =\u003e write!(f, \"{username}@\")?,\n            (None, Some(password)) =\u003e write!(f, \":{password}@\")?,\n            (None, None) =\u003e {}\n        }\n        if !self.addresses.is_empty() {\n            write!(\n                f,\n                \"{}\",\n                self.addresses.iter().map(ToString::to_string).join(\",\")\n            )?;\n        }\n        if let Some(database) = \u0026self.database {\n            write!(f, \"/{database}\")?;\n        }\n        if let Some(fragment) = \u0026self.fragment {\n            write!(f, \"{fragment}\")?;\n        }\n        if !self.params.is_empty() {\n            write!(\n                f,\n                \"?{}\",\n                self.params\n                    .iter()\n                    .map(|(k, v)| format!(\"{k}={v}\"))\n                    .join(\"\u0026\")\n            )?;\n        }\n        Ok(())\n    }\n}\n\nimpl Dsn {\n    /// Parse from a DSN string.\n    #[inline]\n    pub fn parse(dsn: impl AsRef\u003cstr\u003e) -\u003e Result\u003cSelf, DsnError\u003e {\n        dsn.as_ref().parse()\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Dsn::from_str(value)\n    }\n}\n\nimpl TryFrom\u003c\u0026String\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: \u0026String) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Dsn::from_str(value)\n    }\n}\n\nimpl TryFrom\u003cString\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Dsn::from_str(\u0026value)\n    }\n}\n\nimpl TryFrom\u003c\u0026Dsn\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: \u0026Dsn) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(value.clone())\n    }\n}\nimpl FromStr for Dsn {\n    type Err = DsnError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let dsn = DsnParser::parse(Rule::dsn, s)?.next().unwrap();\n\n        let mut to = Dsn::default();\n        for pair in dsn.into_inner() {\n            match pair.as_rule() {\n                Rule::scheme =\u003e {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::driver =\u003e to.driver = inner.as_str().to_string(),\n                            Rule::protocol =\u003e to.protocol = Some(inner.as_str().to_string()),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }\n                Rule::SCHEME_IDENT =\u003e (),\n                Rule::username_with_password =\u003e {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::username =\u003e to.username = Some(inner.as_str().to_string()),\n                            Rule::password =\u003e to.password = Some(inner.as_str().to_string()),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }\n                Rule::protocol_with_addresses =\u003e {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::addresses =\u003e {\n                                for inner in inner.into_inner() {\n                                    match inner.as_rule() {\n                                        Rule::address =\u003e {\n                                            let mut addr = Address::default();\n                                            for inner in inner.into_inner() {\n                                                match inner.as_rule() {\n                                                    Rule::host =\u003e {\n                                                        addr.host = Some(inner.as_str().to_string())\n                                                    }\n                                                    Rule::port =\u003e {\n                                                        addr.port = Some(inner.as_str().parse()?)\n                                                    }\n                                                    Rule::path =\u003e {\n                                                        addr.path = Some(\n                                                            urlencoding::decode(inner.as_str())\n                                                                .expect(\"UTF-8\")\n                                                                .to_string(),\n                                                        )\n                                                    }\n                                                    _ =\u003e unreachable!(),\n                                                }\n                                            }\n                                            to.addresses.push(addr);\n                                        }\n                                        _ =\u003e unreachable!(),\n                                    }\n                                }\n                            }\n                            Rule::protocol =\u003e to.protocol = Some(inner.as_str().to_string()),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }\n                Rule::database =\u003e {\n                    to.database = Some(pair.as_str().to_string());\n                }\n                Rule::fragment =\u003e {\n                    to.fragment = Some(pair.as_str().to_string());\n                }\n                Rule::param =\u003e {\n                    let (mut name, mut value) = (\"\".to_string(), \"\".to_string());\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::name =\u003e name = inner.as_str().to_string(),\n                            Rule::value =\u003e value = inner.as_str().to_string(),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                    to.params.insert(name, value);\n                }\n                Rule::EOI =\u003e {}\n                _ =\u003e unreachable!(),\n            }\n        }\n        Ok(to)\n    }\n}\n\n#[test]\nfn username_with_password() {\n    let s = \"taos://\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos:///\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos://\");\n\n    let s = \"taos://root@\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n    let s = \"taos://root:taosdata@\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn host_port_mix() {\n    let s = \"taos://localhost\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@localhost:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n#[test]\nfn username_with_host() {\n    let s = \"taos://root@localhost\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@localhost:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address::new(\"localhost\", 6030)],\n            ..Default::default()\n        }\n    );\n\n    let s = \"taos://root:taosdata@localhost:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            addresses: vec![Address::new(\"localhost\", 6030)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn username_with_multi_addresses() {\n    let s = \"taos://root@host1.domain:6030,host2.domain:6031\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![\n                Address::new(\"host1.domain\", 6030),\n                Address::new(\"host2.domain\", 6031)\n            ],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root:taosdata@host1:6030,host2:6031\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn db_only() {\n    let s = \"taos:///db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            database: Some(\"db1\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos:///db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            database: Some(\"db1\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn username_with_multi_addresses_database() {\n    let s = \"taos://root@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root:taosdata@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            database: Some(\"db1\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn protocol() {\n    let s = \"taos://root@tcp(host1:6030,host2:6031)/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            protocol: Some(\"tcp\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos+tcp://root@host1:6030,host2:6031/db1\");\n\n    let s = \"taos+tcp://root@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            protocol: Some(\"tcp\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos+tcp://root@host1:6030,host2:6031/db1\");\n}\n\n#[test]\nfn fragment() {\n    let s = \"postgresql://%2Fvar%2Flib%2Fpostgresql/dbname\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"postgresql\".to_string(),\n            database: Some(\"dbname\".to_string()),\n            addresses: vec![Address {\n                path: Some(\"/var/lib/postgresql\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"unix:///path/to/unix.sock\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"unix\".to_string(),\n            fragment: Some(\"/path/to/unix.sock\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite:///c:/full/windows/path/to/file.db\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            fragment: Some(\"/c:/full/windows/path/to/file.db\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite://./file.db\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            fragment: Some(\"./file.db\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite://root:pass@/full/unix/path/to/file.db?mode=0666\u0026readonly=true\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"pass\".to_string()),\n            fragment: Some(\"/full/unix/path/to/file.db\".to_string()),\n            params: BTreeMap::from_iter(vec![\n                (\"mode\".to_string(), \"0666\".to_string()),\n                (\"readonly\".to_string(), \"true\".to_string())\n            ]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn params() {\n    let s = r#\"taos://?abc=abc\"#;\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            params: BTreeMap::from_iter(vec![(\"abc\".to_string(), \"abc\".to_string())]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = r#\"taos://root@localhost?abc=abc\"#;\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address::from_host(\"localhost\")],\n            params: BTreeMap::from_iter(vec![(\"abc\".to_string(), \"abc\".to_string())]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn parse_taos_tmq() {\n    let s = \"taos://root:taosdata@localhost/aa23d04011eca42cf7d8c1dd05a37985?topics=aa23d04011eca42cf7d8c1dd05a37985\u0026group.id=tg2\";\n    let _ = Dsn::from_str(\u0026s).unwrap();\n\n}\n","traces":[{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[14154192],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":139,"address":[14154206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[14154320,14156495,14155802],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":147,"address":[14154350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[14154371,14154838,14154768,14154463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[14154912,14156079,14155033,14156364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[14155233,14155304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[14156178,14155388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[14155420,14155845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[14155625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[14155452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[14156425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[14157899,14156512],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":170,"address":[14156546,14156683,14156726,14157213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[14157055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[14156794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[14157299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[14157468,14157701,14157929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[14157455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[14157952],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":212,"address":[14157973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[14125919,14125808],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":218,"address":[14125833,14125896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[14125952],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":224,"address":[14125984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[14158000],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":230,"address":[14158024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[14158096],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":235,"address":[14158113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[14158192,14160224],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":241,"address":[14158231,14158456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[14158417,14158506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[14158514,14158604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[14158783,14158546,14158923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[14158870,14158950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[14159374,14159062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[14159011,14159417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[14159590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[14159832,14159352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[14160254,14160026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[14159905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[14159846,14160335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[14160343,14160430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[14160600,14160377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[14160608,14160674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[14160843,14160642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[14160947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[14160870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[14267177,14267136],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":275,"address":[14160849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[8222944,8222848],"length":1,"stats":{"Line":1},"fn_name":"parse\u003c\u0026str\u003e"},{"line":283,"address":[8222872,8222931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[14161232],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":291,"address":[14161253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[14161280],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":299,"address":[14161312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[14161471,14161360],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":307,"address":[14161385,14161448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[14161504],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":315,"address":[14161528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[14161600,14162117],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":322,"address":[14162143,14162015,14161651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[14162175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[14169590,14169558,14162220,14162328,14166837],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[14162539,14162613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[14168724,14162718,14169526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[14168927,14168998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[14169072,14169372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[14169104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[14167858,14168692,14162788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[14168132,14168061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[14168206,14168506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[14168238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[14162896,14166810,14167602,14164653,14167570],"length":1,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[14164864,14164938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[14166783,14167256,14167317,14165056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[14165408,14165334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[14165437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[14167120,14165601,14165477,14166694],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[14165881,14165804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[14165977,14166918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[14166455,14166639,14166015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[14166224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[14166053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[14167125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[14167384,14165018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[14163237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[14162995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[14167853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[14162858,14167672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[14163242,14162966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[14163564,14163456,14164402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[14163844,14163767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[14164232,14163924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[14163962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[14164434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[14169636],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":104},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","metrics.rs"],"content":"use std::{thread, time};\n\nuse anyhow::Result;\nuse taosx::metrics::*;\n\nfn main() -\u003e Result\u003c()\u003e {\n    Metrics::default().init().unwrap();\n\n    loop {\n        thread::sleep(time::Duration::from_secs(1));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","backup.rs"],"content":"use clap::Args;\nuse futures::Future;\nuse parquet::{basic::Compression, schema::types::Type};\nuse std::{\n    fmt::Debug,\n    fs::{self, File},\n    io::Write,\n    path::PathBuf,\n    sync::Arc,\n};\nuse taos::prelude::*;\nuse taos::TaosOptions;\n\nuse taosx::{Database, TaosOpts};\nuse thread_id;\nuse tokio::runtime::Builder;\n\nuse crate::commands::backup::{\n    fetch::{fetch_database_info, fetch_table_list},\n    schema::TaosParquetSchema,\n};\n\nuse self::{fetch::fetch_stable_tag_buffer, serialize::Serialize};\n\nmod fetch;\nmod schema;\nmod serialize;\n\n#[derive(Debug, Args, Clone)]\n/// Backup database or tables to specific files.\n///\n/// Basically, an alternative command to `taosdump`.\npub(crate) struct App {\n    #[clap(short, long)]\n    database: Option\u003cString\u003e,\n    #[clap(short, long)]\n    output: Option\u003cString\u003e,\n    #[clap(short, long)]\n    thread: Option\u003cu32\u003e,\n}\n\nfn allocate_task\u003cFut: 'static\u003e(\n    table_list: Vec\u003cString\u003e,\n    schema: Arc\u003cType\u003e,\n    dir: PathBuf,\n    path: \u0026str,\n    mut threads: u32,\n    db: String,\n    f: impl Fn(Arc\u003cType\u003e, Vec\u003cString\u003e, PathBuf, String) -\u003e Fut,\n) where\n    Fut: Future\u003cOutput = ()\u003e + std::marker::Send,\n{\n    let mut own_path = dir;\n    own_path.push(path);\n    fs::create_dir(own_path.clone()).unwrap_or_else(|_| {\n        fs::remove_dir_all(own_path.clone()).unwrap_or_else(|_| {\n            fs::remove_dir(own_path.clone()).unwrap();\n        });\n        fs::create_dir(own_path.clone()).unwrap();\n    });\n    if threads \u003e table_list.len() as _ {\n        threads = table_list.len() as _;\n    }\n    let tables_per_thread = if table_list.len() as u32 % threads == 0 {\n        table_list.len() as u32 / threads\n    } else {\n        table_list.len() as u32 / threads + 1\n    };\n\n    let mut handles = Vec::with_capacity(threads as _);\n    let chunks: Vec\u003c\u0026[String]\u003e = table_list.chunks(tables_per_thread as _).collect();\n    threads = chunks.len() as _;\n\n    log::info!(\n        \"{} threads each deal at most {} tables\",\n        threads,\n        tables_per_thread\n    );\n\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(threads as usize)\n        .enable_all()\n        .build()\n        .unwrap();\n\n    for chunk in chunks {\n        handles.push(runtime.spawn(f(\n            schema.clone(),\n            chunk.to_owned(),\n            own_path.clone(),\n            db.clone(),\n        )));\n    }\n    for handle in handles {\n        runtime.block_on(handle).unwrap();\n    }\n}\n\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        log::info!(\"prepare config options\");\n\n        let database = self.database.as_deref().unwrap_or(\"test\");\n        let db = String::from(database);\n        let threads = self.thread.unwrap_or(1);\n        let output = self.output.as_deref().unwrap_or(\"./\");\n        let path = PathBuf::from(output);\n\n        log::info!(\"prepare parquet schema\");\n\n        let schema = TaosParquetSchema::default().build();\n\n        log::info!(\"start backup database info\");\n\n        let database = fetch_database_info(db.clone());\n\n        backup_database(database, path.clone());\n\n        log::info!(\"finish backup database info\");\n\n        let (select_list, describe_list, stable_list) = fetch_table_list(db.clone());\n\n        log::info!(\n            \"select list: {:?}; describe list {:?}; stable_list{:?}\",\n            select_list,\n            describe_list,\n            stable_list\n        );\n\n        log::info!(\"start backup table meta info\");\n        allocate_task(\n            describe_list,\n            schema.clone(),\n            path.clone(),\n            \"table.info\",\n            threads,\n            db.clone(),\n            backup_table_schema,\n        );\n        log::info!(\"finish backup table meta info\");\n        log::info!(\"start backup table tags\");\n        allocate_task(\n            stable_list,\n            schema.clone(),\n            path.clone(),\n            \"tags\",\n            threads,\n            db.clone(),\n            backup_stable_tags,\n        );\n        log::info!(\"finish backup table tags\");\n        log::info!(\"start backup data\");\n        allocate_task(select_list, schema, path, \"chunk\", threads, db, backup_data);\n        log::info!(\"finish backup data\");\n    }\n}\n\nfn backup_database(database: Database, mut path: PathBuf) {\n    path.push(\"db.info\");\n    let mut file = File::create(path.as_path()).unwrap();\n    let j = serde_json::to_string_pretty(\u0026database).unwrap();\n    file.write_all(j.as_bytes()).unwrap();\n}\n\nasync fn backup_table_schema(\n    schema: Arc\u003cType\u003e,\n    table_list: Vec\u003cString\u003e,\n    mut path: PathBuf,\n    db: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let taos = TaosOptions::new().database(db.clone()).build().unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    for tbname in table_list {\n        let describe = taos.describe(\u0026tbname).await.unwrap();\n        serialize.serialze_table_meta(\u0026tbname, describe);\n    }\n}\n\nasync fn backup_stable_tags(\n    schema: Arc\u003cType\u003e,\n    table_list: Vec\u003cString\u003e,\n    mut path: PathBuf,\n    database: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    for tbname in table_list {\n        let tag_buffer = fetch_stable_tag_buffer(database.clone(), tbname.clone()).await;\n        let mut res = taos\n            .query(format!(\"select tbname{} from {}\", tag_buffer, tbname).as_str())\n            .await\n            .unwrap();\n        let stream = res.block_stream();\n        serialize.serialize_tag(\u0026tbname, stream).await;\n    }\n}\n\nasync fn backup_data(\n    schema: Arc\u003cType\u003e,\n    tbname_list: Vec\u003cString\u003e,\n    mut path: PathBuf,\n    database: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let taos = TaosOptions::new().database(database).build().unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    for tbname in tbname_list {\n        let mut res = taos\n            .query(format!(\"select * from {}\", tbname).as_str())\n            .await\n            .unwrap();\n        let stream = res.block_stream();\n        serialize.serialize_data(\u0026tbname, stream).await;\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","backup_parquet.rs"],"content":"use libtaos::Taos;\nuse parquet::{\n    basic::{\n        Compression, ConvertedType, LogicalType, Repetition, TimeUnit, TimestampType,\n        Type as PhysicalType,\n    },\n    file::{\n        properties::WriterProperties,\n        writer::{FileWriter, SerializedFileWriter},\n    },\n    schema::types::Type,\n};\nuse std::{fs, path::PathBuf, sync::Arc};\nuse taos::r2d2::TaosPool;\nuse taos::BlockExt;\n\npub async fn generate_parquet_schema(taos: \u0026Taos, db: String, stb: \u0026str) -\u003e Arc\u003cType\u003e {\n    let mut fields = vec![];\n    taos.use_database(\u0026db).await.unwrap();\n    let res = taos.describe(stb).await.unwrap();\n    for i in 0..res.cols.len() {\n        match res.cols[i].type_ {\n            libtaos::TaosDataType::Null =\u003e todo!(),\n            libtaos::TaosDataType::Bool =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::BOOLEAN)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::TinyInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::INT_8)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::SmallInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::INT_16)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Int =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::BigInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Float =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::FLOAT)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Double =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::DOUBLE)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Binary =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::BYTE_ARRAY)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Timestamp =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_logical_type(Some(LogicalType::TIMESTAMP(TimestampType {\n                        is_adjusted_to_u_t_c: false,\n                        unit: TimeUnit::MILLIS(Default::default()),\n                    })))\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::NChar =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::BYTE_ARRAY)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_logical_type(Some(LogicalType::STRING(Default::default())))\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UTinyInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_8)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::USmallInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_16)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_32)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UBigInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_64)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Json =\u003e todo!(),\n            libtaos::TaosDataType::Unknown =\u003e todo!(),\n        }\n    }\n    Arc::new(\n        Type::group_type_builder(\"schema\")\n            .with_fields(\u0026mut fields)\n            .build()\n            .unwrap(),\n    )\n}\n\npub async fn backup_data_parquet(\n    pool: TaosPool,\n    db: String,\n    tb: String,\n    schema: Arc\u003cType\u003e,\n    target: PathBuf,\n) {\n    let props = Arc::new(\n        WriterProperties::builder()\n            .set_compression(Compression::SNAPPY)\n            .build(),\n    );\n    let mut path = target.clone();\n    path.push(format!(\"{}.parquet\", tb));\n    let file = fs::File::create(path).unwrap();\n    let mut writer = SerializedFileWriter::new(file, schema, props).unwrap();\n    let taos = pool.get().unwrap();\n    let res = taos\n        .query(format!(\"select * from {}.{} \", db, tb).as_str())\n        .await\n        .unwrap();\n    let stream = res.fetch_block_stream();\n    use futures::future;\n    use futures::stream::StreamExt;\n    stream\n        .enumerate()\n        .for_each(|(_, partial)| {\n            // log::debug!(\"num of row in block: {}\", partial.num_of_rows());\n            let mut row_group_writer = writer.next_row_group().unwrap();\n            for col in partial.columns_iter() {\n                let data_writer = row_group_writer.next_column().unwrap();\n                if let Some(mut writer) = data_writer {\n                    use taos::block::BorrowedColumn::*;\n                    match writer {\n                        parquet::column::writer::ColumnWriter::BoolColumnWriter(ref mut typed) =\u003e {\n                            match col {\n                                Bool(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                        }\n                        parquet::column::writer::ColumnWriter::Int32ColumnWriter(ref mut typed) =\u003e {\n                            // let values;\n                            match col {\n                                TinyInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                    // std::mem::transmute::\u003c*const i32\u003e(values.ptr()).\n\n                                    // values = values\n                                    //     .into_iter()\n                                    //     .map(|v| match v {\n                                    //         Some(u) =\u003e Some(u as i32),\n                                    //         None =\u003e None,\n                                    //     })\n                                    //     .collect::\u003cOption\u003cVec\u003ci32\u003e\u003e\u003e()\n                                    //     .unwrap()\n                                }\n                                SmallInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                Int(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                UTinyInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                USmallInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                UInt(is_nulls, values) =\u003e {\n                                    // let values: Vec\u003ci32\u003e = values.into_iter().map(|v| *v as _).collect();\n                                    let len = values.len();\n                                    let ptr: *mut i32 = values.as_ptr() as _;\n                                    let values = unsafe { std::slice::from_raw_parts(ptr, len) };\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n\n                                _ =\u003e unreachable!(),\n                            }\n                            // typed.write_batch(\u0026values, None, None).unwrap();\n                        }\n                        parquet::column::writer::ColumnWriter::Int64ColumnWriter(ref mut typed) =\u003e {\n                            // let values;\n                            match col {\n                                BigInt(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                UBigInt(is_nulls, values) =\u003e {\n                                    // let values: Vec\u003ci32\u003e = values.into_iter().map(|v| *v as _).collect();\n                                    let len = values.len();\n                                    let ptr: *mut i64 = values.as_ptr() as _;\n                                    let values = unsafe { std::slice::from_raw_parts(ptr, len) };\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                Timestamp(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                            // typed.write_batch(\u0026values, None, None).unwrap();\n                        }\n                        parquet::column::writer::ColumnWriter::FloatColumnWriter(ref mut typed) =\u003e {\n                            // let values;\n                            match col {\n                                Float(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                        }\n                        parquet::column::writer::ColumnWriter::DoubleColumnWriter(\n                            ref mut typed,\n                        ) =\u003e match col {\n                            Double(is_nulls, values) =\u003e {\n                                typed.write_batch(\u0026values, None, None).unwrap();\n                            }\n                            _ =\u003e unreachable!(),\n                        },\n                        parquet::column::writer::ColumnWriter::ByteArrayColumnWriter(\n                            ref mut typed,\n                        ) =\u003e {\n                            let mut values = vec![];\n                            match col {\n                                Binary(v) =\u003e {\n                                    for f in v.into_iter() {\n                                        match f {\n                                            Some(u) =\u003e values.push(\n                                                parquet::data_type::ByteArray::from(u.to_vec()),\n                                            ),\n                                            None =\u003e {\n                                                values.push(parquet::data_type::ByteArray::from(\"\"))\n                                            }\n                                        }\n                                    }\n                                }\n                                NChar(v) =\u003e {\n                                    for f in v.into_iter() {\n                                        match f {\n                                            Some(u) =\u003e values.push(\n                                                parquet::data_type::ByteArray::from(u),\n                                            ),\n                                            None =\u003e {\n                                                values.push(parquet::data_type::ByteArray::from(\"\"))\n                                            }\n                                        }\n                                    }\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                            typed.write_batch(\u0026values, None, None).unwrap();\n                        }\n                        _ =\u003e unreachable!(),\n                    }\n                    row_group_writer.close_column(writer).unwrap();\n                }\n            }\n            writer.close_row_group(row_group_writer).unwrap();\n            future::ready(())\n        })\n        .await;\n    writer.close().unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","fetch.rs"],"content":"use futures::TryStreamExt;\nuse taos::prelude::*;\nuse taosx::Database;\nuse tokio::runtime::Builder;\n#[derive(::serde::Deserialize, Debug)]\npub struct Table {\n    pub table_name: String,\n    pub stable_name: String,\n}\n\npub fn fetch_table_list(database: String) -\u003e (Vec\u003cString\u003e, Vec\u003cString\u003e, Vec\u003cString\u003e) {\n    let mut select_list = vec![];\n    let mut describe_list = vec![];\n    let mut stable_list = vec![];\n    let taos = TaosOptions::new().database(database).build().unwrap();\n    let tables: Vec\u003cTable\u003e = Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(\"show tables\")\n                .await\n                .unwrap()\n                .deserialize_stream()\n                .try_collect()\n                .await\n                .unwrap()\n        });\n    for table in tables {\n        select_list.push(table.table_name.clone());\n        if table.stable_name.is_empty() {\n            describe_list.push(table.table_name);\n        } else if !describe_list.contains(\u0026table.stable_name) {\n            stable_list.push(table.stable_name.clone());\n            describe_list.push(table.stable_name);\n        }\n    }\n    (select_list, describe_list, stable_list)\n}\n\npub fn fetch_database_info(database: String) -\u003e Database {\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    let dbs: Vec\u003cDatabase\u003e = Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(\"show databases\")\n                .await\n                .unwrap()\n                .deserialize_stream()\n                .try_collect()\n                .await\n                .unwrap()\n        });\n    for db in dbs {\n        if db.name == database {\n            return db;\n        }\n    }\n    panic!(\"cannot find database {}\", database);\n}\n\npub async fn fetch_stable_tag_buffer(database: String, stable: String) -\u003e String {\n    let mut tag_buffer = String::from(\"\");\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    let describe = taos\n        .describe(format!(\"{}.{}\", database.clone(), stable).as_str())\n        .await\n        .unwrap();\n    for col in describe {\n        if col.is_tag() {\n            tag_buffer += \",\";\n            tag_buffer += col.field();\n        }\n    }\n    tag_buffer\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","schema.rs"],"content":"use parquet::basic::{Repetition, Type as PhysicalType};\nuse parquet::schema::types::Type;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone, Default)]\npub struct TaosParquetSchema {\n    fields: Vec\u003cArc\u003cType\u003e\u003e,\n}\n\nimpl TaosParquetSchema {\n    fn add_required_byte_array_col(mut self, name: \u0026str) -\u003e Self {\n        self.fields.push(Arc::new(\n            Type::primitive_type_builder(name, PhysicalType::BYTE_ARRAY)\n                .with_repetition(Repetition::REQUIRED)\n                .build()\n                .unwrap(),\n        ));\n        self\n    }\n\n    fn add_group(mut self, group: Arc\u003cType\u003e) -\u003e Self {\n        self.fields.push(group);\n        self\n    }\n\n    fn build_repeated_group(mut self, name: \u0026str) -\u003e Arc\u003cType\u003e {\n        Arc::new(\n            Type::group_type_builder(name)\n                .with_fields(\u0026mut self.fields)\n                .with_repetition(Repetition::REPEATED)\n                .build()\n                .unwrap(),\n        )\n    }\n\n    fn build_schema(mut self, name: \u0026str) -\u003e Arc\u003cType\u003e {\n        Arc::new(\n            Type::group_type_builder(name)\n                .with_fields(\u0026mut self.fields)\n                .build()\n                .unwrap(),\n        )\n    }\n\n    pub fn build(self) -\u003e Arc\u003cType\u003e {\n        self.add_group(\n            TaosParquetSchema::default()\n                .add_required_byte_array_col(\"data\")\n                .build_repeated_group(\"table_info\"),\n        )\n        .build_schema(\"table\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","serialize.rs"],"content":"use std::{fmt::Debug, sync::Arc};\n\nuse futures::{future, StreamExt};\nuse parquet::{\n    basic::Compression,\n    column::writer::*,\n    data_type::{ByteArray, ByteArrayType},\n    file::{\n        properties::WriterProperties,\n        writer::{FileWriter, ParquetWriter, SerializedFileWriter},\n    },\n    schema::types::Type,\n};\n\nuse taos::{\n    block::{BlockStream, Describe},\n    helpers::ColumnMeta,\n    prelude::BlockExt,\n};\nuse taosx::{TaosBlock, TaosDescribe, TaosTag};\n\npub struct Serialize\u003cW: ParquetWriter + 'static\u003e {\n    writer: SerializedFileWriter\u003cW\u003e,\n}\n\nimpl\u003cW: ParquetWriter + 'static\u003e Serialize\u003cW\u003e {\n    pub fn new(target: W, compression: Compression, schema: Arc\u003cType\u003e) -\u003e Self {\n        let props = Arc::new(\n            WriterProperties::builder()\n                .set_compression(compression)\n                .build(),\n        );\n        let writer = SerializedFileWriter::new(target, schema, props).unwrap();\n\n        Self { writer }\n    }\n\n    fn serialize\u003cT\u003e(\u0026mut self, source: T)\n    where\n        T: serde::Serialize + serde::de::DeserializeOwned + Debug,\n    {\n        let mut row_group = self.writer.next_row_group().unwrap();\n        let mut column_writer = row_group.next_column().unwrap().unwrap();\n        let typed = get_typed_column_writer_mut::\u003cByteArrayType\u003e(\u0026mut column_writer);\n        let encoded = bincode::serialize(\u0026source).unwrap();\n        typed\n            .write_batch(\u0026[ByteArray::from(encoded)], Some(\u0026[1]), Some(\u0026[0]))\n            .unwrap();\n        row_group.close_column(column_writer).unwrap();\n        self.writer.close_row_group(row_group).unwrap();\n    }\n\n    pub fn serialze_table_meta(\u0026mut self, name: \u0026str, describe: Describe) {\n        let taos_describe = TaosDescribe::new(name.to_string(), describe);\n        self.serialize(taos_describe);\n    }\n\n    pub async fn serialize_tag(\u0026mut self, name: \u0026str, stream: BlockStream) {\n        stream\n            .enumerate()\n            .for_each(|(_, block)| {\n                let taos_tags = TaosTag::new(name.to_string(), block.iter_rows());\n                self.serialize(taos_tags);\n                future::ready(())\n            })\n            .await;\n    }\n\n    pub async fn serialize_data(\u0026mut self, name: \u0026str, stream: BlockStream) {\n        stream\n            .enumerate()\n            .for_each(|(_, block)| {\n                let taos_block = TaosBlock::new(name.to_string(), block.columns_iter());\n                self.serialize(taos_block);\n                future::ready(())\n            })\n            .await;\n    }\n}\n\nimpl\u003cW: ParquetWriter + 'static\u003e Drop for Serialize\u003cW\u003e {\n    fn drop(\u0026mut self) {\n        self.writer.close().unwrap();\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","export.rs"],"content":"use clap::Args;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Export db or table to specific files.\npub(crate) struct App {\n    name: Option\u003cString\u003e,\n}\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        todo!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","import.rs"],"content":"use clap::Args;\nuse taos::query::Dsn;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Import external files to TDengine.\npub(crate) struct App {\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for source TDengine: taos:///db1, for eg.\n    from: Dsn,\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for target TDengine: taos:///db2, for eg.\n    to: Dsn,\n}\n\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        todo!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","mod.rs"],"content":"#[path = \"backup/backup.rs\"]\npub mod backup;\npub mod export;\npub mod import;\n#[path = \"restore/restore.rs\"]\npub mod restore;\n\npub mod sync;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","deserialize.rs"],"content":"use parquet::{\n    file::{reader::FileReader, serialized_reader::SerializedFileReader},\n    record::Field,\n};\nuse std::io::BufReader;\nuse std::{fs::File, path::PathBuf};\n\nuse taosx::Database;\n\npub fn deserialize_database(path: PathBuf) -\u003e Database {\n    let file = File::open(path).unwrap();\n    let reader = BufReader::new(file);\n    serde_json::from_reader(reader).unwrap()\n}\n\npub struct Deserialize\u003cT: serde::de::DeserializeOwned\u003e {\n    parquet_reader: SerializedFileReader\u003cFile\u003e,\n    pub output: Vec\u003cT\u003e,\n}\n\nimpl\u003cT: serde::de::DeserializeOwned\u003e Deserialize\u003cT\u003e {\n    pub fn new(source: String) -\u003e Self {\n        let parquet_reader = SerializedFileReader::try_from(source).unwrap();\n        let output: Vec\u003cT\u003e = Vec::new();\n        Self {\n            parquet_reader,\n            output,\n        }\n    }\n\n    pub async fn deserialize(\u0026mut self) {\n        let iter = self.parquet_reader.get_row_iter(None).unwrap();\n        for row in iter {\n            let (_, field) = row.get_column_iter().next().unwrap();\n            if let Field::ListInternal(list) = field {\n                for element in list.elements() {\n                    if let Field::Group(g) = element {\n                        let (_, fields) = g.get_column_iter().next().unwrap();\n                        if let Field::Bytes(b) = fields {\n                            self.output\n                                .push(bincode::deserialize::\u003cT\u003e(b.data()).unwrap());\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","restore.rs"],"content":"use clap::Args;\nuse futures::Future;\nuse std::path::PathBuf;\nuse tokio::runtime::Builder;\n\nuse taos::prelude::*;\nuse taosx::{TaosBlock, TaosDescribe, TaosOpts, TaosTag};\npub(crate) mod deserialize;\n\nuse self::deserialize::{deserialize_database, Deserialize};\n#[derive(Debug, Args)]\n/// Restore from a backup output directory.\n\npub(crate) struct App {\n    #[clap(short, long)]\n    database: Option\u003cString\u003e,\n    #[clap(short, long)]\n    input: Option\u003cString\u003e,\n    #[clap(short, long)]\n    thread: Option\u003cu32\u003e,\n}\n\nfn allocate_task\u003cFut: 'static\u003e(\n    db: String,\n    mut dir: PathBuf,\n    path: \u0026str,\n    mut threads: u32,\n    f: impl Fn(Vec\u003cString\u003e, String) -\u003e Fut,\n) where\n    Fut: Future\u003cOutput = ()\u003e + std::marker::Send,\n{\n    dir.push(path);\n    let mut filelist = vec![];\n    for element in dir.read_dir().unwrap() {\n        let filename = element.unwrap().path();\n        if let Some(extension) = filename.extension() {\n            if extension == \"parquet\" {\n                filelist.push(filename.to_str().unwrap().to_string());\n            }\n        }\n    }\n    if threads \u003e filelist.len() as _ {\n        threads = filelist.len() as _;\n    }\n    let file_per_threads = if filelist.len() as u32 % threads == 0 {\n        filelist.len() as u32 / threads\n    } else {\n        filelist.len() as u32 / threads + 1\n    };\n\n    let mut handles = Vec::with_capacity(threads as _);\n    let chunks: Vec\u003c\u0026[String]\u003e = filelist.chunks(file_per_threads as _).collect();\n    threads = chunks.len() as _;\n\n    log::info!(\n        \"{} threads each deal with at most {} files\",\n        threads,\n        file_per_threads\n    );\n\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(threads as usize)\n        .enable_all()\n        .build()\n        .unwrap();\n    for chunk in chunks {\n        handles.push(runtime.spawn(f(chunk.to_owned(), db.clone())))\n    }\n    for handle in handles {\n        runtime.block_on(handle).unwrap();\n    }\n}\n\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        let threads = self.thread.unwrap_or(1);\n        let input = self.input.as_deref().unwrap_or(\"./\");\n        let path = PathBuf::from(input);\n\n        let db = restore_database(path.clone());\n\n        allocate_task(\n            db.clone(),\n            path.clone(),\n            \"table.info\",\n            threads,\n            restore_table_info,\n        );\n\n        allocate_task(db.clone(), path.clone(), \"tags\", threads, restore_tags);\n\n        allocate_task(db, path, \"chunk\", threads, restore_data);\n    }\n}\n\nfn restore_database(mut path: PathBuf) -\u003e String {\n    path.push(\"db.info\");\n    let taos = TaosOptions::new().build().unwrap();\n    let database = deserialize_database(path);\n    Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(format!(\"create database if not exists {}\", database.name))\n                .await\n                .unwrap()\n        });\n\n    database.name\n}\n\nasync fn restore_table_info(filelist: Vec\u003cString\u003e, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::\u003cTaosDescribe\u003e::new(file);\n        deserialize.deserialize().await;\n        let describes = deserialize.output;\n        for describe in describes {\n            let mut col_buffer = String::from(\"\");\n            let mut tag_buffer = String::from(\"\");\n            for col in describe.describe {\n                match col {\n                    taosx::TaosColumnMeta::Column(des) =\u003e {\n                        if des.ty == Ty::VarChar || des.ty == Ty::NChar {\n                            col_buffer +=\n                                format!(\"{} {}({}),\", des.field.as_str(), des.ty, des.length)\n                                    .as_str();\n                        } else {\n                            col_buffer += format!(\"{} {},\", des.field.as_str(), des.ty,).as_str();\n                        }\n                    }\n                    taosx::TaosColumnMeta::Tag(des) =\u003e {\n                        if des.ty == Ty::VarChar || des.ty == Ty::NChar {\n                            tag_buffer +=\n                                format!(\"{} {}({}),\", des.field.as_str(), des.ty, des.length)\n                                    .as_str();\n                        } else {\n                            tag_buffer += format!(\"{} {},\", des.field.as_str(), des.ty,).as_str();\n                        }\n                    }\n                }\n            }\n            col_buffer.pop();\n            tag_buffer.pop();\n            let sql = format!(\n                \"create table {} ({}) tags ({})\",\n                describe.name, col_buffer, tag_buffer\n            );\n            taos.stmt(sql).unwrap().execute().unwrap();\n        }\n    }\n}\n\nasync fn restore_tags(filelist: Vec\u003cString\u003e, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::\u003cTaosTag\u003e::new(file);\n        deserialize.deserialize().await;\n        let taostags = deserialize.output;\n        for taostag in taostags {\n            let stbname = taostag.name;\n            for tag in taostag.tags {\n                let mut sql = String::new();\n                for (index, value) in tag.into_iter().enumerate() {\n                    if index == 0 {\n                        if let Value::VarChar(b) = value {\n                            sql = format!(\"create table {} using {} tags (\", b, \u0026stbname);\n                        }\n                    } else {\n                        match value {\n                            Value::Null =\u003e sql += \"NULL,\",\n                            Value::Bool(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::TinyInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::SmallInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Int(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::BigInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Float(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Double(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::VarChar(v) =\u003e {\n                                sql += format!(\"\\'{}\\',\", v).as_str();\n                            }\n                            Value::Timestamp(v) =\u003e sql += format!(\"{},\", v.as_raw_i64()).as_str(),\n                            Value::NChar(v) =\u003e sql += format!(\"\\'{}\\',\", v).as_str(),\n                            Value::UTinyInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::USmallInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::UInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::UBigInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Json(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            _ =\u003e todo!(),\n                        }\n                    }\n                }\n                sql.pop();\n                sql += \")\";\n                taos.stmt(sql).unwrap().execute().unwrap();\n            }\n        }\n    }\n}\n\nasync fn restore_data(filelist: Vec\u003cString\u003e, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::\u003cTaosBlock\u003e::new(file);\n        deserialize.deserialize().await;\n        let taos_blocks = deserialize.output;\n        for taos_block in taos_blocks {\n            let col_num = taos_block.data.len();\n            let mut prepare = format!(\"insert into {} values (\", taos_block.name);\n            for _ in 0..col_num {\n                prepare += \"?,\";\n            }\n            prepare.pop();\n            prepare += \")\";\n            let mut stmt = taos.stmt(prepare).expect(\"prepare\");\n            let col_vec = taos_block.to_column_vec();\n            let bind: Vec\u003c_\u003e = col_vec.iter().map(|v| v.into()).collect();\n            stmt.multi_bind(\u0026bind).expect(\"bind erro\");\n            stmt.execute().expect(\"execute error\");\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","restore_parquet.rs"],"content":"use bitvec_simd::BitVec;\nuse glob::glob;\nuse parquet::basic::ConvertedType;\nuse parquet::column::reader::{ColumnReader, ColumnReaderImpl};\nuse parquet::data_type::{ByteArray, ByteArrayType, DataType};\nuse parquet::file::reader::FileReader;\nuse parquet::file::serialized_reader::SerializedFileReader;\nuse std::path::PathBuf;\n// use taos::block::serde::Block;\n// use taos::block::Block;\nuse taos::block::Column as Block;\nuse taos::r2d2::TaosPool;\n\npub fn get_parquet_files\u003c'a\u003e(path: PathBuf) -\u003e Vec\u003cString\u003e {\n    let mut file_list = vec![];\n    let paths = glob(format!(\"{}/*.parquet\", path.as_os_str().to_str().unwrap()).as_str()).unwrap();\n    for entry in paths {\n        match entry {\n            Ok(path) =\u003e {\n                let filename = path.to_str().unwrap().split(\"/\").last().unwrap();\n                file_list.push(filename.to_string())\n            }\n            Err(e) =\u003e println!(\"{:?}\", e),\n        }\n    }\n    file_list\n}\n\nfn read\u003cT\u003e(mut column_reader: ColumnReaderImpl\u003cT\u003e, num_rows: usize) -\u003e Vec\u003cT::T\u003e\nwhere\n    T: DataType,\n    T::T: Default + Copy,\n{\n    let mut data = vec![];\n    const BATCH_SIZE: usize = 100;\n    let mut values = [T::T::default(); BATCH_SIZE];\n    for _ in 0..(num_rows + BATCH_SIZE - 1) / BATCH_SIZE {\n        let (num, _) = column_reader\n            .read_batch(BATCH_SIZE, None, None, \u0026mut values)\n            .unwrap();\n        data.extend(\u0026values[0..num]);\n    }\n    data\n}\n\nfn read_str(mut column_reader: ColumnReaderImpl\u003cByteArrayType\u003e, num_rows: usize) -\u003e Vec\u003cByteArray\u003e {\n    let mut data = vec![];\n    const BATCH_SIZE: usize = 10;\n    for _ in 0..(num_rows + BATCH_SIZE - 1 / BATCH_SIZE) {\n        let mut values = vec![];\n        for _ in 0..BATCH_SIZE {\n            values.push(ByteArray::new());\n        }\n        column_reader\n            .read_batch(BATCH_SIZE, None, None, \u0026mut values)\n            .unwrap();\n        data.extend(values);\n    }\n    let _ = data.split_off(num_rows);\n    log::debug!(\"data: {:?}\", data);\n    data\n}\n\npub async fn restore_parquet(pool: TaosPool, path: PathBuf, filename: String, database: String) {\n    let taos = pool.get().unwrap();\n    taos.query(format!(\"use {}\", database)).await.unwrap();\n    let tb = filename.split(\".\").next().unwrap();\n    let parquet_reader =\n        SerializedFileReader::try_from(format!(\"{}/{}.parquet\", path.to_str().unwrap(), tb))\n            .unwrap();\n    let read_schema = parquet_reader.metadata().file_metadata().schema();\n    let mut sql = format!(\"insert into {} values(\", tb);\n    let fields = read_schema.get_fields();\n    let column_num = fields.len();\n    for i in 0..column_num {\n        if i != column_num - 1 {\n            sql += \"?,\";\n        } else {\n            sql += \"?)\";\n        }\n    }\n\n    for row_group in 0..parquet_reader.num_row_groups() {\n        let row_group_reader = parquet_reader.get_row_group(row_group).unwrap();\n        let blocks: Vec\u003c_\u003e = (0..row_group_reader.num_columns())\n            .map(|col_num| {\n                let col_reader = row_group_reader.get_column_reader(col_num).unwrap();\n                let row_num = row_group_reader.metadata().num_rows() as usize;\n                let nulls = BitVec::zeros(row_num);\n\n                match col_reader {\n                    ColumnReader::BoolColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        Block::Bool(nulls, column)\n                    }\n                    ColumnReader::ByteArrayColumnReader(v) =\u003e {\n                        let column = read_str(v, row_num);\n                        match fields.get(col_num).unwrap().get_basic_info().logical_type() {\n                            Some(_) =\u003e Block::NChar(\n                                column\n                                    .into_iter()\n                                    .map(|v| {\n                                        Some(std::str::from_utf8(v.data()).unwrap().to_string())\n                                    })\n                                    .collect(),\n                            ),\n                            None =\u003e Block::Binary(\n                                column\n                                    .into_iter()\n                                    .map(|v| Some(v.data().to_vec()))\n                                    .collect::\u003cVec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e\u003e()\n                                    .to_vec(),\n                            ),\n                        }\n                    }\n                    ColumnReader::DoubleColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        Block::Double(nulls, column)\n                    }\n                    ColumnReader::FloatColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        Block::Float(nulls, column)\n                    }\n                    ColumnReader::Int32ColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n\n                        let values = match fields\n                            .get(col_num)\n                            .unwrap()\n                            .get_basic_info()\n                            .converted_type()\n                        {\n                            ConvertedType::UINT_8 =\u003e Block::UTinyInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u8).collect::\u003cVec\u003cu8\u003e\u003e(),\n                            ),\n                            ConvertedType::UINT_16 =\u003e Block::USmallInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u16).collect::\u003cVec\u003cu16\u003e\u003e(),\n                            ),\n                            ConvertedType::UINT_32 =\u003e Block::UInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u32).collect::\u003cVec\u003cu32\u003e\u003e(),\n                            ),\n                            ConvertedType::INT_8 =\u003e Block::TinyInt(\n                                nulls,\n                                column.into_iter().map(|v| v as i8).collect::\u003cVec\u003ci8\u003e\u003e(),\n                            ),\n                            ConvertedType::INT_16 =\u003e Block::SmallInt(\n                                nulls,\n                                column.into_iter().map(|v| v as i16).collect::\u003cVec\u003ci16\u003e\u003e(),\n                            ),\n                            ConvertedType::NONE =\u003e Block::Int(nulls, column),\n                            _ =\u003e unreachable!(),\n                        };\n                        values\n                    }\n                    ColumnReader::Int64ColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        match fields.get(col_num).unwrap().get_basic_info().logical_type() {\n                            Some(_) =\u003e Block::Timestamp(nulls, column),\n                            None =\u003e match fields\n                                .get(col_num)\n                                .unwrap()\n                                .get_basic_info()\n                                .converted_type()\n                            {\n                                ConvertedType::NONE =\u003e Block::BigInt(nulls, column),\n                                ConvertedType::UINT_64 =\u003e Block::UBigInt(\n                                    nulls,\n                                    column.into_iter().map(|v| v as u64).collect::\u003cVec\u003cu64\u003e\u003e(),\n                                ),\n                                _ =\u003e unreachable!(),\n                            },\n                        }\n                    }\n                    _ =\u003e unreachable!(),\n                }\n            })\n            .collect();\n\n        let bind: Vec\u003c_\u003e = blocks.iter().map(|b| b.into()).collect();\n        let mut stmt = taos.stmt(\u0026sql).unwrap();\n        stmt.multi_bind(\u0026bind).unwrap();\n        stmt.execute().unwrap();\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","sync","mod.rs"],"content":"use anyhow::Result;\nuse clap::Args;\nuse futures::prelude::*;\nuse taos::query::Dsn;\nuse taosx::plugins::sink::taos::TaosSinkBuilder;\nuse taosx::plugins::source::taos::TaosSourceBuilder;\nuse taosx::stream::source::XSourceBuilder;\nuse taosx::stream::stream::XSinkBuilder;\n\nuse taosx::stream::transformer::Action;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Import external files to TDengine.\npub(crate) struct App {\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for source TDengine: taos:///db1, for eg.\n    from: Dsn,\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for target TDengine: taos:///db2, for eg.\n    to: Dsn,\n\n    /// Transformer actions.\n    ///\n    /// Supported action format:\n    ///\n    /// - 'add-tag:tag1=value1': add a tag named `tag1`, and valued `value1`.\n    /// - 'select:subset:a,b,c': select three columns: `a`, `b`, `c`\n    /// - 'select:exclude:a,b,c': select all columns except the three: `a`, `b`, `c`\n    /// - 'rename-table:prefix:v1_': rename all tables as `v1_{{ name }}`\n    /// - 'rename-super-table:suffix:_stb': rename all super tables as suffixed '_stb'\n    /// - 'rename-child-stable:template:prefix_{{ name }}_stb': rename all super tables with prefix 'prefix_' and suffix '_stb'\n    #[clap(short = 'T', long)]\n    transform: Vec\u003cAction\u003e,\n    /// Number of workers for TMQ consumers.\n    #[clap(short = 'j', long)]\n    workers: Option\u003cusize\u003e,\n}\n\nimpl App {\n    pub async fn run_with_taos_opts(self, _opts: \u0026TaosOpts) -\u003e Result\u003c()\u003e {\n        log::debug!(\"app: {self:?}\");\n\n        let mut source_builder = TaosSourceBuilder::from_dsn(self.from)?;\n        let max_workers = source_builder.max_workers();\n\n        let sink_builder = TaosSinkBuilder::from_dsn(self.to)?.with_transformer(self.transform);\n\n        let mut workers = self.workers.unwrap_or(max_workers);\n        if max_workers != 0 \u0026\u0026 workers \u003e max_workers {\n            log::warn!(\"maximum workers for the stream is {max_workers} while you want {workers}, reduce to limit\");\n            workers = max_workers;\n        }\n        if workers == 0 {\n            workers = 1;\n        }\n        let mut handlers = Vec::new();\n        log::info!(\"use {workers} workers (max: {max_workers})\");\n\n        for _ in 0..workers {\n            let source = source_builder.build_source()?;\n            let sink = sink_builder.build_sink()?;\n            handlers.push(tokio::spawn(async move { source.forward(sink).await }));\n        }\n\n        for hd in handlers {\n            hd.await??;\n        }\n\n        let summary = sink_builder.summary();\n\n        log::info!(\n            \"Summary: total synced {} blocks with {} rows\",\n            summary.blocks(),\n            summary.rows()\n        );\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","main.rs"],"content":"mod commands;\nuse clap::{Parser, Subcommand};\nuse log::Level;\nuse pretty_env_logger::env_logger::fmt::Color;\nuse std::io::prelude::*;\nuse taosx::TaosOpts;\n\n#[derive(Parser, Debug)]\n#[clap(author, version, about)]\nstruct Cli {\n    #[clap(flatten)]\n    options: TaosOpts,\n    #[clap(short, long)]\n    log_level: Option\u003clog::LevelFilter\u003e,\n    #[clap(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    Export(commands::export::App),\n    Import(commands::import::App),\n    Backup(commands::backup::App),\n    Restore(commands::restore::App),\n    Sync(commands::sync::App),\n    #[clap(external_subcommand)]\n    External(Vec\u003cString\u003e),\n}\n\npub fn cli\u003c'help\u003e() -\u003e clap::Command\u003c'help\u003e {\n    clap::Command::new(\"taosx\")\n}\n\n#[tokio::main(flavor = \"multi_thread\", worker_threads = 10)]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    let mut builder = pretty_env_logger::formatted_timed_builder();\n    if let Some(level) = cli.log_level {\n        builder.filter_level(level);\n    } else if let Ok(s) = ::std::env::var(\"RUST_LOG\") {\n        builder.parse_filters(\u0026s);\n    } else {\n        builder.filter_level(log::LevelFilter::Info);\n    }\n    builder\n        .format_module_path(true)\n        .format(|buf, record| -\u003e std::result::Result\u003c(), std::io::Error\u003e {\n            fn colored_level\u003c'a\u003e(\n                style: \u0026'a mut pretty_env_logger::env_logger::fmt::Style,\n                level: Level,\n            ) -\u003e pretty_env_logger::env_logger::fmt::StyledValue\u003c'a, \u0026'static str\u003e {\n                match level {\n                    Level::Trace =\u003e style.set_color(Color::Magenta).value(\"TRACE\"),\n                    Level::Debug =\u003e style.set_color(Color::Blue).value(\"DEBUG\"),\n                    Level::Info =\u003e style.set_color(Color::Green).value(\"INFO\"),\n                    Level::Warn =\u003e style.set_color(Color::Yellow).value(\"WARN \"),\n                    Level::Error =\u003e style.set_color(Color::Red).value(\"ERROR\"),\n                }\n            }\n            let mut style = buf.style();\n            let level = colored_level(\u0026mut style, record.level());\n            let mut mod_path = buf.style();\n\n            let mod_path = mod_path.set_bold(true).value(format!(\n                \"{}:{}\",\n                record.file().unwrap_or(\"unknown\"),\n                record.line().unwrap_or(0),\n            ));\n            writeln!(\n                buf,\n                \"[{:29} {: \u003c5}] {} \u003e {}\",\n                chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                level,\n                mod_path,\n                record.args()\n            )\n        })\n        // .is_test(true)\n        .init();\n    let command = cli.command;\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match command {\n        Commands::Export(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Import(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Backup(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Restore(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Sync(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options).await?;\n        }\n\n        Commands::External(args) =\u003e {\n            let (name, args) = args.split_first().unwrap();\n            println!(\"Call external plugin taosx-{name}: {args:?}\");\n            let cmd = format!(\"taosx-{name}\");\n            std::process::Command::new(\u0026cmd)\n                .args(args)\n                .spawn()\n                .expect(\u0026format!(\"unable to run command {cmd}\"));\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","config","mod.rs"],"content":"use anyhow::Result;\nuse linked_hash_map::LinkedHashMap as HashMap;\nuse mdsn::Dsn;\nuse serde::{Deserialize, Serialize};\n\npub struct XSource {\n    plugin: String,\n    dsn: Dsn,\n    options: HashMap\u003cString, String\u003e,\n}\n\npub struct XTransformer {\n    pub name: String,\n    pub options: HashMap\u003cString, String\u003e,\n}\n\npub struct XSink {\n    dsn: Dsn,\n    options: HashMap\u003cString, String\u003e,\n}\npub struct XStream {\n    pub from: Vec\u003cXSource\u003e,\n    pub transformer: Vec\u003cXTransformer\u003e,\n    pub to: Vec\u003cXSink\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use anyhow::Result;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","lib.rs"],"content":"use bitvec_simd::BitVec;\nuse chrono_tz::Tz;\nuse clap::Args;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse taos::prelude::*;\nuse taos::{block::*, helpers::ColumnMeta};\n\nuse url::Url;\n\npub mod config;\npub mod metrics;\npub mod plugins;\npub mod stream;\npub mod task;\npub mod util;\n\n#[derive(Debug, Args)]\npub struct TaosUri {\n    pub uri: Url,\n}\n#[derive(Debug, Args)]\npub struct TaosOpts {\n    /// TDengine host\n    #[clap(short, long, env = \"TAOS_HOST\", group = \"taos-opts\")]\n    pub host: Option\u003cString\u003e,\n    /// TDengine port\n    #[clap(short, long, env = \"TAOS_PORT\", group = \"taos-opts\")]\n    pub port: Option\u003cu16\u003e,\n    /// TDengine username\n    #[clap(short, long, env = \"TAOS_USERNAME\", group = \"taos-opts\")]\n    pub username: Option\u003cString\u003e,\n    /// TDengine password for the user\n    #[clap(short = 'P', long, env = \"TAOS_PASSWORD\", group = \"taos-opts\")]\n    pub password: Option\u003cString\u003e,\n    /// Choose database for the connection\n    #[clap(short, long, env = \"TAOS_DATABASE\", group = \"taos-opts\")]\n    pub database: Option\u003cString\u003e,\n    #[clap(short, long, env = \"TZ\")]\n    /// Timezone, example: Asia/Shanghai\n    pub timezone: Option\u003cTz\u003e,\n    #[clap(short, long, env = \"TAOS_CFG_DIR\")]\n    /// TDengine config directory\n    pub cfg_dir: Option\u003cPathBuf\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Database {\n    pub name: String,\n    pub replica: i16,\n    pub quorum: i16,\n    pub days: i16,\n    pub keep: Option\u003cString\u003e,\n    // pub cache: i32,\n    pub blocks: i32,\n    pub minrows: i32,\n    pub maxrows: i32,\n    pub wallevel: i8,\n    pub fsync: i32,\n    pub comp: i8,\n    pub cachelast: i8,\n    pub precision: String,\n    pub update: i8,\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct TaosDescribe {\n    pub name: String,\n    pub describe: Describe,\n}\n\npub type TaosColumnMeta = ColumnMeta;\nimpl TaosDescribe {\n    pub fn new(name: String, describe: Describe) -\u003e Self {\n        Self { name, describe }\n    }\n}\n\n// #[derive(Debug, Deserialize, Serialize, Clone)]\n// pub enum TaosColumnMeta {\n//     Column(TaosDescribed),\n//     Tag(TaosDescribed),\n// }\n\n// #[derive(Debug, Deserialize, Serialize, Clone)]\n// pub struct TaosDescribed {\n//     pub field: String,\n//     pub r#type: TaosDataType,\n//     pub length: usize,\n// }\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct TaosTag {\n    pub name: String,\n    pub tags: Vec\u003cVec\u003cValue\u003e\u003e,\n}\n\nimpl TaosTag {\n    pub fn new\u003c'b, T: BlockExt\u003e(name: String, iter: taos::query::RowsIter\u003c'b, T\u003e) -\u003e Self {\n        let mut values = vec![];\n        for row in iter {\n            let mut tmp = vec![];\n            for bv in row {\n                tmp.push(bv.1.into_value());\n            }\n            values.push(tmp);\n        }\n        Self { name, tags: values }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct TaosBlock {\n    pub name: String,\n    pub data: Vec\u003cTaosColumn\u003e,\n}\n\nimpl TaosBlock {\n    pub fn new\u003c'b\u003e(name: String, iter: impl Iterator\u003cItem = BorrowedColumn\u003c'b\u003e\u003e) -\u003e Self {\n        let mut data = vec![];\n        for col in iter {\n            data.push(TaosColumn::new(col.into_owned()));\n        }\n        Self { name, data }\n    }\n\n    pub fn to_column_vec(\u0026self) -\u003e Vec\u003cColumn\u003e {\n        self.data.to_vec().iter().map(|v| v.to_column()).collect()\n    }\n\n    // pub fn to_multi_bind(\u0026self) -\u003e Vec\u003cMultiBind\u003e {\n    //     self.data\n    //         .to_vec()\n    //         .iter()\n    //         .map(|v| v.to_column().to_multi_bind())\n    //         .collect()\n    // }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n\npub enum TaosColumn {\n    Null(usize),\n    Bool(Vec\u003cbool\u003e, Vec\u003cbool\u003e),  // 1\n    TinyInt(Vec\u003cbool\u003e, Vec\u003ci8\u003e), // 2\n    SmallInt(Vec\u003cbool\u003e, Vec\u003ci16\u003e),\n    Int(Vec\u003cbool\u003e, Vec\u003ci32\u003e),\n    BigInt(Vec\u003cbool\u003e, Vec\u003ci64\u003e),\n    Float(Vec\u003cbool\u003e, Vec\u003cf32\u003e),\n    Double(Vec\u003cbool\u003e, Vec\u003cf64\u003e),\n    Binary(Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e),\n    Timestamp(Vec\u003cbool\u003e, Vec\u003ci64\u003e),\n    NChar(Vec\u003cOption\u003cString\u003e\u003e),\n    UTinyInt(Vec\u003cbool\u003e, Vec\u003cu8\u003e),\n    USmallInt(Vec\u003cbool\u003e, Vec\u003cu16\u003e),\n    UInt(Vec\u003cbool\u003e, Vec\u003cu32\u003e),\n    UBigInt(Vec\u003cbool\u003e, Vec\u003cu64\u003e), // 14\n    Json(Vec\u003cbool\u003e, Vec\u003cu8\u003e),\n    VarChar(Vec\u003cbool\u003e, Vec\u003cVec\u003cu8\u003e\u003e),\n    VarBinary(Vec\u003cbool\u003e, Vec\u003cVec\u003cu8\u003e\u003e),\n    Decimal(Vec\u003cbool\u003e, Vec\u003cf64\u003e),\n    Blob(Vec\u003cbool\u003e, Vec\u003cVec\u003cu8\u003e\u003e),\n}\n\nimpl TaosColumn {\n    pub fn new(column: Column) -\u003e Self {\n        match column {\n            Column::Null(v) =\u003e Self::Null(v),\n            Column::Bool(is_nulls, v) =\u003e Self::Bool(is_nulls.into_bools(), v),\n            Column::TinyInt(is_nulls, v) =\u003e Self::TinyInt(is_nulls.into_bools(), v),\n            Column::SmallInt(is_nulls, v) =\u003e Self::SmallInt(is_nulls.into_bools(), v),\n            Column::Int(is_nulls, v) =\u003e Self::Int(is_nulls.into_bools(), v),\n            Column::BigInt(is_nulls, v) =\u003e Self::BigInt(is_nulls.into_bools(), v),\n            Column::Float(is_nulls, v) =\u003e Self::Float(is_nulls.into_bools(), v),\n            Column::Double(is_nulls, v) =\u003e Self::Double(is_nulls.into_bools(), v),\n            Column::Binary(v) =\u003e Self::Binary(v),\n            Column::Timestamp(is_nulls, v) =\u003e Self::Timestamp(is_nulls.into_bools(), v),\n            Column::NChar(v) =\u003e Self::NChar(v),\n            Column::UTinyInt(is_nulls, v) =\u003e Self::UTinyInt(is_nulls.into_bools(), v),\n            Column::USmallInt(is_nulls, v) =\u003e Self::USmallInt(is_nulls.into_bools(), v),\n            Column::UInt(is_nulls, v) =\u003e Self::UInt(is_nulls.into_bools(), v),\n            Column::UBigInt(is_nulls, v) =\u003e Self::UBigInt(is_nulls.into_bools(), v),\n            Column::Json(is_nulls, v) =\u003e Self::Json(is_nulls.into_bools(), v),\n            Column::VarChar(is_nulls, v) =\u003e Self::VarChar(is_nulls.into_bools(), v),\n            Column::VarBinary(is_nulls, v) =\u003e Self::VarBinary(is_nulls.into_bools(), v),\n            Column::Decimal(is_nulls, v) =\u003e Self::Decimal(is_nulls.into_bools(), v),\n            Column::Blob(is_nulls, v) =\u003e Self::Blob(is_nulls.into_bools(), v),\n        }\n    }\n\n    pub fn to_multi_bind(\u0026self) -\u003e Column {\n        match self {\n            TaosColumn::Null(v) =\u003e Column::Null(v.to_owned()),\n            TaosColumn::Bool(is_nulls, v) =\u003e Column::Bool(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::TinyInt(is_nulls, v) =\u003e Column::TinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::SmallInt(is_nulls, v) =\u003e Column::SmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Int(is_nulls, v) =\u003e Column::Int(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::BigInt(is_nulls, v) =\u003e Column::BigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Float(is_nulls, v) =\u003e Column::Float(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Double(is_nulls, v) =\u003e Column::Double(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Binary(v) =\u003e Column::Binary(v.to_owned()),\n            TaosColumn::Timestamp(is_nulls, v) =\u003e Column::Timestamp(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::NChar(v) =\u003e Column::NChar(v.to_owned()),\n            TaosColumn::UTinyInt(is_nulls, v) =\u003e Column::UTinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::USmallInt(is_nulls, v) =\u003e Column::USmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UInt(is_nulls, v) =\u003e Column::UInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UBigInt(is_nulls, v) =\u003e Column::UBigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Json(is_nulls, v) =\u003e Column::Json(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarChar(is_nulls, v) =\u003e Column::VarChar(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarBinary(is_nulls, v) =\u003e Column::VarBinary(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Decimal(is_nulls, v) =\u003e Column::Decimal(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Blob(is_nulls, v) =\u003e Column::Blob(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n        }\n    }\n\n    pub fn to_column(\u0026self) -\u003e Column {\n        match self {\n            TaosColumn::Null(v) =\u003e Column::Null(v.to_owned()),\n            TaosColumn::Bool(is_nulls, v) =\u003e Column::Bool(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::TinyInt(is_nulls, v) =\u003e Column::TinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::SmallInt(is_nulls, v) =\u003e Column::SmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Int(is_nulls, v) =\u003e Column::Int(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::BigInt(is_nulls, v) =\u003e Column::BigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Float(is_nulls, v) =\u003e Column::Float(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Double(is_nulls, v) =\u003e Column::Double(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Binary(v) =\u003e Column::Binary(v.to_owned()),\n            TaosColumn::Timestamp(is_nulls, v) =\u003e Column::Timestamp(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::NChar(v) =\u003e Column::NChar(v.to_owned()),\n            TaosColumn::UTinyInt(is_nulls, v) =\u003e Column::UTinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::USmallInt(is_nulls, v) =\u003e Column::USmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UInt(is_nulls, v) =\u003e Column::UInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UBigInt(is_nulls, v) =\u003e Column::UBigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Json(is_nulls, v) =\u003e Column::Json(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarChar(is_nulls, v) =\u003e Column::VarChar(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarBinary(is_nulls, v) =\u003e Column::VarBinary(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Decimal(is_nulls, v) =\u003e Column::Decimal(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Blob(is_nulls, v) =\u003e Column::Blob(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n        }\n    }\n}\n","traces":[{"line":72,"address":[4323058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4323144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4738550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4739056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4738930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4739069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5032539,5031568],"length":1,"stats":{"Line":0},"fn_name":"deunicode_with_tofu_cow"},{"line":87,"address":[5035809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5032589,5032576,5031713],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":89,"address":[4739136],"length":1,"stats":{"Line":0},"fn_name":"into_owned"},{"line":98,"address":[4592496,4592233,4592352,4592606,4592144,4592185,4592278,4592472],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":99,"address":[5035856],"length":1,"stats":{"Line":0},"fn_name":"try_init_timed"},{"line":100,"address":[5032137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5035883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4739184],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":103,"address":[4592560,4592158,4592223,4592394,4592372,4592416,4592516,4592538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5032251,5032308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4739233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4742616,4742592,4742664],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":119,"address":[10784413,10784254,10784511,10784478,10784558,10784211,10784349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4742654,4742611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4592931,4592668,4593229,4593115,4592976,4592707,4592892,4592752,4593022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8564064],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":127,"address":[5032738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5036030,5036090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4739831,4740605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4739941,4739995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4740063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4740152,4740070,4740101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4740074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4582538,4582503,4579904],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":165,"address":[4396050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4396091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[10780386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5037249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4581124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5266816],"length":1,"stats":{"Line":0},"fn_name":"is_synchronous\u003cstd::io::util::Sink\u003e"},{"line":171,"address":[4450784],"length":1,"stats":{"Line":0},"fn_name":"nfd\u003cunicode_normalization::stream_safe::StreamSafe\u003ccore::str::iter::Chars\u003e\u003e"},{"line":172,"address":[4450795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4450845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4581149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[10780611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4457712],"length":1,"stats":{"Line":0},"fn_name":"nfkd\u003ccore::str::iter::Chars\u003e"},{"line":177,"address":[4457733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4457743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4146004,4146229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4146235,4146024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4450864],"length":1,"stats":{"Line":0},"fn_name":"nfc\u003cunicode_normalization::stream_safe::StreamSafe\u003ccore::str::iter::Chars\u003e\u003e"},{"line":182,"address":[4146247,4146064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4457791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4146104,4146317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4146374,4146124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4457808],"length":1,"stats":{"Line":0},"fn_name":"nfkc\u003ccore::str::iter::Chars\u003e"},{"line":187,"address":[4457829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4146673,4146656],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":192,"address":[4717797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4717800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4581786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4457856],"length":1,"stats":{"Line":0},"fn_name":"stream_safe\u003ccore::str::iter::Chars\u003e"},{"line":199,"address":[5033512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4083632],"length":1,"stats":{"Line":0},"fn_name":"base_url"},{"line":203,"address":[4083667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[11894392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4083680],"length":1,"stats":{"Line":0},"fn_name":"encoding_override"},{"line":208,"address":[4083701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5033585,5033664],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":212,"address":[4581918,4580481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[4582017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5034037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[4945780,4944756,4944884,4945012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5034366,5034400,5034464],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":222,"address":[4582368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4582296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4582336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[4582522,4580145,4580260,4582423,4582553,4580085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5033647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5034556,5034649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4083728],"length":1,"stats":{"Line":0},"fn_name":"syntax_violation_callback"},{"line":237,"address":[4083771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5034712,5034851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4083907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4083840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4083899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[10781255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4083991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5039715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5039817,5039972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[5039787,5040002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5039924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[12448734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[7686436,7686370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4584601,4584706,4582576],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":267,"address":[4582659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[4813456,4813472,4813744,4813461,4813491,4813758],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":269,"address":[4582870,4582806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[11013086,11013056,11012997,11012976,11013038,11013008,11012992,11012981],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":272,"address":[4583386,4583054,4582962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4084000],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":276,"address":[4084033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[4584013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5070190,5070255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[10781440],"length":1,"stats":{"Line":1},"fn_name":"ensure"},{"line":284,"address":[5070384,5070425,5070473,5070518],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":287,"address":[5070508,5070411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[4584485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4584523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[4945299,4945171,4945427,4946067,4945555,4945811,4945939,4945043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[4584569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[13990765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[12454064,12456738,12456789,12456840,12456432,12456687,12456330,12455040,12456016,12456032,12455986,12456381,12454016,12456021,12456483,12456534,12456273,12456585,12454033,12456636,12455010],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":301,"address":[4583165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4583245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4584721,4582924,4582821,4583364,4582997,4584620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[11010800],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":310,"address":[4584752,4584877],"length":1,"stats":{"Line":0},"fn_name":"reordered_levels"},{"line":313,"address":[4584840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[4957233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[8565383,8565646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[4585106,4584912],"length":1,"stats":{"Line":0},"fn_name":"reordered_levels_per_char"},{"line":321,"address":[8565822,8565337,8565792,8565706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5149977,5150103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[4585137,4584998,4585093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[4953969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[4586515,4586672,4585216],"length":1,"stats":{"Line":1},"fn_name":"reorder_line"},{"line":333,"address":[5150238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[4585543,4585451,4586702,4586688],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":337,"address":[5150302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[4585888,4585659],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":128},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","metrics","mod.rs"],"content":"use metrics::{counter, describe_gauge, gauge, histogram, register_gauge, register_histogram};\nuse metrics_exporter_prometheus::PrometheusBuilder;\nuse std::{\n    collections::HashSet,\n    net::SocketAddr,\n    time::{Duration, Instant},\n};\n\n#[derive(Debug, Default)]\npub struct Metrics {\n    listen: Option\u003cSocketAddr\u003e,\n    push: Option\u003cString\u003e,\n    push_interval: Option\u003cDuration\u003e,\n    interval: Option\u003cu16\u003e,\n}\n\npub fn process_metrics_init() {\n    register_gauge!(\"taosx_process_cpu_percent\");\n\n    describe_gauge!(\"taosx_process_cpu_percent\", \"CPU percent of the process\");\n}\n\npub fn process_metrics() -\u003e anyhow::Result\u003c()\u003e {\n    let ps = procfs::process::Process::myself()?;\n    let stat = \u0026ps.stat;\n    let ticks = procfs::ticks_per_second()?;\n    let mut proc = psutil::process::Process::current()?;\n\n    let cpu = proc.cpu_percent()?;\n    gauge!(\"taosx_process_cpu_percent\", cpu as f64);\n\n    let mem = proc.memory_percent()?;\n    gauge!(\n        \"taosx_process_mem_percent\",\n        (mem * 10000.0) as u64 as f64 / 100.0\n    );\n\n    let threads = ps.tasks()?.count();\n    gauge!(\"taosx_process_threads\", threads as f64);\n\n    let open_files = proc.open_files()?.len();\n    gauge!(\"taosx_process_open_files\", open_files as f64);\n\n    let uptime = (ps.stat.utime + ps.stat.stime) as f64 / ticks as f64;\n    gauge!(\"taosx_process_uptime\", uptime as f64);\n\n    let io = ps.io()?;\n    gauge!(\"taosx_process_io_read_bytes\", io.read_bytes as f64);\n    gauge!(\"taosx_process_io_write_bytes\", io.write_bytes as f64);\n\n    let fd = ps.fd()?;\n    let mut inodes = HashSet::new();\n    for fd in fd {\n        use procfs::process::FDTarget;\n        match fd.target {\n            FDTarget::Net(inode) =\u003e {\n                inodes.insert(inode);\n            }\n            FDTarget::Socket(inode) =\u003e {\n                inodes.insert(inode);\n            }\n            _ =\u003e {}\n        }\n    }\n\n    let (mut rx, mut tx) = (0, 0);\n\n    let tcp = procfs::net::tcp().unwrap();\n    let tcp6 = procfs::net::tcp6().unwrap();\n    for entry in tcp.into_iter().chain(tcp6) {\n        // find the process (if any) that has an open FD to this entry's inode\n        let local_address = format!(\"{}\", entry.local_address);\n        let remote_addr = format!(\"{}\", entry.remote_address);\n        let state = format!(\"{:?}\", entry.state);\n        if inodes.contains(\u0026entry.inode) {\n            log::debug!(\n                \"{:\u003c26} {:\u003c26} {:\u003c15} {:\u003c12} {}/{} {}/{}\",\n                local_address,\n                remote_addr,\n                state,\n                entry.inode,\n                stat.pid,\n                stat.comm,\n                entry.rx_queue,\n                entry.tx_queue\n            );\n            rx += entry.rx_queue;\n            tx += entry.tx_queue;\n        }\n    }\n\n    gauge!(\"taosx_process_net_rx\", rx as f64);\n    gauge!(\"taosx_process_net_tx\", tx as f64);\n    Ok(())\n}\n\nimpl Metrics {\n    pub fn init(self) -\u003e anyhow::Result\u003c()\u003e {\n        let mut exporter = PrometheusBuilder::new();\n        let interval = self.interval();\n        let dur = Duration::from_secs(interval as u64);\n\n        if let Some(listen) = self.listen {\n            exporter = exporter.with_http_listener(listen);\n        }\n        if let Some(push) = self.push {\n            let interval = self.push_interval.unwrap_or(Duration::from_secs(30));\n            exporter = exporter.with_push_gateway(push, interval)?;\n        }\n        let _ = exporter.install()?;\n        process_metrics_init();\n        std::thread::spawn(move || loop {\n            let _ = process_metrics();\n            metrics::increment_counter!(\"up seconds\");\n            std::thread::sleep(dur);\n        });\n        Ok(())\n    }\n\n    pub fn interval(\u0026self) -\u003e u16 {\n        self.interval.unwrap_or(1)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","mod.rs"],"content":"mod sync;\n\npub mod sink;\npub mod source;\npub mod transformer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sink","mod.rs"],"content":"pub mod taos;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sink","taos","mod.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::IntoDsn;\nuse std::{\n    cell::Cell,\n    fmt::Debug,\n    sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc,\n    },\n    task::Poll,\n};\n\nuse futures::{Sink, Stream, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, Describe, Ty},\n    helpers::{ColumnMeta, Described},\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{\n    stream::{\n        stream::*,\n        transformer::{Action, AddTag, AddTagOpts, Select},\n    },\n    util::sync_table,\n};\nuse taos::prelude::sync::*;\n\npub struct TaosSinkBuilder {\n    dsn: Dsn,\n    builder: Manager,\n    worker: AtomicUsize,\n    transformer: Arc\u003cOption\u003cVec\u003cAction\u003e\u003e\u003e,\n    metrics: Arc\u003cSummary\u003e,\n}\n\n#[derive(Debug)]\npub struct TaosSink {\n    id: usize,\n    taos: Taos,\n    transformer: Arc\u003cOption\u003cVec\u003cAction\u003e\u003e\u003e,\n    metrics: Arc\u003cSummary\u003e,\n}\n\nimpl XSinkBuilder for TaosSinkBuilder {\n    type Error = Error;\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut dsn = dsn.into_dsn()?;\n        if let Some(db) = dsn.database.take() {\n            let taos = Taos::from_dsn(\u0026dsn)?;\n            let db_info: Option\u003cString\u003e = taos.query_one(format!(\n                \"select * from information_schema.user_databases where name = \\\"{db}\\\"\"\n            ))?;\n            if db_info.is_none() {\n                log::warn!(\"create database {db} with default parameters since it's not exist\");\n                taos.exec(format!(\"create database if not exists {db}\"))?;\n            } else {\n                taos.exec(format!(\"create topic if not exists {db} as database {db}\"))?;\n                dsn.params.insert(\"topics\".to_string(), db.to_string());\n            }\n            dsn.database = Some(db);\n        } else {\n            return Err(Error::InvalidDatabase(\n                \"taos sink plugin requires a database name\".to_string(),\n            ));\n        }\n\n        let builder = Manager::from_dsn(\u0026dsn)?;\n        Ok(Self {\n            dsn,\n            builder,\n            transformer: Arc::new(None),\n            worker: AtomicUsize::new(0),\n            metrics: Default::default(),\n        })\n    }\n\n    fn with_transformer(mut self, transformer: Vec\u003cAction\u003e) -\u003e Self {\n        self.transformer = Arc::new(Some(transformer));\n        self\n    }\n\n    fn build_sink(\u0026self) -\u003e Result\u003cXSink\u003cSelf::Error\u003e, Self::Error\u003e {\n        let id = self\n            .worker\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n        Ok(TaosSink {\n            id,\n            taos: self.builder.connect()?,\n            transformer: self.transformer.clone(),\n            metrics: self.metrics.clone(),\n        }\n        .into())\n    }\n\n    fn summary(\u0026self) -\u003e \u0026Summary {\n        \u0026self.metrics\n    }\n}\n\npub fn sync_table_with_transformer(\n    from: \u0026Taos,\n    to: \u0026Taos,\n    db: \u0026str,\n    table: \u0026str,\n    transformer: \u0026[Action],\n) -\u003e Result\u003c(), Error\u003e {\n    use taos::prelude::sync::*;\n    assert!(transformer.len() \u003e 0);\n\n    let stable: Option\u003cString\u003e = from\n        .query_one(format!(\n            \"select stable_name from information_schema.user_tables where db_name = '{db}' and table_name = \\\"{table}\\\"\"\n        ))?\n        .unwrap();\n\n    if let Some(stable) = stable {\n        let desc = from.describe(\u0026format!(\"{db}.`{stable}`\"))?;\n        let mut stable2 = stable.to_string();\n\n        let transformed_desc =\n            transformer\n                .iter()\n                .fold(desc.clone(), |mut desc, action| match action {\n                    Action::AddTag(add_tag) =\u003e {\n                        desc.push(ColumnMeta::Tag(Described {\n                            field: add_tag.name.clone(),\n                            ty: Ty::VarChar,\n                            length: add_tag.len,\n                        }));\n                        desc\n                    }\n                    Action::Select(select) =\u003e match select {\n                        Select::Subset { subset } =\u003e desc\n                            .into_iter()\n                            .filter(|f| subset.contains(\u0026f.field))\n                            .collect(),\n                        Select::Rename { rename } =\u003e desc\n                            .into_iter()\n                            .map(|mut f| {\n                                if let Some(v) = rename.get(f.field()) {\n                                    f.field = v.to_string();\n                                    f\n                                } else {\n                                    f\n                                }\n                            })\n                            .collect(),\n                        Select::Exclude { exclude } =\u003e desc\n                            .into_iter()\n                            .filter(|f| !exclude.contains(\u0026f.field))\n                            .collect(),\n                    },\n                    Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e {\n                        match rename {\n                            crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n                                stable2 = format!(\"{prefix}{stable}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n                                stable2 = format!(\"{stable}{suffix}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n                                stable2 = template.replace(\"{{ name }}\", \u0026stable);\n                            }\n                        }\n                        desc\n                    }\n                    _ =\u003e desc,\n                });\n\n        log::trace!(\"create {stable2}\");\n        let sql = transformed_desc.to_create_table_sql(\u0026stable2);\n        to.exec(sql)?;\n\n        let names = transformer.iter().fold(\n            desc.tag_names().map(ToString::to_string).collect_vec(),\n            |names, action| match action {\n                Action::Select(select) =\u003e match select {\n                    Select::Subset { subset } =\u003e names\n                        .into_iter()\n                        .filter(|name| subset.contains(name))\n                        .collect_vec(),\n                    Select::Rename { rename } =\u003e names\n                        .into_iter()\n                        .map(|f| {\n                            if let Some(v) = rename.get(\u0026f) {\n                                format!(\"`{f}` as `{v}`\")\n                            } else {\n                                f\n                            }\n                        })\n                        .collect_vec(),\n                    Select::Exclude { exclude } =\u003e names\n                        .into_iter()\n                        .filter(|name| !exclude.contains(name))\n                        .collect_vec(),\n                },\n                _ =\u003e names,\n            },\n        );\n\n        let names = names.join(\",\");\n        let children: Vec\u003cVec\u003cValue\u003e\u003e = from\n            .query(format!(\"select tbname,{names} from {stable}\"))?\n            .deserialize()\n            .try_collect()?;\n\n        let children = transformer\n            .iter()\n            .fold(children, |children, action| match action {\n                Action::AddTag(add_tag) =\u003e match \u0026add_tag.opts {\n                    AddTagOpts::Value { value } =\u003e children\n                        .into_iter()\n                        .map(|mut v| {\n                            v.push(Value::VarChar(value.clone()));\n                            v\n                        })\n                        .collect_vec(),\n                    AddTagOpts::Template { template: _ } =\u003e todo!(),\n                },\n                Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e match rename {\n                    crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(format!(\"{prefix}{name}\"));\n                            child\n                        })\n                        .collect_vec(),\n                    crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(format!(\"{name}{suffix}\"));\n                            child\n                        })\n                        .collect_vec(),\n                    crate::stream::transformer::RenameOpts::Template { template } =\u003e children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(template.replace(\"{{ name }}\", name));\n                            child\n                        })\n                        .collect_vec(),\n                },\n                _ =\u003e children,\n            });\n\n        // todo: use par_iter to speed up tables creation.\n        // todo: single table not work, blocked by https://jira.taosdata.com:18080/browse/TD-16117\n        for child in children {\n            let tbname = child[0].to_string().unwrap();\n            let tags_values = child[1..].into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {tbname} using {stable2} tags({tags_values})\"\n            ))\n            .unwrap();\n        }\n\n        // let fields: Vec\u003cValue\u003e = from\n        //     .query_one(format!(\n        //         \"select {names} from {stable} where tbname = '{table}'\"\n        //     ))?\n        //     .unwrap();\n\n        // let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n        // to.exec(format!(\n        //     \"create table if not exists {table} using {stable} tags({tags_values})\"\n        // ))?;\n    } else {\n        let mut table = table.to_string();\n        log::info!(\"describe table {table}\");\n        let desc = from.describe(\u0026format!(\"{db}.`{table}`\"))?;\n        log::info!(\"table {table}: {desc:?}\");\n\n        let desc = transformer\n            .iter()\n            .fold(desc.clone(), |desc, action| match action {\n                Action::Select(select) =\u003e match select {\n                    Select::Subset { subset } =\u003e desc\n                        .into_iter()\n                        .filter(|f| subset.contains(\u0026f.field))\n                        .collect(),\n                    Select::Rename { rename } =\u003e desc\n                        .into_iter()\n                        .map(|mut f| {\n                            if let Some(v) = rename.get(f.field()) {\n                                f.field = v.to_string();\n                                f\n                            } else {\n                                f\n                            }\n                        })\n                        .collect(),\n                    Select::Exclude { exclude } =\u003e desc\n                        .into_iter()\n                        .filter(|f| !exclude.contains(\u0026f.field))\n                        .collect(),\n                },\n                Action::RenameTable(rename) =\u003e {\n                    match rename {\n                        crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n                            table = format!(\"{prefix}{table}\");\n                        }\n                        crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n                            table = format!(\"{table}{suffix}\");\n                        }\n                        crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n                            table = template.replace(\"{{ name }}\", \u0026table);\n                        }\n                    }\n                    desc\n                }\n                _ =\u003e desc,\n            });\n        let sql = desc.to_create_table_sql(\u0026table);\n        log::info!(\"exec sql: {sql}\");\n        to.exec(sql).unwrap();\n    }\n    Ok(())\n}\n\nimpl Sink\u003c(\u0026Taos, SyncBlock)\u003e for TaosSink {\n    type Error = Error;\n\n    fn poll_ready(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        Poll::Ready(Ok(()))\n    }\n\n    fn start_send(\n        mut self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        item: (\u0026Taos, SyncBlock),\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.consume_block(item.0, \u0026item.1)\n    }\n\n    fn poll_flush(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        Poll::Ready(Ok(()))\n    }\n\n    fn poll_close(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        Poll::Ready(Ok(()))\n    }\n}\n\nimpl TaosxSink for TaosSink {\n    type Error = Error;\n\n    fn batch_size(\u0026self) -\u003e usize {\n        1\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn consume_block(\u0026mut self, taos: \u0026Taos, block: \u0026SyncBlock) -\u003e Result\u003c(), Self::Error\u003e {\n        let idx = self.id;\n        let db = block.tmq_db_name().unwrap();\n        taos.exec(format!(\"use {db}\"))?;\n        let table = block.tmq_table_name().unwrap();\n        log::debug!(\"[{idx}] db: {db}, table: {table}\");\n\n        if let Some(transformer) = self.transformer.as_ref() {\n            // if self.taos.exec(format!(\"describe {table}\")).is_err() {\n            //     sync_table_with_transformer(taos, \u0026self.taos, db, \u0026table, \u0026transformer)?;\n            // }\n            // let mut table = table.to_string();\n            // let fields = block.fields();\n\n            // let mut bind: Vec\u003cTaosMultiBind\u003e = Vec::new();\n\n            // for action in transformer {\n            //     match action {\n            //         Action::Select(Select::Subset { subset }) =\u003e {\n            //             bind = block\n            //                 .columns_iter()\n            //                 .zip(fields)\n            //                 .filter_map(|(col, field)| {\n            //                     if subset.contains(\u0026field.name().to_string()) {\n            //                         Some(col.into())\n            //                     } else {\n            //                         None\n            //                     }\n            //                 })\n            //                 .collect()\n            //         }\n            //         Action::Select(Select::Exclude { exclude }) =\u003e {\n            //             bind = block\n            //                 .columns_iter()\n            //                 .zip(fields)\n            //                 .filter_map(|(col, field)| {\n            //                     if !exclude.contains(\u0026field.name().to_string()) {\n            //                         Some(col.into())\n            //                     } else {\n            //                         None\n            //                     }\n            //                 })\n            //                 .collect()\n            //         }\n            //         Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e {\n            //             match rename {\n            //                 crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n            //                     table = format!(\"{prefix}{table}\");\n            //                 }\n            //                 crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n            //                     table = format!(\"{table}{suffix}\");\n            //                 }\n            //                 crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n            //                     table = template.replace(\"{{ name }}\", \u0026table);\n            //                 }\n            //             }\n            //         }\n            //         _ =\u003e (),\n            //     }\n            // }\n            // if bind.is_empty() {\n            //     bind = block.columns_iter().map(Into::into).collect();\n            // }\n\n            // let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n            // let mut stmt = self\n            //     .taos\n            //     .stmt(format!(\"insert into {table} values({questions})\"))?;\n            // stmt.multi_bind(\u0026bind)?;\n            // stmt.execute()?;\n            // let inserted = stmt.affected_rows();\n            // log::info!(\"[{idx}] inserted {inserted} rows into {table}\");\n            // return Ok(());\n            let mut table2 = table.to_string();\n            let fields = block.fields();\n\n            let mut bind: Vec\u003cTaosMultiBind\u003e = Vec::new();\n\n            for action in transformer {\n                match action {\n                    Action::Select(Select::Subset { subset }) =\u003e {\n                        bind = block\n                            .columns_iter()\n                            .zip(fields)\n                            .filter_map(|(col, field)| {\n                                if subset.contains(\u0026field.name().to_string()) {\n                                    Some(col.into())\n                                } else {\n                                    None\n                                }\n                            })\n                            .collect()\n                    }\n                    Action::Select(Select::Exclude { exclude }) =\u003e {\n                        bind = block\n                            .columns_iter()\n                            .zip(fields)\n                            .filter_map(|(col, field)| {\n                                if !exclude.contains(\u0026field.name().to_string()) {\n                                    Some(col.into())\n                                } else {\n                                    None\n                                }\n                            })\n                            .collect()\n                    }\n                    Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e {\n                        match rename {\n                            crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n                                table2 = format!(\"{prefix}{table}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n                                table2 = format!(\"{table}{suffix}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n                                table2 = template.replace(\"{{ name }}\", \u0026table);\n                            }\n                        }\n                    }\n                    _ =\u003e (),\n                }\n            }\n            if bind.is_empty() {\n                bind = block.columns_iter().map(Into::into).collect();\n            }\n\n            if self.taos.exec(format!(\"describe {table2}\")).is_err() {\n                sync_table_with_transformer(taos, \u0026self.taos, db, \u0026table, \u0026transformer)?;\n            }\n            let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n            let mut stmt = self\n                .taos\n                .stmt(format!(\"insert into {table2} values({questions})\"))?;\n            stmt.multi_bind(\u0026bind)?;\n            stmt.execute()?;\n            let inserted = stmt.affected_rows();\n            self.metrics.blocks.fetch_add(1, Ordering::SeqCst);\n            self.metrics.rows.fetch_add(inserted, Ordering::SeqCst);\n            log::info!(\"[{idx}] inserted {inserted} rows into {table2}\");\n            return Ok(());\n        }\n\n        if self.taos.exec(format!(\"describe {table}\")).is_err() {\n            log::info!(\"[{idx}] synchronize table schema {table}\");\n            sync_table(taos, \u0026self.taos, \u0026db, \u0026table)?;\n            log::info!(\"[{idx}] synchronize table {table} done\");\n        }\n\n        let bind: Vec\u003cTaosMultiBind\u003e = block.columns_iter().map(|col| col.into()).collect();\n        let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n        let mut stmt = self\n            .taos\n            .stmt(format!(\"insert into {table} values({questions})\"))?;\n        stmt.multi_bind(\u0026bind)?;\n        stmt.execute()?;\n        let inserted = stmt.affected_rows();\n        self.metrics.blocks.fetch_add(1, Ordering::SeqCst);\n        self.metrics.rows.fetch_add(inserted, Ordering::SeqCst);\n        log::info!(\"[{idx}] inserted {inserted} rows into {table}\");\n        Ok(())\n    }\n\n    fn consume_raw_block(\u0026mut self, _: \u0026[u8]) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_line(\n        \u0026mut self,\n        item: \u0026str,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Line, precision)?;\n        Ok(())\n    }\n\n    fn consume_schemaless_telnet(\n        \u0026mut self,\n        item: \u0026str,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Telnet, precision)?;\n        Ok(())\n    }\n\n    fn consume_schemaless_json(\n        \u0026mut self,\n        item: \u0026str,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Json, precision)?;\n        Ok(())\n    }\n}\n\n#[taos::test(log_level = \"debug\", databases = 2)]\nasync fn test(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq = TmqBuilder::from_dsn(format!(\n        \"taos:///{db1}?topics={db1}\u0026group.id={db1}\u0026wait=1000\"\n    ))?\n    .build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n\n    let mut rs = taos2.query(\"select * from stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test_with_action_add_tag(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq =\n        TmqBuilder::from_dsn(format!(\"taos:///{db1}?topics={db1}\u0026group.id={db1}\"))?.build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .with_transformer(vec![Action::AddTag(AddTag {\n            name: \"f1\".to_string(),\n            len: 10,\n            opts: AddTagOpts::value(\"v1\"),\n        })])\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n    taos2.exec(\"reset query cache\")?;\n\n    let mut rs = taos2.query(\"select tbname, f1 from stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from tb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from tb2\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test_with_transformer(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq =\n        TmqBuilder::from_dsn(format!(\"taos:///{db1}?topics={db1}\u0026group.id={db1}\"))?.build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .with_transformer(vec![\n            Action::AddTag(AddTag {\n                name: \"f1\".to_string(),\n                len: 10,\n                opts: AddTagOpts::value(\"v1\"),\n            }),\n            Action::Select(crate::stream::transformer::Select::exclude(vec![\n                \"c_bool\".to_string()\n            ])),\n            Action::RenameTable(crate::stream::transformer::RenameOpts::prefix(\"p_\")),\n        ])\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n\n    let mut rs = taos2.query(\"select * from p_stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from p_tb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from p_tb2\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"debug\", precision = \"ns\")]\nasync fn sink_sml_line(taos: \u0026Taos) -\u003e Result\u003c(), Error\u003e {\n    let database = \"_rs_sml_\";\n    taos.exec(format!(\"drop database if exists {database}\"))?;\n    taos.exec(format!(\"create database {database} schemaless 1\"))?;\n    let lines = vec![\"st,t1=abc c1=3i64,c3=\\\"def\\\",c2=false 1626006833639000000\"];\n    let builder = TaosSinkBuilder::from_dsn(format!(\"taos:///{database}\"))?;\n    let mut sink = builder.build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    for line in lines {\n        sink.send(XLine::new_line(line)).await?;\n    }\n\n    let taos = builder.builder.connect()?;\n    let table = taos.describe(\"st\")?;\n    dbg!(table);\n\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Weather {\n        _ts: String,\n        c1: i64,\n        c2: bool,\n        c3: String,\n    }\n    let mut rs = taos.query(\"select * from st\")?;\n    for block in rs.blocks_iter() {\n        dbg!(block.deserialize_into_vec::\u003cWeather\u003e());\n    }\n    Ok(())\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","csv","mod.rs"],"content":"use taos::query::Dsn;\n\npub struct Csv {\n    dsn: Dsn,\n}\n\nimpl Csv {\n    fn from_dsn(dsn: impl Into\u003cDsn\u003e) -\u003e Result\u003cSelf, anyhow::Error\u003e {\n        let dsn = dsn.into();\n        Ok(Self { dsn })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","mod.rs"],"content":"pub mod csv;\npub mod taos;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","taos.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::{DsnError, IntoDsn};\nuse serde::Deserialize;\n\nuse std::{\n    any::Any,\n    borrow::Cow,\n    collections::{BTreeSet, HashMap},\n    ffi::c_void,\n    fmt::Debug,\n    marker::PhantomData,\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    sync::{Arc, Weak},\n    task::Poll, str::FromStr,\n};\n\nuse futures::{Sink, Stream, StreamExt, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, BlockStream, Field, Ty},\n    prelude::AsyncFetchable,\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{\n    plugins::sink::taos::TaosSinkBuilder,\n    stream::{source::XSourceBuilder, stream::XSinkBuilder, transformer::Action},\n    util::sync_table,\n};\n\nuse crate::stream::stream::{SinkProtocol, TaosxSinkItem};\n\npub use taos::prelude::sync::*;\n\n#[derive(Debug)]\npub enum TaosItem {\n    Block(Arc\u003cTaos\u003e, SyncBlock),\n}\n\nimpl\u003c'a\u003e TaosxSinkItem for TaosItem {\n    fn protocol(\u0026self) -\u003e SinkProtocol {\n        match self {\n            Self::Block(_, _) =\u003e SinkProtocol::Block,\n        }\n    }\n\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        match self {\n            Self::Block(taos, block) =\u003e (taos.as_ref(), \u0026block),\n        }\n    }\n\n    fn as_raw_block(\u0026self) -\u003e Option\u003cstd::borrow::Cow\u003c[u8]\u003e\u003e {\n        None\n    }\n\n    fn as_record(\u0026self) -\u003e Option\u003cstd::borrow::Cow\u003c[Value]\u003e\u003e {\n        None\n    }\n\n    fn precision(\u0026self) -\u003e SchemalessPrecision {\n        SchemalessPrecision::NonConfigured\n    }\n\n    fn as_schemaless_line(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_telnet(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_json(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    const PROTOCOL: SinkProtocol = SinkProtocol::__NoneExhaustive;\n}\n\npub struct TaosSourceBuilder {\n    from: Dsn,\n    manager: Manager,\n    tmq_builder: TmqBuilder,\n    max_workers: usize,\n    protocol: SinkProtocol,\n}\n\n#[derive(Debug)]\npub struct TaosSource {\n    taos: Arc\u003cTaos\u003e,\n    consumer: Consumer,\n    protocol: SinkProtocol,\n    rs: Option\u003cResultSet\u003e,\n    blocks: Option\u003cBlockStream\u003e,\n}\n\nimpl Drop for TaosSource {\n    fn drop(\u0026mut self) {\n        self.blocks.take();\n        self.rs.take();\n    }\n}\n\nuse taos::prelude::Error;\n\nimpl XSourceBuilder for TaosSourceBuilder {\n    type Error = Error;\n\n    type Item = TaosItem;\n    type XSource = TaosSource;\n\n    const NAME: \u0026'static str = \"taos\";\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut dsn = dsn.into_dsn()?;\n        if dsn.database.is_none() {\n            Err(DsnError::RequireDatabase(\n                \"please input a database or topic/stream name\".to_string(),\n            ))?;\n        }\n\n        let mut max_workers = 0;\n        let db = dsn.database.take().unwrap(); // unwrap is safe.\n\n        let taos = Taos::from_dsn(\u0026dsn)?;\n\n        let topics: HashMap\u003c_, _\u003e = taos\n            .topics()?\n            .into_iter()\n            .map(|topic| (topic.name().to_string(), topic))\n            .collect();\n\n        #[derive(Default, Deserialize)]\n        struct VGroups {\n            vgroups: usize,\n        }\n        // For `?topics=` options.\n        if let Some(opt) = dsn.params.get(\"topics\") {\n            let topic_names = opt.split(\",\").map(|s| s.to_string()).collect_vec();\n            if topic_names.is_empty() {\n                return Err(Error::InvalidTopic(\"topics is empty\".to_string()));\n            }\n            let mut db_name = None;\n            {\n                for topic_name in topic_names {\n                    if let Some(topic) = topics.get(\u0026topic_name) {\n                        let db = topic.db_name();\n                        let vgroups: VGroups = taos\n                            .query_one(format!(\n                            \"select * from information_schema.user_databases where name = '{db}'\"))?\n                            .unwrap_or_default();\n                        if max_workers \u003c vgroups.vgroups {\n                            max_workers = vgroups.vgroups;\n                        }\n                        if let Some(db1) = db_name.as_ref() {\n                            if db1 != topic.db_name() {\n                                // return Err(Error::InvalidTopic(\n                                //     \"topics should be in same database\".to_string(),\n                                // ));\n                                log::warn!(\"subscribe topics in different database\");\n                            }\n                        } else {\n                            db_name = Some(topic.db_name().to_string());\n                        }\n                    } else {\n                        return Err(Error::InvalidTopic(format!(\"topic {topic_name} not found\")));\n                    }\n                }\n            }\n            dsn.database = db_name;\n            // check group id\n            if !dsn.params.contains_key(\"group.id\") {\n                let opt = opt.to_string();\n                dsn.params.insert(\"group.id\".to_string(), opt);\n            }\n        } else {\n            // If no `topics` option in params, check if the database identity is topic(s) or not.\n            dsn.params.insert(\"topics\".to_string(), db.to_string());\n            for db in db.split(\",\") {\n                if let Some(topic) = topics.get(db) {\n                    let db_name = topic.db_name();\n                    dsn.database = Some(db_name.to_string());\n                } else {\n                    // todo: support subscribe stable/table.\n                    let db_info: Option\u003cString\u003e = taos.query_one(format!(\n                        \"select * from information_schema.user_databases where name = \\\"{db}\\\"\"\n                    ))?;\n                    if db_info.is_none() {\n                        return Err(Error::InvalidDatabase(db.to_string()));\n                    }\n                    taos.exec(format!(\"create topic if not exists {db} as database {db}\"))?;\n                    dsn.database = Some(db.to_string());\n                }\n\n                let vgroups: VGroups = taos\n                    .query_one(format!(\n                        \"select * from information_schema.user_databases where name = '{db}'\"\n                    ))?\n                    .unwrap_or_default();\n                if max_workers \u003c vgroups.vgroups {\n                    max_workers = vgroups.vgroups;\n                }\n            }\n\n            if !dsn.params.contains_key(\"group.id\") {\n                dsn.params.insert(\"group.id\".to_string(), db.to_string());\n            }\n        }\n        // check group id\n        if !dsn.params.contains_key(\"wait\") {\n            dsn.params.insert(\"wait\".to_string(), \"10\".to_string());\n        }\n        let manager = Manager::from_dsn(dsn.clone())?;\n\n        Ok(Self {\n            from: dsn.clone(),\n            manager,\n            tmq_builder: TmqBuilder::from_dsn(dsn)?,\n            max_workers,\n            protocol: SinkProtocol::Block,\n        })\n    }\n\n    fn dsn(\u0026self) -\u003e Cow\u003cDsn\u003e {\n        Cow::Borrowed(\u0026self.from)\n    }\n\n    fn build_source(\u0026mut self) -\u003e Result\u003cSelf::XSource, Self::Error\u003e {\n        Ok(TaosSource {\n            taos: Arc::new(self.manager.connect()?),\n            consumer: self.tmq_builder.build()?,\n            protocol: SinkProtocol::Block,\n            rs: None,\n            blocks: None,\n        })\n    }\n\n    fn protocol(\u0026self) -\u003e SinkProtocol {\n        todo!()\n    }\n\n    fn max_workers(\u0026self) -\u003e usize {\n        self.max_workers\n    }\n\n    fn database_options(\u0026self) -\u003e Vec\u003c(String, String)\u003e {\n        unimplemented!()\n    }\n\n    fn schema_iter\u003cI\u003e(\u0026self) -\u003e I\n    where\n        I: Iterator\u003cItem = crate::stream::source::XSchema\u003e,\n    {\n        unimplemented!()\n    }\n}\n\nimpl Stream for TaosSource {\n    type Item = Result\u003cTaosItem, Error\u003e;\n\n    fn poll_next(\n        mut self: Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        match self.protocol {\n            SinkProtocol::ResultSet =\u003e todo!(),\n            SinkProtocol::Block =\u003e {\n                if let Some(blocks) = self.blocks.as_mut() {\n                    match blocks.poll_next_unpin(cx) {\n                        Poll::Pending =\u003e Poll::Pending,\n                        Poll::Ready(None) =\u003e {\n                            self.blocks = None;\n                            self.rs = None;\n                            match self.consumer.poll_next_unpin(cx) {\n                                Poll::Pending =\u003e Poll::Pending,\n                                Poll::Ready(None) =\u003e Poll::Ready(None),\n                                Poll::Ready(Some(rs)) =\u003e match rs {\n                                    Ok(mut rs) =\u003e {\n                                        self.blocks = Some(rs.block_stream());\n                                        self.rs = Some(rs);\n                                        self.blocks.as_mut().unwrap().poll_next_unpin(cx).map(\n                                            |block| {\n                                                block.map(|block| {\n                                                    Ok(TaosItem::Block(self.taos.clone(), block))\n                                                })\n                                            },\n                                        )\n                                    }\n                                    Err(err) =\u003e Poll::Ready(Some(Err(err.into()))),\n                                },\n                            }\n                        }\n                        Poll::Ready(Some(block)) =\u003e {\n                            Poll::Ready(Some(Ok(TaosItem::Block(self.taos.clone(), block))))\n                        }\n                    }\n                } else {\n                    match self.consumer.poll_next_unpin(cx) {\n                        Poll::Pending =\u003e Poll::Pending,\n                        Poll::Ready(None) =\u003e Poll::Ready(None),\n                        Poll::Ready(Some(rs)) =\u003e match rs {\n                            Ok(mut rs) =\u003e {\n                                self.blocks = Some(rs.block_stream());\n                                self.rs = Some(rs);\n                                self.blocks\n                                    .as_mut()\n                                    .unwrap()\n                                    .poll_next_unpin(cx)\n                                    .map(|block| {\n                                        block.map(|block| {\n                                            Ok(TaosItem::Block(self.taos.clone(), block))\n                                        })\n                                    })\n                            }\n                            Err(_) =\u003e Poll::Ready(None),\n                        },\n                    }\n                }\n            }\n            SinkProtocol::RawBlock =\u003e todo!(),\n            SinkProtocol::Record =\u003e todo!(),\n            SinkProtocol::SmlLine =\u003e todo!(),\n            SinkProtocol::SmlTelnet =\u003e todo!(),\n            SinkProtocol::SmlJson =\u003e todo!(),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e anyhow::Result\u003c()\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut source_builder = TaosSourceBuilder::from_dsn(format!(\"taos:///{db1}?wait=1000\"))?;\n    let mut source = source_builder.build_source()?;\n\n    let mut rows = 0;\n    let mut tables = std::collections::BTreeSet::new();\n    while let Some(Ok(item)) = source.next().await {\n        println!(\"{:?}\", item);\n        let block = item.as_block().1;\n        rows += block.num_of_rows();\n        let table = block.tmq_table_name().unwrap();\n        tables.insert(table.to_string());\n    }\n    anyhow::ensure!(rows == 8);\n    anyhow::ensure!(tables.into_iter().collect_vec() == vec![\"tb1\", \"tb2\", \"tb3\", \"tb4\"]);\n\n    taos.exec_many([\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db2 = databases[1];\n    let transformers = vec![Action::from_str(\"add-tag:f1(10)=value1\")?];\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?.with_transformer(transformers).build_sink()?;\n\n    source.forward(\u0026mut sink).await?;\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"debug\")]\nasync fn test_sync() -\u003e anyhow::Result\u003c()\u003e {\n    return Ok(());\n    let db1 = \"abc1\";\n    // if taos.query_one::\u003cString\u003e(\"select name from information_schema.user_databases where name = abc1\")?.is_none() {\n    //     return Ok(());\n    // }\n    let mut source_builder =\n        TaosSourceBuilder::from_dsn(format!(\"taos:///{db1}?group.id=1\u0026wait=20000\"))?;\n    let source = source_builder.build_source()?;\n    let db2 = \"abc2\";\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?.build_sink()?;\n\n    source.forward(\u0026mut sink).await?;\n\n    Ok(())\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sync","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","transformer","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","mod.rs"],"content":"pub mod sink;\npub mod source;\npub mod transformer;\n\npub mod stream;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","sink.rs"],"content":"use std::iter::Product;\n\nuse linked_hash_map::LinkedHashMap;\nuse taos::query::Dsn;\n\n#[repr(C)]\npub enum SourceType {\n    Database,\n}\npub trait ISSourceType {\n    const SOURCE_TYPE: SourceType;\n}\n\npub trait TaosxSource: Sized {\n    type Error;\n    const NAME: \u0026'static str;\n    const KEYS: \u0026'static [\u0026'static str];\n\n    fn new(dsn: Dsn, opts: LinkedHashMap\u003c\u0026'static str, String\u003e) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    type Product;\n    fn produce(\u0026mut self) -\u003e Self::Product;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","source.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::{DsnError, IntoDsn};\n\nuse std::{\n    any::Any,\n    borrow::Cow,\n    collections::{BTreeSet, HashMap},\n    ffi::c_void,\n    fmt::Debug,\n    marker::PhantomData,\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    sync::{Arc, Weak},\n    task::Poll,\n};\n\nuse futures::{Sink, Stream, StreamExt, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, BlockStream, Field, Ty},\n    prelude::AsyncFetchable,\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{plugins::sink::taos::TaosSinkBuilder, stream::stream::XSinkBuilder, util::sync_table};\n\nuse super::stream::{SinkProtocol, TaosxSinkItem};\n\npub use taos::prelude::sync::*;\n\npub enum XSchema {\n    STableBegin,\n    STableSpan {\n        name: String,\n        tags: Vec\u003cField\u003e,\n        fields: Vec\u003cField\u003e,\n        options: Vec\u003c(String, String)\u003e,\n    },\n    STableEnd,\n    TableBegin,\n    Table {\n        name: String,\n        fields: Vec\u003cField\u003e,\n        options: Vec\u003c(String, String)\u003e,\n    },\n    TableEnd,\n    ChildTableBegin,\n    ChildTable {\n        name: String,\n        stable: String,\n        fields: Vec\u003cValue\u003e,\n    },\n    ChildTableEnd,\n}\n\npub trait XSourceBuilder\nwhere\n    Self: Sized,\n{\n    type Error: std::error::Error;\n    type Item: TaosxSinkItem;\n    type XSource: Stream\u003cItem = Result\u003cSelf::Item, Self::Error\u003e\u003e;\n\n    const NAME: \u0026'static str;\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    fn dsn(\u0026self) -\u003e Cow\u003cDsn\u003e;\n\n    fn max_workers(\u0026self) -\u003e usize {\n        0\n    }\n\n    fn database_options(\u0026self) -\u003e Vec\u003c(String, String)\u003e {\n        unimplemented!()\n    }\n\n    fn schema_iter\u003cI\u003e(\u0026self) -\u003e I\n    where\n        I: Iterator\u003cItem = XSchema\u003e,\n    {\n        unimplemented!()\n    }\n\n    fn protocol(\u0026self) -\u003e SinkProtocol;\n\n    fn build_source(\u0026mut self) -\u003e Result\u003cSelf::XSource, Self::Error\u003e;\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","stream","mod.rs"],"content":"use derive_more::{Deref, DerefMut};\nuse mdsn::IntoDsn;\nuse std::{\n    borrow::Cow,\n    fmt::Debug,\n    pin::Pin,\n    sync::atomic::{AtomicUsize, Ordering},\n};\n\nuse taos::prelude::{SchemalessPrecision, SyncBlock, Taos, Value};\n\nuse super::transformer::Action;\n\n#[derive(Debug, Clone, Copy)]\n#[non_exhaustive]\npub enum SinkProtocol {\n    /// TDengine result set type for [taos::Taos] only.\n    ResultSet,\n    /// A stream data block from tmq consumer.\n    Block,\n    /// Raw block as a single bytes.\n    RawBlock,\n    /// A record for a table or stable.\n    Record,\n    /// InfluxDB line protocol record.\n    SmlLine,\n    /// OpenTSDB telnet protocol record string.\n    SmlTelnet,\n    /// OpenTSDB json protocol.\n    SmlJson,\n    #[non_exhaustive]\n    __NoneExhaustive,\n}\n\n#[derive(Debug, Default)]\npub struct Summary {\n    pub blocks: AtomicUsize,\n    pub rows: AtomicUsize,\n}\n\nimpl Summary {\n    pub fn blocks(\u0026self) -\u003e usize {\n        self.blocks.load(Ordering::Acquire)\n    }\n    pub fn rows(\u0026self) -\u003e usize {\n        self.rows.load(Ordering::Acquire)\n    }\n}\n\npub trait XSinkBuilder\nwhere\n    Self: Sized,\n{\n    type Error: std::error::Error;\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    fn with_transformer(self, transformers: Vec\u003cAction\u003e) -\u003e Self;\n\n    fn build_sink(\u0026self) -\u003e Result\u003cXSink\u003cSelf::Error\u003e, Self::Error\u003e;\n\n    fn summary(\u0026self) -\u003e \u0026Summary;\n\n    fn build_sink_for_protocol(\u0026self, _: SinkProtocol) -\u003e Result\u003cXSink\u003cSelf::Error\u003e, Self::Error\u003e {\n        self.build_sink()\n    }\n}\n\n#[derive(Debug, Deref, DerefMut)]\npub struct XSink\u003cE\u003e(Box\u003cdyn TaosxSink\u003cError = E\u003e\u003e);\n\nimpl\u003cE, T\u003e From\u003cT\u003e for XSink\u003cE\u003e\nwhere\n    E: 'static + Send + Sync + std::error::Error,\n    T: 'static + TaosxSink\u003cError = E\u003e,\n{\n    fn from(value: T) -\u003e Self {\n        XSink(Box::new(value))\n    }\n}\n\nimpl\u003cE, I\u003e futures::Sink\u003cI\u003e for XSink\u003cE\u003e\nwhere\n    E: 'static + Send + Sync + std::error::Error,\n    I: TaosxSinkItem,\n{\n    type Error = E;\n\n    fn poll_ready(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        std::task::Poll::Ready(Ok(()))\n    }\n\n    fn start_send(self: std::pin::Pin\u003c\u0026mut Self\u003e, item: I) -\u003e Result\u003c(), Self::Error\u003e {\n        let sink = Pin::into_inner(self);\n        match item.protocol() {\n            SinkProtocol::ResultSet =\u003e todo!(),\n            SinkProtocol::Block =\u003e {\n                let (taos, block) = item.as_block();\n                sink.consume_block(taos, block)\n            }\n            SinkProtocol::RawBlock =\u003e {\n                if let Some(block) = item.as_raw_block() {\n                    sink.consume_raw_block(\u0026block)\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::Record =\u003e todo!(),\n            SinkProtocol::SmlLine =\u003e {\n                if let Some(line) = item.as_schemaless_line() {\n                    sink.consume_schemaless_line(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::SmlTelnet =\u003e {\n                if let Some(line) = item.as_schemaless_telnet() {\n                    sink.consume_schemaless_telnet(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::SmlJson =\u003e {\n                if let Some(line) = item.as_schemaless_json() {\n                    sink.consume_schemaless_json(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            _ =\u003e todo!(),\n        }\n    }\n\n    fn poll_flush(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        std::task::Poll::Ready(Ok(()))\n    }\n\n    fn poll_close(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        std::task::Poll::Ready(Ok(()))\n    }\n}\n\npub type TaosxSinkError = anyhow::Error;\npub trait TaosxSink: Debug + Send {\n    type Error: 'static + Send + Sync + std::error::Error;\n    fn batch_size(\u0026self) -\u003e usize {\n        1\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn consume_block(\u0026mut self, _: \u0026Taos, _: \u0026SyncBlock) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_raw_block(\u0026mut self, _: \u0026[u8]) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_line(\n        \u0026mut self,\n        _: \u0026str,\n        _: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_telnet(\n        \u0026mut self,\n        _: \u0026str,\n        _: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_json(\n        \u0026mut self,\n        _: \u0026str,\n        _: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n}\n\npub trait TaosxSinkItem: Send {\n    const PROTOCOL: SinkProtocol;\n\n    fn protocol(\u0026self) -\u003e SinkProtocol {\n        Self::PROTOCOL\n    }\n\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        unimplemented!()\n    }\n\n    fn as_raw_block(\u0026self) -\u003e Option\u003cCow\u003c[u8]\u003e\u003e {\n        None\n    }\n\n    fn as_record(\u0026self) -\u003e Option\u003cCow\u003c[Value]\u003e\u003e {\n        None\n    }\n\n    fn precision(\u0026self) -\u003e SchemalessPrecision {\n        SchemalessPrecision::NonConfigured\n    }\n\n    fn as_schemaless_line(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_telnet(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_json(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n}\n\nimpl TaosxSinkItem for (\u0026Taos, SyncBlock) {\n    const PROTOCOL: SinkProtocol = SinkProtocol::Block;\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        (self.0, \u0026self.1)\n    }\n}\n\nimpl TaosxSinkItem for (\u0026Taos, \u0026SyncBlock) {\n    const PROTOCOL: SinkProtocol = SinkProtocol::Block;\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        (self.0, self.1)\n    }\n}\n\npub struct XLine\u003c'a\u003e(\u0026'a str, SchemalessPrecision);\n\nimpl\u003c'a\u003e XLine\u003c'a\u003e {\n    pub fn new_line(input: \u0026'a str) -\u003e Self {\n        XLine(input, SchemalessPrecision::Nanoseconds)\n    }\n    pub fn new_line_with_precision(input: \u0026'a str, precision: SchemalessPrecision) -\u003e Self {\n        XLine(input, precision)\n    }\n}\n\nimpl\u003c'a\u003e TaosxSinkItem for XLine\u003c'a\u003e {\n    const PROTOCOL: SinkProtocol = SinkProtocol::SmlLine;\n    fn precision(\u0026self) -\u003e SchemalessPrecision {\n        self.1\n    }\n    fn as_schemaless_line(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        Some(self.0)\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":58},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","transformer.rs"],"content":"use std::str::FromStr;\n\nuse linked_hash_map::LinkedHashMap as HashMap;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum AddTagOpts {\n    Value { value: String },\n    Template { template: String },\n}\n\nimpl AddTagOpts {\n    pub fn value(value: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Value {\n            value: value.into(),\n        }\n    }\n    pub fn template(template: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Template {\n            template: template.into(),\n        }\n    }\n}\n\nconst fn default_tag_length() -\u003e usize {\n    100\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\npub struct AddTag {\n    pub name: String,\n    #[serde(flatten)]\n    pub opts: AddTagOpts,\n\n    #[serde(default = \"default_tag_length\")]\n    pub len: usize,\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum AddTagParseError {\n    #[error(\"Empty AddTag option\")]\n    Empty,\n    #[error(\"Invalid AddTag option: {0}\")]\n    Invalid(String),\n}\n\nimpl FromStr for AddTag {\n    type Err = AddTagParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if s.is_empty() {\n            return Err(AddTagParseError::Empty);\n        }\n        use lazy_static::lazy_static;\n        use regex::Regex;\n        lazy_static! {\n            static ref RE: Regex =\n                Regex::new(r\"(?P\u003cf\u003e[^=()\\s]+)(\\((?P\u003cl\u003e\\d+)\\))?=((?P\u003ct\u003e.*\\{\\{.*\\}\\}.*)|(?P\u003cv\u003e.*))\")\n                    .unwrap();\n        }\n        // RE.matches(s).into_iter()\n        if let Some(cap) = RE.captures(s) {\n            let name = cap[\"f\"].to_string();\n            let len = cap\n                .name(\"l\")\n                .and_then(|m| m.as_str().parse().ok())\n                .unwrap_or_else(default_tag_length);\n            if let Some(v) = cap.name(\"v\") {\n                Ok(AddTag {\n                    name,\n                    len,\n                    opts: AddTagOpts::value(v.as_str()),\n                })\n            } else if let Some(t) = cap.name(\"t\") {\n                Ok(AddTag {\n                    name,\n                    len,\n                    opts: AddTagOpts::template(t.as_str()),\n                })\n            } else {\n                unreachable!()\n            }\n        } else {\n            Err(AddTagParseError::Invalid(s.to_string()))\n        }\n    }\n}\n\n#[test]\nfn parse_add_tag() {\n    let errors = [\n        (\"\", AddTagParseError::Empty),\n        (\"a\", AddTagParseError::Invalid(\"\".to_string())),\n    ];\n    for (s, e) in errors {\n        let ee = AddTag::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let add_tags = [\n        (\n            \"f1=v1\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Value {\n                    value: \"v1\".to_string(),\n                },\n                len: 100,\n            },\n        ),\n        (\n            \"f1(200)=v1\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Value {\n                    value: \"v1\".to_string(),\n                },\n                len: 200,\n            },\n        ),\n        (\n            \"f1(200)={{ host }}\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Template {\n                    template: \"{{ host }}\".to_string(),\n                },\n                len: 200,\n            },\n        ),\n    ];\n    for (s, a) in add_tags {\n        let aa = AddTag::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum RenameOpts {\n    Prefix { prefix: String },\n    Suffix { suffix: String },\n    Template { template: String },\n}\n\nimpl RenameOpts {\n    pub fn prefix(prefix: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Prefix {\n            prefix: prefix.into(),\n        }\n    }\n    pub fn suffix(input: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Suffix {\n            suffix: input.into(),\n        }\n    }\n    pub fn template(input: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Template {\n            template: input.into(),\n        }\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum RenameParseError {\n    #[error(\"Empty rename option is not valid\")]\n    Empty,\n    #[error(\"Empty rename option for variant: {0}\")]\n    EmptyOptionForVariant(\u0026'static str),\n    #[error(\n        \"Invalid rename option: {0} which should match pattern `\u003cprefix|suffix|template\u003e:\u003cvalue\u003e`\"\n    )]\n    FormatError(String),\n    #[error(\"Invalid rename variant: {0} while parsing `{1}`\")]\n    InvalidVariant(String, String),\n}\n\nimpl FromStr for RenameOpts {\n    type Err = RenameParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        use RenameParseError::*;\n        if s.is_empty() {\n            return Err(Empty);\n        }\n        let (variant, option) = s.split_once(':').ok_or(FormatError(s.to_string()))?;\n        match variant {\n            \"prefix\" =\u003e {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"prefix\"))\n                } else {\n                    Ok(RenameOpts::prefix(option))\n                }\n            }\n            \"suffix\" =\u003e {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"suffix\"))\n                } else {\n                    Ok(RenameOpts::suffix(option))\n                }\n            }\n            \"template\" =\u003e {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"template\"))\n                } else {\n                    Ok(RenameOpts::template(option))\n                }\n            }\n            variant =\u003e Err(InvalidVariant(variant.to_string(), s.to_string())),\n        }\n    }\n}\n\n#[test]\nfn test_rename_opts_from_str() {\n    use RenameParseError::*;\n    let errors = [\n        (\"\", Empty),\n        (\"a\", FormatError(\"a\".to_string())),\n        (\"a:\", InvalidVariant(\"a\".to_string(), \"a:\".to_string())),\n        (\"prefix:\", EmptyOptionForVariant(\"prefix\")),\n        (\"suffix:\", EmptyOptionForVariant(\"suffix\")),\n        (\"template:\", EmptyOptionForVariant(\"template\")),\n    ];\n    for (s, e) in errors {\n        let ee = RenameOpts::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let actions = [\n        (\"prefix:v1_\", RenameOpts::prefix(\"v1_\")),\n        (\"suffix:_v1\", RenameOpts::suffix(\"_v1\")),\n        (\"template:v1_v1\", RenameOpts::template(\"v1_v1\")),\n    ];\n    for (s, a) in actions {\n        let aa = RenameOpts::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum Select {\n    Subset { subset: Vec\u003cString\u003e },\n    Exclude { exclude: Vec\u003cString\u003e },\n    Rename { rename: HashMap\u003cString, String\u003e },\n}\n\nimpl Select {\n    pub fn subset(subset: Vec\u003cString\u003e) -\u003e Self {\n        Self::Subset { subset }\n    }\n\n    pub fn exclude(exclude: Vec\u003cString\u003e) -\u003e Self {\n        Self::Exclude { exclude }\n    }\n\n    pub fn rename\u003cI: IntoIterator\u003cItem = (impl Into\u003cString\u003e, impl Into\u003cString\u003e)\u003e\u003e(\n        rename: I,\n    ) -\u003e Self {\n        Self::Rename {\n            rename: rename\n                .into_iter()\n                .map(|(a, b)| (a.into(), b.into()))\n                .collect(),\n        }\n    }\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum SelectParseError {\n    #[error(\"Empty select option\")]\n    Empty,\n    #[error(\"Empty select option for variant: {0}\")]\n    EmptyOptionForVariant(\u0026'static str),\n    #[error(\"Invalid select option: {0}, use like `select:\u003ctype\u003e:\u003copts\u003e`\")]\n    InvalidSelect(String),\n    #[error(\"Invalid select variant: {0} while parsing `{1}`\")]\n    InvalidVariant(String, String),\n    #[error(\"Invalid rename option: {0} while parsing `{1}`\")]\n    InvalidRename(String, String),\n}\n\nimpl FromStr for Select {\n    type Err = SelectParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if s.is_empty() {\n            return Err(SelectParseError::Empty);\n        }\n        let (select, fields) = s\n            .split_once(':')\n            .ok_or(SelectParseError::InvalidSelect(s.to_string()))?;\n        match select {\n            \"subset\" =\u003e {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"subset\"));\n                }\n                let v = fields.split(\",\").map(ToString::to_string).collect();\n                Ok(Select::subset(v))\n            }\n            \"exclude\" =\u003e {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"exclude\"));\n                }\n                let v = fields.split(\",\").map(ToString::to_string).collect();\n                Ok(Select::exclude(v))\n            }\n            \"rename\" =\u003e {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"rename\"));\n                }\n                use itertools::Itertools;\n                let v: Vec\u003c_\u003e = fields\n                    .split(\",\")\n                    .map(|f| {\n                        f.split_once(\"=\")\n                            .ok_or(SelectParseError::InvalidRename(\n                                f.to_string(),\n                                s.to_string(),\n                            ))\n                            .map(|(f, v)| (f.to_string(), v.to_string()))\n                    })\n                    .try_collect()?;\n                Ok(Select::rename(v))\n            }\n            t =\u003e Err(SelectParseError::InvalidVariant(\n                t.to_string(),\n                s.to_string(),\n            )),\n        }\n    }\n}\n\n#[test]\nfn test_select_from_str() {\n    let errors = [\n        (\"\", SelectParseError::Empty),\n        (\"a\", SelectParseError::InvalidSelect(\"a\".to_string())),\n        (\n            \"a:\",\n            SelectParseError::InvalidVariant(\"a\".to_string(), \"a:\".to_string()),\n        ),\n        (\"subset:\", SelectParseError::EmptyOptionForVariant(\"subset\")),\n        (\n            \"exclude:\",\n            SelectParseError::EmptyOptionForVariant(\"exclude\"),\n        ),\n        (\"rename:\", SelectParseError::EmptyOptionForVariant(\"rename\")),\n        (\n            \"rename:a,b\",\n            SelectParseError::InvalidRename(\"a\".to_string(), \"rename:a,b\".to_string()),\n        ),\n    ];\n    for (s, e) in errors {\n        let ee = Select::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let selects = [\n        (\n            \"subset:a,b\",\n            Select::subset(vec![\"a\".to_string(), \"b\".to_string()]),\n        ),\n        (\n            \"exclude:a,b\",\n            Select::exclude(vec![\"a\".to_string(), \"b\".to_string()]),\n        ),\n        (\"rename:a=b,c=d\", Select::rename([(\"a\", \"b\"), (\"c\", \"d\")])),\n    ];\n    for (s, a) in selects {\n        let aa = Select::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\n#[serde(tag = \"action\")]\npub enum Action {\n    Select(Select),\n    AddTag(AddTag),\n    RenameTable(RenameOpts),\n    RenameChildTable(RenameOpts),\n    RenameSuperTable(RenameOpts),\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum ActionParseError {\n    #[error(\"Empty action option is not valid\")]\n    EmptyAction,\n    #[error(\"Invalid action: {0}, use `\u003caction\u003e:\u003coption\u003e` format\")]\n    FormatError(String),\n    #[error(\"Unsupported action type: {0}\")]\n    Unsupported(String),\n    #[error(\"AddTag parse error: {0}\")]\n    AddTagError(#[from] AddTagParseError),\n    #[error(\"Select parse error: {0}\")]\n    SelectError(#[from] SelectParseError),\n    #[error(\"Rename parse error: {0}\")]\n    RenameError(#[from] RenameParseError),\n}\n\nimpl FromStr for Action {\n    type Err = ActionParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        use ActionParseError::*;\n        if s.is_empty() {\n            return Err(EmptyAction);\n        }\n        use convert_case::{Case, Casing};\n        let (action, option) = s.split_once(\":\").ok_or(FormatError(s.to_string()))?;\n        match action.to_case(Case::Pascal).as_str() {\n            \"AddTag\" =\u003e Ok(Action::AddTag(AddTag::from_str(option)?)),\n            \"Select\" =\u003e Ok(Action::Select(Select::from_str(option)?)),\n            \"RenameTable\" =\u003e Ok(Action::RenameTable(RenameOpts::from_str(option)?)),\n            \"RenameSuperTable\" =\u003e Ok(Action::RenameSuperTable(RenameOpts::from_str(option)?)),\n            \"RenameChildTable\" =\u003e Ok(Action::RenameChildTable(RenameOpts::from_str(option)?)),\n            _ =\u003e Err(Unsupported(action.to_string())),\n        }\n    }\n}\n\n#[test]\nfn test_action_from_str() {\n    use ActionParseError::*;\n    let errors = [\n        (\"\", EmptyAction),\n        (\"a\", FormatError(\"a\".to_string())),\n        (\"a:\", Unsupported(\"a\".to_string())),\n        (\"add-tag:\", AddTagError(AddTagParseError::Empty)),\n        (\"select:\", SelectError(SelectParseError::Empty)),\n        (\"rename-table:\", RenameError(RenameParseError::Empty)),\n    ];\n    for (s, e) in errors {\n        let ee = Action::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let actions = [\n        (\n            \"add-tag:a=b\",\n            Action::AddTag(AddTag {\n                name: \"a\".to_string(),\n                len: 100,\n                opts: AddTagOpts::value(\"b\"),\n            }),\n        ),\n        (\n            \"select:subset:a,b\",\n            Action::Select(Select::subset(vec![\"a\".to_string(), \"b\".to_string()])),\n        ),\n        (\n            \"rename-table:template:v1_v1\",\n            Action::RenameTable(RenameOpts::template(\"v1_v1\")),\n        ),\n    ];\n    for (s, a) in actions {\n        let aa = Action::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\npub trait Transform {\n    fn transform(\u0026mut self, action: \u0026Action) -\u003e anyhow::Result\u003c()\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use anyhow::Result;\n    #[test]\n    fn action() -\u003e Result\u003c()\u003e {\n        let json = r#\"[\n            { \"action\": \"AddTag\", \"name\": \"f1\", \"value\": \"f2\" },\n            { \"action\": \"AddTag\", \"name\": \"f1\", \"template\": \"{{ host }}\" },\n            { \"action\": \"Select\", \"subset\": [\"a\", \"b\"] },\n            { \"action\": \"Select\", \"rename\": { \"a\": \"a1\", \"b\": \"b1\" } }\n        ]\"#;\n        let addtag: Vec\u003cAction\u003e = serde_json::from_str(json)?;\n        dbg!(addtag);\n        Ok(())\n    }\n\n    #[test]\n    fn test_trait() {\n        struct A;\n        impl Transform for A {\n            fn transform(\u0026mut self, _: \u0026Action) -\u003e anyhow::Result\u003c()\u003e {\n                Ok(())\n            }\n        }\n        let action = Action::from_str(\"select:subset:a,b,c\").unwrap();\n        let mut a = A;\n        a.transform(\u0026action).unwrap();\n    }\n}\n","traces":[{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","task","mod.rs"],"content":"use linked_hash_map::LinkedHashMap;\nuse serde_json::Value;\n\n///\n// {\n//   \"source\": [\n//     \"dsn1\",\n//     \"dsn2\"\n//   ],\n//   \"transformer\": {\n//     \"AddTag\": {\n//       \"city\": {\n//         \"fromOptions\": \"host\"\n//       }\n//     },\n//     \"AlterTable\": {\n//       \"prefix\": \"taosx_\"\n//     }\n//   },\n//   \"sink\": [\n//     \"sink1\",\n//     \"sink2\"\n//   ]\n// }\npub struct Task {\n    source: Vec\u003cSource\u003e,\n    transformer: Transformers,\n    sink: Vec\u003cSink\u003e,\n}\n\npub struct Source {\n    plugin: String,\n    dsn: String,\n    options: Value,\n}\n\npub struct Sink {\n    dsn: String,\n    options: LinkedHashMap\u003cString, String\u003e,\n}\n\nimpl Sink {\n    pub fn plugin\u003cT\u003e(\u0026self) -\u003e Box\u003cdyn SinkPlugin\u003cStream = T\u003e\u003e {\n        unimplemented!()\n    }\n}\n\npub trait SinkPlugin {\n    type Stream;\n\n    fn accepted_content(\u0026self) -\u003e Vec\u003cString\u003e;\n\n    fn consume(\u0026mut self, stream: Self::Stream);\n}\n\npub struct Transformers(LinkedHashMap\u003cString, TransformerOptions\u003e);\n\npub struct TransformerOptions(Value);\n\n#[cfg(test)]\nmod tests {\n    use futures::sink::{self, SinkExt};\n    use taos::prelude::*;\n\n    #[taos::test]\n    async fn sink_unfold(taos: \u0026Taos, database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n        let unfold = sink::unfold(0, |mut sum, i: i32| async move {\n            sum += i;\n            eprintln!(\"sum: {sum}, i = {}\", i);\n            Ok::\u003c_, futures::never::Never\u003e(sum)\n        });\n        futures::pin_mut!(unfold);\n        unfold.send(5).await?;\n        unfold.send(5).await?;\n        unfold.send(5).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","util","mod.rs"],"content":"use std::collections::HashMap;\n\nuse futures::prelude::*;\nuse log::info;\nuse serde::Deserialize;\nuse taos::prelude::{Error, Taos};\n\npub async fn sync_schema(from: \u0026Taos, to: \u0026Taos) -\u003e Result\u003c(), Error\u003e {\n    use taos::prelude::*;\n    let stables: Vec\u003cString\u003e = from\n        .query(\"show stables\")\n        .await?\n        .deserialize_stream()\n        .try_collect()\n        .await?;\n    let mut stable_fields = HashMap::new();\n    for stable in stables {\n        // todo: use \"show create\" sql?\n        // from.query(format!(\"show create stable {stable}\")).await?;\n        let desc = from.describe(\u0026stable).await?;\n        let sql = desc.to_create_table_sql(\u0026stable);\n        stable_fields.insert(stable, desc);\n        to.exec(sql).await?;\n    }\n\n    #[derive(Deserialize)]\n    struct Table {\n        table_name: String,\n        db_name: String,\n        stable_name: Option\u003cString\u003e,\n    }\n    let tables: Vec\u003cTable\u003e = from\n        .query(\"show tables\")\n        .await?\n        .deserialize_stream()\n        .try_collect()\n        .await?;\n    use itertools::Itertools;\n    for table in tables {\n        let table_name = \u0026table.table_name;\n        if let Some(stable) = table.stable_name {\n            let fields = \u0026stable_fields[\u0026stable];\n            let tags = fields.tag_names().collect_vec();\n            let names = fields.tag_names().join(\",\");\n            let fields: Vec\u003cValue\u003e = from\n                .query_one(format!(\n                    \"select {names} from {stable} where tbname = '{table_name}'\"\n                ))\n                .await?\n                .unwrap();\n\n            let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {table_name} using {stable} tags({tags_values})\"\n            ))\n            .await?;\n            // tags.iter().zip(fields).map(|(name, value)| format!(\"\"))\n            // let tags_stmt = tags.map(|_| '?').join(\",\");\n            // let mut stmt = to.stmt(format!(\"create table if not exists ? using ({tags_stmt})\"))?;\n            // stmt.set_tbname_tags(\u0026table.table_name, \u0026fields);\n        } else {\n            let desc = from.describe(table_name).await?;\n            let sql = desc.to_create_table_sql(table_name);\n            to.exec(sql).await?;\n        }\n    }\n\n    // let tables: Vec\u003c\n    Ok(())\n}\n\npub fn sync_table(from: \u0026Taos, to: \u0026Taos, db: \u0026str, table: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    use taos::prelude::sync::*;\n\n    let stable: Option\u003cString\u003e = from\n        .query_one(format!(\n            \"select stable_name from information_schema.user_tables where db_name = '{db}' and table_name = \\\"{table}\\\"\"\n        ))?\n        .unwrap();\n    use itertools::Itertools;\n\n    if let Some(stable) = stable {\n        let desc = from.describe(\u0026format!(\"{db}.`{stable}`\"))?;\n        let sql = desc.to_create_table_sql(\u0026stable);\n        to.exec(sql)?;\n\n        let names = desc.tag_names().join(\",\");\n        let children: Vec\u003cVec\u003cValue\u003e\u003e = from\n            .query(format!(\"select tbname,{names} from {stable}\"))?\n            .deserialize()\n            .try_collect()?;\n\n        // todo: use par_iter to speed up tables creation.\n        // todo: single table not work, blocked by https://jira.taosdata.com:18080/browse/TD-16117\n        for child in children {\n            let tbname = child[0].to_string().unwrap();\n            let tags_values = child[1..].into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {tbname} using {stable} tags({tags_values})\"\n            ))?;\n        }\n\n        // let fields: Vec\u003cValue\u003e = from\n        //     .query_one(format!(\n        //         \"select {names} from {stable} where tbname = '{table}'\"\n        //     ))?\n        //     .unwrap();\n\n        // let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n        // to.exec(format!(\n        //     \"create table if not exists {table} using {stable} tags({tags_values})\"\n        // ))?;\n    } else {\n        info!(\"describe table {table}\");\n        let desc = from.describe(\u0026format!(\"{db}.`{table}`\"))?;\n        info!(\"table {table}: {desc:?}\");\n        let sql = desc.to_create_table_sql(\u0026table);\n        info!(\"exec sql: {sql}\");\n        to.exec(sql)?;\n    }\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","benches","async_query.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\n\nuse taos::{Taos, TaosOptions};\n\nfn bench_query_sync0(taos: \u0026Taos) {\n    use taos::prelude::AsyncQueryable;\n    let _ = taos.query_sync(\"select * from log.logs\");\n}\n\nfn bench_query_sync1(taos: \u0026Taos) {\n    use taos::prelude::sync::Queryable;\n    let _ = taos.query(\"select * from log.logs\");\n}\n\nfn criterion_benchmark(c: \u0026mut Criterion) {\n    // Optionally include some setup\n    let taos = TaosOptions::new().build().unwrap();\n    let mut group = c.benchmark_group(\"query - do nothing\");\n    use criterion::*;\n    group.sampling_mode(SamplingMode::Linear);\n    group.measurement_time(std::time::Duration::from_secs(15));\n    use tokio::runtime;\n\n    let _rt = runtime::Runtime::new().unwrap();\n\n    group.bench_function(\"async\", |b| b.iter(|| bench_query_sync0(\u0026taos)));\n    group.bench_function(\"sync\", |b| b.iter(|| bench_query_sync1(\u0026taos)));\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","examples","benchmark-query.rs"],"content":"use anyhow::Result;\nuse taos::prelude::sync::*;\n\n// Refer to [Jira TD-15233](https://jira.taosdata.com:18080/browse/TD-15233)\nfn main() -\u003e Result\u003c()\u003e {\n    let taos = TaosOptions::new().database(\"abc1\").build()?;\n    let rs: (String, String) = taos\n        .query_one(\"select tbname, location from meters limit 1\")?\n        .unwrap();\n    dbg!(rs);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","examples","db-create-drop.rs"],"content":"use anyhow::Result;\nuse taos::prelude::sync::*;\n\n// Refer to [Jira TD-15233](https://jira.taosdata.com:18080/browse/TD-15233)\nfn main() -\u003e Result\u003c()\u003e {\n    let taos = TaosOptions::new().build()?;\n    taos.exec(\"create database abc\")?;\n    taos.exec(\"drop database abc\")?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","async_query.rs"],"content":"use std::{\n    ffi::c_void,\n    future::Future,\n    marker::PhantomData,\n    os::raw::c_int,\n    pin::Pin,\n    sync::Arc,\n    task::{Context, Poll, Waker},\n};\n\nuse std::sync::Mutex;\nuse taos_sys::ffi::TAOS_RES;\n\nuse crate::prelude::sync::ResultSet;\nuse crate::{util::IntoCStr, Result, Taos};\n\npub struct QueryFuture\u003c'query\u003e {\n    shared_state: Arc\u003cMutex\u003cSharedState\u003e\u003e,\n    _marker: PhantomData\u003c\u0026'query Taos\u003e,\n}\n\n/// Shared state between the future and the waiting thread\nstruct SharedState {\n    completed: bool,\n    result: *mut TAOS_RES,\n    code: i32,\n    waker: Option\u003cWaker\u003e,\n}\n\nunsafe impl Send for SharedState {}\nunsafe impl Sync for SharedState {}\n\nimpl Unpin for SharedState {}\nimpl\u003c'query\u003e Unpin for QueryFuture\u003c'query\u003e {}\nimpl\u003c'query\u003e Future for QueryFuture\u003c'query\u003e {\n    type Output = Result\u003cResultSet\u003e;\n    fn poll\u003c'a\u003e(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\n        // Look at the shared state to see if the timer has already completed.\n        let mut shared_state = self.shared_state.lock().unwrap();\n        if shared_state.completed {\n            Poll::Ready(Ok(ResultSet::from_ptr_with_code(\n                shared_state.result,\n                shared_state.code,\n            )?))\n        } else {\n            // Set waker so that the thread can wake up the current task\n            // when the timer has completed, ensuring that the future is polled\n            // again and sees that `completed = true`.\n            //\n            // It's tempting to do this once rather than repeatedly cloning\n            // the waker each time. However, the Future can move between\n            // tasks on the executor, which could cause a stale waker pointing\n            // to the wrong task, preventing from waking up\n            // correctly.\n            //\n            // N.B. it's possible to check for this using the `Waker::will_wake`\n            // function, but we omit that here to keep things simple.\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\nimpl\u003c'query\u003e QueryFuture\u003c'query\u003e {\n    /// Create a new `TimerFuture` which will complete after the provided\n    /// timeout.\n    pub fn new\u003c'a\u003e(taos: \u0026Taos, sql: impl IntoCStr\u003c'a\u003e) -\u003e Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            result: std::ptr::null_mut(),\n            code: 0,\n            waker: None,\n        }));\n\n        unsafe extern \"C\" fn async_query_callback(\n            param: *mut c_void,\n            res: *mut TAOS_RES,\n            code: c_int,\n        ) {\n            let param = param as *const Arc\u003cMutex\u003cSharedState\u003e\u003e;\n            let state = param.read();\n            let mut s = state.lock().unwrap();\n\n            (*s).completed = true;\n            (*s).result = res;\n            (*s).code = code;\n            if let Some(waker) = s.waker.take() {\n                waker.wake()\n            }\n        }\n\n        taos.0.query_a(\n            sql.into_c_str().as_ptr(),\n            async_query_callback as _,\n            Box::into_raw(Box::new(shared_state.clone())) as *mut _,\n        );\n\n        QueryFuture {\n            shared_state,\n            _marker: PhantomData,\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","block","mod.rs"],"content":"use std::{\n    ffi::c_void,\n    marker::PhantomData,\n    os::raw::c_int,\n    sync::{atomic::AtomicU64, Arc, Mutex, RwLock},\n    task::{Poll, Waker},\n};\n\nuse futures::Stream;\n\nuse taos_sys::ffi::*;\nuse taos_sys::*;\n\npub use taos_query::common::*;\n\nuse crate::impls::SyncBlock;\n\n#[derive(Debug)]\npub struct BlockStream {\n    raw: Arc\u003cRawRes\u003e,\n    summary: Arc\u003c(AtomicU64, AtomicU64)\u003e,\n    state: Arc\u003cMutex\u003cBlockState\u003e\u003e,\n}\n\nimpl BlockStream {\n    pub(crate) fn from_raw(raw: Arc\u003cRawRes\u003e, summary: Arc\u003c(AtomicU64, AtomicU64)\u003e) -\u003e Self {\n        let state = Arc::new(Mutex::new(BlockState {\n            completed: false,\n            result: std::ptr::null_mut(),\n            num_of_rows: 0,\n            waker: None,\n        }));\n\n        Self {\n            raw,\n            state,\n            summary,\n        }\n    }\n    pub(crate) fn append_num_of_rows(\u0026self, num_of_rows: i32) {\n        use std::sync::atomic::Ordering::SeqCst;\n        self.summary.0.fetch_add(1, SeqCst);\n        self.summary.1.fetch_add(num_of_rows as _, SeqCst);\n    }\n}\n\nunsafe impl Send for BlockStream {}\nunsafe impl Sync for BlockStream {}\n\n#[derive(Debug)]\nstruct BlockState {\n    /// Whether or not the sleep time has elapsed\n    completed: bool,\n    result: *mut TAOS_RES,\n    num_of_rows: i32,\n    waker: Option\u003cWaker\u003e,\n}\n\nimpl Stream for BlockStream {\n    // type Item = (*mut TAOS_RES, i32);\n    type Item = SyncBlock;\n\n    fn poll_next(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        // todo(3.0): remove these line to use taos_query_a in async/await impl.\n        if crate::client_info().starts_with(\"3\") {\n            let block = if let Ok(Some((data, num_of_rows, lengths))) = self.raw.fetch_block() {\n                log::trace!(\"fetch block: {num_of_rows}\");\n\n                self.append_num_of_rows(num_of_rows);\n\n                Some(SyncBlock {\n                    raw: self.raw.clone(),\n                    fields: None,\n                    precision: self.raw.precision(),\n                    data,\n                    lengths,\n                    num_of_rows: num_of_rows as _,\n                })\n            } else {\n                None\n            };\n            return Poll::Ready(block);\n        }\n\n        let mut s = self.state.lock().unwrap();\n        unsafe extern \"C\" fn async_fetch_callback(\n            param: *mut c_void,\n            res: *mut TAOS_RES,\n            num_of_rows: c_int,\n        ) {\n            let param = param as *const Arc\u003cMutex\u003cBlockState\u003e\u003e;\n            let state = param.read();\n            let mut s = state.lock().unwrap();\n\n            (*s).completed = true;\n            (*s).result = res;\n            (*s).num_of_rows = num_of_rows;\n            if let Some(waker) = s.waker.take() {\n                waker.wake()\n            }\n        }\n\n        if s.completed \u0026\u0026 s.num_of_rows != 0 {\n            let num_of_rows = s.num_of_rows;\n            s.completed = false;\n            s.num_of_rows = 0;\n            drop(s);\n\n            self.append_num_of_rows(num_of_rows);\n\n            // Wake up poll.\n            Poll::Ready(Self::Item::from_async_query(\n                self.raw.clone(),\n                self.raw.block(),\n                num_of_rows,\n            ))\n        } else if s.completed \u0026\u0026 s.num_of_rows == 0 {\n            Poll::Ready(None)\n        } else {\n            let res = if s.result.is_null() {\n                self.raw.as_ptr()\n            } else {\n                s.result\n            };\n            s.waker = Some(cx.waker().clone());\n            drop(s);\n\n            unsafe {\n                taos_fetch_rows_a(\n                    res,\n                    async_fetch_callback as _,\n                    Box::into_raw(Box::new(self.state.clone())) as *mut _,\n                );\n            }\n            Poll::Pending\n        }\n    }\n}\n","traces":[{"line":26,"address":[3686113,3685840,3686140],"length":1,"stats":{"Line":0},"fn_name":"from_raw"},{"line":27,"address":[3685975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3685963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[3686160],"length":1,"stats":{"Line":0},"fn_name":"append_num_of_rows"},{"line":42,"address":[3686182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[3686227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3687516,3686288,3687483],"length":1,"stats":{"Line":0},"fn_name":"poll_next"},{"line":68,"address":[3686335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3687478,3686462,3686560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[3686835,3686624,3686738,3686929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3686899,3687110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[3687357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3687124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[3687194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3687285,3687206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3687349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3686549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3687572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3687648,3686435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[3689890,3689440],"length":1,"stats":{"Line":0},"fn_name":"async_fetch_callback"},{"line":94,"address":[3689479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3689495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3689573,3689506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3689706,3689639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3689710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3689744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3689916,3689777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3689956,3690017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[3687843,3687735,3688443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[3687950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3688002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3688041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[3688083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3688118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3688378,3688425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3688167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[3688245,3688321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3688632,3687920,3688494,3689369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3688603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3688571,3688642,3688805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3688694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3688794,3688670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3688777,3688812,3689081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3689046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3689103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3689312,3689116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3689362],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","helpers","mod.rs"],"content":"// mod describe;\n// pub use describe::*;\n\n// mod database;\n// pub use database::*;\npub use taos_query::helpers::*;\n\n#[cfg(feature = \"test\")]\npub mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","helpers","tests.rs"],"content":"use std::{io::Write, ops::Deref, str::FromStr, sync::Once};\n\nuse log::Level;\nuse pretty_env_logger::env_logger::fmt::{Color, StyledValue};\n\nuse crate::prelude::sync::*;\n\nuse anyhow::Result;\n\nuse taos_query::common::Precision;\n\n/// Used in [test(naming = \"uuid-v1\")] macro to choose database naming strategy\n#[derive(Debug)]\npub enum NamingStrategy {\n    Random,\n    UuidV1,\n    Named(String),\n}\n\nimpl NamingStrategy {\n    fn name(\u0026self) -\u003e String {\n        use NamingStrategy::*;\n        match self {\n            Random =\u003e {\n                // randomly generate\n                use faker_rand::lorem::Word;\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option\u003cThreadRng\u003e = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let rng = unsafe { RNG.as_mut().unwrap() };\n                String::from_iter([rng.gen::\u003cWord\u003e().to_string(), rng.gen::\u003cWord\u003e().to_string()])\n            }\n            UuidV1 =\u003e {\n                // time-based uuid generator\n                use uuid::v1::{Context, Timestamp};\n                use uuid::Uuid;\n\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option\u003cThreadRng\u003e = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let context = Context::new(unsafe { RNG.as_mut().unwrap().gen() });\n                let dur = std::time::SystemTime::now()\n                    .duration_since(std::time::SystemTime::UNIX_EPOCH)\n                    .expect(\"\");\n                let ts = Timestamp::from_unix(\u0026context, dur.as_secs(), dur.subsec_nanos());\n\n                let mut node = [0u8; 6];\n                for i in 0..6 {\n                    node[i] = unsafe { RNG.as_mut().unwrap() }.gen();\n                }\n                let mut uuid: Vec\u003c_\u003e = Uuid::new_v1(ts, \u0026node)\n                    .as_hyphenated()\n                    .to_string()\n                    .replace(\"-\", \"\")\n                    .chars()\n                    .collect();\n                for _ in 0..uuid.len() {\n                    if uuid[0].is_alphabetic() {\n                        log::trace!(\n                            \"create database with name: {}\",\n                            String::from_iter(uuid.clone())\n                        );\n                        break;\n                    } else {\n                        uuid.rotate_left(1);\n                    }\n                }\n                if uuid[0].is_alphabetic() {\n                    String::from_iter(uuid)\n                } else {\n                    self.name()\n                }\n            }\n            Named(name) =\u003e name.clone(),\n        }\n    }\n}\n\nimpl Iterator for NamingStrategy {\n    type Item = String;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        Some(self.name())\n    }\n}\n\nimpl Default for NamingStrategy {\n    fn default() -\u003e Self {\n        NamingStrategy::UuidV1\n    }\n}\n\nimpl From\u003c()\u003e for NamingStrategy {\n    fn from(_: ()) -\u003e Self {\n        NamingStrategy::default()\n    }\n}\n\nimpl From\u003c\u0026str\u003e for NamingStrategy {\n    fn from(s: \u0026str) -\u003e Self {\n        match s {\n            \"random\" =\u003e NamingStrategy::Random,\n            \"uuid-v1\" | \"uuidv1\" | \"UuidV1\" =\u003e NamingStrategy::UuidV1,\n            _ =\u003e NamingStrategy::Named(s.to_string()),\n        }\n    }\n}\nimpl From\u003cString\u003e for NamingStrategy {\n    fn from(s: String) -\u003e Self {\n        match s.as_str() {\n            \"random\" =\u003e NamingStrategy::Random,\n            \"uuid-v1\" | \"uuidv1\" | \"UuidV1\" =\u003e NamingStrategy::UuidV1,\n            _ =\u003e NamingStrategy::Named(s),\n        }\n    }\n}\n\n#[derive(Debug)]\n/// Used in [test(drop = \"\u003cstrategy\u003e\")] macro to make sure to drop before/after test.\npub enum DroppingStrategy {\n    None,\n    Before,\n    After,\n    Always,\n}\n\nimpl DroppingStrategy {\n    fn drop_after(\u0026self) -\u003e bool {\n        use DroppingStrategy::*;\n        matches!(self, After | Always)\n    }\n    fn drop_before(\u0026self) -\u003e bool {\n        use DroppingStrategy::*;\n        matches!(self, Before | Always)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for DroppingStrategy {\n    fn from(s: \u0026str) -\u003e Self {\n        match s.as_ref() {\n            \"none\" =\u003e DroppingStrategy::None,\n            \"before\" =\u003e DroppingStrategy::Before,\n            \"after\" =\u003e DroppingStrategy::After,\n            \"always\" =\u003e DroppingStrategy::Always,\n            _ =\u003e unreachable!(\"invalid drop strategy used in [test] macro\"),\n        }\n    }\n}\n\nimpl From\u003cString\u003e for DroppingStrategy {\n    fn from(s: String) -\u003e Self {\n        Self::from(s.as_str())\n    }\n}\n\nimpl From\u003c()\u003e for DroppingStrategy {\n    fn from(_: ()) -\u003e Self {\n        DroppingStrategy::default()\n    }\n}\n\nimpl Default for DroppingStrategy {\n    fn default() -\u003e Self {\n        DroppingStrategy::Always\n    }\n}\n\n#[derive(Debug)]\npub enum PrecisionStrategy {\n    Preset(Precision),\n    Random,\n    Cyclic,\n}\n\nimpl PrecisionStrategy {\n    fn precision(\u0026self) -\u003e Precision {\n        use PrecisionStrategy::*;\n        match self {\n            Preset(p) =\u003e p.clone(),\n            Random =\u003e {\n                //\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option\u003cThreadRng\u003e = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let rng = unsafe { RNG.as_mut().unwrap() };\n                rng.gen::\u003cu8\u003e().into()\n            }\n            Cyclic =\u003e {\n                static mut ITER: u64 = 0;\n                let p = match unsafe { ITER % 3 } {\n                    0 =\u003e Precision::Millisecond,\n                    1 =\u003e Precision::Microsecond,\n                    2 =\u003e Precision::Nanosecond,\n                    _ =\u003e unreachable!(),\n                };\n                unsafe { ITER += 1 };\n                p\n            }\n        }\n    }\n}\n\nimpl Iterator for PrecisionStrategy {\n    type Item = Precision;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        Some(self.precision())\n    }\n}\n\nimpl From\u003c()\u003e for PrecisionStrategy {\n    fn from(_: ()) -\u003e Self {\n        PrecisionStrategy::default()\n    }\n}\n\nimpl Default for PrecisionStrategy {\n    fn default() -\u003e Self {\n        PrecisionStrategy::Preset(Precision::Millisecond)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for PrecisionStrategy {\n    fn from(s: \u0026str) -\u003e Self {\n        PrecisionStrategy::from_str(s).expect(\u0026format!(\"invalid precision strategy: {}\", s))\n    }\n}\n\nimpl FromStr for PrecisionStrategy {\n    type Err = crate::Error;\n\n    fn from_str(s: \u0026str) -\u003e crate::Result\u003cSelf\u003e {\n        use PrecisionStrategy::*;\n        match Precision::from_str(s) {\n            Ok(p) =\u003e Ok(Preset(p)),\n            Err(_) =\u003e match s {\n                \"random\" =\u003e Ok(Random),\n                \"cyclic\" =\u003e Ok(Cyclic),\n                _ =\u003e Err(err!('str \"unsupported strategy {}\")),\n            },\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum LogLevel {\n    /// Default,\n    Default,\n    /// A level lower than all log levels.\n    Off,\n    /// Corresponds to the `Error` log level.\n    Error,\n    /// Corresponds to the `Warn` log level.\n    Warn,\n    /// Corresponds to the `Info` log level.\n    Info,\n    /// Corresponds to the `Debug` log level.\n    Debug,\n    /// Corresponds to the `Trace` log level.\n    Trace,\n}\n\nimpl LogLevel {\n    fn to_log_level_filter(\u0026self) -\u003e Option\u003clog::LevelFilter\u003e {\n        use LogLevel::*;\n        match self {\n            Default =\u003e None,\n            Off =\u003e Some(log::LevelFilter::Off),\n            Error =\u003e Some(log::LevelFilter::Error),\n            Warn =\u003e Some(log::LevelFilter::Warn),\n            Info =\u003e Some(log::LevelFilter::Info),\n            Debug =\u003e Some(log::LevelFilter::Debug),\n            Trace =\u003e Some(log::LevelFilter::Trace),\n        }\n    }\n}\nimpl Default for LogLevel {\n    fn default() -\u003e Self {\n        LogLevel::Default\n    }\n}\n\nimpl From\u003c\u0026str\u003e for LogLevel {\n    fn from(s: \u0026str) -\u003e Self {\n        use LogLevel::*;\n        match s {\n            \"off\" =\u003e Off,\n            \"error\" =\u003e Error,\n            \"warn\" =\u003e Warn,\n            \"info\" =\u003e Info,\n            \"debug\" =\u003e Debug,\n            \"trace\" =\u003e Trace,\n            _ =\u003e Off,\n        }\n    }\n}\n\nimpl From\u003c()\u003e for LogLevel {\n    fn from(_: ()) -\u003e Self {\n        Self::default()\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Common {\n    log_level: LogLevel,\n}\n\nimpl Common {\n    pub fn log_level(mut self, level: impl Into\u003cLogLevel\u003e) -\u003e Self {\n        self.log_level = level.into();\n        self\n    }\n\n    pub fn init(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"* common init started\");\n        static LOGGER_INIT: Once = Once::new();\n        LOGGER_INIT.call_once(|| {\n            let mut builder = pretty_env_logger::formatted_timed_builder();\n            if let Some(lv) = self.log_level.to_log_level_filter() {\n                builder.filter_level(lv);\n            } else {\n                if let Ok(s) = ::std::env::var(\"RUST_LOG\") {\n                    builder.parse_filters(\u0026s);\n                }\n            }\n            builder\n                .format_module_path(true)\n                .format(|buf, record| -\u003e std::result::Result\u003c(), std::io::Error\u003e {\n                    fn colored_level\u003c'a\u003e(\n                        style: \u0026'a mut pretty_env_logger::env_logger::fmt::Style,\n                        level: Level,\n                    ) -\u003e StyledValue\u003c'a, \u0026'static str\u003e {\n                        match level {\n                            Level::Trace =\u003e style.set_color(Color::Magenta).value(\"TRACE\"),\n                            Level::Debug =\u003e style.set_color(Color::Blue).value(\"DEBUG\"),\n                            Level::Info =\u003e style.set_color(Color::Green).value(\"INFO\"),\n                            Level::Warn =\u003e style.set_color(Color::Yellow).value(\"WARN \"),\n                            Level::Error =\u003e style.set_color(Color::Red).value(\"ERROR\"),\n                        }\n                    }\n                    let mut style = buf.style();\n                    let level = colored_level(\u0026mut style, record.level());\n                    let mut mod_path = buf.style();\n\n                    let mod_path = mod_path.set_bold(true).value(format!(\n                        \"{}:{}\",\n                        record.file().unwrap_or(\"unknown\"),\n                        record.line().unwrap_or(0),\n                    ));\n                    writeln!(\n                        buf,\n                        \"[{:29} {: \u003c5}] {} \u003e {}\",\n                        chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                        level,\n                        mod_path,\n                        record.args()\n                    )\n                })\n                // .is_test(true)\n                .init();\n        });\n        log::info!(\"common init done\");\n        Ok(())\n    }\n}\n#[derive(Debug, Default)]\n\npub struct Builder {\n    naming: NamingStrategy,\n    precision: PrecisionStrategy,\n    dropping: DroppingStrategy,\n    databases: usize,\n}\nimpl Builder {\n    pub fn new(\n        naming: impl Into\u003cNamingStrategy\u003e,\n        drop: impl Into\u003cDroppingStrategy\u003e,\n        precision: impl Into\u003cPrecisionStrategy\u003e,\n        databases: usize,\n    ) -\u003e Self {\n        Self {\n            naming: naming.into(),\n            precision: precision.into(),\n            dropping: drop.into(),\n            databases,\n        }\n    }\n\n    pub fn naming(mut self, naming: impl Into\u003cNamingStrategy\u003e) -\u003e Self {\n        self.naming = naming.into();\n        self\n    }\n    pub fn dropping(mut self, drop: impl Into\u003cDroppingStrategy\u003e) -\u003e Self {\n        self.dropping = drop.into();\n        self\n    }\n    pub fn precision(mut self, precision: impl Into\u003cPrecisionStrategy\u003e) -\u003e Self {\n        self.precision = precision.into();\n        self\n    }\n    pub fn databases(mut self, databases: usize) -\u003e Self {\n        self.databases = databases.into();\n        self\n    }\n\n    pub fn build(self) -\u003e Result\u003cTaosWrapper\u003e {\n        let opts = TaosOptions::new();\n        log::trace!(\"use options: {opts:#?}\");\n\n        let taos = opts.build()?;\n        log::info!(\"connected\");\n\n        let db: Vec\u003c_\u003e = self\n            .naming\n            .into_iter()\n            .zip(self.precision.into_iter())\n            .take(self.databases)\n            .collect();\n        let mut used = false;\n        for (name, precision) in \u0026db {\n            if self.dropping.drop_before() {\n                taos.exec(format!(\"drop database if exists {}\", name))?;\n            }\n            taos.exec(format!(\n                \"create database if not exists {} precision '{}' keep 36500\",\n                name, precision\n            ))?;\n            if !used {\n                taos.exec(format!(\"use {}\", name))?;\n                used = true;\n            }\n        }\n        Ok(TaosWrapper {\n            taos,\n            db,\n            drop: self.dropping,\n        })\n    }\n}\n\npub struct TaosWrapper {\n    taos: Taos,\n    db: Vec\u003c(String, Precision)\u003e,\n    drop: DroppingStrategy,\n}\n\nimpl Deref for TaosWrapper {\n    type Target = Taos;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.taos\n    }\n}\n\nimpl Drop for TaosWrapper {\n    fn drop(\u0026mut self) {\n        self.clean().unwrap();\n    }\n}\n\nimpl TaosWrapper {\n    pub fn taos(\u0026self) -\u003e \u0026Taos {\n        \u0026self.taos\n    }\n\n    pub fn databases_with_precision(\u0026self) -\u003e \u0026[(String, Precision)] {\n        \u0026self.db\n    }\n\n    pub fn databases(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.db.iter().map(|v| v.0.as_str()).collect()\n    }\n\n    pub fn default_database(\u0026self) -\u003e \u0026str {\n        \u0026self.db[0].0\n    }\n\n    fn clean(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.drop.drop_after() {\n            for (name, _) in \u0026self.db {\n                log::trace!(\"drop database: {}\", name);\n                self.taos\n                    .exec(format!(\"drop database if exists {}\", name))?;\n                log::trace!(\"dropped database: {}\", name);\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":21,"address":[3801008,3802275],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":23,"address":[3801047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3801093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[3754929,3754852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3803420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[3803474,3803564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3801134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3755041,3754964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[3801222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3801319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[3801428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3801530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3801880,3801550,3801742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3801893,3801766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3801712,3801916,3802190,3802050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3802399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3802647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3802982,3802866,3802742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3802928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[3803214,3802710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[3803240,3802609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3803294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[3803279,3803367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3801188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3803872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":91,"address":[3803891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3803952],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":97,"address":[3803955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3803968],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":103,"address":[3803980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3804000],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":110,"address":[3804050,3804119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3804091,3804140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3804254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[3804320,3804639],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":118,"address":[3804347,3804419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3804506,3804435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3804533,3804478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3804672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3804768],"length":1,"stats":{"Line":0},"fn_name":"drop_after"},{"line":138,"address":[3804777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3804832],"length":1,"stats":{"Line":0},"fn_name":"drop_before"},{"line":142,"address":[3804841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[3804880],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":148,"address":[3804903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[3804992,3804928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[3805052,3804969,3805013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[3805102,3805063,3805029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[3805155,3805079,3805113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[3805264,3805360],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":160,"address":[3805332,3805273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3805392],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":166,"address":[3805396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3805424],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":172,"address":[3805428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3805440],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":186,"address":[3805454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3805508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[3755125,3755072],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":195,"address":[3755076,3755153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3805779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3805830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[3805562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3805667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[3805677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3805687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3805695,3805740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3805730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3805872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":219,"address":[3805881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[3805920],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":225,"address":[3805924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[3805952],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":231,"address":[3805956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3805984,3806250],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":237,"address":[3806001,3806276,3806401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[3806432,3806782],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":246,"address":[3806475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[3806506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[3806661,3806617,3806549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3806633,3806730,3806691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3806750,3806697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[3806832],"length":1,"stats":{"Line":1},"fn_name":"to_log_level_filter"},{"line":278,"address":[3806841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[3806870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[3806881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3806892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3806903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[3806914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3806925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3806936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[3806960],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":291,"address":[3806964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[3806976],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":299,"address":[3807000,3807064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[3807121,3807082,3807041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[3807098,3807132,3807171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[3807221,3807182,3807148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[3807274,3807235,3807198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[3807251,3807288,3807304],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[3807294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3807328],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":312,"address":[3807332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[3286720,3286768],"length":1,"stats":{"Line":2},"fn_name":"log_level\u003c()\u003e"},{"line":323,"address":[3286731,3286809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[3286748,3286826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[3807360],"length":1,"stats":{"Line":1},"fn_name":"init"},{"line":328,"address":[3807380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[3755583,3755184,3755793],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":331,"address":[3755204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[3755286,3755694,3755228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[3755741,3755343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3755362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[3755548,3755460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[3755715,3755748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[3755824,3757345,3757217],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":342,"address":[3807712],"length":1,"stats":{"Line":0},"fn_name":"colored_level"},{"line":346,"address":[3807747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[3807903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[3807974,3807876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3807849,3808004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[3808034,3807819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[3807789,3808064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3755871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[3755893,3755976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[3755991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[3756051,3756242,3756386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[3756132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[3756317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[3756716,3756952,3757228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3756677,3756614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[3756927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[3807551,3807614,3807460],"length":1,"stats":{"Line":4},"fn_name":null},{"line":376,"address":[3807592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":414,"address":[3808096,3808220],"length":1,"stats":{"Line":0},"fn_name":"databases"},{"line":415,"address":[3808196,3808133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[3808200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[3809727,3811598,3808256],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":420,"address":[3808293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[3808657,3808563,3808466,3808377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[3808627,3808863,3808977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[3809306,3808933,3809436,3809209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[3809623,3809678,3809378,3809738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[3809558,3809666,3809705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[3809674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[3809765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[3809868,3809773,3810134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[3810497,3810170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[3810239,3810502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[3810201,3811087,3810703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[3810977,3811391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[3811396,3811137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[3811383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[3810014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[3809971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[3809979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3810011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[3811632],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":469,"address":[3723040],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":470,"address":[3723049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[3811648],"length":1,"stats":{"Line":0},"fn_name":"taos"},{"line":479,"address":[3811664],"length":1,"stats":{"Line":0},"fn_name":"databases_with_precision"},{"line":480,"address":[3811673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[3811712],"length":1,"stats":{"Line":0},"fn_name":"databases"},{"line":484,"address":[3757401,3757376],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":487,"address":[3811856],"length":1,"stats":{"Line":0},"fn_name":"default_database"},{"line":488,"address":[3811865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[3811936],"length":1,"stats":{"Line":0},"fn_name":"clean"},{"line":492,"address":[3811956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[3811998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[3812296,3812101,3812201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[3812582,3812755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[3812267,3812455,3812699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[3812860,3812661,3812800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[3811979],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":175},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","impls","asyncs.rs"],"content":"use std::ffi::c_void;\nuse std::os::raw::c_int;\n\nuse async_trait::async_trait;\n\nuse taos_query::common::*;\nuse taos_query::{AsyncFetchable, AsyncQueryable};\nuse taos_sys::DroppableRawRes;\n\nuse super::ResultSet;\nuse crate::util::IntoCStr;\nuse crate::Taos;\n\nimpl AsyncFetchable for ResultSet {\n    type BlockStream = crate::block::BlockStream;\n\n    #[inline]\n    fn affected_rows(\u0026self) -\u003e i32 {\n        self.raw.affected_rows()\n    }\n\n    #[inline]\n    fn precision(\u0026self) -\u003e Precision {\n        self.raw.precision()\n    }\n\n    #[inline]\n    fn fields(\u0026self) -\u003e \u0026[Field] {\n        \u0026self.raw.fields()\n    }\n\n    #[inline]\n    fn summary(\u0026self) -\u003e (usize, usize) {\n        use std::sync::atomic::Ordering::SeqCst;\n        (\n            self.summary.0.load(SeqCst) as _,\n            self.summary.1.load(SeqCst) as _,\n        )\n    }\n\n    #[inline]\n    fn block_stream(\u0026mut self) -\u003e Self::BlockStream {\n        crate::block::BlockStream::from_raw(self.raw.raw(), self.summary.clone())\n    }\n}\n\n#[async_trait]\nimpl\u003c'q\u003e AsyncQueryable\u003c'q\u003e for Taos {\n    type Error = super::Error;\n\n    type AsyncResultSet = ResultSet;\n\n    /// Query use taosc query_a API.\n    async fn query\u003cT: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cSelf::AsyncResultSet, Self::Error\u003e {\n        // todo(3.0): remove these line to use taos_query_a in async/await impl.\n        if crate::client_info().starts_with(\"3\") {\n            let raw = self.0.query(sql.as_ref())?;\n            return Ok(ResultSet::new(raw));\n        }\n        use tokio::sync::oneshot::{channel, Sender};\n        let (sender, rx) = channel::\u003cResult\u003cSelf::AsyncResultSet, taos_error::Error\u003e\u003e();\n\n        pub unsafe extern \"C\" fn async_query_callback(\n            param: *mut c_void,\n            ptr: *mut c_void,\n            code: c_int,\n        ) {\n            let sender = param as *mut Sender\u003c_\u003e;\n            let sender = Box::from_raw(sender);\n            let code = if code \u003e 0 { 0 } else { code };\n            let res = DroppableRawRes::from_ptr_with_code(ptr, code.into()).map(ResultSet::new);\n\n            log::trace!(\n                \"in async query callback, got TAOS_RES: {res:?}, will be send to:{sender:?}\"\n            );\n\n            sender.send(res).unwrap();\n            log::trace!(\"ptr: {ptr:#?}, code: {code}\");\n        }\n        self.0.query_a(\n            sql.as_ref().into_c_str().as_ptr(),\n            async_query_callback as _,\n            Box::into_raw(Box::new(sender)) as *mut _,\n        );\n        Ok(rx.await.unwrap()?)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use anyhow::Result;\n    use taos_macros::test;\n\n    #[test(log_level = \"info\")]\n    async fn async_query_de(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        use taos_query::{AsyncFetchable, AsyncQueryable};\n        taos.exec(\n            \"create table tb1 (ts timestamp, level tinyint, content varchar(100),\\\n             dnode_id int, dnode_ep varchar(100))\",\n        )\n        .await?;\n        taos.exec(\"insert into tb1 values(now, 1, '', 1, 'abc')\")\n            .await?;\n        let mut rs = \u003cTaos as AsyncQueryable\u003e::query(taos, \"select * from tb1\").await?;\n\n        assert!(rs.fields().len() == 5);\n        #[derive(Debug, serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Record {\n            ts: String,\n            level: i8,\n            content: String,\n            dnode_id: i32,\n            dnode_ep: String,\n        }\n\n        use futures::prelude::stream::*;\n        use taos_query::BlockExt;\n        while let Some(block) = rs.block_stream().next().await {\n            let des = itertools::Itertools::collect_vec(\n                block.deserialize::\u003c(i64, i32, \u0026str, i32, String)\u003e().take(1),\n            );\n            log::info!(\"first row in block: {:?}\", des);\n        }\n        let (blocks, records) = rs.summary();\n        println!(\"total blocks: {}, total rows: {}\", blocks, records);\n        assert!(records \u003c= 10000);\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[3482160],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":19,"address":[3482169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[3482208],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":24,"address":[3482217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3482256],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":29,"address":[3482265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[3482320],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":36,"address":[3482334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3482379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3482639,3482464,3482611],"length":1,"stats":{"Line":0},"fn_name":"block_stream"},{"line":43,"address":[3482623,3482496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3783280,3783552],"length":1,"stats":{"Line":0},"fn_name":"query\u003calloc::string::String\u003e"},{"line":59,"address":[3997539,3994792,3997448,3994859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3995019,3997695,3997830,3997621,3994941,3995154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3998039,3995363,3997792,3995116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3997582,3995481,3998178,3994902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4011072,4012468,4012517],"length":1,"stats":{"Line":0},"fn_name":"async_query_callback"},{"line":71,"address":[4011109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4011133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4011162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4011194,4011291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4011531,4011700,4011345,4011434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4011595,4011948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4011974,4012098,4012183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3995901,3998594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3995584,3995703,3998277,3995505,3998202,3998396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[3995867,3998560,3998408,3995715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3705342,3706047],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","impls","mod.rs"],"content":"use std::{\n    ffi::c_void,\n    slice,\n    sync::{atomic::AtomicU64, Arc},\n};\n\nuse bitvec_simd::BitVec;\nuse itertools::Itertools;\nuse mdsn::IntoDsn;\nuse taos_error::Code;\nuse thiserror::Error;\n\nuse taos_query::{common::*, Address, BlockExt, Dsn, DsnError, Fetchable, FromDsn, Queryable};\nuse taos_sys::{DroppableRawRes, RawRes, ffi::TAOS_RES};\n\nuse crate::{util::IntoCStr, Taos, TaosOptions};\n\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"Parse dsn error: {0}\")]\n    DsnError(#[from] DsnError),\n    #[error(\"Internal error: {0}\")]\n    Driver(#[from] taos_error::Error),\n    #[error(\"Deserialization error {0}\")]\n    Deserialize(#[from] serde::de::value::Error),\n    #[error(\"Invalid topic: {0}\")]\n    InvalidTopic(String),\n    #[error(\"Invalid database: {0}\")]\n    InvalidDatabase(String),\n    #[error(\"Error: {0}\")]\n    Custom(String),\n    #[error(transparent)]\n    Other(#[from] anyhow::Error),\n}\n\nimpl Error {\n    pub(crate) fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::Custom(format!(\"{msg}\"))\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::Custom(format!(\"{msg}\"))\n    }\n}\n\n// A result should not be clone-able.\n// Result set live shorter than query lifetime.\n#[derive(Debug)]\npub struct ResultSet {\n    raw: DroppableRawRes,\n    independent: bool,\n    summary: Arc\u003c(AtomicU64, AtomicU64)\u003e,\n}\n\nimpl ResultSet {\n    pub(crate) fn from_ptr(ptr: *mut c_void) -\u003e Result\u003cSelf, taos_error::Error\u003e {\n        let raw = RawRes::from_ptr(ptr).map(DroppableRawRes::new)?;\n        Ok(ResultSet {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        })\n    }\n    pub(crate) fn from_ptr_with_code(\n        ptr: *mut c_void,\n        code: impl Into\u003cCode\u003e,\n    ) -\u003e Result\u003cSelf, taos_error::Error\u003e {\n        let raw = RawRes::from_ptr_with_code(ptr, code.into()).map(DroppableRawRes::new)?;\n        Ok(ResultSet {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        })\n    }\n\n    pub(crate) fn as_ptr(\u0026self) -\u003e *mut TAOS_RES {\n        self.raw.as_ptr()\n    }\n\n    pub(crate) fn from_raw_res(raw: RawRes) -\u003e Self {\n        Self {\n            raw: DroppableRawRes::new(raw),\n            independent: false,\n            summary: Default::default(),\n        }\n    }\n\n    pub(crate) fn new(raw: DroppableRawRes) -\u003e Self {\n        Self {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        }\n    }\n\n    pub(crate) fn independent(mut self) -\u003e Self {\n        self.independent = true;\n        self\n    }\n\n    pub(crate) fn append_num_of_rows(\u0026self, num_of_rows: i32) {\n        use std::sync::atomic::Ordering::SeqCst;\n        self.summary.0.fetch_add(1, SeqCst);\n        self.summary.1.fetch_add(num_of_rows as _, SeqCst);\n    }\n}\n\n#[derive(Debug)]\npub struct SyncBlock {\n    pub raw: Arc\u003cRawRes\u003e,\n    pub fields: Option\u003cVec\u003cField\u003e\u003e,\n    pub precision: Precision,\n    pub data: *mut *mut c_void,\n    pub lengths: *const i32,\n    pub num_of_rows: usize,\n}\n\nunsafe impl Send for SyncBlock {}\nunsafe impl Sync for SyncBlock {}\n\nimpl SyncBlock {\n    pub fn tmq_table_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.raw.tmq_table_name()\n    }\n    pub fn tmq_db_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.raw.tmq_db_name()\n    }\n}\n\nimpl\u003c'b\u003e BlockExt for SyncBlock {\n    // type Value = BorrowedValue\u003c'b\u003e;\n\n    fn num_of_rows(\u0026self) -\u003e usize {\n        self.num_of_rows\n    }\n\n    fn fields(\u0026self) -\u003e \u0026[Field] {\n        if let Some(fields) = self.fields.as_ref() {\n            fields\n        } else {\n            \u0026self.raw.fields()\n        }\n    }\n\n    fn precision(\u0026self) -\u003e Precision {\n        self.precision\n    }\n\n    fn is_null(\u0026self, row: usize, col: usize) -\u003e bool {\n        self.raw.is_null(row as _, col as _)\n    }\n\n    unsafe fn cell_unchecked(\u0026self, row: usize, col: usize) -\u003e (\u0026Field, BorrowedValue) {\n        let inner = self.data.add(col);\n        // log::debug!(\"inner: {inner:?} at ({row}, {col})\");\n\n        let field = self.get_field_unchecked(col);\n        let is_null = self.is_null(row, col);\n        if is_null {\n            return (field, BorrowedValue::Null);\n        }\n\n        macro_rules! parse_cell {\n            ($f:ident, $t:ty) =\u003e {\n                paste::paste! {\n                    BorrowedValue::$f({\n                        (*inner as *const $t).add(row).read()\n                    })\n                }\n            };\n        }\n\n        let read_bytes_from_ptr = |inner: *mut *mut c_void, col: usize| {\n            if crate::client_info().starts_with(\"3\") {\n                let offsets = self.raw.get_column_data_offset(col);\n                let offset = offsets.add(row).read();\n                if offset == -1 {\n                    \"\".as_bytes()\n                } else {\n                    let ptr = (*inner as *const u8).add(offset as usize);\n                    let len = ptr.cast::\u003ci16\u003e().read();\n                    let start = ptr.offset(2);\n\n                    slice::from_raw_parts(start, len as _)\n                }\n            } else {\n                let length = *self.lengths.add(col) as usize;\n                let ptr = (*inner as *const u8).add(row * length as usize);\n                let len = ptr.cast::\u003ci16\u003e().read();\n                let start = ptr.offset(2);\n\n                slice::from_raw_parts(start, len as _)\n            }\n        };\n\n        let value = match field.ty() {\n            Ty::Null =\u003e BorrowedValue::Null,\n            Ty::Bool =\u003e parse_cell!(Bool, bool),\n            Ty::TinyInt =\u003e parse_cell!(TinyInt, i8),\n            Ty::SmallInt =\u003e parse_cell!(SmallInt, i16),\n            Ty::Int =\u003e parse_cell!(Int, i32),\n            Ty::BigInt =\u003e parse_cell!(BigInt, i64),\n            Ty::UTinyInt =\u003e parse_cell!(UTinyInt, u8),\n            Ty::USmallInt =\u003e parse_cell!(USmallInt, u16),\n            Ty::UInt =\u003e parse_cell!(UInt, u32),\n            Ty::UBigInt =\u003e parse_cell!(UBigInt, u64),\n            Ty::Float =\u003e parse_cell!(Float, f32),\n            Ty::Double =\u003e parse_cell!(Double, f64),\n            Ty::Timestamp =\u003e {\n                let raw = (*inner as *const i64).add(row).read();\n                let precision = self.precision();\n                BorrowedValue::Timestamp(Timestamp::new(raw, precision))\n            }\n            Ty::VarChar =\u003e BorrowedValue::VarChar(std::str::from_utf8_unchecked(\n                read_bytes_from_ptr(inner, col),\n            )),\n            Ty::NChar =\u003e BorrowedValue::NChar(\n                std::str::from_utf8_unchecked(read_bytes_from_ptr(inner, col)).into(),\n            ),\n            Ty::Json =\u003e BorrowedValue::Json(read_bytes_from_ptr(inner, col).into()),\n            _ =\u003e BorrowedValue::Null,\n        };\n        (field as _, value)\n    }\n\n    unsafe fn get_col_unchecked(\u0026self, col: usize) -\u003e BorrowedColumn {\n        let inner = self.data.add(col);\n        let field = self.get_field_unchecked(col);\n        let num_of_rows = self.num_of_rows() as usize;\n        let is_nulls =\n            BitVec::from_bool_iterator((0..num_of_rows as usize).map(|row| self.is_null(row, col)));\n\n        macro_rules! column_transmute {\n            ($f:ident, $t:ty) =\u003e {\n                paste::paste! {\n                    BorrowedColumn::$f(is_nulls, {\n                        std::slice::from_raw_parts(*inner as *const $t, num_of_rows)\n                    })\n                }\n            };\n        }\n        match field.ty() {\n            Ty::Null =\u003e BorrowedColumn::Null(num_of_rows),\n            Ty::Bool =\u003e column_transmute!(Bool, bool),\n            Ty::TinyInt =\u003e column_transmute!(TinyInt, i8),\n            Ty::SmallInt =\u003e column_transmute!(SmallInt, i16),\n            Ty::Int =\u003e column_transmute!(Int, i32),\n            Ty::BigInt =\u003e column_transmute!(BigInt, i64),\n            Ty::UTinyInt =\u003e column_transmute!(UTinyInt, u8),\n            Ty::USmallInt =\u003e column_transmute!(USmallInt, u16),\n            Ty::UInt =\u003e column_transmute!(UInt, u32),\n            Ty::UBigInt =\u003e column_transmute!(UBigInt, u64),\n            Ty::Float =\u003e column_transmute!(Float, f32),\n            Ty::Double =\u003e column_transmute!(Double, f64),\n            Ty::Timestamp =\u003e {\n                let raw = std::slice::from_raw_parts(*inner as *const i64, num_of_rows);\n                BorrowedColumn::Timestamp(is_nulls, raw)\n            }\n            Ty::VarChar =\u003e {\n                let length = self.lengths.add(col);\n                let item = (0..num_of_rows)\n                    .map(|n| {\n                        let ptr = (*inner as *const u8).offset(n as isize * *length as isize);\n                        let len = ptr.cast::\u003ci16\u003e().read();\n                        let start = ptr.offset(2);\n                        if is_nulls.get_unchecked(n) {\n                            None\n                        } else {\n                            Some(slice::from_raw_parts(start, len as _))\n                        }\n                    })\n                    .collect_vec();\n\n                BorrowedColumn::Binary(item)\n            }\n            Ty::NChar =\u003e {\n                let length = self.lengths.add(col);\n                let item = (0..num_of_rows)\n                    .map(|n| {\n                        let ptr = (*inner as *const u8).offset(n as isize * *length as isize);\n                        let len = ptr.cast::\u003ci16\u003e().read();\n                        let start = ptr.offset(2);\n                        if is_nulls.get_unchecked(n) {\n                            None\n                        } else {\n                            Some(std::str::from_utf8_unchecked(slice::from_raw_parts(\n                                start as _, len as _,\n                            )))\n                        }\n                    })\n                    .collect_vec();\n\n                BorrowedColumn::NChar(item)\n            }\n            _ =\u003e unreachable!(\"unsupported borrowed column type\"),\n        }\n    }\n}\n\nimpl Fetchable for ResultSet {\n    fn fields(\u0026self) -\u003e \u0026[Field] {\n        \u0026self.raw.fields()\n    }\n\n    fn precision(\u0026self) -\u003e Precision {\n        self.raw.precision()\n    }\n\n    fn summary(\u0026self) -\u003e (usize, usize) {\n        use std::sync::atomic::Ordering::SeqCst;\n        (\n            self.summary.0.load(SeqCst) as _,\n            self.summary.1.load(SeqCst) as _,\n        )\n    }\n\n    fn affected_rows(\u0026self) -\u003e i32 {\n        self.raw.affected_rows()\n    }\n}\n\nimpl Iterator for ResultSet {\n    type Item = SyncBlock;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if let Ok(Some((data, num_of_rows, lengths))) = self.raw.fetch_block() {\n            log::debug!(\"fetch block with {num_of_rows} rows\");\n            self.append_num_of_rows(num_of_rows);\n            let fields = if self.independent {\n                Some(self.raw.fetch_fields())\n            } else {\n                None\n            };\n\n            Some(SyncBlock {\n                raw: self.raw.raw(),\n                fields,\n                precision: self.precision(),\n                data,\n                lengths,\n                num_of_rows: num_of_rows as _,\n            })\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003c'r, 'q\u003e SyncBlock {\n    #[inline]\n    pub fn from_raw_with_ptr(\n        raw: Arc\u003cRawRes\u003e,\n        data: *mut *mut c_void,\n        num_of_rows: i32,\n    ) -\u003e Option\u003cSelf\u003e {\n        let precision = raw.precision();\n        if num_of_rows \u003e 0 {\n            let lengths = raw.fetch_lengths();\n            Some(SyncBlock {\n                raw,\n                data,\n                fields: None,\n                precision: precision,\n                lengths,\n                num_of_rows: num_of_rows as _,\n            })\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    pub fn from_async_query(\n        raw: Arc\u003cRawRes\u003e,\n        data: *mut *mut c_void,\n        num_of_rows: i32,\n    ) -\u003e Option\u003cSelf\u003e {\n        Self::from_raw_with_ptr(raw, data, num_of_rows)\n    }\n}\n\nimpl\u003c'q\u003e Queryable\u003c'q\u003e for Taos {\n    type Error = Error;\n\n    type ResultSet = ResultSet;\n\n    fn query\u003cT: AsRef\u003cstr\u003e\u003e(\u0026self, sql: T) -\u003e Result\u003cResultSet, Self::Error\u003e {\n        log::trace!(\"sql: {}\", sql.as_ref());\n        let raw = self.0.query(sql.as_ref())?;\n        Ok(ResultSet::new(raw))\n    }\n}\n\nimpl FromDsn for Taos {\n    type Err = Error;\n\n    fn hygienize(dsn: Dsn) -\u003e Result\u003c(Dsn, Vec\u003cAddress\u003e), DsnError\u003e {\n        if dsn.driver != \"taos\" {\n            return Err(DsnError::InvalidDriver(dsn.driver));\n        }\n        Ok((dsn, vec![]))\n    }\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let dsn = dsn.into_dsn()?;\n        if dsn.addresses.len() == 0 {\n            Ok(Taos::new(\n                (),\n                \u0026dsn.username,\n                \u0026dsn.password,\n                \u0026dsn.database,\n                0,\n            )?)\n        } else {\n            let Address { host, port, .. } = \u0026dsn.addresses[0];\n            Ok(Taos::new(\n                host,\n                \u0026dsn.username,\n                \u0026dsn.password,\n                \u0026dsn.database,\n                port.unwrap_or_default(),\n            )?)\n        }\n    }\n\n    fn ping(_dsn: \u0026Dsn) -\u003e Result\u003c(), Self::Err\u003e {\n        Ok(())\n    }\n}\n\n#[taos_macros::test(log_level = \"debug\")]\nfn show_databases(taos: \u0026Taos) -\u003e Result\u003c(), Error\u003e {\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, \"show databases\")?;\n\n    log::debug!(\"{rs:?}\");\n\n    let fields = rs.fields();\n\n    log::debug!(\"fields[{}]: {fields:?}\", fields.len());\n\n    let precision = rs.precision();\n    log::debug!(\"precision: {}\", precision);\n\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        name: String,\n        ntables: u64,\n    }\n\n    for record in rs.deserialize() {\n        let record: Record = record?;\n        println!(\"{record:?}\");\n    }\n\n    Ok(())\n}\n\n#[taos_macros::test(crate, log_level = \"trace\")]\nfn sync_query_on_non_queryable_sql(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, format!(\"use {database}\"))?;\n\n    assert!(rs.precision() == Precision::Millisecond); // `ms` is the default precision.\n    assert!(rs.fields().len() == 0);\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        ts: String,\n        level: i8,\n        content: String,\n        dnode_id: i32,\n        dnode_ep: String,\n    }\n\n    for record in rs.deserialize() {\n        let _: Record = record?;\n    }\n\n    // Queried 0 rows.\n    assert_eq!(rs.summary(), (0, 0));\n    Ok(())\n}\n\n#[taos_macros::test(crate, log_level = \"info\")]\nfn sync_query_de(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    let affected_rows = \u003cTaos as Queryable\u003e::exec(taos, \"use log\")?;\n    assert!(affected_rows == 0);\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, \"select * from log.logs limit 10000\")?;\n\n    assert!(rs.fields().len() == 5);\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        ts: String,\n        level: i8,\n        content: String,\n        dnode_id: i32,\n        dnode_ep: String,\n    }\n\n    for record in rs.deserialize() {\n        let _: Record = record?;\n    }\n    let (blocks, records) = rs.summary();\n    println!(\"total blocks: {}, total rows: {}\", blocks, records);\n    Ok(())\n}\n\n#[taos_macros::test(crate)]\nfn sync_query_block_de_ref(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    use itertools::Itertools;\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, \"select * from log.logs limit 10000\")?;\n\n    for block in \u0026mut rs {\n        let des = block\n            .deserialize::\u003c(i64, i32, \u0026str)\u003e()\n            .take(1)\n            .collect_vec();\n        log::info!(\"first row in block: {:?}\", des);\n    }\n\n    let (blocks, records) = rs.summary();\n    println!(\"total blocks: {}, total rows: {}\", blocks, records);\n    Ok(())\n}\n\n#[test]\nfn two_cluster() -\u003e Result\u003c(), Error\u003e {\n    return Ok(());\n    let t1 = TaosOptions::default().port(6030u16).build()?;\n    let d1: (i32, String) = t1.query_one(\"show dnodes\")?.unwrap();\n    let t2 = TaosOptions::default().port(16030u16).build()?;\n    let d2: (i32, String) = t2.query_one(\"show dnodes\")?.unwrap();\n    dbg!(\u0026d1, \u0026d2);\n    assert!(d1 != d2);\n    Ok(())\n}\n\npub(crate) mod asyncs;\n","traces":[{"line":37,"address":[3767856,3768105],"length":1,"stats":{"Line":0},"fn_name":"custom\u003calloc::string::String\u003e"},{"line":41,"address":[3767955,3767884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3768144,3768630,3768370,3768400],"length":1,"stats":{"Line":0},"fn_name":"custom\u003ccore::fmt::Arguments\u003e"},{"line":50,"address":[3768490,3768427,3768230,3768172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3472304,3472707,3472728],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":65,"address":[3472466,3472329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3472619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3472427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3472448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3769117,3768672,3769138],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code\u003ci32\u003e"},{"line":76,"address":[3768876,3768720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3769029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3768837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3768858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3472768],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":85,"address":[3472777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3472816,3472943],"length":1,"stats":{"Line":0},"fn_name":"from_raw_res"},{"line":90,"address":[3472830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[3472861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3472976,3473082],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":100,"address":[3472999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3473120],"length":1,"stats":{"Line":0},"fn_name":"independent"},{"line":105,"address":[3473123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[3473127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3473152],"length":1,"stats":{"Line":0},"fn_name":"append_num_of_rows"},{"line":111,"address":[3473174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3473219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3473280],"length":1,"stats":{"Line":0},"fn_name":"tmq_table_name"},{"line":131,"address":[3473289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3473344],"length":1,"stats":{"Line":0},"fn_name":"tmq_db_name"},{"line":134,"address":[3473353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[3473408],"length":1,"stats":{"Line":0},"fn_name":"num_of_rows"},{"line":142,"address":[3473413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3473424],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":146,"address":[3473438,3473593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[3473486,3473583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[3473509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[3473600],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":154,"address":[3473605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[3473616],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":158,"address":[3473645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[3473712],"length":1,"stats":{"Line":0},"fn_name":"cell_unchecked"},{"line":162,"address":[3473775,3473842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3473866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[3473904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3473941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[3474018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3473963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3770249,3769239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[3769414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3769556,3769484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[3769577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3769645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[3769678,3769740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[3769753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3769838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3769856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[3769401,3769950,3769331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3770057,3769961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3770102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3770187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[3770205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[3473987,3474067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3474126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3474217,3476351,3474147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[3474300,3474230,3476309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3476264,3474313,3474387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3474400,3474474,3476222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[3474561,3474487,3476177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[3475721,3475069,3474999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[3475676,3475082,3475156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[3475169,3475634,3475243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3475256,3475589,3475330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[3476129,3474574,3474648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[3476081,3474661,3474735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3474904,3475895,3474830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[3475922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[3475948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[3476019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[3474756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[3475771,3474925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3475490,3475351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[3474113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[3475408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[3480169,3476400,3478323],"length":1,"stats":{"Line":0},"fn_name":"get_col_unchecked"},{"line":235,"address":[3476530,3476455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3476546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[3476584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[3476622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3476750,3476816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3476927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[3480051,3476943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[3479933,3477030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[3479815,3477117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3477204,3479697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[3479579,3477291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[3477768,3478574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[3477849,3478462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[3477930,3478353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[3478011,3478214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[3479461,3477378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[3479343,3477465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[3477648,3478959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3478975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[3477560,3479093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3479169,3479101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3479129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[3770437,3770347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[3770482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[3770567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[3770585,3770688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[3770641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[3770678,3770619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3479247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3477691,3478699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3478775,3478707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[3478735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[3770827,3770737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[3770872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[3770957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[3770975,3771103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[3771031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3771013,3771068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[3771009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[3478853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[3480240],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":310,"address":[3480249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3480304],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":314,"address":[3480313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[3480352],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":320,"address":[3480366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3480411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[3480496],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":326,"address":[3480505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3481595,3481650,3480544],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":334,"address":[3480582,3480647,3481590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3480886,3480966,3480705,3480804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[3480949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[3481134,3481160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[3481167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[3481140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[3481469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[3481268,3481335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[3481343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[3481383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3481461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[3480640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[3482036,3481680],"length":1,"stats":{"Line":0},"fn_name":"from_raw_with_ptr"},{"line":364,"address":[3481726,3481809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[3481835,3482034,3481852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3481857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[3481953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[3481926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3481939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[3481951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[3481845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[3482112],"length":1,"stats":{"Line":0},"fn_name":"from_async_query"},{"line":386,"address":[3482138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[3780176,3782093,3781152,3781117],"length":1,"stats":{"Line":0},"fn_name":"query\u003c\u0026str\u003e"},{"line":396,"address":[3780375,3780216,3781430,3781272,3781187,3780462,3780293,3781351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[3780690,3781405,3781784,3780830,3781644,3780433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[3780787,3782012,3781741,3781042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[3981035,3980705,3980320],"length":1,"stats":{"Line":0},"fn_name":"hygienize"},{"line":406,"address":[3980445,3980350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[3980526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[3980456,3981071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[3981488],"length":1,"stats":{"Line":0},"fn_name":"ping"},{"line":435,"address":[3981496],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":201},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","lib.rs"],"content":"use std::sync::Once;\n\npub use impls::Error;\npub use taos_error::{Code, Error as TaosError};\n\npub use taos_query as query;\nuse taos_sys::*;\n\nmacro_rules! err {\n    (custom $err:expr) =\u003e {\n        \u003ccrate::Error as ::serde::de::Error\u003e::custom($err)\n    };\n    ('str $err:expr) =\u003e {\n        \u003ccrate::Error as ::serde::de::Error\u003e::custom($err)\n    };\n}\n\n// pub mod timestamp;\n\nmod options;\n\npub use options::TaosOptions;\n\nmod util;\nuse util::*;\n\n// deprecated method.\nmod async_query;\n\npub mod helpers;\n\npub mod stream;\n\nmod result;\n\npub mod tmq;\n\nmod schemaless;\n\nmod impls;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, crate::impls::Error\u003e;\n\n#[derive(Debug)]\npub struct Taos(RawTaos);\n\nunsafe impl Send for Taos {}\nunsafe impl Sync for Taos {}\n\nimpl Taos {\n    fn new\u003c'a\u003e(\n        host: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        user: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        pass: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        db: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        port: u16,\n    ) -\u003e Result\u003cSelf\u003e {\n        Ok(Self(RawTaos::connect(\n            host.into().as_ptr(),\n            user.into().as_ptr(),\n            pass.into().as_ptr(),\n            db.into().as_ptr(),\n            port,\n        )?))\n    }\n\n    /// Asynchronously query with sql\n    // pub fn query\u003c'a, 'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'a\u003e,\n    // ) -\u003e impl Future\u003cOutput = Result\u003cTaosResult\u003c'query\u003e\u003e\u003e {\n    //     async_query::QueryFuture::new(self, sql)\n    // }\n\n    /// Query without result.\n    // pub async fn exec\u003c'a, 'query\u003e(\u0026'query self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cusize\u003e {\n    //     let res = self.query(sql).await?;\n    //     Ok(res.affected_rows() as _)\n    // }\n\n    // pub fn exec_sync\u003c'a, 'query\u003e(\u0026'query self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cusize\u003e {\n    //     futures::executor::block_on(self.exec(sql))\n    // }\n\n    // pub fn query_sync\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     futures::executor::block_on(self.query(sql))\n    // }\n\n    // pub fn query_sync2\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     futures::executor::block_on(self.query2(sql))\n    // }\n    // pub fn query_sync3\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     futures::executor::block_on(self.query3(sql))\n    // }\n    // pub async fn query2\u003c'a, 'q\u003e(\u0026'q self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cTaosResult\u003c'q\u003e\u003e {\n    //     // use tokio::sync::oneshot;\n    //     use oneshot::channel;\n    //     use oneshot::Sender;\n    //     // use std::sync::mpsc::channel;\n    //     // use std::sync::mpsc::Sender;\n    //     let (sender, rx) = channel();\n\n    //     pub unsafe extern \"C\" fn async_query_callback(\n    //         param: *mut c_void,\n    //         res: *mut c_void,\n    //         code: c_int,\n    //     ) {\n    //         assert!(code == 0);\n    //         // let _ = RawRes::from_ptr(res);\n    //         let v = TaosResult::try_from_ptr(res);\n    //         // let param = param as *mut CallbackArg;\n    //         // let args = Box::from_raw(param);\n    //         // let CallbackArg { sender } = *args;\n    //         // sender.send(v).unwrap();\n    //         let sender = param as *mut Sender\u003c_\u003e;\n    //         let sender = Box::from_raw(sender);\n\n    //         sender.send(v).unwrap();\n    //     }\n    //     // let args = CallbackArg { sender };\n    //     // let args = Box::new(args);\n    //     // let ptr = Box::pin(tx);\n    //     self.0.query_a(\n    //         sql.into_c_str().as_ptr(),\n    //         async_query_callback as _,\n    //         Box::into_raw(Box::new(sender)) as *mut _,\n    //     );\n    //     rx.await.unwrap()\n    //     // rx.await.map_err(|e| Error::from_string(format!(\"{}\", e)))\n    // }\n    // pub async fn query3\u003c'a, 'q\u003e(\u0026'q self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cTaosResult\u003c'q\u003e\u003e {\n    //     // use tokio::sync::oneshot;\n    //     use tokio::sync::oneshot::channel;\n    //     use tokio::sync::oneshot::Sender;\n    //     // use std::sync::mpsc::channel;\n    //     // use std::sync::mpsc::Sender;\n    //     let (sender, rx) = channel();\n\n    //     pub unsafe extern \"C\" fn async_query_callback(\n    //         param: *mut c_void,\n    //         res: *mut c_void,\n    //         code: c_int,\n    //     ) {\n    //         assert!(code == 0);\n    //         // let _ = RawRes::from_ptr(res);\n    //         let v = TaosResult::try_from_ptr(res);\n    //         // let param = param as *mut CallbackArg;\n    //         // let args = Box::from_raw(param);\n    //         // let CallbackArg { sender } = *args;\n    //         // sender.send(v).unwrap();\n    //         let sender = param as *mut Sender\u003c_\u003e;\n    //         let sender = Box::from_raw(sender);\n\n    //         sender.send(v).unwrap();\n    //     }\n    //     // let args = CallbackArg { sender };\n    //     // let args = Box::new(args);\n    //     // let ptr = Box::pin(tx);\n    //     self.0.query_a(\n    //         sql.into_c_str().as_ptr(),\n    //         async_query_callback as _,\n    //         Box::into_raw(Box::new(sender)) as *mut _,\n    //     );\n    //     rx.await.unwrap()\n    //     // rx.await.map_err(|e| Error::from_string(format!(\"{}\", e)))\n    // }\n\n    // pub fn query_sync0\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     self.0\n    //         .query(sql.into_c_str().as_ptr())\n    //         .map(TaosResult::from_raw)\n    // }\n\n    pub(crate) fn as_raw(\u0026self) -\u003e *mut taos_sys::ffi::TAOS {\n        self.0.as_ptr()\n    }\n}\n\npub mod block;\n\npub fn client_info() -\u003e \u0026'static str {\n    static ONCE: Once = Once::new();\n    static mut VERSION: \u0026str = \"\";\n    ONCE.call_once(|| unsafe {\n        VERSION = RawTaos::version()\n            .to_str()\n            .expect(\"get client info should always be ok\");\n    });\n    unsafe { VERSION }\n}\npub mod stmt;\n\n#[cfg(feature = \"r2d2\")]\npub mod r2d2;\n\npub mod prelude {\n    //! Preludes for async/await queries.\n    //!\n    //! ```rust\n    //! use taos::prelude::*;\n    //! use tokio;\n    //!\n    //! #[tokio::main]\n    //! async fn main() -\u003e anyhow::Result\u003c()\u003e {\n    //!     let taos = TaosOptions::default().build()?;\n    //!     taos.exec(\"drop database if exists test_prelude\").await?;\n    //!     taos.exec(\"create database test_prelude precision 'us'\").await?;\n    //!     taos.exec(\"use test_prelude\").await?;\n    //!     taos.exec(\"create stable meters (ts timestamp, current float, voltage int, phase float) \\\n    //!                tags(gid int, location binary(16))\").await?;\n    //!     let count: u32 = taos.query_one(\"select count(*) from meters\").await?.unwrap_or(0);\n    //!     assert!(count == 0);\n    //!\n    //!     let results = taos.query(\"select * from meters\").await?;\n    //!     assert!(results.precision() == \"us\");\n    //!     assert_eq!(results.num_of_fields(), 6);\n    //!     Ok(())\n    //! }\n    //! ```\n    pub use crate::impls::Error;\n    pub use crate::impls::ResultSet;\n    pub use crate::impls::SyncBlock;\n    pub use crate::options::TaosOptions;\n    pub use crate::query::FromDsn;\n    pub use crate::schemaless::{SchemalessPrecision, SchemalessProtocol};\n    pub use crate::stmt::{TaosBind, TaosMultiBind};\n    pub use crate::Taos;\n    pub use taos_query::common::{Precision, Timestamp, Ty, Value};\n    pub use taos_query::{common, AsyncFetchable, AsyncQueryable, BlockCodec, BlockExt};\n\n    #[cfg(feature = \"r2d2\")]\n    pub use crate::r2d2::TaosPool;\n\n    pub type Manager = taos_query::Manager\u003cTaos\u003e;\n\n    #[cfg(feature = \"r2d2\")]\n    pub type Pool = taos_query::Pool\u003cTaos\u003e;\n\n    pub mod sync {\n\n        pub use crate::impls::Error;\n        pub use crate::impls::ResultSet;\n        pub use crate::impls::SyncBlock;\n        pub use crate::options::TaosOptions;\n        pub use crate::query::FromDsn;\n        pub use crate::schemaless::{SchemalessPrecision, SchemalessProtocol};\n        pub use crate::stmt::{TaosBind, TaosMultiBind};\n        pub use crate::Taos;\n        // pub use mdsn::{Dsn, IntoDsn};\n\n        pub use taos_query::common::{Precision, Timestamp, Ty, Value};\n        pub use taos_query::{common, BlockCodec, BlockExt, Fetchable, Queryable};\n\n        #[cfg(feature = \"r2d2\")]\n        pub use crate::r2d2::TaosPool;\n\n        pub type Manager = taos_query::Manager\u003cTaos\u003e;\n\n        #[cfg(feature = \"r2d2\")]\n        pub type Pool = taos_query::Pool\u003cTaos\u003e;\n    }\n}\n#[cfg(feature = \"test\")]\npub use taos_macros::test;\n\n// pub use taos_query::BlockExt;\n#[cfg(test)]\nmod tests {\n    use super::{client_info, Taos, TaosOptions};\n    use taos_macros::test;\n\n    use crate::prelude::*;\n    use anyhow::Result;\n\n    #[test]\n    fn test_invalid_database() {\n        let res = TaosOptions::default().database(\"invalid_database\").build();\n        assert!(res.is_err());\n\n        let err = res.unwrap_err();\n        dbg!(err);\n    }\n\n    #[test(log_level = \"trace\")]\n    async fn test_information_schema(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n        let info: Vec\u003cValue\u003e = taos\n            .query_one(\"select * from information_schema.user_databases where name like 'infor%'\")\n            .await?\n            .unwrap();\n        dbg!(info);\n        Ok(())\n    }\n    #[test]\n    async fn test_describe(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n        let desc = taos.describe(\"log.logs\").await?;\n        dbg!(desc);\n        Ok(())\n    }\n    #[tokio::test]\n    async fn test_databases() -\u003e Result\u003c()\u003e {\n        let taos = TaosOptions::new().build()?;\n        let desc = taos.databases().await?;\n        println!(\"done\");\n        dbg!(desc);\n        Ok(())\n    }\n    #[test(crate)]\n    fn test_client_info() {\n        let version = client_info();\n        dbg!(format!(\"{version}\"));\n    }\n\n    #[test(crate)]\n    fn test_err() {\n        fn err_with_res() -\u003e Result\u003c()\u003e {\n            let taos = Taos::new(\n                \"localhost\",\n                std::ptr::null() as *const i8,\n                \"taosdata\",\n                std::ptr::null() as *const i8,\n                0,\n            )?;\n            taos.query_sync(\"select * from log.logs\")?;\n            Ok(())\n        }\n        err_with_res().unwrap();\n    }\n    #[test(crate)]\n    fn query_async_await_future_test() {\n        tokio::runtime::Builder::new_multi_thread()\n            .enable_all()\n            .build()\n            .unwrap()\n            .block_on(async {\n                let taos = Taos::new(\"localhost\", \"root\", \"taosdata\", \"log\", 0).unwrap();\n                let mut res = taos\n                    .query(\"select * from log.logs limit 10000\")\n                    .await\n                    .unwrap();\n                let stream = res.block_stream();\n\n                use futures::stream::StreamExt;\n                let lengths = stream\n                    .enumerate()\n                    .map(|(bi, partial)| {\n                        partial\n                            .iter_rows()\n                            .enumerate()\n                            .map(|(ri, values)| {\n                                println!(\"block {bi}, row {ri}: {values:?}\");\n                                return 1;\n                            })\n                            .sum::\u003cusize\u003e()\n                    })\n                    .fold(0, |acc, n| futures::future::ready(acc + n))\n                    .await;\n                println!(\"lengths is {lengths}\");\n            });\n    }\n}\n","traces":[{"line":51,"address":[3782985,3782128,3783151],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026core::option::Option\u003calloc::string::String\u003e, \u0026core::option::Option\u003calloc::string::String\u003e, \u0026core::option::Option\u003calloc::string::String\u003e, \u0026core::option::Option\u003calloc::string::String\u003e\u003e"},{"line":58,"address":[3782913,3782698,3782209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3782257,3782317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3782387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3782484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3782581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3981520],"length":1,"stats":{"Line":0},"fn_name":"as_raw"},{"line":187,"address":[3981529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[3981552],"length":1,"stats":{"Line":0},"fn_name":"client_info"},{"line":196,"address":[3783168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":197,"address":[3783172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3981573],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","options.rs"],"content":"use std::{\n    collections::BTreeMap,\n    ffi::{CStr, CString},\n    path::PathBuf,\n    sync::Once,\n};\n\nuse crate::{Result, Taos};\n\nuse taos_sys::*;\n\n#[derive(Debug, Default)]\npub struct TaosOptions {\n    pub(crate) host: Option\u003cString\u003e,\n    pub(crate) port: Option\u003cu16\u003e, // make it optional with concern for REST.\n    pub(crate) username: Option\u003cString\u003e,\n    pub(crate) password: Option\u003cString\u003e,\n    pub(crate) database: Option\u003cString\u003e,\n\n    locale: Option\u003cString\u003e,\n    charset: Option\u003cString\u003e,\n    timezone: Option\u003cString\u003e,\n    config_dir: Option\u003cPathBuf\u003e,\n    shell_activity_timer: Option\u003cu16\u003e,\n    pub(crate) params: BTreeMap\u003cString, String\u003e,\n}\n\nmacro_rules! _build_opt {\n    ($option:ident) =\u003e {\n        _build_opt!($option, String);\n    };\n    ($option:ident, $ty:ty) =\u003e {\n        pub fn $option\u003cT: Into\u003c$ty\u003e\u003e(mut self, $option: T) -\u003e Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n    ($option:ident, $setter:block) =\u003e {\n        pub fn $option\u003cT: Into\u003cString\u003e\u003e(mut self, $option: T) -\u003e Self {\n            $setter;\n            self\n        }\n    };\n    ($option:ident, $ty:ty, $setter:block) =\u003e {\n        pub fn $option\u003cT: Into\u003c$ty\u003e\u003e(mut self, $option: T) -\u003e Self {\n            let $option = $option.into();\n            $setter;\n            self.$option = Some($option);\n            self\n        }\n    };\n}\n\n#[test]\nfn test_options() {\n    let opts = TaosOptions::parse(\"taos+driver:///db\");\n    dbg!(opts);\n}\nimpl TaosOptions {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n    pub fn parse(dsn: \u0026str) -\u003e Result\u003cSelf\u003e {\n        if dsn.is_empty() {\n            return Ok(Self::new());\n        }\n        let dsn = url::Url::parse(dsn).unwrap();\n        dbg!(dsn);\n        Ok(Self::default())\n    }\n    _build_opt!(host);\n    _build_opt!(username);\n    _build_opt!(password);\n    _build_opt!(database);\n    _build_opt!(port, u16);\n\n    _build_opt!(locale, String, {\n        let cstr = CString::new(locale.clone()).expect(\"invalid locale\");\n        unsafe { taos_options(TSDB_OPTION_LOCALE, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(charset, String, {\n        let cstr = CString::new(charset.clone()).expect(\"invalid charset\");\n        unsafe { taos_options(TSDB_OPTION_CHARSET, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(timezone, String, {\n        let cstr = CString::new(timezone.clone()).expect(\"invalid timezone\");\n        unsafe { taos_options(TSDB_OPTION_TIMEZONE, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(config_dir, PathBuf, {\n        let config_dir = config_dir\n            .canonicalize()\n            .expect(\"invalid path for config dir\");\n        let cstr = CString::new(config_dir.to_string_lossy().as_bytes()).expect(\"path to c string\");\n        unsafe { taos_options(TSDB_OPTION_CONFIGDIR, cstr.as_c_str().as_ptr() as _) };\n    });\n\n    _build_opt!(shell_activity_timer, u16, {\n        let cstr = CString::new(format!(\"{}\", shell_activity_timer))\n            .expect(\"invalid shell activity timer\");\n        unsafe {\n            taos_options(\n                TSDB_OPTION_SHELL_ACTIVITY_TIMER,\n                cstr.as_c_str().as_ptr() as _,\n            )\n        };\n    });\n\n    pub fn set_config_json(\u0026self, json: \u0026str) {\n        let c_str = CString::new(json).expect(\"json to c string\");\n        unsafe {\n            let res = taos_set_config(c_str.as_ptr());\n            if res.code != SET_CONF_RET_SUCC {\n                let msg = CStr::from_ptr(\u0026res.msg as _);\n                panic!(\"set config failed: {}\", msg.to_string_lossy());\n            }\n        }\n    }\n\n    pub fn set_param(\u0026mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e \u0026mut Self {\n        self.params.insert(key.into(), value.into());\n        self\n    }\n\n    pub fn build(\u0026self) -\u003e Result\u003cTaos\u003e {\n        static SET_CONFIG: Once = Once::new();\n        SET_CONFIG.call_once(|| {\n            // println!(\"initialize taos options\");\n            if !self.params.is_empty() {\n                let json = serde_json::to_string(\u0026self.params).expect(\"params to json\");\n                self.set_config_json(\u0026json);\n            }\n        });\n\n        Taos::new(\n            \u0026self.host,\n            \u0026self.username,\n            \u0026self.password,\n            \u0026self.database,\n            self.port.unwrap_or(0),\n        )\n    }\n}\n\n#[test]\nfn test_options_builder() {\n    let opts = TaosOptions::new();\n    let _taos = opts.build().unwrap();\n}\n\n#[test]\nfn test_options_builder_all() {\n    use crate::prelude::*;\n    let opts = TaosOptions::new()\n        .locale(\"en_US\")\n        .charset(\"UTF-8\")\n        .timezone(\"Asia/Chongqing\")\n        .config_dir(\"/etc/taos\")\n        .host(\"localhost\")\n        .port(6030u16)\n        .username(\"root\")\n        .password(\"taosdata\");\n    let taos = opts.build().unwrap();\n    let _res = futures::executor::block_on(taos.query(\"show databases\")).unwrap();\n}\n","traces":[{"line":60,"address":[3606992],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":61,"address":[3607000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3607024,3607925],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":64,"address":[3607101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3607157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3607142,3607232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3607261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3607951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3608016,3608491],"length":1,"stats":{"Line":0},"fn_name":"set_config_json"},{"line":109,"address":[3608047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3608106,3608174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3608207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[3608260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[3608308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3608528],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":126,"address":[3608552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3962670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3962707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3962837,3962774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3608587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3608595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3608607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3608619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3608631],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","r2d2.rs"],"content":"use super::{Error, Result, Taos, TaosOptions};\n\n/// Connection pool with r2d2.\npub type TaosPool = r2d2::Pool\u003cTaosOptions\u003e;\n\nimpl r2d2::ManageConnection for TaosOptions {\n    type Connection = Taos;\n    type Error = Error;\n\n    fn connect(\u0026self) -\u003e Result\u003cSelf::Connection\u003e {\n        self.build()\n    }\n\n    fn is_valid(\u0026self, _: \u0026mut Self::Connection) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    fn has_broken(\u0026self, _: \u0026mut Self::Connection) -\u003e bool {\n        false\n    }\n}\n\n#[test]\nfn test_r2d2() {\n    use crate::prelude::*;\n    use std::sync::mpsc::channel;\n    use std::thread;\n\n    let opts = TaosOptions::new();\n    let pool = TaosPool::builder().build(opts).expect(\"\");\n    let (tx, rx) = channel();\n    for _ in 0..4 {\n        let tx = tx.clone();\n        let pool = pool.clone();\n        thread::spawn(move || {\n            let taos = pool.get().unwrap();\n            let _ = taos.query_sync(\"show connections\").unwrap().affected_rows();\n            tx.send(10).unwrap();\n        });\n    }\n    for _ in 0..4 {\n        let j = rx.recv().unwrap();\n        println!(\"res: {j}\");\n    }\n}\n","traces":[{"line":10,"address":[3608720],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":11,"address":[3608737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[3608768],"length":1,"stats":{"Line":0},"fn_name":"is_valid"},{"line":15,"address":[3608784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3608800],"length":1,"stats":{"Line":0},"fn_name":"has_broken"}],"covered":0,"coverable":5},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","result.rs"],"content":"// // use block::Row;\n// use futures::Stream;\n// use serde::de::DeserializeOwned;\n\n// use taos_sys::{ffi::*, DroppableRawRes as RawRes, *};\n\n// use crate::*;\n\n// #[derive(Debug)]\n// pub enum TaosResult\u003c'a\u003e {\n//     WithFields(RawRes\u003c'a\u003e),\n//     WithoutFields(RawRes\u003c'a\u003e),\n// }\n\n// unsafe impl\u003c'a\u003e Send for TaosResult\u003c'a\u003e {}\n// unsafe impl\u003c'a\u003e Sync for TaosResult\u003c'a\u003e {}\n\n// impl\u003c'a\u003e TaosResult\u003c'a\u003e {\n//     pub(crate) const fn as_raw(\u0026self) -\u003e \u0026RawRes {\n//         match self {\n//             TaosResult::WithFields(res) =\u003e res,\n//             TaosResult::WithoutFields(res) =\u003e res,\n//         }\n//     }\n//     pub(crate) fn from_raw(raw: RawRes\u003c'a\u003e) -\u003e Self {\n//         match raw.num_fields() {\n//             0 =\u003e TaosResult::WithoutFields(raw),\n//             _ =\u003e TaosResult::WithFields(raw),\n//         }\n//     }\n\n//     pub(crate) fn new(result: *mut TAOS_RES, code: i32) -\u003e Result\u003cSelf\u003e {\n//         if code \u003c 0 {\n//             let code: Code = (code \u0026 0xffff).into();\n//             RawRes::from_ptr_with_code(result, code).map(Self::from_raw)\n//         } else {\n//             RawRes::from_ptr_with_code(result, Code::Success).map(Self::from_raw)\n//         }\n//     }\n\n//     pub fn num_of_fields(\u0026self) -\u003e usize {\n//         self.as_raw().fields().len()\n//     }\n\n//     pub fn precision(\u0026self) -\u003e Precision {\n//         self.as_raw().precision()\n//     }\n\n//     pub fn affected_rows(\u0026self) -\u003e usize {\n//         self.as_raw().affected_rows() as _\n//     }\n\n//     pub fn block_stream(\u0026self) -\u003e block::BlockStream {\n//         block::BlockStream::from_raw(self.as_raw().raw(), Default::default())\n//     }\n\n//     pub fn deserialize_stream\u003c'b, T: 'a + 'b\u003e(\n//         \u0026self,\n//     ) -\u003e impl Stream\u003cItem = std::result::Result\u003cT, serde::de::value::Error\u003e\u003e + '_\n//     where\n//         T: DeserializeOwned,\n//     {\n//         use futures::StreamExt;\n//         use taos_query::BlockExt;\n//         self.block_stream()\n//             .flat_map(|block| futures::stream::iter(block.deserialize_into_vec()))\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","schemaless.rs"],"content":"use crate::{taos_schemaless_insert, IntoCStr, Taos};\nuse taos_error::*;\n\nuse itertools::Itertools;\n\npub use taos_sys::{SchemalessPrecision, SchemalessProtocol};\n\nimpl Taos {\n    /// Schemaless insert with different protocol and timestamp precision.\n    ///\n    /// - InfluxDB line protocol\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [\"st,t1=abc,t2=def,t3=anything c1=3i64,c3=L\\\"pass\\\",c2=false,c4=4f64 1626006833639000000\"];\n    ///     taos.schemaless_insert(\u0026lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_NANOSECONDS)?;\n    ///     ```\n    ///\n    /// - OpenTSDB telnet protocol\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [\"sys.if.bytes.out 1479496100 1.3E3 host=web01 interface=eth0\"];\n    ///     taos.schemaless_insert(\u0026lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n    ///     ```\n    ///\n    /// - or OpenTSDB json protocol.\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [r#\"\n    ///         {\n    ///             \"metric\":   \"st\",\n    ///             \"timestamp\":        1626006833,\n    ///             \"value\":    10,\n    ///             \"tags\":     {\n    ///                 \"t1\":   true,\n    ///                 \"t2\":   false,\n    ///                 \"t3\":   10,\n    ///                 \"t4\":   \"123_abc_.!@#$%^\u0026*:;,./?|+-=()[]{}\u003c\u003e\"\n    ///             }\n    ///         }\"#];\n    ///     taos.schemaless_insert(\u0026lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n    ///     ```\n    ///\n    pub fn schemaless_insert\u003c'a, T: IntoCStr\u003c'a\u003e\u003e(\n        \u0026self,\n        lines: impl IntoIterator\u003cItem = T\u003e,\n        protocol: SchemalessProtocol,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003ci32\u003e {\n        let lines: Vec\u003c_\u003e = lines.into_iter().map(|line| line.into_c_str()).collect();\n        let mut lines = lines\n            .iter()\n            .map(|line| line.as_ptr() as *mut i8)\n            .collect_vec();\n        let lines = lines.as_mut_slice();\n        unsafe {\n            let res = taos_schemaless_insert(\n                self.as_raw(),\n                lines.as_mut_ptr() as *mut *mut i8,\n                lines.len() as _,\n                protocol,\n                precision,\n            );\n\n            taos_sys::RawRes::from_ptr(res).map(|res| res.affected_rows())\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::schemaless::*;\n\n    use crate::prelude::*;\n\n    use anyhow::Result;\n    use taos_sys::TSDB_SML_JSON_PROTOCOL;\n    use taos_sys::TSDB_SML_LINE_PROTOCOL;\n    use taos_sys::TSDB_SML_TELNET_PROTOCOL;\n    use taos_sys::TSDB_SML_TIMESTAMP_SECONDS;\n\n    #[crate::test]\n    /// Test schemaless insert with InfluxDB line protocol\n    async fn line_insert(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        let lines = [\"st,t1=abc c1=3i64,c3=\\\"def\\\",c2=false 1626006833639000000\"];\n        // let lines = [\"st,t1=abc c1=3i64,c2=false,c3=L\\\"def\\\" 1626006833639000000\"];\n        let res = taos.schemaless_insert(\n            \u0026lines,\n            TSDB_SML_LINE_PROTOCOL,\n            SchemalessPrecision::Nanoseconds,\n        )?;\n        assert_eq!(res, 1);\n\n        let res = taos.query(\"select * from st\").await?.to_records();\n        println!(\"{res:?}\");\n        Ok(())\n    }\n\n    #[crate::test]\n    /// Test schemaless insert with OpenTSDB telnet protocol\n    async fn telnet_insert(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        let lines = [\n            \"sys.if.bytes.out 1479496100 1.3E3 host=web01 interface=eth0\",\n            \"sys.if.bytes.out 1479496200 1.4E3 host=web02 interface=eth1\",\n            \"sys.if.bytes.out 1479496300 2.1E3 host=web03 interface=eth2\",\n            \"sys.if.bytes.out 1479496400 3.5E3 host=web04 interface=eth3\",\n        ];\n\n        let res =\n            taos.schemaless_insert(\u0026lines, TSDB_SML_TELNET_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n        assert_eq!(res, 4);\n\n        let res = taos.query(\"select * from `sys.if.bytes.out`\").await?;\n        println!(\"{res:?}\");\n        Ok(())\n    }\n\n    #[crate::test]\n    /// Test schemaless insert with OpenTSDB json protocol\n    async fn json_insert(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        let lines = [r#\"\n        {\n            \"metric\":   \"st\",\n            \"timestamp\":        1626006833,\n            \"value\":    10,\n            \"tags\":     {\n                \"t1\":   true,\n                \"t2\":   false,\n                \"t3\":   10,\n                \"t4\":   \"123_abc_.!@#$%^\u0026*:;,./?|+-=()[]{}\u003c\u003e\"\n            }\n        }\"#];\n        let _: serde_json::Value = serde_json::from_str(lines[0]).unwrap();\n\n        let res =\n            taos.schemaless_insert(\u0026lines, TSDB_SML_JSON_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n        assert_eq!(res, 1);\n\n        let res = taos.query(\"select * from st\").await?;\n        println!(\"{res:?}\");\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","bind.rs"],"content":"use crate::util::IntoCStr;\n\nuse taos_query::common::Ty;\nuse taos_sys::*;\n\nuse chrono::{DateTime, NaiveDateTime};\nuse paste::paste;\n\nuse std::os::raw::{c_int, c_void};\nuse std::ptr;\nuse std::time::SystemTime;\n\n#[repr(transparent)]\npub struct BindParam(TaosBindV2);\n\nunsafe impl std::marker::Send for BindParam {}\nunsafe impl std::marker::Sync for BindParam {}\n\npub trait IntoBindParam {\n    fn into_bind_param(self) -\u003e BindParam;\n}\n\nimpl IntoBindParam for BindParam {\n    fn into_bind_param(self) -\u003e BindParam {\n        self\n    }\n}\nimpl BindParam {\n    pub fn new(buffer_type: Ty) -\u003e Self {\n        let buffer: *mut c_void = ptr::null_mut();\n        let length: *mut usize = ptr::null_mut();\n        let is_null: *mut c_int = ptr::null_mut();\n        let error: *mut c_int = ptr::null_mut();\n        Self(TaosBindV2 {\n            buffer_type: buffer_type as _,\n            buffer,\n            buffer_length: 0,\n            length,\n            is_null,\n            is_unsigned: 0,\n            error,\n            allocated: 0,\n            u: TaosBindUnionV2 { ts: 0 },\n        })\n    }\n    pub fn null() -\u003e Self {\n        let mut null = Self::new(Ty::Null);\n        let v = Box::new(1i8);\n        null.0.is_null = Box::into_raw(v) as _;\n        null\n    }\n\n    unsafe fn free(\u0026mut self) {\n        if !self.0.buffer.is_null() {\n            Vec::from_raw_parts(self.0.buffer as _, *self.0.length, *self.0.length);\n        }\n        if !self.0.length.is_null() {\n            Box::from_raw(self.0.length);\n        }\n        if !self.0.is_null.is_null() {\n            Box::from_raw(self.0.is_null);\n        }\n        if !self.0.error.is_null() {\n            Box::from_raw(self.0.error);\n        }\n    }\n}\n\nimpl Drop for BindParam {\n    fn drop(\u0026mut self) {\n        unsafe { self.free() }\n    }\n}\n\nmacro_rules! _impl_primitive_into_bind_param {\n    ($ty:ty, $target:ident, $v:expr) =\u003e {\n        impl IntoBindParam for $ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                let mut param = BindParam::new(Ty::$target);\n                param.0.buffer_length = std::mem::size_of::\u003c$ty\u003e();\n                let v = Box::new(self);\n                param.0.buffer = Box::into_raw(v) as _;\n                let l = Box::new(param.0.buffer_length);\n                param.0.length = Box::into_raw(l) as _;\n                param\n            }\n        }\n        impl IntoBindParam for \u0026$ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (*self).into_bind_param()\n            }\n        }\n        impl IntoBindParam for \u0026\u0026$ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (*self).into_bind_param()\n            }\n        }\n        paste! {\n            #[std::prelude::v1::test]\n            // #[proc_test_catalog::test_catalogue]\n            #[doc = \"Test bind param for type: \" $ty \" =\u003e \" $target]\n            fn [\u003ctest_ $ty:snake\u003e]() {\n                let v: $ty = $v;\n                let p = v.into_bind_param();\n                let v2 = unsafe { *(p.0.buffer as *const $ty) };\n                assert!(v == v2);\n            }\n        }\n    };\n}\nmacro_rules! _impl_ref_into_bind_param {\n    ($ty:ty) =\u003e {\n        impl IntoBindParam for $ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (\u0026self).into_bind_param()\n            }\n        }\n        impl IntoBindParam for \u0026\u0026$ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (*self).into_bind_param()\n            }\n        }\n    };\n}\n\nimpl\u003cT: IntoBindParam\u003e IntoBindParam for Option\u003cT\u003e {\n    fn into_bind_param(self) -\u003e BindParam {\n        match self {\n            None =\u003e BindParam::null(),\n            Some(v) =\u003e v.into_bind_param(),\n        }\n    }\n}\n\nimpl\u003cT: IntoBindParam, E: std::error::Error\u003e IntoBindParam for std::result::Result\u003cT, E\u003e {\n    fn into_bind_param(self) -\u003e BindParam {\n        match self {\n            Err(_) =\u003e BindParam::null(),\n            Ok(v) =\u003e v.into_bind_param(),\n        }\n    }\n}\n\nimpl IntoBindParam for bool {\n    fn into_bind_param(self) -\u003e BindParam {\n        let v: i8 = if self { 1 } else { 0 };\n        let mut param = BindParam::new(Ty::Bool);\n        param.0.buffer_length = std::mem::size_of::\u003ci8\u003e();\n        let v = Box::new(v);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\nimpl IntoBindParam for \u0026bool {\n    fn into_bind_param(self) -\u003e BindParam {\n        (*self).into_bind_param()\n    }\n}\nimpl IntoBindParam for \u0026\u0026bool {\n    fn into_bind_param(self) -\u003e BindParam {\n        (*self).into_bind_param()\n    }\n}\n\n_impl_primitive_into_bind_param!(i8, TinyInt, 0);\n_impl_primitive_into_bind_param!(i16, SmallInt, 0);\n_impl_primitive_into_bind_param!(i32, Int, 0);\n_impl_primitive_into_bind_param!(i64, BigInt, 0);\n_impl_primitive_into_bind_param!(u8, UTinyInt, 0);\n_impl_primitive_into_bind_param!(u16, USmallInt, 0);\n_impl_primitive_into_bind_param!(u32, UInt, 0);\n_impl_primitive_into_bind_param!(u64, UBigInt, 0);\n_impl_primitive_into_bind_param!(f32, Float, 0.);\n_impl_primitive_into_bind_param!(f64, Double, 0.);\n\n// impl IntoBindParam for \u0026BStr {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let mut param = BindParam::new(Ty::Binary);\n//         param.0.buffer_length = self.len();\n\n//         let cstr = self.to_c_string();\n//         param.0.buffer = cstr.as_ptr() as _;\n//         std::mem::forget(cstr);\n\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n\n// impl IntoBindParam for \u0026BString {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let bstr: \u0026BStr = self.as_ref();\n//         bstr.into_bind_param()\n//     }\n// }\n// _impl_ref_into_bind_param!(BString);\n\nimpl IntoBindParam for \u0026str {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::NChar);\n        param.0.buffer_length = self.len();\n\n        let cstr = self.into_c_str();\n        param.0.buffer = cstr.as_ptr() as _;\n        std::mem::forget(cstr);\n\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\nimpl IntoBindParam for \u0026String {\n    fn into_bind_param(self) -\u003e BindParam {\n        self.as_str().into_bind_param()\n    }\n}\n_impl_ref_into_bind_param!(String);\n\nimpl IntoBindParam for \u0026SystemTime {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        let duration = self\n            .duration_since(std::time::UNIX_EPOCH)\n            .expect(\"systemtime before unix epoch is not invalid\");\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(duration.as_millis());\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n_impl_ref_into_bind_param!(SystemTime);\n\nimpl IntoBindParam for \u0026NaiveDateTime {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        let timestamp = self.timestamp_millis();\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(timestamp);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n_impl_ref_into_bind_param!(NaiveDateTime);\n\nimpl\u003cTz: chrono::TimeZone\u003e IntoBindParam for \u0026DateTime\u003cTz\u003e {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        let timestamp = self.timestamp_millis();\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(timestamp);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n\n// impl IntoBindParam for \u0026Timestamp {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let mut param = BindParam::new(Ty::Timestamp);\n//         param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n//         let v = Box::new(self.timestamp);\n//         param.0.buffer = Box::into_raw(v) as _;\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n// _impl_ref_into_bind_param!(Timestamp);\n\n// impl IntoBindParam for \u0026serde_json::Value {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let mut param = BindParam::new(Ty::Json);\n\n//         let data = serde_json::to_vec(self).expect(\"json to u8 vector\");\n//         param.0.buffer_length = data.len();\n\n//         param.0.buffer = data.as_ptr() as _;\n//         std::mem::forget(data);\n\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n// _impl_ref_into_bind_param!(serde_json::Value);\n\n// impl IntoBindParam for \u0026Field {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         match self {\n//             Field::Null =\u003e BindParam::null(),\n//             Field::Timestamp(v) =\u003e v.into_bind_param(),\n//             Field::Bool(v) =\u003e v.into_bind_param(),\n//             Field::TinyInt(v) =\u003e v.into_bind_param(),\n//             Field::SmallInt(v) =\u003e v.into_bind_param(),\n//             Field::Int(v) =\u003e v.into_bind_param(),\n//             Field::BigInt(v) =\u003e v.into_bind_param(),\n//             Field::UTinyInt(v) =\u003e v.into_bind_param(),\n//             Field::USmallInt(v) =\u003e v.into_bind_param(),\n//             Field::UInt(v) =\u003e v.into_bind_param(),\n//             Field::UBigInt(v) =\u003e v.into_bind_param(),\n//             Field::Float(v) =\u003e v.into_bind_param(),\n//             Field::Double(v) =\u003e v.into_bind_param(),\n//             Field::Binary(v) =\u003e v.into_bind_param(),\n//             Field::NChar(v) =\u003e v.into_bind_param(),\n//             Field::Json(v) =\u003e v.into_bind_param(),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n// _impl_ref_into_bind_param!(Field);\n","traces":[{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","mod.rs"],"content":"use crate::{impls::ResultSet, Taos};\nuse taos_sys::stmt::RawStmt;\n\nuse std::marker::PhantomData;\n\npub use taos_sys::{TaosBind, TaosMultiBind};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, taos_error::Error\u003e;\n/// Stmt handler.\npub struct Stmt\u003c'stmt\u003e(RawStmt, PhantomData\u003c\u0026'stmt Taos\u003e);\n\nimpl\u003c'stmt\u003e Stmt\u003c'stmt\u003e {\n    pub fn execute(\u0026self) -\u003e Result\u003c()\u003e {\n        self.0.execute()\n    }\n\n    pub fn result(\u0026mut self) -\u003e ResultSet {\n        ResultSet::from_raw_res(self.0.use_result())\n    }\n\n    pub fn multi_bind(\u0026mut self, params: \u0026[TaosMultiBind]) -\u003e Result\u003c()\u003e {\n        self.0.bind_param_batch(params)?;\n        self.0.add_batch()?;\n        Ok(())\n    }\n\n    pub fn multi_bind_at(\u0026mut self, bind: \u0026TaosMultiBind, col: usize) -\u003e Result\u003c()\u003e {\n        self.0.bind_single_param_batch(bind, col as i32)\n    }\n\n    pub fn num_params(\u0026self) -\u003e Result\u003cusize\u003e {\n        Ok(self.0.num_params()? as _)\n    }\n\n    pub fn set_tbname_tags(\u0026mut self, name: impl AsRef\u003cstr\u003e, tags: \u0026[TaosBind]) -\u003e Result\u003c()\u003e {\n        self.0.set_tbname_tags_v3(name.as_ref(), tags)\n    }\n    pub fn set_tbname(\u0026mut self, name: impl AsRef\u003cstr\u003e) -\u003e Result\u003c()\u003e {\n        self.0.set_tbname(name.as_ref())\n    }\n    pub fn set_sub_tbname(\u0026mut self, name: impl AsRef\u003cstr\u003e) -\u003e Result\u003c()\u003e {\n        self.0.set_sub_tbname(name.as_ref())\n    }\n\n    pub fn is_insert(\u0026self) -\u003e bool {\n        self.0.is_insert().unwrap_or(false)\n    }\n\n    pub fn affected_rows(\u0026self) -\u003e usize {\n        self.0.affected_rows() as _\n    }\n}\n\n// impl\u003c'c\u003e From\u003c\u0026'c Column\u003e for MultiBind\u003c'c\u003e {\n//     fn from(col: \u0026'c Column) -\u003e Self {\n//         match col {\n//             Column::Null(n) =\u003e MultiBind::nulls(*n),\n//             Column::Bool(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Int(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::BigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::UInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Float(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Double(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Timestamp(nulls, values) =\u003e MultiBind::from_raw_timestamps(nulls, values),\n//             Column::Binary(values) =\u003e MultiBind::from_binary_vec(values),\n//             Column::NChar(values) =\u003e MultiBind::from_string_vec(values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\n// impl\u003c'b\u003e From\u003cBorrowedColumn\u003c'b\u003e\u003e for MultiBind\u003c'b\u003e {\n//     fn from(col: BorrowedColumn\u003c'b\u003e) -\u003e Self {\n//         match col {\n//             BorrowedColumn::Null(n) =\u003e MultiBind::nulls(n),\n//             BorrowedColumn::Bool(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Int(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::UInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Float(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Double(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) =\u003e {\n//                 MultiBind::from_raw_timestamps(\u0026nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) =\u003e MultiBind::from_binary_vec(\u0026values),\n//             BorrowedColumn::NChar(values) =\u003e MultiBind::from_string_vec(\u0026values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\n// impl\u003c'b, 'c\u003e From\u003c\u0026'c BorrowedColumn\u003c'b\u003e\u003e for MultiBind\u003c'c\u003e {\n//     fn from(col: \u0026'c BorrowedColumn\u003c'b\u003e) -\u003e Self {\n//         match col {\n//             BorrowedColumn::Null(n) =\u003e MultiBind::nulls(*n),\n//             BorrowedColumn::Bool(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Int(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Float(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Double(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) =\u003e {\n//                 MultiBind::from_raw_timestamps(nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) =\u003e MultiBind::from_binary_vec(values),\n//             BorrowedColumn::NChar(values) =\u003e MultiBind::from_string_vec(values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\nimpl Taos {\n    /// Create stmt with sql\n    pub fn stmt\u003c'a, 'stmt\u003e(\u0026'stmt self, sql: impl AsRef\u003cstr\u003e) -\u003e Result\u003cStmt\u003c'stmt\u003e\u003e {\n        let mut stmt = RawStmt::from_raw_taos(\u0026self.0);\n        let sql = sql.as_ref();\n        log::trace!(\"stmt: {sql}\");\n        stmt.prepare(sql)?;\n        Ok(Stmt(stmt, PhantomData))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use bitvec_simd::BitVec;\n    use itertools::Itertools;\n    use taos_query::common::itypes::ITimestamp;\n    use taos_sys::TaosBind;\n    use taos_sys::TaosMultiBind;\n\n    use crate::prelude::common::*;\n    use crate::prelude::sync::*;\n    use crate::test;\n    use anyhow::Result;\n\n    // todo: stmt query support.\n    // #[test]\n    // fn test_stmt(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n    //     let mut stmt = taos.stmt(\"show databases\")?;\n    //     stmt.execute()?;\n    //     let mut rs = stmt.result();\n    //     for block in rs {\n    //         println!(\"{block:?}\");\n    //     }\n    //     Ok(())\n    // }\n\n    #[test]\n    fn test_multi_bind(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(concat!(\n            \"create table if not exists tb (ts timestamp,\",\n            \"c1 bool, c2 tinyint, c3 smallint, c4 int,\",\n            \"c5 bigint,\",\n            \"c6 tinyint unsigned,\",\n            \"c7 smallint unsigned,\",\n            \"c8 int unsigned,\",\n            \"c9 bigint unsigned,\",\n            \"c10 float,\",\n            \"c11 double,\",\n            \"c12 timestamp,\",\n            \"c13 binary(100),\",\n            \"c14 nchar(100))\",\n        ))?;\n\n        const N: usize = 100;\n        let nulls = BitVec::zeros(N);\n\n        let ts = Column::Timestamp(\n            nulls.clone(),\n            (0..N).map(|ts| ts as i64 + 1_500_000_000_000).collect(),\n        );\n\n        macro_rules! col {\n            ($ty:ident) =\u003e {\n                dbg!(Column::$ty(\n                    nulls.clone(),\n                    (0..N).map(|_| rand::random()).collect()\n                ))\n            };\n        }\n        let c1 = col!(Bool);\n        let c2 = col!(TinyInt);\n        let c3 = col!(SmallInt);\n        let c4 = col!(Int);\n        let c5 = col!(BigInt);\n        let c6 = col!(UTinyInt);\n        let c7 = col!(USmallInt);\n        let c8 = col!(UInt);\n        let c9 = col!(UBigInt);\n        let c10 = col!(Float);\n        let c11 = col!(Double);\n        let c12 = col!(Timestamp);\n        let c13 = Column::Binary(\n            (0..N)\n                .map(|_| Some(String::from(\"abc\").into_bytes()))\n                .collect(),\n        );\n        let c14 = Column::NChar((0..N).map(|_| None).collect());\n\n        let block = vec![\n            ts, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n        ];\n        let binds: Vec\u003cTaosMultiBind\u003e = block.iter().map(|c| dbg!(c.into())).collect();\n        let marks: String = std::iter::repeat(\"?\").take(15).join(\",\");\n        let mut stmt = taos\n            .stmt(format!(\"insert into tb values({marks})\"))\n            .unwrap();\n        stmt.multi_bind(\u0026binds).unwrap();\n\n        stmt.execute().unwrap();\n\n        let rows = stmt.affected_rows();\n        assert_eq!(N, rows as usize);\n\n        let mut rs = taos.query(\"select * from tb\")?;\n        for row in rs.rows_iter() {\n            for col in \u0026row {\n                println!(\"{:?}\", col);\n            }\n        }\n\n        Ok(())\n    }\n    #[crate::test(naming = \"abc\", dropping = \"none\")]\n    fn test_multi_bind_tags(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(concat!(\n            \"create table if not exists tb (ts timestamp, v binary(100)) tags(\",\n            \"c1 bool,\",\n            \"c2 tinyint,\",\n            \"c3 smallint,\",\n            \"c4 int,\",\n            \"c5 bigint,\",\n            \"c6 tinyint unsigned,\",\n            \"c7 smallint unsigned,\",\n            \"c8 int unsigned,\",\n            \"c9 bigint unsigned,\",\n            \"c10 float,\",\n            \"c11 double,\",\n            \"c12 timestamp)\",\n        ))?;\n        const N: usize = 5;\n        let nulls = BitVec::zeros(N);\n        let v: Vec\u003cOption\u003cString\u003e\u003e = (0..N).map(|_| Some(\"hello\".to_string())).collect();\n        let _ints = Column::NChar(v);\n        let v: Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e = (0..N)\n            .map(|_| Some(\"hello\".to_string().into_bytes()))\n            .collect();\n        let v = Column::Binary(v);\n\n        let ts = Column::Timestamp(\n            nulls.clone(),\n            (0..N).map(|ts| ts as i64 + 1500000000000).collect(),\n        );\n\n        macro_rules! tag {\n            ($v:expr) =\u003e {\n                dbg!(TaosBind::from(\u0026$v))\n            };\n        }\n        let c1 = tag!(true);\n        let c2 = tag!(1i8);\n        let c3 = tag!(1i16);\n        let c4 = tag!(1i32);\n        let c5 = tag!(1i64);\n        let c6 = tag!(1u8);\n        let c7 = tag!(1u16);\n        let c8 = tag!(1u32);\n        let c9 = tag!(1u64);\n        let c10 = tag!(0.0f32);\n        let c11 = tag!(0.0f64);\n        let c12 = tag!(ITimestamp(1500000000000));\n        // let c13 = tag!();\n        // let c14 = Column::NChar((0..N).map(|_| None).collect());\n\n        let tags = vec![c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12];\n        let marks: String = std::iter::repeat(\"?\").take(12).join(\",\");\n\n        let block = vec![ts, v];\n        let values: Vec\u003cTaosMultiBind\u003e = block.iter().map(|c| dbg!(c.into())).collect();\n\n        let mut stmt = taos\n            .stmt(format!(\"insert into ? using tb tags({marks}) values(?, ?)\"))\n            .unwrap();\n        stmt.set_tbname_tags(\"tb1\", \u0026tags)?;\n        println!(\"bind parmas: {values:#?}\");\n        stmt.multi_bind(\u0026values).unwrap();\n        stmt.execute().unwrap();\n\n        let rows = stmt.affected_rows();\n        assert_eq!(N, rows as usize);\n\n        let mut res = taos.query(\"select * from tb\").unwrap();\n\n        #[derive(Debug, PartialEq, serde::Deserialize)]\n        struct Row {\n            ts: i64,\n            v: String,\n            c1: bool,\n            c2: i8,\n            c3: i16,\n            c4: i32,\n            c5: i64,\n            c6: u8,\n            c7: u16,\n            c8: u32,\n            c9: u64,\n            c10: f32,\n            c11: f64,\n            c12: i64,\n        }\n        let data: Row = res\n            .deserialize()\n            .next()\n            .expect(\"there's no database\")\n            .expect(\"\");\n        dbg!(\u0026data);\n        assert!(\n            data == Row {\n                ts: 1500000000000,\n                v: \"hello\".to_string(),\n                c1: true,\n                c2: 1,\n                c3: 1,\n                c4: 1,\n                c5: 1,\n                c6: 1,\n                c7: 1,\n                c8: 1,\n                c9: 1,\n                c10: 0.0,\n                c11: 0.0,\n                c12: 1500000000000\n            }\n        );\n        Ok(())\n    }\n}\n\n// #[cfg(test)]\n// mod test {\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(format!(\n//         .await?;\n//         let mut stmt = taos.stmt(\"insert into ? values(?,?)\")?;\n//         stmt.set_tbname(\"tb0\")?;\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         stmt.bind(vec![ts, value.clone()].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select n from tb0\").await?;\n//         assert_eq!(value, res.rows[0][0]);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n\n//     macro_rules! _test_column_null {\n//         ($ty:ty, $v:expr) =\u003e {\n//             paste::paste! {\n//                 #[tokio::test]\n//                 #[test_catalogue()]\n//                 #[doc = \"Test bind null to type \" $ty]\n//                 async fn [\u003cnull_ $ty:snake\u003e]() -\u003e Result\u003c(), Error\u003e {\n//                     let db = stdext::function_name!()\n//                         .replace(\"::{{closure}}\", \"\")\n//                         .replace(\"::\", \"_\");\n//                     stmt_test(\u0026db, $v, Field::Null).await\n//                 }\n//             }\n//         };\n//     }\n//     _test_column_null!(bool, \"bool\");\n//     _test_column_null!(tinyint, \"tinyint\");\n//     _test_column_null!(smallint, \"smallint\");\n//     _test_column_null!(int, \"int\");\n//     _test_column_null!(bigint, \"bigint\");\n//     _test_column_null!(utinyint, \"tinyint unsigned\");\n//     _test_column_null!(usmallint, \"smallint unsigned\");\n//     _test_column_null!(uint, \"int unsigned\");\n//     _test_column_null!(ubigint, \"bigint unsigned\");\n//     _test_column_null!(timestamp, \"timestamp\");\n//     _test_column_null!(float, \"float\");\n//     _test_column_null!(double, \"double\");\n//     _test_column_null!(binary, \"binary(10)\");\n//     _test_column_null!(nchar, \"nchar(10)\");\n//     #[should_panic]\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test bind null to json tag, should panic because json is not supported in cols\n//     async fn null_json() -\u003e () {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"json\", Field::Null).await.unwrap()\n//     }\n\n//     async fn stmt_tag(db: \u0026str, ty: \u0026str, tag: Field) -\u003e Result\u003c(), Error\u003e {\n//         let taos = taos()?;\n//         println!(\"test {} using {}\", ty, db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(format!(\n//             \"create table if not exists stb0 (ts timestamp, v int) tags (n {})\",\n//             ty\n//         ))\n//         .await?;\n//         println!(\"start stmt\");\n//         let mut stmt = taos.stmt(\"insert into ? using stb0 tags(?) values(?,?)\")?;\n//         println!(\"set tags\");\n//         stmt.set_tbname_tags(\"tb0\", [\u0026tag])?;\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         println!(\"bind stmt\");\n//         stmt.bind(vec![ts, Field::Null].iter())?;\n//         println!(\"execute\");\n//         stmt.execute()?;\n//         println!(\"execute stmt done\");\n//         let res = taos.query(\"select n from tb0\").await?;\n//         assert_eq!(tag, res.rows[0][0]);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n//     macro_rules! _test_tag_null {\n//         ($ty:ty, $v:expr) =\u003e {\n//             paste::paste! {\n//                 #[tokio::test]\n//                 #[test_catalogue()]\n//                 #[doc = \"Test bind null to type \" $ty]\n//                 async fn [\u003cnull_tag_ $ty:snake\u003e]() -\u003e Result\u003c(), Error\u003e {\n//                     let db = stdext::function_name!()\n//                         .replace(\"::{{closure}}\", \"\")\n//                         .replace(\"::\", \"_\")\n//                         .replace(\"libtaos_\", \"\");\n//                     stmt_tag(\u0026db, $v, Field::Null).await\n//                 }\n//             }\n//         };\n//     }\n//     _test_tag_null!(bool, \"bool\");\n//     _test_tag_null!(tinyint, \"tinyint\");\n//     _test_tag_null!(smallint, \"smallint\");\n//     _test_tag_null!(int, \"int\");\n//     _test_tag_null!(bigint, \"bigint\");\n//     _test_tag_null!(utinyint, \"tinyint unsigned\");\n//     _test_tag_null!(usmallint, \"smallint unsigned\");\n//     _test_tag_null!(uint, \"int unsigned\");\n//     _test_tag_null!(ubigint, \"bigint unsigned\");\n//     _test_tag_null!(timestamp, \"timestamp\");\n//     _test_tag_null!(float, \"float\");\n//     _test_tag_null!(double, \"double\");\n//     _test_tag_null!(binary, \"binary(10)\");\n//     _test_tag_null!(nchar, \"nchar(10)\");\n//     // set null in json tag is currently abort taosd. see TD-12452.\n//     // TD-12452 is fixed by https://github.com/taosdata/TDengine/pull/9317\n//     _test_tag_null!(json, \"json\");\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with bool values.\n//     async fn bool() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"bool\", Field::Bool(true)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with tiny int values.\n//     async fn tinyint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"tinyint\", Field::TinyInt(-0x7f)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with small int values.\n//     async fn smallint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"smallint\", Field::SmallInt(0x7fff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with int values.\n//     async fn int() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"int\", Field::Int(0x7fffffff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with bigint values.\n//     async fn bigint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"bigint\", Field::BigInt(0x7fffffff_ffffffff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned tinyint values.\n//     async fn utinyint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"tinyint unsigned\", Field::UTinyInt(0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned smallint values.\n//     async fn usmallint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"smallint unsigned\", Field::USmallInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned int values.\n//     async fn uint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"int unsigned\", Field::UInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned bigint values.\n//     async fn ubigint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"bigint unsigned\", Field::UBigInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with float values.\n//     async fn float() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"float\", Field::Float(1.0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with double values.\n//     async fn double() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"double\", Field::Double(1.0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with binary values.\n//     async fn binary() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::Binary(\"0123456789\".into());\n//         stmt_test(\u0026db, \"binary(10)\", v).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with nchar(unicode) values.\n//     async fn nchar() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::NChar(\"\".into());\n//         stmt_test(\u0026db, \"nchar(10)\", v).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with json values.\n//     async fn json() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::Json(serde_json::from_str(\"{\\\"tag1\\\":\\\"\\\"}\").unwrap());\n\n//         let taos = taos()?;\n//         println!(\"test json using {}\", db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\"create stable if not exists stb0 (ts timestamp, n int) tags(j json)\")\n//             .await?;\n//         let mut stmt = taos.stmt(\"insert into ? using stb0 tags(?) values(?,?)\")?;\n//         println!(\"set tbname with tags\");\n//         stmt.set_tbname_tags(\"tb0\", [\u0026v])?;\n//         println!(\"bind values\");\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         stmt.bind(vec![ts, Field::Int(3)].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select j from stb0\").await?;\n//         let row = res.rows.iter().next().unwrap();\n//         assert_eq!(\u0026v, row.iter().next().unwrap());\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with all types of values.\n//     async fn all_types() -\u003e Result\u003c(), Error\u003e {\n//         let taos = taos()?;\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{}\", db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\n//             \"create table if not exists tb0 (ts timestamp,\n//              c1 tinyint, c2 smallint, c3 int, c4 bigint,\n//              c5 tinyint unsigned, c6 smallint unsigned, c7 int unsigned, c8 bigint unsigned,\n//              c9 float, c10 double, c11 binary(10), c12 nchar(10))\",\n//         )\n//         .await?;\n//         let mut stmt = taos.stmt(\"insert into ? values(?,?,?,?,?,?,?,?,?,?,?,?,?)\")?;\n//         stmt.set_tbname(\"tb0\")?;\n//         assert!(stmt.is_insert());\n\n//         assert_eq!(stmt.num_params(), 13);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         let c1 = Field::TinyInt(1);\n//         let c2 = Field::SmallInt(2);\n//         let c3 = Field::Int(3);\n//         let c4 = Field::BigInt(4);\n//         let c5 = Field::UTinyInt(5);\n//         let c6 = Field::USmallInt(6);\n//         let c7 = Field::UInt(7);\n//         let c8 = Field::UBigInt(8);\n//         let c9 = Field::Float(9.0);\n//         let c10 = Field::Double(9.0);\n//         let c11 = Field::Binary(\"binary\".into());\n//         let c12 = Field::NChar(\"nchar\".into());\n//         stmt.bind(vec![ts, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from tb0\").await?;\n//         println!(\"{:?}\", res);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT set tbname with upper-case stable, see jira TD-12977\n//     async fn test_uppercase_tbname() -\u003e Result\u003c(), Error\u003e {\n//         let db = \"uppercase_test\";\n//         let taos = taos()?;\n//         taos.exec(format!(\"drop database if exists {db}\")).await?;\n//         taos.exec(format!(\"create database {db}\")).await?;\n//         taos.exec(format!(\"use {db}\")).await?;\n//         taos.exec(format!(\"create stable STB(ts timestamp, n int) tags(b int)\")).await?;\n//         let mut stmt = taos.stmt(\"insert into ? using STB tags(?) values(?, ?)\")?;\n\n//         stmt.set_tbname_tags(\"tb0\", [0i32])?;\n//         // stmt.bind(\u0026[0i32])?;\n//         let values = vec![Field::Timestamp(Timestamp::now()), Field::Int(10)];\n//         stmt.bind(\u0026values)?;\n\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n\n//         let _ = stmt.execute()?;\n//         const LIMIT: i64 = 100;\n\n//         for i in 1..LIMIT {\n//             stmt.set_tbname_tags(format!(\"tb{}\", i), \u0026[2i32])?;\n//             stmt.bind(\u0026values)?;\n//         }\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from stb\").await?;\n//         assert_eq!(res.rows[0][0], Field::BigInt(LIMIT));\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n\n//         Ok(())\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT API insertion with tags\n//     async fn test_stmt_tags() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{:?}\", db);\n//         let taos = taos()?;\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\"create table if not exists stb (ts timestamp, n int) tags(b int)\")\n//             .await?;\n\n//         let mut stmt = taos.stmt(\"insert into ? using stb tags(?) values(?, ?)\")?;\n\n//         stmt.set_tbname_tags(\"tb0\", [0i32])?;\n//         // stmt.bind(\u0026[0i32])?;\n//         let values = vec![Field::Timestamp(Timestamp::now()), Field::Int(10)];\n//         stmt.bind(\u0026values)?;\n\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n\n//         let _ = stmt.execute()?;\n//         const LIMIT: i64 = 100;\n\n//         for i in 1..LIMIT {\n//             stmt.set_tbname_tags(format!(\"tb{}\", i), \u0026[2i32])?;\n//             stmt.bind(\u0026values)?;\n//         }\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from stb\").await?;\n//         assert_eq!(res.rows[0][0], Field::BigInt(LIMIT));\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n// }\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","multi_bind.rs"],"content":"use std::{marker::PhantomData, mem::ManuallyDrop};\n\nuse bitvec_simd::BitVec;\n\nuse taos_query::common::Ty;\nuse taos_sys::TaosMultiBind;\n\n#[derive(Debug)]\npub struct MultiBind\u003c'a\u003e(TaosMultiBind, PhantomData\u003c\u0026'a u8\u003e);\n\nunsafe impl\u003c'a\u003e Send for MultiBind\u003c'a\u003e {}\nunsafe impl\u003c'a\u003e Sync for MultiBind\u003c'a\u003e {}\n\npub(crate) trait TaosTypeOf {\n    fn taos_type_of() -\u003e Ty;\n}\n\nmacro_rules! impl_taos_type_of {\n    ($f:ty, $t:ident) =\u003e {\n        impl TaosTypeOf for $f {\n            #[inline]\n            fn taos_type_of() -\u003e Ty {\n                Ty::$t\n            }\n        }\n    };\n}\n\nimpl_taos_type_of!(bool, Bool);\nimpl_taos_type_of!(i8, TinyInt);\nimpl_taos_type_of!(i16, SmallInt);\nimpl_taos_type_of!(i32, Int);\nimpl_taos_type_of!(i64, BigInt);\nimpl_taos_type_of!(u8, UTinyInt);\nimpl_taos_type_of!(u16, USmallInt);\nimpl_taos_type_of!(u32, UInt);\nimpl_taos_type_of!(u64, UBigInt);\nimpl_taos_type_of!(f32, Float);\nimpl_taos_type_of!(f64, Double);\n\nimpl\u003c'a\u003e MultiBind\u003c'a\u003e {\n    pub(crate) fn nulls(n: usize) -\u003e Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::Null as _,\n                buffer: std::ptr::null_mut(),\n                buffer_length: 0,\n                length: n as _,\n                is_null: std::ptr::null_mut(),\n                num: n as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_primitives\u003cT: TaosTypeOf\u003e(nulls: \u0026BitVec, values: \u0026[T]) -\u003e Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: T::taos_type_of() as _,\n                buffer: values.as_ptr() as _,\n                buffer_length: std::mem::size_of::\u003cT\u003e(),\n                length: values.len() as _,\n                is_null: ManuallyDrop::new(nulls.clone().into_bools()).as_ptr() as _,\n                num: values.len() as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_raw_timestamps(nulls: \u0026BitVec, values: \u0026[i64]) -\u003e Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::Timestamp as _,\n                buffer: values.as_ptr() as _,\n                buffer_length: std::mem::size_of::\u003ci64\u003e(),\n                length: values.len() as _,\n                is_null: ManuallyDrop::new(nulls.clone().into_bools()).as_ptr() as _,\n                num: values.len() as _,\n            },\n            PhantomData,\n        )\n    }\n\n    pub(crate) fn from_binary_vec(values: \u0026[Option\u003cimpl AsRef\u003c[u8]\u003e\u003e]) -\u003e Self {\n        let mut buffer_length = 0;\n        let num = values.len();\n        let mut nulls = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { nulls.set_len(num) };\n        nulls.fill(false);\n        let mut length: ManuallyDrop\u003cVec\u003ci32\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { length.set_len(num) };\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                length[i] = v.len() as _;\n                if v.len() \u003e buffer_length {\n                    buffer_length = v.len();\n                }\n            } else {\n                nulls[i] = true;\n            }\n        }\n        let buffer_size = buffer_length * values.len();\n        let mut buffer: ManuallyDrop\u003cVec\u003cu8\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(buffer_size));\n        unsafe { buffer.set_len(buffer_size) };\n        buffer.fill(0);\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                unsafe {\n                    let dst = buffer.as_mut_ptr().add(buffer_length * i);\n                    std::intrinsics::copy_nonoverlapping(v.as_ptr(), dst, v.len());\n                }\n            }\n        }\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::VarChar as _,\n                buffer: buffer.as_ptr() as _,\n                buffer_length,\n                length: length.as_ptr() as _,\n                is_null: nulls.as_ptr() as _,\n                num: num as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_string_vec(values: \u0026[Option\u003cimpl AsRef\u003cstr\u003e\u003e]) -\u003e Self {\n        let values: Vec\u003c_\u003e = values\n            .iter()\n            .map(|f| {\n                f.as_ref()\n                    .map(|s| dbg!(s.as_ref().to_string()).into_bytes())\n            })\n            .collect();\n        let mut s = Self::from_binary_vec(\u0026values);\n        s.0.buffer_type = Ty::NChar as _;\n        s\n    }\n}\n\nimpl\u003c'a\u003e Drop for MultiBind\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        let ty = Ty::from(self.0.buffer_type as u8);\n        if ty == Ty::VarChar || ty == Ty::NChar {\n            let len = self.0.buffer_length * self.0.num as usize;\n            unsafe { Vec::from_raw_parts(self.0.buffer as *mut u8, len, len as _) };\n            unsafe {\n                Vec::from_raw_parts(self.0.length as *mut i32, self.0.num as _, self.0.num as _)\n            };\n        }\n        unsafe { Vec::from_raw_parts(self.0.is_null as *mut i8, self.0.num as _, self.0.num as _) };\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":74},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stream","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","timestamp.rs"],"content":"use serde::{Deserialize, Serialize};\nuse taos_sys::Precision;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\npub enum TimestampValue {\n    Milliseconds(i64),\n    Microseconds(i64),\n    Nanoseconds(i64),\n}\n\nimpl TimestampValue {\n    pub fn new(raw: i64, precision: Precision) -\u003e Self {\n        match precision {\n            Precision::Millisecond =\u003e TimestampValue::Milliseconds(raw),\n            Precision::Microsecond =\u003e TimestampValue::Microseconds(raw),\n            Precision::Nanosecond =\u003e TimestampValue::Nanoseconds(raw),\n        }\n    }\n    pub fn as_raw_i64(\u0026self) -\u003e \u0026i64 {\n        match self {\n            TimestampValue::Milliseconds(raw)\n            | TimestampValue::Microseconds(raw)\n            | TimestampValue::Nanoseconds(raw) =\u003e raw,\n        }\n    }\n    pub fn to_naive_datetime(\u0026self) -\u003e chrono::NaiveDateTime {\n        let duration = match self {\n            TimestampValue::Milliseconds(raw) =\u003e chrono::Duration::milliseconds(*raw),\n            TimestampValue::Microseconds(raw) =\u003e chrono::Duration::microseconds(*raw),\n            TimestampValue::Nanoseconds(raw) =\u003e chrono::Duration::nanoseconds(*raw),\n        };\n        chrono::NaiveDateTime::from_timestamp(0, 0)\n            .checked_add_signed(duration)\n            .unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","conf.rs"],"content":"use crate::{IntoCStr, TaosOptions};\nuse taos_error::*;\n\nuse std::{ffi::c_void, iter::Iterator};\nuse taos_query::Dsn;\nuse taos_sys::*;\n\nuse super::Consumer;\n/* tmq conf */\npub struct TmqConf(*mut tmq_conf_t);\n\nimpl TmqConf {\n    pub(crate) fn as_ptr(\u0026self) -\u003e *mut tmq_conf_t {\n        self.0\n    }\n    pub(crate) fn new() -\u003e Self {\n        Self(unsafe { tmq_conf_new() })\n    }\n\n    pub(crate) fn from_dsn(dsn: \u0026Dsn) -\u003e Result\u003cSelf\u003e {\n        let mut conf = Self::new();\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        // todo: host port?\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(database, \"db\");\n        conf.with(dsn.params.iter().filter(|(k, _)| k.contains(\".\")))\n    }\n\n    pub fn from_opts(opts: \u0026TaosOptions) -\u003e Result\u003cSelf\u003e {\n        let mut conf = Self::new();\n\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) =\u003e {\n                if let Some($f) = \u0026opts.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) =\u003e {\n                if let Some($f) = \u0026opts.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        _set_opt!(host, \"ip\");\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(port, \"port\");\n        _set_opt!(database, \"db\");\n\n        conf.with(opts.params.iter().filter(|(k, _)| k.contains(\".\")))\n    }\n\n    pub fn group_id(mut self, id: \u0026str) -\u003e Self {\n        self.set(\"group.id\", id)\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n    pub fn client_id(mut self, id: \u0026str) -\u003e Self {\n        self.set(\"client.id\", id)\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n\n    pub fn enable_auto_commit(mut self, enabled: bool) -\u003e Self {\n        self.set(\"enable.auto.commit\", if enabled { \"true\" } else { \"false\" })\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n\n    pub fn with\u003cK: AsRef\u003cstr\u003e, V: AsRef\u003cstr\u003e\u003e(\n        mut self,\n        iter: impl Iterator\u003cItem = (K, V)\u003e,\n    ) -\u003e Result\u003cSelf\u003e {\n        for (k, v) in iter {\n            self.set(k, v)?;\n        }\n        Ok(self)\n    }\n\n    pub fn set\u003cK: AsRef\u003cstr\u003e, V: AsRef\u003cstr\u003e\u003e(\u0026mut self, key: K, value: V) -\u003e Result\u003c\u0026mut Self\u003e {\n        let ret = unsafe {\n            tmq_conf_set(\n                self.0,\n                key.as_ref().into_c_str().as_ptr(),\n                value.as_ref().into_c_str().as_ptr(),\n            )\n        };\n        match ret {\n            tmq_conf_res_t::Ok =\u003e Ok(self),\n            tmq_conf_res_t::Invalid =\u003e Err(Error::from_string(\"invalid key value set for tmq\")),\n            tmq_conf_res_t::Unknown =\u003e Err(Error::from_string(\"unknown key for tmq conf\")),\n        }\n    }\n\n    pub fn set_auto_commit_cb(\u0026mut self, cb: tmq_commit_cb, param: *mut c_void) -\u003e () {\n        unsafe {\n            tmq_conf_set_auto_commit_cb(self.0, cb, param);\n        }\n    }\n\n    pub fn consumer(\u0026self) -\u003e Result\u003cConsumer\u003e {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.0, err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                Err(Error::from_string(\n                    String::from_utf8_lossy(\u0026err).to_string(),\n                ))\n            } else {\n                Ok(Consumer::new(tmq, 0))\n            }\n        }\n    }\n}\n\nimpl Drop for TmqConf {\n    fn drop(\u0026mut self) {\n        log::trace!(\"tmq config destroy\");\n        unsafe { tmq_conf_destroy(self.0) };\n        log::trace!(\"tmq config destroyed safely\");\n    }\n}\n","traces":[{"line":13,"address":[3962992],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":14,"address":[3962997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[3963008],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":17,"address":[3963012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3963749,3963056,3965607],"length":1,"stats":{"Line":0},"fn_name":"from_dsn"},{"line":21,"address":[3963092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3963159,3963760,3963333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3963239,3963983,3964082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3964705,3964024,3964817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3965585,3964746,3965457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3965648,3966394,3969712],"length":1,"stats":{"Line":0},"fn_name":"from_opts"},{"line":43,"address":[3965687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3966405,3965773,3965966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3966743,3966631,3965863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3967460,3966681,3967369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3967413,3968184,3968083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3968922,3968807,3968131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3944944,3944958],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":67,"address":[3969889,3969760],"length":1,"stats":{"Line":0},"fn_name":"group_id"},{"line":68,"address":[3969784,3969845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[3969880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3969920,3970049],"length":1,"stats":{"Line":0},"fn_name":"client_id"},{"line":73,"address":[3969944,3970005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3970040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3970080,3970269],"length":1,"stats":{"Line":0},"fn_name":"enable_auto_commit"},{"line":79,"address":[3970101,3970224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3970259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3946319,3945040,3945696,3945663],"length":1,"stats":{"Line":0},"fn_name":"with\u003c\u0026alloc::string::String, \u0026alloc::string::String, core::iter::adapters::filter::Filter\u003calloc::collections::btree::map::Iter\u003calloc::string::String, alloc::string::String\u003e, taos::tmq::conf::{impl#0}::from_dsn::{closure_env#0}\u003e\u003e"},{"line":88,"address":[3945062,3945718,3946270,3946022,3945836,3945614,3945180,3945455,3946111,3945366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[3945465,3945342,3945393,3945998,3946121,3946049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3945645,3946301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3948267,3947057,3947088,3947777,3947538,3946352,3946818,3948567,3947808],"length":1,"stats":{"Line":0},"fn_name":"set\u003c\u0026str, \u0026str\u003e"},{"line":97,"address":[3947856,3947134,3946414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3947313,3946593,3947214,3946494,3946422,3947947,3948046,3947142,3947867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3946605,3948063,3946746,3947325,3947466,3948192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3947568,3948297,3946848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3946958,3947678,3948407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3946976,3947637,3947696,3948366,3948439,3946917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3948335,3946886,3947017,3947606,3948480,3947737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3970304],"length":1,"stats":{"Line":0},"fn_name":"set_auto_commit_cb"},{"line":111,"address":[3970322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3970658,3970336],"length":1,"stats":{"Line":0},"fn_name":"consumer"},{"line":117,"address":[3970366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[3970388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3970451,3970727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3970576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3970488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3970712,3970463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3723584],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":132,"address":[3723604,3723695,3723752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3723741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3723924,3723830,3723985],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":52},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","consumer.rs"],"content":"use std::{intrinsics::transmute, task::Poll};\n\nuse crate::prelude::ResultSet;\nuse futures::{FutureExt, Stream};\nuse taos_error::*;\nuse taos_sys::*;\n\nuse super::TmqList;\n\n#[derive(Debug)]\npub struct ConsumerRef(*mut tmq_t);\n\nimpl ConsumerRef {\n    pub(crate) fn from_ptr(ptr: *mut tmq_t) -\u003e Self {\n        ConsumerRef(ptr)\n    }\n    pub fn commit(\u0026self, offsets: \u0026ResultSet) -\u003e Result\u003c()\u003e {\n        unsafe { tmq_commit_sync(self.0, offsets.as_ptr()) }.ok_or(\"commit failed\")\n    }\n}\n\n#[derive(Debug)]\npub struct Consumer {\n    ptr: *mut tmq_t,\n    wait: i64,\n}\n\nimpl Unpin for Consumer {}\n\nunsafe impl Send for Consumer {}\nunsafe impl Sync for Consumer {}\n\nimpl Consumer {\n    pub(crate) fn as_raw(\u0026self) -\u003e *mut tmq_t {\n        self.ptr\n    }\n    pub(crate) fn new(ptr: *mut tmq_t, wait: i64) -\u003e Self {\n        Self { ptr, wait }\n    }\n\n    pub(crate) fn subscribe(\u0026mut self, topic_list: \u0026TmqList) -\u003e Result\u003c()\u003e {\n        unsafe { tmq_subscribe(self.as_raw(), topic_list.0) }.ok_or(\"subscribe failed\")\n    }\n\n    pub fn subscription(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let tl = TmqList::new();\n\n        unsafe { tmq_subscription(self.as_raw(), \u0026mut tl.as_ptr()) }\n            .ok_or(\"get topic list failed\")\n            .map(|_| {\n                tl.to_str_vec()\n                    .into_iter()\n                    .map(ToString::to_string)\n                    .collect()\n            })\n    }\n\n    pub fn commit_sync(\u0026mut self, msg: \u0026ResultSet) -\u003e Result\u003c()\u003e {\n        unsafe { tmq_commit_sync(self.as_raw(), msg.as_ptr() as _) }.ok_or(\"commit failed\")\n    }\n\n    pub fn commit_non_blocking(\u0026mut self, msg: \u0026ResultSet, callback: fn(ConsumerRef, Result\u003c()\u003e)) {\n        unsafe {\n            tmq_commit_async(\n                self.as_raw(),\n                msg.as_ptr(),\n                super::tmq_commit_callback,\n                Box::into_raw(Box::new(callback)) as _,\n            )\n        }\n    }\n\n    pub async fn commit(\u0026mut self, msg: \u0026ResultSet) -\u003e Result\u003c()\u003e {\n        use tokio::sync::oneshot::{channel, Sender};\n        let (sender, rx) = channel::\u003cResult\u003c()\u003e\u003e();\n        unsafe extern \"C\" fn tmq_commit_async_cb(\n            _tmq: *mut tmq_t,\n            resp: tmq_resp_err_t,\n            param: *mut std::os::raw::c_void,\n        ) {\n            let offsets = resp.ok_or(\"commit failed\").map(|_| ());\n            let sender = param as *mut Sender\u003c_\u003e;\n            let sender = Box::from_raw(sender);\n            sender.send(offsets).unwrap();\n        }\n\n        unsafe {\n            tmq_commit_async(\n                self.as_raw(),\n                msg.as_ptr(),\n                tmq_commit_async_cb,\n                Box::into_raw(Box::new(sender)) as *mut _,\n            )\n        }\n        Ok(rx.await.unwrap()?)\n    }\n\n    pub fn poll(\u0026mut self) -\u003e Option\u003ccrate::Result\u003cResultSet\u003e\u003e {\n        let res = unsafe { tmq_consumer_poll(self.as_raw(), self.wait) };\n        if res.is_null() {\n            None\n        } else {\n            Some(\n                ResultSet::from_ptr(res)\n                    .map(|rs| rs.independent())\n                    .map_err(Into::into),\n            )\n        }\n    }\n\n    pub fn async_poll(\n        \u0026mut self,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e Poll\u003cOption\u003ccrate::Result\u003cResultSet\u003e\u003e\u003e {\n        struct TmqRef(*mut tmq_t);\n        unsafe impl Send for TmqRef {}\n        unsafe impl Sync for TmqRef {}\n        let wait = self.wait;\n        let ptr = TmqRef(self.as_raw());\n        tokio::task::spawn_blocking(move || {\n            let ptr = unsafe { transmute(ptr) };\n            let res = unsafe { tmq_consumer_poll(ptr, wait) };\n            if res.is_null() {\n                None\n            } else {\n                Some(\n                    ResultSet::from_ptr(res)\n                        .map(|rs| rs.independent())\n                        .map_err(Into::into),\n                )\n            }\n        })\n        .poll_unpin(cx)\n        .map(|res| res.unwrap())\n    }\n\n    pub async fn async_poll2(\u0026mut self) -\u003e Option\u003ccrate::Result\u003cResultSet\u003e\u003e {\n        struct TmqRef(*mut tmq_t);\n        unsafe impl Send for TmqRef {}\n        unsafe impl Sync for TmqRef {}\n        let wait = self.wait;\n        let ptr = TmqRef(self.as_raw());\n        tokio::task::spawn_blocking(move || {\n            let ptr = unsafe { transmute(ptr) };\n            let res = unsafe { tmq_consumer_poll(ptr, wait) };\n            if res.is_null() {\n                None\n            } else {\n                Some(\n                    ResultSet::from_ptr(res)\n                        .map(|rs| rs.independent())\n                        .map_err(Into::into),\n                )\n            }\n        })\n        .await\n        .unwrap_or(None)\n    }\n\n    pub fn poll_wait(\u0026mut self, wait_time: i64) -\u003e Option\u003ccrate::Result\u003cResultSet\u003e\u003e {\n        let res = unsafe { tmq_consumer_poll(self.as_raw(), wait_time) };\n        if res.is_null() {\n            None\n        } else {\n            Some(ResultSet::from_ptr(res).map_err(Into::into))\n        }\n    }\n\n    pub fn unsubscribe(\u0026mut self) {\n        unsafe {\n            log::trace!(\"close consumer\");\n            tmq_consumer_close(self.as_raw());\n            log::trace!(\"consumer closed safely\");\n        }\n    }\n}\n\nimpl Iterator for Consumer {\n    type Item = Result\u003cResultSet\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        todo!()\n    }\n}\n\nimpl Drop for Consumer {\n    fn drop(\u0026mut self) {\n        unsafe {\n            log::trace!(\"close consumer\");\n            tmq_consumer_close(self.as_raw());\n            log::trace!(\"consumer closed safely\");\n        }\n    }\n}\n\nimpl Stream for Consumer {\n    type Item = crate::Result\u003cResultSet\u003e;\n\n    fn poll_next(\n        mut self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        // self.async_poll2().boxed().poll_unpin(cx)\n        Poll::Ready(self.poll())\n    }\n}\n","traces":[{"line":14,"address":[3890976],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":15,"address":[3890985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3891008],"length":1,"stats":{"Line":0},"fn_name":"commit"},{"line":18,"address":[3891045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3891136],"length":1,"stats":{"Line":0},"fn_name":"as_raw"},{"line":35,"address":[3891141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3891152],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":41,"address":[3891200],"length":1,"stats":{"Line":0},"fn_name":"subscribe"},{"line":42,"address":[3891242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3891558,3891328],"length":1,"stats":{"Line":0},"fn_name":"subscription"},{"line":46,"address":[3891355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3891430,3891371,3891524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3891519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[3423314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3891600],"length":1,"stats":{"Line":0},"fn_name":"commit_sync"},{"line":59,"address":[3891642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3891728],"length":1,"stats":{"Line":0},"fn_name":"commit_non_blocking"},{"line":65,"address":[3891757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3891773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3891866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[3891920,3891941],"length":1,"stats":{"Line":0},"fn_name":"commit"},{"line":76,"address":[3892308,3891984],"length":1,"stats":{"Line":0},"fn_name":"tmq_commit_async_cb"},{"line":81,"address":[3423392],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":82,"address":[3892079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3892087,3892149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3892157,3892272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3892368],"length":1,"stats":{"Line":0},"fn_name":"poll"},{"line":99,"address":[3892406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3892455,3892582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3892501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3892521,3892480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3423419,3423408],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":111,"address":[3892592,3892849],"length":1,"stats":{"Line":0},"fn_name":"async_poll"},{"line":118,"address":[3892642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3892659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3423472],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":121,"address":[3423510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[3423549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3423700,3423573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3423619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3423685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[3423639,3423598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3423712,3423723],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":134,"address":[3423776,3423792],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":137,"address":[3892912,3892896],"length":1,"stats":{"Line":0},"fn_name":"async_poll2"},{"line":160,"address":[3892944],"length":1,"stats":{"Line":0},"fn_name":"poll_wait"},{"line":161,"address":[3892995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3893145,3893040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[3893086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3893106,3893065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[3893152],"length":1,"stats":{"Line":0},"fn_name":"unsubscribe"},{"line":171,"address":[3893322,3893172,3893263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[3893309,3893408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3893514,3893578,3893414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3893680],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":187,"address":[3724080],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":189,"address":[3724191,3724100,3724250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3724336,3724237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[3724342,3724506,3724442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[3893728],"length":1,"stats":{"Line":0},"fn_name":"poll_next"},{"line":204,"address":[3893758],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":61},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","mod.rs"],"content":"use std::{\n    ffi::{c_void, CStr},\n    fmt::Debug,\n    mem::ManuallyDrop,\n    slice,\n    sync::{Arc, Weak},\n};\n\nuse taos_error::*;\n\nuse crate::{IntoCStr, Taos};\nuse mdsn::IntoDsn;\nuse taos_query::Dsn;\nuse taos_sys::*;\n\nunsafe extern \"C\" fn tmq_commit_callback(\n    _tmq: *mut tmq_t,\n    resp: tmq_resp_err_t,\n    param: *mut c_void,\n) {\n    log::info!(\"commit {resp:?}\");\n    let cons = ConsumerRef::from_ptr(_tmq);\n    let cb: \u0026Weak\u003cfn(ConsumerRef, Result\u003c()\u003e)\u003e = std::mem::transmute(param);\n    (*cb.as_ptr())(cons, resp.ok_or(\"commit failed\"));\n}\n\n#[derive(Debug)]\npub struct TmqList(*mut tmq_list_t);\n\nimpl TmqList {\n    fn new() -\u003e Self {\n        Self(unsafe { tmq_list_new() })\n    }\n    fn as_ptr(\u0026self) -\u003e *mut tmq_list_t {\n        self.0\n    }\n    fn append\u003c'a\u003e(\u0026mut self, c_str: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003c()\u003e {\n        let ret = unsafe { tmq_list_append(self.0, c_str.into_c_str().as_ptr()) };\n        if ret == 0 {\n            Ok(())\n        } else {\n            Err(Error::new(Code::Failed, \"append tmq list error\"))\n        }\n    }\n\n    fn from_topics\u003c'a, T: IntoCStr\u003c'a\u003e\u003e(topics: impl IntoIterator\u003cItem = T\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut list = Self::new();\n        for topic in topics {\n            list.append(topic)?;\n        }\n        Ok(list)\n    }\n\n    pub fn iter(\u0026self) -\u003e std::vec::IntoIter\u003c\u0026str\u003e {\n        self.to_str_vec().into_iter()\n    }\n\n    pub fn to_str_vec(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        unsafe {\n            let ptr = self.as_ptr();\n            let len = tmq_list_get_size(ptr);\n            if len == 0 {\n                return vec![];\n            }\n            let arr = tmq_list_to_c_array(ptr);\n            slice::from_raw_parts(arr, len as usize)\n                .into_iter()\n                .map(|ptr| {\n                    CStr::from_ptr(*ptr)\n                        .to_str()\n                        .expect(\"topic should always be utf-8 valid\")\n                })\n                .collect()\n        }\n    }\n}\n\nimpl\u003c'a\u003e IntoIterator for \u0026'a TmqList {\n    type Item = \u0026'a str;\n\n    type IntoIter = std::vec::IntoIter\u003c\u0026'a str\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.iter()\n    }\n}\n\n// todo: tmq_list_destroy cause double free error.\nimpl Drop for TmqList {\n    fn drop(\u0026mut self) {\n        unsafe {\n            log::trace!(\"list destroy\");\n            tmq_list_destroy(self.0);\n            log::trace!(\"list destroy destroyed\");\n        }\n    }\n}\n\nmod conf;\npub use conf::*;\n\nmod consumer;\npub use consumer::Consumer;\n\nuse self::consumer::ConsumerRef;\n\npub struct TmqBuilder {\n    conf: TmqConf,\n    wait: i64,\n    topics: TmqList,\n    on_commit: Option\u003cArc\u003cfn(ConsumerRef, Result\u003c()\u003e)\u003e\u003e,\n}\n\nimpl TmqBuilder {\n    pub fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e crate::Result\u003cSelf\u003e {\n        let dsn = dsn.into_dsn().unwrap();\n        log::debug!(\"build from {dsn}\");\n        let mut conf = TmqConf::new();\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        // todo: host port?\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(database, \"db\");\n\n        if let Some(addr) = dsn.addresses.first() {\n            if let Some(host) = addr.host.as_ref() {\n                conf.set(\"td.connect.ip\", host)?;\n            }\n            if let Some(port) = addr.port.as_ref() {\n                conf.set(\"td.connect.port\", format!(\"{}\", port))?;\n            }\n        }\n        conf.set(\"msg.with.table.name\", \"true\")?;\n\n        // let tmq_params = dsn.params.iter_mut().filter(|(k, _)| k.contains(\".\")).collect();\n        let mut conf = conf.with(dsn.params.iter().filter(|(k, _)| k.contains(\".\")))?;\n        // conf.set(\"msg.with.table.name\".to_string(), \"true\".to_string()).unwrap();\n\n        let wait = dsn\n            .params\n            .get(\"wait\")\n            .and_then(|s| s.parse().ok())\n            .unwrap_or(100);\n        log::debug!(\"with wait time {wait}ms\");\n        let mut topics = TmqList::new();\n        if let Some(t) = dsn.params.get(\"topics\") {\n            for s in t.split(\",\") {\n                topics.append(s)?;\n            }\n        }\n        Ok(Self {\n            conf,\n            wait,\n            topics,\n            on_commit: None,\n        })\n    }\n\n    pub fn on_auto_commit(\u0026mut self, callback: fn(ConsumerRef, Result\u003c()\u003e)) -\u003e \u0026mut Self {\n        let on_commit = Arc::new(callback);\n        let cb = Arc::downgrade(\u0026on_commit);\n        self.on_commit = Some(on_commit);\n        // todo: callback pointer should be freed in Drop.\n        self.conf\n            .set_auto_commit_cb(tmq_commit_callback, Box::into_raw(Box::new(cb)) as _);\n        self\n    }\n\n    pub fn build(\u0026self) -\u003e crate::Result\u003cConsumer\u003e {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.conf.as_ptr(), err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                return Err(crate::Error::custom(\n                    String::from_utf8_lossy(\u0026err).to_string(),\n                ));\n            } else {\n                let mut cons = Consumer::new(tmq, self.wait);\n                cons.subscribe(\u0026self.topics)?;\n                Ok(cons)\n            }\n        }\n    }\n\n    pub fn subscribe\u003c'a, T: IntoCStr\u003c'a\u003e\u003e(\n        \u0026self,\n        topics: impl IntoIterator\u003cItem = T\u003e,\n    ) -\u003e crate::Result\u003cConsumer\u003e {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.conf.as_ptr(), err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                return Err(crate::Error::custom(\n                    String::from_utf8_lossy(\u0026err).to_string(),\n                ));\n            } else {\n                let mut cons = Consumer::new(tmq, self.wait);\n                let topics = TmqList::from_topics(topics)?;\n                cons.subscribe(\u0026topics)?;\n                Ok(cons)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::sync::atomic;\n    use std::sync::Arc;\n    use std::thread;\n    use std::time::Duration;\n\n    use crate::prelude::sync::*;\n    use crate::tmq::*;\n\n    use anyhow::Result;\n\n    #[crate::test(log_level = \"debug\")]\n    fn independent_blocks(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(\"create table tb1 (ts timestamp, v1 int)\")?;\n        taos.exec(\"create table tb2 (ts timestamp, v2 int)\")?;\n        taos.exec(\"create table tb3 (ts timestamp, v3 int)\")?;\n        taos.exec(\"create table tb4 (ts timestamp, v4 int)\")?;\n        taos.exec(\"create table tb5 (ts timestamp, v5 int)\")?;\n        taos.exec(concat!(\n            \"insert into tb1 values(now, 1) \",\n            \"tb2 values(now, 2) \",\n            \"tb3 values(now, 3)\",\n            \"tb4 values(now, 4)\",\n            \"tb5 values(now, 5)\",\n        ))?;\n        taos.exec(format!(\"create topic {database} as {database}\"))?;\n\n        let builder = TmqBuilder::from_dsn(format!(\n            \"taos:///{database}?topics={database}\u0026group.id={database}\u0026wait=1000\"\n        ))?;\n        let mut tmq = builder.build()?;\n        while let Some(Ok(mut rs)) = tmq.poll() {\n            for block in rs.blocks_iter() {\n                let fields = block.fields();\n                let tbname = block.tmq_table_name().unwrap();\n                log::info!(\"block table name: {tbname}\");\n                assert!(fields.len() == 2);\n                dbg!(fields);\n                for row in block.deserialize::\u003c(String, i32)\u003e() {\n                    let row = row?;\n                    dbg!(row);\n                }\n            }\n            let (blocks, records) = rs.summary();\n            log::info!(\"fetch {blocks} blocks, with {records} records\");\n        }\n        Ok(())\n    }\n\n    fn drop_topic(taos: \u0026Taos, topic: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(format!(\"drop topic if exists {topic}\"))?;\n        Ok(())\n    }\n\n    fn _build_consumer(taos: \u0026Taos) -\u003e Result\u003cConsumer\u003e {\n        println!(\"consumer config\");\n        let mut conf = TmqConf::new();\n        conf.set(\"group.id\", \"tg2\")?;\n        unsafe extern \"C\" fn tmq_commit_callback(\n            _tmq: *mut tmq_t,\n            resp: tmq_resp_err_t,\n            param: *mut c_void,\n        ) {\n            log::info!(\"commit {resp:?}\");\n        }\n        conf.set_auto_commit_cb(tmq_commit_callback, std::ptr::null_mut());\n        println!(\"build consumer\");\n        Ok(conf.consumer()?)\n    }\n\n    fn process_message(msg: \u0026mut ResultSet) {\n        let rows = msg.to_rows_vec();\n\n        for row in rows {\n            println!(\"{row:?}\");\n        }\n    }\n\n    fn insert(database: \u0026str, max_inserts: usize) -\u003e Result\u003c()\u003e {\n        println!(\"connect taos in a spawned thread\");\n        let taos = Taos::new((), \"root\", \"taosdata\", database, 0)?;\n        println!(\"start to insert 10 rows\");\n        for i in 0..max_inserts {\n            use crate::prelude::sync::*;\n            taos.exec(\u0026format!(\"insert into tu1 values (now, {i})\"))?;\n            println!(\"- {i} rows inserted\");\n        }\n        drop(taos);\n        println!(\"write data thread finish\");\n        Ok(())\n    }\n    fn sync_consume_loop(database: \u0026str, consumer: \u0026mut Consumer) -\u003e Result\u003c()\u003e {\n        println!(\"consume loop\");\n        let running = Arc::new(atomic::AtomicBool::new(true));\n        let msg_count = atomic::AtomicUsize::new(0);\n        let running2 = running.clone();\n\n        let database = database.to_string();\n        thread::spawn(move || match insert(\u0026database, 10) {\n            Ok(_) =\u003e {\n                running2.store(false, atomic::Ordering::SeqCst);\n            }\n            Err(err) =\u003e {\n                running2.store(false, atomic::Ordering::SeqCst);\n                eprintln!(\"{}\", err.to_string());\n            }\n        });\n\n        println!(\"inserting thread spawned.\");\n        while running.load(atomic::Ordering::SeqCst)\n            || msg_count.load(atomic::Ordering::SeqCst) \u003c 10\n        {\n            println!(\"looping...\");\n            if let Some(Ok(mut msg)) = consumer.poll_wait(1000) {\n                println!(\"msg: {}\", msg_count.load(atomic::Ordering::SeqCst));\n                process_message(\u0026mut msg);\n                msg_count.fetch_add(1, atomic::Ordering::SeqCst);\n\n                consumer.commit_sync(\u0026msg)?;\n                println!(\"msg summary: {:?}\", msg.summary());\n            }\n        }\n        println!(\"loop done\");\n        Ok(())\n    }\n\n    // todo: drop after consume will cause segmentation fault, use specific db name and no dropping.\n    // #[crate::test(log_level = \"trace\", naming = \"tmq_consume_test\", dropping = \"none\")]\n    #[crate::test(log_level = \"trace\")]\n    fn tmq_consume(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n        let version = crate::client_info();\n        println!(\"version: {}\", version);\n        if !version.starts_with(\"3\") {\n            return Ok(());\n        }\n        println!(\"connected\");\n        taos.exec_many([\n            \"create stable if not exists st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists tu1 using st1 tags(1)\",\n            \"create table if not exists tu2 using st1 tags(2)\",\n        ])?;\n        taos.create_topic_as_database(database, database)?;\n\n        let topic = database;\n        let gid = database;\n\n        let dsn = format!(\"taos:///{database}?topics={topic}\u0026group.id={gid}\u0026wait=1000\");\n        log::info!(\"subscribe with dsn: {dsn}\");\n        let mut consumer = TmqBuilder::from_dsn(\u0026dsn)?\n            .on_auto_commit(\n                |_: ConsumerRef, _: std::result::Result\u003c(), taos_error::Error\u003e| {\n                    log::info!(\"rust callback\");\n                },\n            )\n            .build()?;\n        println!(\"topics created\");\n        sync_consume_loop(database, \u0026mut consumer)?;\n        dbg!(consumer.subscription()?);\n        std::mem::drop(consumer);\n        drop_topic(\u0026taos, \u0026topic)?;\n        println!(\"finished\");\n        Ok(())\n    }\n\n    /// Consume from one database and write to another.\n    // #[crate::test(log_level = \"trace\")]\n    #[crate::test(log_level = \"trace\", naming = \"tmq1\")]\n    async fn tmq_stream(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n        let version = crate::client_info();\n        println!(\"version: {}\", version);\n        if !version.starts_with(\"3\") {\n            return Ok(());\n        }\n        println!(\"connected\");\n        taos.exec_many([\n            \"create stable if not exists st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists tu1 using st1 tags(1)\",\n            \"create table if not exists tu2 using st1 tags(2)\",\n        ])?;\n        taos.create_topic_as_database(database, database)?;\n\n        let topic = database;\n        let gid = database;\n\n        let dsn = format!(\n            \"taos:///{database}?topics={topic}\u0026group.id={gid}\u0026wait=2000\u0026msg.with.table.name=true\"\n        );\n        log::info!(\"subscribe with dsn: {dsn}\");\n        let consumer = TmqBuilder::from_dsn(\u0026dsn)?\n            .on_auto_commit(\n                |_: ConsumerRef, _: std::result::Result\u003c(), taos_error::Error\u003e| {\n                    log::info!(\"rust callback\");\n                },\n            )\n            .build()?;\n        println!(\"topics created\");\n\n        const MAX_INSERTS: usize = 10;\n        let database = database.to_string();\n        thread::spawn(move || insert(\u0026database, MAX_INSERTS));\n\n        taos.exec_many([\n            \"create database if not exists db2\",\n            \"create stable if not exists db2.st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists db2.tu1 using db2.st1 tags(1)\",\n            \"create table if not exists db2.tu2 using db2.st1 tags(2)\",\n        ])?;\n        let unfold = futures::sink::unfold(0, |mut sum, mut rs: ResultSet| async move {\n            for block in rs.blocks_iter() {\n                let bind: Vec\u003cTaosMultiBind\u003e = block.columns_iter().map(|col| col.into()).collect();\n                let table = block.tmq_table_name().unwrap();\n                let mut stmt = taos.stmt(format!(\"insert into db2.{table} values(?,?)\"))?;\n                stmt.multi_bind(\u0026bind)?;\n                stmt.execute()?;\n                let inserted = stmt.affected_rows();\n                log::info!(\"inserted {inserted} rows\");\n            }\n            let (blocks, rows) = rs.summary();\n            assert!(blocks == 1, \"tmq response blocks always should be 1\");\n            sum += rows;\n            eprintln!(\"sum: {sum}, rows in block = {rows}\");\n            Ok::\u003c_, crate::Error\u003e(sum)\n        });\n        futures::pin_mut!(unfold);\n        use futures::prelude::*;\n        consumer.forward(unfold).await?;\n\n        let db2_rows: usize = taos.query_one(\"select count(*) from db2.tu1\")?.unwrap_or(0);\n        drop_topic(\u0026taos, \u0026topic)?;\n        taos.exec(\"drop database db2\")?;\n        if db2_rows != MAX_INSERTS {\n            anyhow::bail!(\"inserted rows not match\");\n        }\n        println!(\"finished\");\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[3683488],"length":1,"stats":{"Line":0},"fn_name":"tmq_commit_callback"},{"line":21,"address":[3683616,3683525,3683685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[3683662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[3683827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[3683861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3683952],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":32,"address":[3683956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3684000],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":35,"address":[3684005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3684016],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":55,"address":[3684035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3684080],"length":1,"stats":{"Line":0},"fn_name":"to_str_vec"},{"line":60,"address":[3684115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3684135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3684153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3684163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3684176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3684204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3602736],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":69,"address":[3602750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3684320],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":84,"address":[3684337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3723088],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":92,"address":[3723108,3723199,3723256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[3723245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3723489,3723428,3723334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3684883,3684368],"length":1,"stats":{"Line":0},"fn_name":"on_auto_commit"},{"line":172,"address":[3684413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3684429,3684498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3684508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[3684823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[3684598,3684797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[3684403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3685267,3684928],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":183,"address":[3684958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3684980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[3685046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3685185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3685097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3685063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[3685311,3685482,3685383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3685441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":95},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","util","mod.rs"],"content":"pub use taos_sys::into_c_str::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","tests","de.rs"],"content":"#![allow(dead_code)]\nuse chrono::NaiveDateTime;\nuse futures::StreamExt;\nuse futures::TryStreamExt;\nuse std::ffi::CString;\n\nuse taos::helpers::ShowDatabase;\n\nuse taos::prelude::*;\n\npub use taos::helpers;\n#[derive(serde::Deserialize, Debug)]\nstruct JsonTag {\n    name: String,\n}\n\n#[derive(serde::Deserialize, Debug)]\nstruct Record {\n    ts: NaiveDateTime,\n    i8: i8,\n    i16: i16,\n    i32: i32,\n    i64: i64,\n    u8: u8,\n    u16: u16,\n    u32: u32,\n    u64: u64,\n    raw_ts: i64,\n    c_str: CString,\n    str: String,\n    json_tag: serde_json::Value,\n}\n#[derive(serde::Deserialize, Debug)]\nstruct RecordOption {\n    ts: Option\u003cNaiveDateTime\u003e,\n    i8: Option\u003ci8\u003e,\n    i16: Option\u003ci16\u003e,\n    i32: Option\u003ci32\u003e,\n    i64: Option\u003ci64\u003e,\n    u8: Option\u003cu8\u003e,\n    u16: Option\u003cu16\u003e,\n    u32: Option\u003cu32\u003e,\n    u64: Option\u003cu64\u003e,\n    raw_ts: Option\u003ci64\u003e,\n    c_str: Option\u003cCString\u003e,\n    str: Option\u003cString\u003e,\n    json_tag: Option\u003cserde_json::Value\u003e,\n}\n#[derive(serde::Deserialize, Debug)]\nstruct RecordOptionWithJsonTag {\n    ts: Option\u003cNaiveDateTime\u003e,\n    i8: Option\u003ci8\u003e,\n    i16: Option\u003ci16\u003e,\n    i32: Option\u003ci32\u003e,\n    i64: Option\u003ci64\u003e,\n    u8: Option\u003cu8\u003e,\n    u16: Option\u003cu16\u003e,\n    u32: Option\u003cu32\u003e,\n    u64: Option\u003cu64\u003e,\n    raw_ts: Option\u003ci64\u003e,\n    c_str: Option\u003cCString\u003e,\n    str: Option\u003cString\u003e,\n    json_tag: Option\u003cJsonTag\u003e,\n}\n\n#[cfg(any(feature = \"test\", test))]\n#[taos::test(log_level = \"trace\")]\nasync fn de_seq_value(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (gid int, location nchar(16))\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags(1, 'beijing') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags(2, 'shanghai') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos.query(\"select tbname,gid,location from stb1\").await?;\n    use futures::StreamExt;\n\n    use futures::future;\n    res.deserialize_stream::\u003cVec\u003cValue\u003e\u003e()\n        .enumerate()\n        .for_each(|(_, v)| {\n            let value = v.unwrap();\n            log::debug!(\"{:?}\", value);\n            future::ready(())\n        })\n        .await;\n\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_seq_value2(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (groupid int, location nchar(16))\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags(1, 'beijing') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags(2, 'shanghai') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos\n        .query(\"select tbname,groupid,location from stb1\")\n        .await?;\n    use futures::StreamExt;\n\n    // block.rows_iter()\n    // let mut stream = res.deserialize_stream();\n    use futures::future;\n    res.deserialize_stream::\u003cVec\u003cValue\u003e\u003e()\n        .enumerate()\n        .for_each(|(_, v)| {\n            let value = v.unwrap();\n            log::debug!(\"{:?}\", value);\n            future::ready(())\n        })\n        .await;\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_all(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    use futures::StreamExt;\n\n    // block.rows_iter()\n    let record: Record = res.deserialize_stream().next().await.unwrap()?;\n    log::debug!(\"fetched record {:?}\", record);\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\", dropping = \"none\")]\nasync fn de_all_option(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags('{\"name\":\"\"}') \"#,\n        r#\"values (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\"#\n    ))?;\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    // block.rows_iter()\n    let record: Vec\u003cRecordOption\u003e = res.deserialize_stream().try_collect().await?;\n    log::debug!(\"fetched record {:?}\", record);\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\")]\nasync fn de_all_option_with_json_tag_struct(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags('{\"name\":\"\"}') \"#,\n        r#\"values (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\"#\n    ))?;\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    // block.rows_iter()\n    let record: Vec\u003cRecordOptionWithJsonTag\u003e = res.deserialize_stream().try_collect().await?;\n    log::debug!(\"fetched records {:#?}\", record);\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_string(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    let mut res = taos.query(\"select server_version() as version\").await?;\n    use futures::StreamExt;\n\n    let version: String = res\n        .deserialize_stream()\n        .next()\n        .await\n        .expect(\"select version\")?;\n    println!(\"version: {version}\");\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_wrapper_struct(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    let mut res = taos.query(\"select server_version() as version\").await?;\n    use futures::StreamExt;\n\n    #[derive(::serde::Deserialize, Debug)]\n    struct Version(String);\n    let version: Version = res\n        .deserialize_stream()\n        .next()\n        .await\n        .expect(\"select version\")?;\n    println!(\"version: {:?}\", version);\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_named_struct(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    macro_rules! de {\n        ($taos:expr, $sql:expr) =\u003e {\n            $taos\n                .query($sql)\n                .await?\n                .deserialize_stream()\n                .next()\n                .await\n                .unwrap()?\n        };\n    }\n    #[derive(::serde::Deserialize, Debug)]\n    struct Version {\n        version: String,\n    }\n    #[derive(::serde::Deserialize, Debug)]\n    struct WrapperVersion(String);\n    #[derive(::serde::Deserialize, Debug)]\n    struct WrapperOptionVersion(Option\u003cString\u003e);\n\n    // value\n    let _version: String = de!(taos, \"select server_version()\");\n    // tuple\n    let _version: (String,) = de!(taos, \"select server_version()\");\n    // struct\n    let _version: Version = de!(taos, \"select server_version() as version\");\n    // option\n    let _version: Option\u003cString\u003e = de!(taos, \"select server_version() as version\");\n    // wrapper struct\n    let _version: WrapperVersion = de!(taos, \"select server_version() as version\");\n    // wrapper struct with option\n    let _version: WrapperOptionVersion = dbg!(de!(taos, \"select server_version() as version\"));\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_vec(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    // let taos = TaosOptions::new().build()?;\n    // std::env::set_var(\"RUST_LOG\", \"trace\");\n    // pretty_env_logger::init();\n\n    let db: Vec\u003cShowDatabase\u003e = taos.databases().await?;\n    println!(\"db: {:?}\", db);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-error","build.rs"],"content":"use std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::{error::Error, io::BufReader};\n\nuse heck::*;\nuse regex::Regex;\n\nfn code_from_header(\n    header: impl AsRef\u003cPath\u003e,\n    mut output: impl Write,\n) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let regex = Regex::new(\n        r\"#define TSDB_CODE_(?P\u003cname\u003e\\S+)\\s+TAOS_DEF_ERROR_CODE\\(0, (?P\u003ccode\u003e\\S+)\\)\\s+//.(?P\u003creason\u003e.*).\\)\",\n    )?;\n\n    let file = File::open(header)?;\n    let buf = BufReader::new(file);\n    const NAME: \u0026str = \"Code\";\n    writeln!(\n        output,\n        r#\"\nuse std::fmt;\n\nuse num_enum::{{FromPrimitive, IntoPrimitive}};\n\nmacro_rules! _impl_fmt {{\n    ($fmt:ident) =\u003e {{\n        impl fmt::$fmt for {NAME} {{\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {{\n                let val = *self as i32;\n                fmt::$fmt::fmt(\u0026val, f)\n            }}\n        }}\n    }};\n}}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum {NAME} {{\n    /// Success, 0\n    Success = 0x0000,\"#\n    )?;\n    let codes: Vec\u003c_\u003e = buf\n        .lines()\n        .flat_map(Result::ok)\n        .flat_map(|line| {\n            regex.captures(\u0026line).map(|caps| {\n                (\n                    caps.name(\"name\").unwrap().as_str().to_string(),\n                    caps.name(\"code\").unwrap().as_str().to_string(),\n                    caps.name(\"reason\").unwrap().as_str().to_string(),\n                )\n            })\n        })\n        .collect();\n    for (name, code, reason) in \u0026codes {\n        writeln!(output, \"    /// {}: {}\", name, reason)?;\n        writeln!(output, \"    {} = {},\", name.to_upper_camel_case(), code)?;\n    }\n    writeln!(\n        output,\n        r#\"\n    #[num_enum(default)]\n    Failed = 0xffff,\n}}\n\nimpl {NAME} {{\n    pub fn success(\u0026self) -\u003e bool {{\n        matches!(self, {NAME}::Success)\n    }}\"#\n    )?;\n\n    for (name, _, reason) in \u0026codes {\n        writeln!(output, \"    /// {}: {}\", name, reason)?;\n        writeln!(\n            output,\n            \"    pub fn {}(\u0026self) -\u003e bool {{\\n        matches!(self, {NAME}::{})\\n    }}\",\n            name.to_snake_case(),\n            name.to_upper_camel_case()\n        )?;\n    }\n    writeln!(output, r#\"}}\"#)?;\n\n    writeln!(\n        output,\n        r#\"\nimpl {NAME} {{\n    pub fn to_str(\u0026self) -\u003e \u0026'static str {{\n        use {NAME}::*;\n        match self {{\n            Success =\u003e \"Success\",\n\"#\n    )?;\n    for (name, _, reason) in \u0026codes {\n        writeln!(\n            output,\n            r#\"            {} =\u003e \"{reason}\",\"#,\n            name.to_upper_camel_case()\n        )?;\n    }\n    writeln!(\n        output,\n        r#\"            Failed =\u003e \"Unknown or needn't tell detail error\",\"#\n    )?;\n    writeln!(\n        output,\n        r#\"        }}\n    }}\n}}\n\"#\n    )?;\n    Ok(())\n}\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let header = \"src/taoserror.h\";\n    println!(\"cargo:rerun-if-changed={header}\");\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    let out_dir = env::var_os(\"OUT_DIR\").unwrap();\n    let rs = File::create(Path::new(\u0026out_dir).join(\"code.rs\"))?;\n    code_from_header(header, rs)?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-error","src","lib.rs"],"content":"use std::{\n    borrow::Cow,\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nmod code {\n    include!(concat!(env!(\"OUT_DIR\"), \"/code.rs\"));\n}\n\npub use code::Code;\nuse serde::de;\n\n#[derive(Debug)]\npub struct Error {\n    code: Code,\n    err: Cow\u003c'static, str\u003e,\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\nimpl std::error::Error for Error {}\n\nimpl Error {\n    #[inline]\n    pub fn new(code: impl Into\u003cCode\u003e, err: impl Into\u003cCow\u003c'static, str\u003e\u003e) -\u003e Self {\n        Self {\n            code: code.into(),\n            err: err.into(),\n        }\n    }\n\n    #[inline]\n    pub fn from_code(code: impl Into\u003cCode\u003e) -\u003e Self {\n        Self {\n            code: code.into(),\n            err: \"\".into(),\n        }\n    }\n\n    #[inline]\n    pub fn from_string(err: impl Into\u003cCow\u003c'static, str\u003e\u003e) -\u003e Self {\n        Self {\n            code: Code::Failed,\n            err: err.into(),\n        }\n    }\n}\n\nimpl FromStr for Error {\n    type Err = ();\n\n    #[inline]\n    fn from_str(s: \u0026str) -\u003e std::result::Result\u003cSelf, Self::Err\u003e {\n        Ok(Self {\n            code: Code::Failed,\n            err: s.to_string().into(),\n        })\n    }\n}\n\nimpl Display for Error {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{:#06X}] {}\", self.code, self.err)\n    }\n}\n\nimpl de::Error for Error {\n    #[inline]\n    fn custom\u003cT: fmt::Display\u003e(msg: T) -\u003e Error {\n        Error::from_string(format!(\"{}\", msg))\n    }\n}\n\n#[test]\nfn test_display() {\n    let err = Error::new(Code::Success, \"Success\");\n    assert_eq!(format!(\"{err}\"), \"[0x0000] Success\");\n}\n","traces":[{"line":26,"address":[8118550,8118320,8118576,8118778,8118806,8119017,8118522,8118832],"length":1,"stats":{"Line":0},"fn_name":"new\u003ctaos_error::code::Code, alloc::string::String\u003e"},{"line":28,"address":[8118880,8118613,8118357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[8118419,8118939,8118675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[8119040],"length":1,"stats":{"Line":0},"fn_name":"from_code\u003ctaos_error::code::Code\u003e"},{"line":36,"address":[8119069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8119079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3841600,3841712],"length":1,"stats":{"Line":0},"fn_name":"from_string\u003c\u0026str\u003e"},{"line":45,"address":[3841631,3841733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8764448],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":55,"address":[8764515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8764477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[8764485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3972080],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":65,"address":[3972113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[8782992,8783192],"length":1,"stats":{"Line":0},"fn_name":"custom\u003ccore::fmt::Arguments\u003e"},{"line":72,"address":[8783080,8783022],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","src","lib.rs"],"content":"#[cfg(test)]\nmod tests {\n    use taos::Taos;\n    use taos_macros::test;\n\n    #[test]\n    fn sync() {}\n\n    #[test]\n    async fn async_unit() {}\n\n    #[test]\n    async fn async_with_taos(_taos: \u0026Taos) {}\n\n    #[test]\n    async fn async_with_taos_db(_taos: \u0026Taos, _database: \u0026str) {}\n\n    #[test(databases = 10)]\n    async fn async_with_taos_multi(taos: \u0026Taos, _databases: \u0026[\u0026str]) -\u003e taos::Result\u003c()\u003e {\n        let a = taos.databases().await?;\n        assert!(a.len() \u003e= 10);\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","anyhow-d6c2a10a550f3674","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(\u0026self) -\u003e Option\u003c\u0026Backtrace\u003e {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ =\u003e {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","anyhow-db2f151f47fbe6e5","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(\u0026self) -\u003e Option\u003c\u0026Backtrace\u003e {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ =\u003e {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","taos-error-377b4e21fb40c858","out","code.rs"],"content":"\nuse std::fmt;\n\nuse num_enum::{FromPrimitive, IntoPrimitive};\n\nmacro_rules! _impl_fmt {\n    ($fmt:ident) =\u003e {\n        impl fmt::$fmt for Code {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                let val = *self as i32;\n                fmt::$fmt::fmt(\u0026val, f)\n            }\n        }\n    };\n}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum Code {\n    /// Success, 0\n    Success = 0x0000,\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    TscInvalidOperation = 0x0200,\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    TscInvalidQhandle = 0x0201,\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    TscInvalidTimeStamp = 0x0202,\n    /// TSC_INVALID_VALUE: Invalid value in client\n    TscInvalidValue = 0x0203,\n    /// TSC_INVALID_VERSION: Invalid client version\n    TscInvalidVersion = 0x0204,\n    /// TSC_INVALID_IE: Invalid client ie\n    TscInvalidIe = 0x0205,\n    /// TSC_INVALID_FQDN: Invalid host name\n    TscInvalidFqdn = 0x0206,\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    TscInvalidUserLength = 0x0207,\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    TscInvalidPassLength = 0x0208,\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    TscInvalidDbLength = 0x0209,\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    TscInvalidTableIdLength = 0x020A,\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    TscInvalidConnection = 0x020B,\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    TscOutOfMemory = 0x020C,\n    /// TSC_NO_DISKSPACE: System out of disk space\n    TscNoDiskspace = 0x020D,\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    TscQueryCacheErased = 0x020E,\n    /// TSC_QUERY_CANCELLED: Query terminated\n    TscQueryCancelled = 0x020F,\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    TscSortedResTooMany = 0x0210,\n    /// TSC_APP_ERROR: Application error\n    TscAppError = 0x0211,\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    TscActionInProgress = 0x0212,\n    /// TSC_DISCONNECTED: Disconnected from service\n    TscDisconnected = 0x0213,\n    /// TSC_NO_WRITE_AUTH: No write permission\n    TscNoWriteAuth = 0x0214,\n    /// TSC_CONN_KILLED: Connection killed\n    TscConnKilled = 0x0215,\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    TscSqlSyntaxError = 0x0216,\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    TscDbNotSelected = 0x0217,\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    TscInvalidTableName = 0x0218,\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    TscExceedSqlLimit = 0x0219,\n    /// TSC_FILE_EMPTY: File is empty\n    TscFileEmpty = 0x021A,\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    TscLineSyntaxError = 0x021B,\n    /// TSC_NO_META_CACHED: No table meta cached\n    TscNoMetaCached = 0x021C,\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    TscDupColNames = 0x021D,\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    TscInvalidTagLength = 0x021E,\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    TscInvalidColumnLength = 0x021F,\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    TscDupTagNames = 0x0220,\n    /// TSC_INVALID_JSON: Invalid JSON format\n    TscInvalidJson = 0x0221,\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    TscInvalidJsonType = 0x0222,\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    TscInvalidJsonConfig = 0x0223,\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    TscValueOutOfRange = 0x0224,\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    TscInvalidProtocolType = 0x0225,\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    TscInvalidPrecisionType = 0x0226,\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    TscResTooMany = 0x0227,\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    TscInvalidSchemaVersion = 0x0228,\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    MndInvalidTopic = 0x0392,\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    MndInvalidTopicOption = 0x0393,\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    MndInvalidTopicPartitons = 0x0394,\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    MndTopicAlreadyExist = 0x0395,\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    TdbInvalidTableId = 0x0600,\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    TdbInvalidTableType = 0x0601,\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    TdbIvdTbSchemaVersion = 0x0602,\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    TdbTableAlreadyExist = 0x0603,\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    TdbInvalidConfig = 0x0604,\n    /// TDB_INIT_FAILED: Tsdb init failed\n    TdbInitFailed = 0x0605,\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    TdbNoDiskspace = 0x0606,\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    TdbNoDiskPermissions = 0x0607,\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    TdbFileCorrupted = 0x0608,\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    TdbOutOfMemory = 0x0609,\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    TdbTagVerOutOfDate = 0x060A,\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    TdbTimestampOutOfRange = 0x060B,\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    TdbSubmitMsgMssedUp = 0x060C,\n    /// TDB_INVALID_ACTION: Invalid operation\n    TdbInvalidAction = 0x060D,\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    TdbInvalidCreateTbMsg = 0x060E,\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    TdbNoTableDataInMem = 0x060F,\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    TdbFileAlreadyExists = 0x0610,\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    TdbTableReconfigure = 0x0611,\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    TdbIvdCreateTableInfo = 0x0612,\n    /// TDB_NO_AVAIL_DISK: No available disk\n    TdbNoAvailDisk = 0x0613,\n    /// TDB_MESSED_MSG: TSDB messed message\n    TdbMessedMsg = 0x0614,\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    TdbIvldTagVal = 0x0615,\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    TdbNoCacheLastRow = 0x0616,\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    TdbIncompleteDfileset = 0x0617,\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    QryInvalidQhandle = 0x0700,\n    /// QRY_INVALID_MSG: Invalid message\n    QryInvalidMsg = 0x0701,\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    QryNoDiskspace = 0x0702,\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    QryOutOfMemory = 0x0703,\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    QryAppError = 0x0704,\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    QryDupJoinKey = 0x0705,\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    QryExceedTagsLimit = 0x0706,\n    /// QRY_NOT_READY: Query not ready\n    QryNotReady = 0x0707,\n    /// QRY_HAS_RSP: Query should response\n    QryHasRsp = 0x0708,\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    QryInExec = 0x0709,\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    QryTooManyTimewindow = 0x070A,\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    QryNotEnoughBuffer = 0x070B,\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    QryInconsistan = 0x070C,\n    /// QRY_SYS_ERROR: System error\n    QrySysError = 0x070D,\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    QryInvalidTimeCondition = 0x070E,\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    QryInvalidSchemaVersion = 0x0710,\n\n    #[num_enum(default)]\n    Failed = 0xffff,\n}\n\nimpl Code {\n    pub fn success(\u0026self) -\u003e bool {\n        matches!(self, Code::Success)\n    }\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    pub fn tsc_invalid_operation(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidOperation)\n    }\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    pub fn tsc_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidQhandle)\n    }\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    pub fn tsc_invalid_time_stamp(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTimeStamp)\n    }\n    /// TSC_INVALID_VALUE: Invalid value in client\n    pub fn tsc_invalid_value(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidValue)\n    }\n    /// TSC_INVALID_VERSION: Invalid client version\n    pub fn tsc_invalid_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidVersion)\n    }\n    /// TSC_INVALID_IE: Invalid client ie\n    pub fn tsc_invalid_ie(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidIe)\n    }\n    /// TSC_INVALID_FQDN: Invalid host name\n    pub fn tsc_invalid_fqdn(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidFqdn)\n    }\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    pub fn tsc_invalid_user_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidUserLength)\n    }\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    pub fn tsc_invalid_pass_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPassLength)\n    }\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    pub fn tsc_invalid_db_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidDbLength)\n    }\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    pub fn tsc_invalid_table_id_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableIdLength)\n    }\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    pub fn tsc_invalid_connection(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidConnection)\n    }\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    pub fn tsc_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TscOutOfMemory)\n    }\n    /// TSC_NO_DISKSPACE: System out of disk space\n    pub fn tsc_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoDiskspace)\n    }\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    pub fn tsc_query_cache_erased(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCacheErased)\n    }\n    /// TSC_QUERY_CANCELLED: Query terminated\n    pub fn tsc_query_cancelled(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCancelled)\n    }\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    pub fn tsc_sorted_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSortedResTooMany)\n    }\n    /// TSC_APP_ERROR: Application error\n    pub fn tsc_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscAppError)\n    }\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    pub fn tsc_action_in_progress(\u0026self) -\u003e bool {\n        matches!(self, Code::TscActionInProgress)\n    }\n    /// TSC_DISCONNECTED: Disconnected from service\n    pub fn tsc_disconnected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDisconnected)\n    }\n    /// TSC_NO_WRITE_AUTH: No write permission\n    pub fn tsc_no_write_auth(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoWriteAuth)\n    }\n    /// TSC_CONN_KILLED: Connection killed\n    pub fn tsc_conn_killed(\u0026self) -\u003e bool {\n        matches!(self, Code::TscConnKilled)\n    }\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    pub fn tsc_sql_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSqlSyntaxError)\n    }\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    pub fn tsc_db_not_selected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDbNotSelected)\n    }\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    pub fn tsc_invalid_table_name(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableName)\n    }\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    pub fn tsc_exceed_sql_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::TscExceedSqlLimit)\n    }\n    /// TSC_FILE_EMPTY: File is empty\n    pub fn tsc_file_empty(\u0026self) -\u003e bool {\n        matches!(self, Code::TscFileEmpty)\n    }\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    pub fn tsc_line_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscLineSyntaxError)\n    }\n    /// TSC_NO_META_CACHED: No table meta cached\n    pub fn tsc_no_meta_cached(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoMetaCached)\n    }\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    pub fn tsc_dup_col_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupColNames)\n    }\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    pub fn tsc_invalid_tag_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTagLength)\n    }\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    pub fn tsc_invalid_column_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidColumnLength)\n    }\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    pub fn tsc_dup_tag_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupTagNames)\n    }\n    /// TSC_INVALID_JSON: Invalid JSON format\n    pub fn tsc_invalid_json(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJson)\n    }\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    pub fn tsc_invalid_json_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonType)\n    }\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    pub fn tsc_invalid_json_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonConfig)\n    }\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    pub fn tsc_value_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TscValueOutOfRange)\n    }\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    pub fn tsc_invalid_protocol_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidProtocolType)\n    }\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    pub fn tsc_invalid_precision_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPrecisionType)\n    }\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    pub fn tsc_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscResTooMany)\n    }\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    pub fn tsc_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidSchemaVersion)\n    }\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    pub fn mnd_invalid_topic(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopic)\n    }\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    pub fn mnd_invalid_topic_option(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicOption)\n    }\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    pub fn mnd_invalid_topic_partitons(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicPartitons)\n    }\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    pub fn mnd_topic_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::MndTopicAlreadyExist)\n    }\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    pub fn tdb_invalid_table_id(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableId)\n    }\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    pub fn tdb_invalid_table_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableType)\n    }\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    pub fn tdb_ivd_tb_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdTbSchemaVersion)\n    }\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    pub fn tdb_table_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableAlreadyExist)\n    }\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    pub fn tdb_invalid_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidConfig)\n    }\n    /// TDB_INIT_FAILED: Tsdb init failed\n    pub fn tdb_init_failed(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInitFailed)\n    }\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    pub fn tdb_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskspace)\n    }\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    pub fn tdb_no_disk_permissions(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskPermissions)\n    }\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    pub fn tdb_file_corrupted(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileCorrupted)\n    }\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    pub fn tdb_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbOutOfMemory)\n    }\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    pub fn tdb_tag_ver_out_of_date(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTagVerOutOfDate)\n    }\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    pub fn tdb_timestamp_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTimestampOutOfRange)\n    }\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    pub fn tdb_submit_msg_mssed_up(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbSubmitMsgMssedUp)\n    }\n    /// TDB_INVALID_ACTION: Invalid operation\n    pub fn tdb_invalid_action(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidAction)\n    }\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    pub fn tdb_invalid_create_tb_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidCreateTbMsg)\n    }\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    pub fn tdb_no_table_data_in_mem(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoTableDataInMem)\n    }\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    pub fn tdb_file_already_exists(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileAlreadyExists)\n    }\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    pub fn tdb_table_reconfigure(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableReconfigure)\n    }\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    pub fn tdb_ivd_create_table_info(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdCreateTableInfo)\n    }\n    /// TDB_NO_AVAIL_DISK: No available disk\n    pub fn tdb_no_avail_disk(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoAvailDisk)\n    }\n    /// TDB_MESSED_MSG: TSDB messed message\n    pub fn tdb_messed_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbMessedMsg)\n    }\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    pub fn tdb_ivld_tag_val(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvldTagVal)\n    }\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    pub fn tdb_no_cache_last_row(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoCacheLastRow)\n    }\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    pub fn tdb_incomplete_dfileset(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIncompleteDfileset)\n    }\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    pub fn qry_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidQhandle)\n    }\n    /// QRY_INVALID_MSG: Invalid message\n    pub fn qry_invalid_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidMsg)\n    }\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    pub fn qry_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNoDiskspace)\n    }\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    pub fn qry_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::QryOutOfMemory)\n    }\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    pub fn qry_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QryAppError)\n    }\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    pub fn qry_dup_join_key(\u0026self) -\u003e bool {\n        matches!(self, Code::QryDupJoinKey)\n    }\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    pub fn qry_exceed_tags_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::QryExceedTagsLimit)\n    }\n    /// QRY_NOT_READY: Query not ready\n    pub fn qry_not_ready(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotReady)\n    }\n    /// QRY_HAS_RSP: Query should response\n    pub fn qry_has_rsp(\u0026self) -\u003e bool {\n        matches!(self, Code::QryHasRsp)\n    }\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    pub fn qry_in_exec(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInExec)\n    }\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    pub fn qry_too_many_timewindow(\u0026self) -\u003e bool {\n        matches!(self, Code::QryTooManyTimewindow)\n    }\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    pub fn qry_not_enough_buffer(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotEnoughBuffer)\n    }\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    pub fn qry_inconsistan(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInconsistan)\n    }\n    /// QRY_SYS_ERROR: System error\n    pub fn qry_sys_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QrySysError)\n    }\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    pub fn qry_invalid_time_condition(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidTimeCondition)\n    }\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    pub fn qry_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidSchemaVersion)\n    }\n}\n\nimpl Code {\n    pub fn to_str(\u0026self) -\u003e \u0026'static str {\n        use Code::*;\n        match self {\n            Success =\u003e \"Success\",\n\n            TscInvalidOperation =\u003e \"Invalid Operation\",\n            TscInvalidQhandle =\u003e \"Invalid qhandle\",\n            TscInvalidTimeStamp =\u003e \"Invalid combination of client/service time\",\n            TscInvalidValue =\u003e \"Invalid value in client\",\n            TscInvalidVersion =\u003e \"Invalid client version\",\n            TscInvalidIe =\u003e \"Invalid client ie\",\n            TscInvalidFqdn =\u003e \"Invalid host name\",\n            TscInvalidUserLength =\u003e \"Invalid user name\",\n            TscInvalidPassLength =\u003e \"Invalid password\",\n            TscInvalidDbLength =\u003e \"Database name too long\",\n            TscInvalidTableIdLength =\u003e \"Table name too long\",\n            TscInvalidConnection =\u003e \"Invalid connection\",\n            TscOutOfMemory =\u003e \"System out of memory\",\n            TscNoDiskspace =\u003e \"System out of disk space\",\n            TscQueryCacheErased =\u003e \"Query cache erased\",\n            TscQueryCancelled =\u003e \"Query terminated\",\n            TscSortedResTooMany =\u003e \"Result set too large to be sorted\",\n            TscAppError =\u003e \"Application error\",\n            TscActionInProgress =\u003e \"Action in progress\",\n            TscDisconnected =\u003e \"Disconnected from service\",\n            TscNoWriteAuth =\u003e \"No write permission\",\n            TscConnKilled =\u003e \"Connection killed\",\n            TscSqlSyntaxError =\u003e \"Syntax error in SQL\",\n            TscDbNotSelected =\u003e \"Database not specified or available\",\n            TscInvalidTableName =\u003e \"Table does not exist\",\n            TscExceedSqlLimit =\u003e \"SQL statement too long check maxSQLLength config\",\n            TscFileEmpty =\u003e \"File is empty\",\n            TscLineSyntaxError =\u003e \"Syntax error in Line\",\n            TscNoMetaCached =\u003e \"No table meta cached\",\n            TscDupColNames =\u003e \"duplicated column names\",\n            TscInvalidTagLength =\u003e \"Invalid tag length\",\n            TscInvalidColumnLength =\u003e \"Invalid column length\",\n            TscDupTagNames =\u003e \"duplicated tag names\",\n            TscInvalidJson =\u003e \"Invalid JSON format\",\n            TscInvalidJsonType =\u003e \"Invalid JSON data type\",\n            TscInvalidJsonConfig =\u003e \"Invalid JSON configuration\",\n            TscValueOutOfRange =\u003e \"Value out of range\",\n            TscInvalidProtocolType =\u003e \"Invalid line protocol type\",\n            TscInvalidPrecisionType =\u003e \"Invalid timestamp precision type\",\n            TscResTooMany =\u003e \"Result set too large to be output\",\n            TscInvalidSchemaVersion =\u003e \"invalid table schema version\",\n            MndInvalidTopic =\u003e \"Invalid topic nam\",\n            MndInvalidTopicOption =\u003e \"Invalid topic optio\",\n            MndInvalidTopicPartitons =\u003e \"Invalid topic partitons num, valid range: [1, 1000\",\n            MndTopicAlreadyExist =\u003e \"Topic already exist\",\n            TdbInvalidTableId =\u003e \"Invalid table ID\",\n            TdbInvalidTableType =\u003e \"Invalid table type\",\n            TdbIvdTbSchemaVersion =\u003e \"Invalid table schema version\",\n            TdbTableAlreadyExist =\u003e \"Table already exists\",\n            TdbInvalidConfig =\u003e \"Invalid configuration\",\n            TdbInitFailed =\u003e \"Tsdb init failed\",\n            TdbNoDiskspace =\u003e \"No diskspace for tsdb\",\n            TdbNoDiskPermissions =\u003e \"No permission for disk files\",\n            TdbFileCorrupted =\u003e \"Data file(s) corrupted\",\n            TdbOutOfMemory =\u003e \"Out of memory\",\n            TdbTagVerOutOfDate =\u003e \"Tag too old\",\n            TdbTimestampOutOfRange =\u003e \"Timestamp data out of range\",\n            TdbSubmitMsgMssedUp =\u003e \"Submit message is messed up\",\n            TdbInvalidAction =\u003e \"Invalid operation\",\n            TdbInvalidCreateTbMsg =\u003e \"Invalid creation of table\",\n            TdbNoTableDataInMem =\u003e \"No table data in memory skiplist\",\n            TdbFileAlreadyExists =\u003e \"File already exists\",\n            TdbTableReconfigure =\u003e \"Need to reconfigure table\",\n            TdbIvdCreateTableInfo =\u003e \"Invalid information to create table\",\n            TdbNoAvailDisk =\u003e \"No available disk\",\n            TdbMessedMsg =\u003e \"TSDB messed message\",\n            TdbIvldTagVal =\u003e \"TSDB invalid tag value\",\n            TdbNoCacheLastRow =\u003e \"TSDB no cache last row data\",\n            TdbIncompleteDfileset =\u003e \"TSDB incomplete DFileSet\",\n            QryInvalidQhandle =\u003e \"Invalid handle\",\n            QryInvalidMsg =\u003e \"Invalid message\",\n            QryNoDiskspace =\u003e \"No diskspace for query\",\n            QryOutOfMemory =\u003e \"System out of memory\",\n            QryAppError =\u003e \"Unexpected generic error in query\",\n            QryDupJoinKey =\u003e \"Duplicated join key\",\n            QryExceedTagsLimit =\u003e \"Tag condition too many\",\n            QryNotReady =\u003e \"Query not ready\",\n            QryHasRsp =\u003e \"Query should response\",\n            QryInExec =\u003e \"Multiple retrieval of this query\",\n            QryTooManyTimewindow =\u003e \"Too many time window in query\",\n            QryNotEnoughBuffer =\u003e \"Query buffer limit has reached\",\n            QryInconsistan =\u003e \"File inconsistency in replica\",\n            QrySysError =\u003e \"System error\",\n            QryInvalidTimeCondition =\u003e \"invalid time condition\",\n            QryInvalidSchemaVersion =\u003e \"invalid schema version\",\n            Failed =\u003e \"Unknown or needn't tell detail error\",\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","taos-error-9a878855c40049e3","out","code.rs"],"content":"\nuse std::fmt;\n\nuse num_enum::{FromPrimitive, IntoPrimitive};\n\nmacro_rules! _impl_fmt {\n    ($fmt:ident) =\u003e {\n        impl fmt::$fmt for Code {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                let val = *self as i32;\n                fmt::$fmt::fmt(\u0026val, f)\n            }\n        }\n    };\n}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum Code {\n    /// Success, 0\n    Success = 0x0000,\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    TscInvalidOperation = 0x0200,\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    TscInvalidQhandle = 0x0201,\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    TscInvalidTimeStamp = 0x0202,\n    /// TSC_INVALID_VALUE: Invalid value in client\n    TscInvalidValue = 0x0203,\n    /// TSC_INVALID_VERSION: Invalid client version\n    TscInvalidVersion = 0x0204,\n    /// TSC_INVALID_IE: Invalid client ie\n    TscInvalidIe = 0x0205,\n    /// TSC_INVALID_FQDN: Invalid host name\n    TscInvalidFqdn = 0x0206,\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    TscInvalidUserLength = 0x0207,\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    TscInvalidPassLength = 0x0208,\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    TscInvalidDbLength = 0x0209,\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    TscInvalidTableIdLength = 0x020A,\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    TscInvalidConnection = 0x020B,\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    TscOutOfMemory = 0x020C,\n    /// TSC_NO_DISKSPACE: System out of disk space\n    TscNoDiskspace = 0x020D,\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    TscQueryCacheErased = 0x020E,\n    /// TSC_QUERY_CANCELLED: Query terminated\n    TscQueryCancelled = 0x020F,\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    TscSortedResTooMany = 0x0210,\n    /// TSC_APP_ERROR: Application error\n    TscAppError = 0x0211,\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    TscActionInProgress = 0x0212,\n    /// TSC_DISCONNECTED: Disconnected from service\n    TscDisconnected = 0x0213,\n    /// TSC_NO_WRITE_AUTH: No write permission\n    TscNoWriteAuth = 0x0214,\n    /// TSC_CONN_KILLED: Connection killed\n    TscConnKilled = 0x0215,\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    TscSqlSyntaxError = 0x0216,\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    TscDbNotSelected = 0x0217,\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    TscInvalidTableName = 0x0218,\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    TscExceedSqlLimit = 0x0219,\n    /// TSC_FILE_EMPTY: File is empty\n    TscFileEmpty = 0x021A,\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    TscLineSyntaxError = 0x021B,\n    /// TSC_NO_META_CACHED: No table meta cached\n    TscNoMetaCached = 0x021C,\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    TscDupColNames = 0x021D,\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    TscInvalidTagLength = 0x021E,\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    TscInvalidColumnLength = 0x021F,\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    TscDupTagNames = 0x0220,\n    /// TSC_INVALID_JSON: Invalid JSON format\n    TscInvalidJson = 0x0221,\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    TscInvalidJsonType = 0x0222,\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    TscInvalidJsonConfig = 0x0223,\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    TscValueOutOfRange = 0x0224,\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    TscInvalidProtocolType = 0x0225,\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    TscInvalidPrecisionType = 0x0226,\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    TscResTooMany = 0x0227,\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    TscInvalidSchemaVersion = 0x0228,\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    MndInvalidTopic = 0x0392,\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    MndInvalidTopicOption = 0x0393,\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    MndInvalidTopicPartitons = 0x0394,\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    MndTopicAlreadyExist = 0x0395,\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    TdbInvalidTableId = 0x0600,\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    TdbInvalidTableType = 0x0601,\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    TdbIvdTbSchemaVersion = 0x0602,\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    TdbTableAlreadyExist = 0x0603,\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    TdbInvalidConfig = 0x0604,\n    /// TDB_INIT_FAILED: Tsdb init failed\n    TdbInitFailed = 0x0605,\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    TdbNoDiskspace = 0x0606,\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    TdbNoDiskPermissions = 0x0607,\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    TdbFileCorrupted = 0x0608,\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    TdbOutOfMemory = 0x0609,\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    TdbTagVerOutOfDate = 0x060A,\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    TdbTimestampOutOfRange = 0x060B,\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    TdbSubmitMsgMssedUp = 0x060C,\n    /// TDB_INVALID_ACTION: Invalid operation\n    TdbInvalidAction = 0x060D,\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    TdbInvalidCreateTbMsg = 0x060E,\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    TdbNoTableDataInMem = 0x060F,\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    TdbFileAlreadyExists = 0x0610,\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    TdbTableReconfigure = 0x0611,\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    TdbIvdCreateTableInfo = 0x0612,\n    /// TDB_NO_AVAIL_DISK: No available disk\n    TdbNoAvailDisk = 0x0613,\n    /// TDB_MESSED_MSG: TSDB messed message\n    TdbMessedMsg = 0x0614,\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    TdbIvldTagVal = 0x0615,\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    TdbNoCacheLastRow = 0x0616,\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    TdbIncompleteDfileset = 0x0617,\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    QryInvalidQhandle = 0x0700,\n    /// QRY_INVALID_MSG: Invalid message\n    QryInvalidMsg = 0x0701,\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    QryNoDiskspace = 0x0702,\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    QryOutOfMemory = 0x0703,\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    QryAppError = 0x0704,\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    QryDupJoinKey = 0x0705,\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    QryExceedTagsLimit = 0x0706,\n    /// QRY_NOT_READY: Query not ready\n    QryNotReady = 0x0707,\n    /// QRY_HAS_RSP: Query should response\n    QryHasRsp = 0x0708,\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    QryInExec = 0x0709,\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    QryTooManyTimewindow = 0x070A,\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    QryNotEnoughBuffer = 0x070B,\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    QryInconsistan = 0x070C,\n    /// QRY_SYS_ERROR: System error\n    QrySysError = 0x070D,\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    QryInvalidTimeCondition = 0x070E,\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    QryInvalidSchemaVersion = 0x0710,\n\n    #[num_enum(default)]\n    Failed = 0xffff,\n}\n\nimpl Code {\n    pub fn success(\u0026self) -\u003e bool {\n        matches!(self, Code::Success)\n    }\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    pub fn tsc_invalid_operation(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidOperation)\n    }\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    pub fn tsc_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidQhandle)\n    }\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    pub fn tsc_invalid_time_stamp(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTimeStamp)\n    }\n    /// TSC_INVALID_VALUE: Invalid value in client\n    pub fn tsc_invalid_value(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidValue)\n    }\n    /// TSC_INVALID_VERSION: Invalid client version\n    pub fn tsc_invalid_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidVersion)\n    }\n    /// TSC_INVALID_IE: Invalid client ie\n    pub fn tsc_invalid_ie(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidIe)\n    }\n    /// TSC_INVALID_FQDN: Invalid host name\n    pub fn tsc_invalid_fqdn(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidFqdn)\n    }\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    pub fn tsc_invalid_user_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidUserLength)\n    }\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    pub fn tsc_invalid_pass_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPassLength)\n    }\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    pub fn tsc_invalid_db_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidDbLength)\n    }\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    pub fn tsc_invalid_table_id_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableIdLength)\n    }\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    pub fn tsc_invalid_connection(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidConnection)\n    }\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    pub fn tsc_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TscOutOfMemory)\n    }\n    /// TSC_NO_DISKSPACE: System out of disk space\n    pub fn tsc_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoDiskspace)\n    }\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    pub fn tsc_query_cache_erased(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCacheErased)\n    }\n    /// TSC_QUERY_CANCELLED: Query terminated\n    pub fn tsc_query_cancelled(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCancelled)\n    }\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    pub fn tsc_sorted_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSortedResTooMany)\n    }\n    /// TSC_APP_ERROR: Application error\n    pub fn tsc_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscAppError)\n    }\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    pub fn tsc_action_in_progress(\u0026self) -\u003e bool {\n        matches!(self, Code::TscActionInProgress)\n    }\n    /// TSC_DISCONNECTED: Disconnected from service\n    pub fn tsc_disconnected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDisconnected)\n    }\n    /// TSC_NO_WRITE_AUTH: No write permission\n    pub fn tsc_no_write_auth(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoWriteAuth)\n    }\n    /// TSC_CONN_KILLED: Connection killed\n    pub fn tsc_conn_killed(\u0026self) -\u003e bool {\n        matches!(self, Code::TscConnKilled)\n    }\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    pub fn tsc_sql_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSqlSyntaxError)\n    }\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    pub fn tsc_db_not_selected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDbNotSelected)\n    }\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    pub fn tsc_invalid_table_name(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableName)\n    }\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    pub fn tsc_exceed_sql_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::TscExceedSqlLimit)\n    }\n    /// TSC_FILE_EMPTY: File is empty\n    pub fn tsc_file_empty(\u0026self) -\u003e bool {\n        matches!(self, Code::TscFileEmpty)\n    }\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    pub fn tsc_line_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscLineSyntaxError)\n    }\n    /// TSC_NO_META_CACHED: No table meta cached\n    pub fn tsc_no_meta_cached(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoMetaCached)\n    }\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    pub fn tsc_dup_col_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupColNames)\n    }\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    pub fn tsc_invalid_tag_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTagLength)\n    }\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    pub fn tsc_invalid_column_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidColumnLength)\n    }\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    pub fn tsc_dup_tag_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupTagNames)\n    }\n    /// TSC_INVALID_JSON: Invalid JSON format\n    pub fn tsc_invalid_json(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJson)\n    }\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    pub fn tsc_invalid_json_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonType)\n    }\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    pub fn tsc_invalid_json_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonConfig)\n    }\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    pub fn tsc_value_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TscValueOutOfRange)\n    }\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    pub fn tsc_invalid_protocol_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidProtocolType)\n    }\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    pub fn tsc_invalid_precision_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPrecisionType)\n    }\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    pub fn tsc_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscResTooMany)\n    }\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    pub fn tsc_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidSchemaVersion)\n    }\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    pub fn mnd_invalid_topic(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopic)\n    }\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    pub fn mnd_invalid_topic_option(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicOption)\n    }\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    pub fn mnd_invalid_topic_partitons(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicPartitons)\n    }\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    pub fn mnd_topic_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::MndTopicAlreadyExist)\n    }\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    pub fn tdb_invalid_table_id(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableId)\n    }\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    pub fn tdb_invalid_table_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableType)\n    }\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    pub fn tdb_ivd_tb_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdTbSchemaVersion)\n    }\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    pub fn tdb_table_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableAlreadyExist)\n    }\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    pub fn tdb_invalid_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidConfig)\n    }\n    /// TDB_INIT_FAILED: Tsdb init failed\n    pub fn tdb_init_failed(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInitFailed)\n    }\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    pub fn tdb_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskspace)\n    }\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    pub fn tdb_no_disk_permissions(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskPermissions)\n    }\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    pub fn tdb_file_corrupted(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileCorrupted)\n    }\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    pub fn tdb_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbOutOfMemory)\n    }\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    pub fn tdb_tag_ver_out_of_date(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTagVerOutOfDate)\n    }\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    pub fn tdb_timestamp_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTimestampOutOfRange)\n    }\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    pub fn tdb_submit_msg_mssed_up(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbSubmitMsgMssedUp)\n    }\n    /// TDB_INVALID_ACTION: Invalid operation\n    pub fn tdb_invalid_action(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidAction)\n    }\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    pub fn tdb_invalid_create_tb_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidCreateTbMsg)\n    }\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    pub fn tdb_no_table_data_in_mem(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoTableDataInMem)\n    }\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    pub fn tdb_file_already_exists(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileAlreadyExists)\n    }\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    pub fn tdb_table_reconfigure(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableReconfigure)\n    }\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    pub fn tdb_ivd_create_table_info(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdCreateTableInfo)\n    }\n    /// TDB_NO_AVAIL_DISK: No available disk\n    pub fn tdb_no_avail_disk(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoAvailDisk)\n    }\n    /// TDB_MESSED_MSG: TSDB messed message\n    pub fn tdb_messed_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbMessedMsg)\n    }\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    pub fn tdb_ivld_tag_val(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvldTagVal)\n    }\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    pub fn tdb_no_cache_last_row(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoCacheLastRow)\n    }\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    pub fn tdb_incomplete_dfileset(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIncompleteDfileset)\n    }\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    pub fn qry_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidQhandle)\n    }\n    /// QRY_INVALID_MSG: Invalid message\n    pub fn qry_invalid_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidMsg)\n    }\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    pub fn qry_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNoDiskspace)\n    }\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    pub fn qry_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::QryOutOfMemory)\n    }\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    pub fn qry_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QryAppError)\n    }\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    pub fn qry_dup_join_key(\u0026self) -\u003e bool {\n        matches!(self, Code::QryDupJoinKey)\n    }\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    pub fn qry_exceed_tags_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::QryExceedTagsLimit)\n    }\n    /// QRY_NOT_READY: Query not ready\n    pub fn qry_not_ready(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotReady)\n    }\n    /// QRY_HAS_RSP: Query should response\n    pub fn qry_has_rsp(\u0026self) -\u003e bool {\n        matches!(self, Code::QryHasRsp)\n    }\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    pub fn qry_in_exec(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInExec)\n    }\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    pub fn qry_too_many_timewindow(\u0026self) -\u003e bool {\n        matches!(self, Code::QryTooManyTimewindow)\n    }\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    pub fn qry_not_enough_buffer(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotEnoughBuffer)\n    }\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    pub fn qry_inconsistan(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInconsistan)\n    }\n    /// QRY_SYS_ERROR: System error\n    pub fn qry_sys_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QrySysError)\n    }\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    pub fn qry_invalid_time_condition(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidTimeCondition)\n    }\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    pub fn qry_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidSchemaVersion)\n    }\n}\n\nimpl Code {\n    pub fn to_str(\u0026self) -\u003e \u0026'static str {\n        use Code::*;\n        match self {\n            Success =\u003e \"Success\",\n\n            TscInvalidOperation =\u003e \"Invalid Operation\",\n            TscInvalidQhandle =\u003e \"Invalid qhandle\",\n            TscInvalidTimeStamp =\u003e \"Invalid combination of client/service time\",\n            TscInvalidValue =\u003e \"Invalid value in client\",\n            TscInvalidVersion =\u003e \"Invalid client version\",\n            TscInvalidIe =\u003e \"Invalid client ie\",\n            TscInvalidFqdn =\u003e \"Invalid host name\",\n            TscInvalidUserLength =\u003e \"Invalid user name\",\n            TscInvalidPassLength =\u003e \"Invalid password\",\n            TscInvalidDbLength =\u003e \"Database name too long\",\n            TscInvalidTableIdLength =\u003e \"Table name too long\",\n            TscInvalidConnection =\u003e \"Invalid connection\",\n            TscOutOfMemory =\u003e \"System out of memory\",\n            TscNoDiskspace =\u003e \"System out of disk space\",\n            TscQueryCacheErased =\u003e \"Query cache erased\",\n            TscQueryCancelled =\u003e \"Query terminated\",\n            TscSortedResTooMany =\u003e \"Result set too large to be sorted\",\n            TscAppError =\u003e \"Application error\",\n            TscActionInProgress =\u003e \"Action in progress\",\n            TscDisconnected =\u003e \"Disconnected from service\",\n            TscNoWriteAuth =\u003e \"No write permission\",\n            TscConnKilled =\u003e \"Connection killed\",\n            TscSqlSyntaxError =\u003e \"Syntax error in SQL\",\n            TscDbNotSelected =\u003e \"Database not specified or available\",\n            TscInvalidTableName =\u003e \"Table does not exist\",\n            TscExceedSqlLimit =\u003e \"SQL statement too long check maxSQLLength config\",\n            TscFileEmpty =\u003e \"File is empty\",\n            TscLineSyntaxError =\u003e \"Syntax error in Line\",\n            TscNoMetaCached =\u003e \"No table meta cached\",\n            TscDupColNames =\u003e \"duplicated column names\",\n            TscInvalidTagLength =\u003e \"Invalid tag length\",\n            TscInvalidColumnLength =\u003e \"Invalid column length\",\n            TscDupTagNames =\u003e \"duplicated tag names\",\n            TscInvalidJson =\u003e \"Invalid JSON format\",\n            TscInvalidJsonType =\u003e \"Invalid JSON data type\",\n            TscInvalidJsonConfig =\u003e \"Invalid JSON configuration\",\n            TscValueOutOfRange =\u003e \"Value out of range\",\n            TscInvalidProtocolType =\u003e \"Invalid line protocol type\",\n            TscInvalidPrecisionType =\u003e \"Invalid timestamp precision type\",\n            TscResTooMany =\u003e \"Result set too large to be output\",\n            TscInvalidSchemaVersion =\u003e \"invalid table schema version\",\n            MndInvalidTopic =\u003e \"Invalid topic nam\",\n            MndInvalidTopicOption =\u003e \"Invalid topic optio\",\n            MndInvalidTopicPartitons =\u003e \"Invalid topic partitons num, valid range: [1, 1000\",\n            MndTopicAlreadyExist =\u003e \"Topic already exist\",\n            TdbInvalidTableId =\u003e \"Invalid table ID\",\n            TdbInvalidTableType =\u003e \"Invalid table type\",\n            TdbIvdTbSchemaVersion =\u003e \"Invalid table schema version\",\n            TdbTableAlreadyExist =\u003e \"Table already exists\",\n            TdbInvalidConfig =\u003e \"Invalid configuration\",\n            TdbInitFailed =\u003e \"Tsdb init failed\",\n            TdbNoDiskspace =\u003e \"No diskspace for tsdb\",\n            TdbNoDiskPermissions =\u003e \"No permission for disk files\",\n            TdbFileCorrupted =\u003e \"Data file(s) corrupted\",\n            TdbOutOfMemory =\u003e \"Out of memory\",\n            TdbTagVerOutOfDate =\u003e \"Tag too old\",\n            TdbTimestampOutOfRange =\u003e \"Timestamp data out of range\",\n            TdbSubmitMsgMssedUp =\u003e \"Submit message is messed up\",\n            TdbInvalidAction =\u003e \"Invalid operation\",\n            TdbInvalidCreateTbMsg =\u003e \"Invalid creation of table\",\n            TdbNoTableDataInMem =\u003e \"No table data in memory skiplist\",\n            TdbFileAlreadyExists =\u003e \"File already exists\",\n            TdbTableReconfigure =\u003e \"Need to reconfigure table\",\n            TdbIvdCreateTableInfo =\u003e \"Invalid information to create table\",\n            TdbNoAvailDisk =\u003e \"No available disk\",\n            TdbMessedMsg =\u003e \"TSDB messed message\",\n            TdbIvldTagVal =\u003e \"TSDB invalid tag value\",\n            TdbNoCacheLastRow =\u003e \"TSDB no cache last row data\",\n            TdbIncompleteDfileset =\u003e \"TSDB incomplete DFileSet\",\n            QryInvalidQhandle =\u003e \"Invalid handle\",\n            QryInvalidMsg =\u003e \"Invalid message\",\n            QryNoDiskspace =\u003e \"No diskspace for query\",\n            QryOutOfMemory =\u003e \"System out of memory\",\n            QryAppError =\u003e \"Unexpected generic error in query\",\n            QryDupJoinKey =\u003e \"Duplicated join key\",\n            QryExceedTagsLimit =\u003e \"Tag condition too many\",\n            QryNotReady =\u003e \"Query not ready\",\n            QryHasRsp =\u003e \"Query should response\",\n            QryInExec =\u003e \"Multiple retrieval of this query\",\n            QryTooManyTimewindow =\u003e \"Too many time window in query\",\n            QryNotEnoughBuffer =\u003e \"Query buffer limit has reached\",\n            QryInconsistan =\u003e \"File inconsistency in replica\",\n            QrySysError =\u003e \"System error\",\n            QryInvalidTimeCondition =\u003e \"invalid time condition\",\n            QryInvalidSchemaVersion =\u003e \"invalid schema version\",\n            Failed =\u003e \"Unknown or needn't tell detail error\",\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","cfg.rs"],"content":"use proc_macro2::*;\nuse quote::*;\nuse syn::{ForeignItemFn, ItemFn};\n\n/// Replace official `[cfg]` macro to add empty backport functions after the foreign mod block.\npub fn cfg(attr: impl Into\u003cTokenStream\u003e, item: impl Into\u003cTokenStream\u003e) -\u003e TokenStream {\n    let cfg = attr.into();\n\n    let item = item.into();\n    // taos cfg only focus on foreign mod.\n    let syn: syn::ItemForeignMod = match syn::parse2(item.clone()) {\n        Ok(it) =\u003e it,\n        Err(_) =\u003e {\n            return quote! {\n              #[cfg(#cfg)]\n              #item\n            }\n        }\n    };\n\n    let mut backport = TokenStream::new();\n\n    for item_fn in syn.items {\n        assert!(matches!(item_fn, syn::ForeignItem::Fn(_)));\n        if let syn::ForeignItem::Fn(item_fn) = item_fn {\n            let item_fn = foreign_fn_to_item_fn(item_fn);\n            backport.extend(quote! {\n                #[cfg(not(#cfg))]\n                #[no_mangle]\n                #item_fn\n            });\n        }\n    }\n    return quote! {\n        #[cfg(#cfg)]\n        #item\n\n        #backport\n    };\n}\n\n/// Convert a extern \"C\" foreign function to a no_mangle Rust fn.\nfn foreign_fn_to_item_fn(item: ForeignItemFn) -\u003e ItemFn {\n    let mut sig = item.sig;\n    // use extern \"C\"\n    let abi: syn::Abi = syn::parse_quote!(extern \"C\");\n    sig.abi = Some(abi);\n    let un: syn::token::Unsafe = syn::parse_quote!(unsafe);\n    sig.unsafety = Some(un);\n\n    // add panic block\n    let err = Literal::string(\u0026format!(\n        \"C function {} is not supported in this build\",\n        sig.ident\n    ));\n    let block: syn::Block = syn::parse_quote! {\n        {\n            panic!(#err);\n        }\n    };\n    ItemFn {\n        attrs: item.attrs,\n        vis: item.vis,\n        sig: sig,\n        block: Box::new(block),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::cfg;\n    use quote::quote;\n    use syn::{ForeignItemFn, ItemFn};\n\n    #[test]\n    fn nothing() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            #[doc = \"doc\"]\n            fn abc() {}\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            #[doc = \"doc\"]\n            fn abc() {}\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn simple() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            // doc\n            extern \"C\" {\n                pub fn a();\n            }\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            extern \"C\" {\n                pub fn a();\n            }\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn a () {\n              panic!(\"C function a is not supported in this build\");\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn test_foreign_to_item() {\n        let c: ForeignItemFn = syn::parse_quote! {\n\n            pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n        };\n        let r = super::foreign_fn_to_item_fn(c);\n\n        let e: ItemFn = syn::parse_quote!(\n            pub unsafe extern \"C\" fn tmq_list_new() -\u003e *mut tmq_list_t {\n                panic!(\"C function tmq_list_new is not supported in this build\");\n            }\n        );\n        assert_eq!(r, e);\n        dbg!(\u0026r);\n    }\n\n    #[test]\n    fn tmq_demo() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            // doc\n            extern \"C\" {\n                pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n                pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32;\n            }\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            extern \"C\" {\n                pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n                pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32;\n            }\n\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn tmq_list_new() -\u003e *mut tmq_list_t {\n                panic!(\"C function tmq_list_new is not supported in this build\");\n            }\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32 {\n                panic!(\"C function tmq_list_append is not supported in this build\");\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","lib.rs"],"content":"extern crate proc_macro;\n\nmod cfg;\nmod test;\n\n/// A `[cfg]`-like macro to add backport code for extern \"C\" foreign mod.\n///\n/// ```rust\n/// # use taos_macros::c_cfg;\n///\n/// #[c_cfg(feature = \"ft1\")]\n/// extern \"C\" {\n///     pub fn raw_c_fn(arg1: *mut std::os::raw::c_void) -\u003e std::os::raw::c_int;\n/// }\n/// ```\n///\n/// The code will expand to:\n///\n/// ```rust\n/// #[cfg(feature = \"ft1\")]\n/// extern \"C\" {\n///     pub fn raw_c_fn(arg1: *mut std::os::raw::c_void) -\u003e std::os::raw::c_int;\n/// }\n/// #[cfg(not(feature = \"ft1\"))]\n/// #[no_mangle]\n/// pub extern \"C\" fn raw_c_fn(arg1: *mut std::os::raw::c_void) -\u003e std::os::raw::c_int {\n///     panic!(\"C function raw_c_fn is not supported in this build\");\n/// }\n/// ```\n#[proc_macro_attribute]\npub fn c_cfg(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -\u003e proc_macro::TokenStream {\n    cfg::cfg(attr, item).into()\n}\n\n/// A powerful test macro for taos, you can replace std test macro in your taos test cases.\n///\n/// ## Use as [`[test]`](https://doc.rust-lang.org/std/prelude/v1/macro.test.html) does\n///\n/// ```rust\n/// use taos_macros::test;\n/// #[test]\n/// fn test1() {}\n/// ```\n///\n/// ## Use with taos connection.\n///\n/// ```rust\n/// use taos_macros::test;\n///\n/// #[test]\n/// async fn show_databases(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n///     let _ = taos.databases().await;\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Use with taos connection and a prebuilt database\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test]\n/// async fn use_database(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Use with taos connection and a prebuilt database with specific precision\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(precision = \"ns\")]\n/// async fn with_precision(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(databases\n///         .iter()\n///         .any(|db| db.name == database \u0026\u0026 db.props.precision.as_ref().unwrap().eq(\"ns\")));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Specify a custom database name\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(naming = \"abc1\")]\n/// async fn custom_database(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(database == \"abc1\");\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Naming the database with random words\n///\n/// By default, `[test]` macro use [uuid v1](https://docs.rs/uuid/latest/uuid/struct.Uuid.html#method.new_v1)\n/// naming strategy. It will satisfy most cases. But if you want to use another naming strategy, you can use\n/// `\"random\"` to generate database names with [faker_rand](https://docs.rs/faker_rand).\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(naming = \"random\")]\n/// async fn random_naming(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Generate many databases in one case\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(databases = 10)]\n/// async fn multi_databases(_taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c()\u003e {\n///     assert!(databases.len() == 10);\n///     Ok(())\n/// }\n/// ```\n///\n#[proc_macro_attribute]\npub fn test(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -\u003e proc_macro::TokenStream {\n    test::test(attr, item)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","test.rs"],"content":"use proc_macro2::*;\nuse quote::*;\n\n#[derive(Debug, PartialEq, Eq)]\nenum Requires {\n    None,\n    TaosOnly,\n    WithDatabase,\n    WithMulti,\n}\n\nimpl Default for Requires {\n    fn default() -\u003e Self {\n        Self::None\n    }\n}\n\n#[derive(Default, Debug, PartialEq, Eq)]\nstruct Params {\n    is_async: bool,\n    fn_name: String,\n    requires: Requires,\n    is_result: bool,\n}\n\nimpl Params {\n    fn from_tokens(item: TokenStream) -\u003e Self {\n        // let item_fn: syn::ItemFn = match syn::parse(item.clone().into()) {\n        //     Ok(item) =\u003e item,\n        //     Err(e) =\u003e panic!(\"#[test] only used in function\"),\n        // };\n        // dbg!(item_fn);\n        let tokens: Vec\u003c_\u003e = item.into_iter().collect();\n        let mut iter = tokens.iter();\n\n        let mut params = Params::default();\n        while let Some(token) = iter.next() {\n            use TokenTree::*;\n            match token {\n                // Function comment\n                Punct(punct) if punct.as_char() == '#' =\u003e {\n                    let _ = iter.next();\n                }\n                // Check if is async function\n                Ident(ident) if ident.to_string() == \"async\" =\u003e {\n                    params.is_async = true;\n                }\n                // Parse function name and parameters\n                Ident(ident) if ident.to_string() == \"fn\" =\u003e {\n                    if let Some(Ident(ident)) = iter.next() {\n                        params.fn_name = ident.to_string();\n                    } else {\n                        panic!(\"can't parse fn name\");\n                    }\n\n                    if let Some(Group(fn_params)) = iter.next() {\n                        let tt: Vec\u003c_\u003e = fn_params.stream().into_iter().collect();\n                        params.requires = parse_database_requires(\u0026tt);\n                    }\n                }\n                // Parse return type\n                Punct(punct) if punct.as_char() == '-' =\u003e {\n                    // \u003e\n                    let _ = iter.next();\n                    let mut return_type_tt = Vec::new();\n                    if let Some(ident) = iter.next() {\n                        // dbg!(\u0026ty);\n                        if let Ident(ty) = ident {\n                            if ty.to_string().ends_with(\"Result\") {\n                                params.is_result = true;\n                                break;\n                            }\n                        }\n                        return_type_tt.push(ident.clone());\n                    }\n\n                    while let Some(token) = iter.next() {\n                        if let Group(group) = token {\n                            let v = group.delimiter();\n                            if v == Delimiter::Brace {\n                                break;\n                            }\n                        }\n                        return_type_tt.push(token.clone());\n                    }\n\n                    params.is_result = return_type_tt.into_iter().any(|t| {\n                        if let Ident(ty) = t {\n                            ty.to_string().ends_with(\"Result\")\n                        } else {\n                            false\n                        }\n                    });\n                }\n                _ =\u003e {\n                    // dbg!(\u0026token);\n                }\n            }\n        }\n        params\n    }\n}\n\n#[derive(Default, Debug)]\nstruct Attr {\n    rt: Option\u003cString\u003e,\n    databases: Option\u003cusize\u003e,\n    naming: Option\u003cLiteral\u003e,\n    precision: Option\u003cLiteral\u003e,\n    dropping: Option\u003cLiteral\u003e,\n    log_level: Option\u003cLiteral\u003e,\n}\n\nimpl PartialEq for Attr {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        macro_rules! _literal_eq {\n            ($attr:ident) =\u003e {\n                match (self.$attr.as_ref(), other.$attr.as_ref()) {\n                    (None, None) =\u003e true,\n                    (Some(lhs), Some(rhs)) if lhs.to_string() == rhs.to_string() =\u003e true,\n                    _ =\u003e false,\n                }\n            };\n        }\n        self.rt == other.rt\n            \u0026\u0026 self.databases == other.databases\n            \u0026\u0026 _literal_eq!(naming)\n            \u0026\u0026 _literal_eq!(precision)\n            \u0026\u0026 _literal_eq!(dropping)\n    }\n}\n\nimpl Attr {\n    fn from_iter(iter: impl IntoIterator\u003cItem = TokenTree\u003e) -\u003e Attr {\n        let mut iter = iter.into_iter();\n        let mut attr = Attr::default();\n        while let Some(t) = iter.next() {\n            // panic!(\"{}\", \u0026t);\n            // dbg!(\u0026t);\n            match t {\n                TokenTree::Ident(ident) if ident.to_string() == \"databases\" =\u003e {\n                    const EXPECT: \u0026str = \"expect `[test(databases = \\\"\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e {\n                            attr.databases = Some(value.to_string().parse().expect(EXPECT))\n                        }\n                        _ =\u003e unreachable!(\"expect `[test(databases = \\\"\\\")]`\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"rt\" =\u003e {\n                    const EXPECT: \u0026str = \"`[test(rt = \\\"tokio|async_std\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.rt = Some(value.to_string()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"naming\" =\u003e {\n                    const EXPECT: \u0026str =\n                        \"`[test(naming = \\\"random|uuid-v1|sequential|\u003ccustom\u003e\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.naming = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"dropping\" =\u003e {\n                    const EXPECT: \u0026str = \"`[test(drop = \\\"none|before|after|always\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.dropping = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"precision\" =\u003e {\n                    const EXPECT: \u0026str = \"`[test(drop = \\\"ms|us|ns|random|cyclic\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.precision = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n\n                TokenTree::Ident(ident)\n                    if ident.to_string() == \"log_level\" || ident.to_string() == \"log-level\" =\u003e\n                {\n                    const EXPECT: \u0026str = \"`[test(log_level = \\\"trace|debug|info|warn|error\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.log_level = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                _ =\u003e (),\n            }\n        }\n        attr\n    }\n\n    fn naming_token_stream(\u0026self) -\u003e TokenStream {\n        match \u0026self.naming {\n            Some(naming) =\u003e naming.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n\n    fn drop_token_stream(\u0026self) -\u003e TokenStream {\n        match \u0026self.dropping {\n            Some(drop) =\u003e drop.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n    fn precision_token_stream(\u0026self) -\u003e TokenStream {\n        match \u0026self.precision {\n            Some(precision) =\u003e precision.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n\n    fn crate_token_stream(\u0026self) -\u003e TokenStream {\n        let crate_name = std::env::var(\"CARGO_PKG_NAME\").unwrap();\n\n        if crate_name == \"taos\" {\n            quote!(crate)\n        } else {\n            quote!(taos)\n        }\n    }\n\n    fn databases(\u0026self, requires: \u0026Requires) -\u003e usize {\n        match requires {\n            Requires::None =\u003e 0,\n            Requires::TaosOnly =\u003e 0,\n            Requires::WithDatabase =\u003e 1,\n            Requires::WithMulti =\u003e self.databases.unwrap_or(1),\n        }\n    }\n\n    fn log_level(\u0026self) -\u003e TokenStream {\n        match \u0026self.log_level {\n            Some(log_level) =\u003e log_level.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n\n    fn with_params(\u0026self, tokens: TokenStream) -\u003e TokenStream {\n        let Params {\n            is_async,\n            fn_name,\n            requires,\n            is_result,\n        } = Params::from_tokens(tokens.clone());\n\n        let fn_name = Ident::new(\u0026fn_name, Span::call_site());\n        let naming = self.naming_token_stream();\n        let drop = self.drop_token_stream();\n        let precision = self.precision_token_stream();\n        let log_level = self.log_level();\n        let _crate = self.crate_token_stream();\n        let databases = self.databases(\u0026requires);\n\n        let common = quote! {\n            #_crate::helpers::tests::Common::default()\n                .log_level(#log_level)\n                .init()?;\n        };\n\n        let builder = quote! {\n            let __taos = #_crate::helpers::tests::Builder::default()\n               .naming(#naming)\n               .precision(#precision)\n               .dropping(#drop)\n               .databases(#databases)\n               .build()?;\n            let _taos = __taos.taos();\n        };\n        let builder = match requires {\n            Requires::None =\u003e quote!(\n                #fn_name()\n            ),\n            Requires::TaosOnly =\u003e quote! {\n                #builder\n                #fn_name(_taos)\n            },\n            Requires::WithDatabase =\u003e quote! {\n                #builder\n                let _database = __taos.default_database();\n                #fn_name(_taos, _database)\n            },\n            Requires::WithMulti =\u003e quote! {\n                #builder\n                let _databases = __taos.databases();\n                #fn_name(_taos, \u0026_databases)\n            },\n        };\n\n        match (is_async, is_result) {\n            (true, true) =\u003e {\n                quote! {\n                    #[tokio::test]\n                    async fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder.await?;\n                        Ok(())\n                    }\n                }\n            }\n            (true, false) =\u003e {\n                quote! {\n                    #[tokio::test]\n                    async fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder.await;\n                        Ok(())\n                    }\n                }\n            }\n            (false, true) =\u003e {\n                quote! {\n                    #[std::prelude::v1::test]\n                    fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder?;\n                        Ok(())\n                    }\n                }\n            }\n            _ =\u003e {\n                quote! {\n                    #[std::prelude::v1::test]\n                    fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder;\n                        Ok(())\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn parse_database_requires(params: \u0026[TokenTree]) -\u003e Requires {\n    let mut iter = params.iter();\n    let mut has_taos = false;\n    let mut ret = Requires::None;\n    while let Some(t) = iter.next() {\n        use TokenTree::*;\n        match t {\n            Ident(ident) if ident.to_string() == \"taos\" || ident.to_string() == \"_taos\" =\u003e {\n                let _ = iter.next();\n                let _ = iter.next();\n                let ty = iter.next().unwrap();\n                assert!(ty.to_string().ends_with(\"Taos\"));\n                has_taos = true;\n                ret = Requires::TaosOnly;\n            }\n            Ident(ident) if ident.to_string() == \"database\" || ident.to_string() == \"_database\" =\u003e {\n                if !has_taos {\n                    panic!(\"please use test fn parameters: `taos: \u0026Taos, database: \u0026str`\");\n                }\n                ret = Requires::WithDatabase;\n            }\n            Ident(ident)\n                if ident.to_string() == \"databases\" || ident.to_string() == \"_databases\" =\u003e\n            {\n                if !has_taos {\n                    panic!(\"please use test fn parameters: `taos: \u0026Taos, databases: \u0026[String]`\");\n                }\n                ret = Requires::WithMulti;\n            }\n            _ =\u003e (),\n        }\n    }\n    ret\n}\npub(crate) fn test(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -\u003e proc_macro::TokenStream {\n    Attr::from_iter(TokenStream::from(attr))\n        .with_params(TokenStream::from(item))\n        .into()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Attr;\n    use proc_macro2::*;\n    use quote::quote;\n\n    #[test]\n    fn default_sync() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            fn test_fn() { }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[std::prelude::v1::test]\n            fn test_fn() -\u003e anyhow::Result\u003c()\u003e {\n                fn test_fn() { }\n\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test_fn();\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn default_async() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            async fn async_simple() { }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[tokio::test]\n            async fn async_simple() -\u003e anyhow::Result\u003c()\u003e {\n                async fn async_simple() { }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                async_simple().await;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn sync_with_result() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            fn test() -\u003e Result\u003c()\u003e {\n                Ok(())\n            }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[std::prelude::v1::test]\n            fn test() -\u003e anyhow::Result\u003c()\u003e {\n                fn test() -\u003e Result\u003c()\u003e {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test()?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn async_with_result() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            async fn test() -\u003e Result\u003c()\u003e {\n                Ok(())\n            }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[tokio::test]\n            async fn test() -\u003e anyhow::Result\u003c()\u003e {\n                async fn test() -\u003e Result\u003c()\u003e {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test().await?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n    #[test]\n    fn attr_from_iter() {\n        let attr = quote! {\n            databases = 10, rt = \"tokio\", naming = \"random\", dropping = \"always\"\n        };\n\n        let attr = super::Attr::from_iter(attr);\n\n        assert_eq!(\n            attr,\n            Attr {\n                databases: Some(10),\n                rt: Some(\"\\\"tokio\\\"\".to_string()),\n                naming: Some(Literal::string(\"random\")),\n                precision: None,\n                dropping: Some(Literal::string(\"always\")),\n                log_level: None,\n            }\n        );\n\n        let fn_item = quote! {\n            /// Comment.\n            ///\n            /// Long comment.\n            async fn test_a(taos: \u0026Taos, database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n                Ok(())\n            }\n        };\n        let params = super::Params::from_tokens(fn_item.clone().into());\n        dbg!(params);\n        let tokens = attr.with_params(fn_item);\n\n        let expect = quote! {\n            #[tokio::test]\n            async fn test_a() -\u003e anyhow::Result\u003c()\u003e {\n                /// Comment.\n                ///\n                /// Long comment.\n                async fn test_a(taos: \u0026Taos, database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                let __taos = taos::helpers::tests::Builder::default()\n                       .naming(\"random\")\n                       .precision(())\n                       .dropping(\"always\")\n                       .databases(1usize)\n                       .build()?;\n                let _taos = __taos.taos();\n                let _database = __taos.default_database();\n                test_a(_taos, _database).await?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n        dbg!(tokens.to_string());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","tests","taos_cfg.rs"],"content":"use taos_macros::c_cfg;\n\n#[c_cfg(v3)]\nextern \"C\" {\n    fn test_cfg(_a: usize, _b: *mut usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","tests","test.rs"],"content":"use anyhow::Result;\nuse taos::prelude::*;\nuse taos_macros::test;\n\n#[test()]\nfn sync() {}\n\n#[test]\nasync fn async_unit() {}\n\n#[test]\nasync fn async_with_taos(taos: \u0026Taos) {\n    dbg!(taos);\n}\n\n#[test]\nasync fn async_with_taos_db(_taos: \u0026Taos, _database: \u0026str) {}\n\n#[test]\nasync fn show_databases(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n    let databases = taos.databases().await?;\n    assert!(databases.iter().any(|db| db.name == database));\n    Ok(())\n}\n\n#[test(precision = \"ns\")]\nasync fn with_precision(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n    let databases = taos.databases().await?;\n    assert!(databases\n        .iter()\n        .any(|db| db.name == database \u0026\u0026 db.props.precision.as_ref().unwrap().as_str().eq(\"ns\")));\n    Ok(())\n}\n\n#[test(naming = \"abc1\")]\nasync fn custom_database(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n    let databases = taos.databases().await?;\n    assert!(database == \"abc1\");\n    assert!(databases.iter().any(|db| db.name == database));\n    Ok(())\n}\n\n#[test(databases = 10)]\nasync fn multi_databases(_taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c()\u003e {\n    assert!(databases.len() == 10);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","build.rs"],"content":"fn main() {\n    if rustc_version::version_meta().unwrap().channel == rustc_version::Channel::Nightly {\n        println!(\"cargo:rustc-cfg=nightly\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","column","mod.rs"],"content":"use bitvec_simd::BitVec;\nuse itertools::Itertools;\n\n// use crate::stmt::MultiBind;\n\nuse super::value::BorrowedValue;\n\n#[derive(Debug, serde::Serialize)]\npub enum BorrowedColumn\u003c'b\u003e {\n    Null(usize),\n    Bool(BitVec, \u0026'b [bool]),  // 1\n    TinyInt(BitVec, \u0026'b [i8]), // 2\n    SmallInt(BitVec, \u0026'b [i16]),\n    Int(BitVec, \u0026'b [i32]),\n    BigInt(BitVec, \u0026'b [i64]),\n    Float(BitVec, \u0026'b [f32]),\n    Double(BitVec, \u0026'b [f64]),\n    Binary(Vec\u003cOption\u003c\u0026'b [u8]\u003e\u003e),\n    Timestamp(BitVec, \u0026'b [i64]),\n    NChar(Vec\u003cOption\u003c\u0026'b str\u003e\u003e),\n    UTinyInt(BitVec, \u0026'b [u8]),\n    USmallInt(BitVec, \u0026'b [u16]),\n    UInt(BitVec, \u0026'b [u32]),\n    UBigInt(BitVec, \u0026'b [u64]), // 14\n    Json(BitVec, \u0026'b [u8]),\n    VarChar(BitVec, Vec\u003c\u0026'b [u8]\u003e),\n    VarBinary(BitVec, Vec\u003c\u0026'b [u8]\u003e),\n    Decimal(BitVec, \u0026'b [f64]),\n    Blob(BitVec, Vec\u003c\u0026'b [u8]\u003e),\n}\n\n#[derive(Debug, serde::Serialize, serde::Deserialize)]\npub enum Column {\n    Null(usize),\n    Bool(BitVec, Vec\u003cbool\u003e),  // 1\n    TinyInt(BitVec, Vec\u003ci8\u003e), // 2\n    SmallInt(BitVec, Vec\u003ci16\u003e),\n    Int(BitVec, Vec\u003ci32\u003e),\n    BigInt(BitVec, Vec\u003ci64\u003e),\n    Float(BitVec, Vec\u003cf32\u003e),\n    Double(BitVec, Vec\u003cf64\u003e),\n    Binary(Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e),\n    Timestamp(BitVec, Vec\u003ci64\u003e),\n    NChar(Vec\u003cOption\u003cString\u003e\u003e),\n    UTinyInt(BitVec, Vec\u003cu8\u003e),\n    USmallInt(BitVec, Vec\u003cu16\u003e),\n    UInt(BitVec, Vec\u003cu32\u003e),\n    UBigInt(BitVec, Vec\u003cu64\u003e), // 14\n    Json(BitVec, Vec\u003cu8\u003e),\n    VarChar(BitVec, Vec\u003cVec\u003cu8\u003e\u003e),\n    VarBinary(BitVec, Vec\u003cVec\u003cu8\u003e\u003e),\n    Decimal(BitVec, Vec\u003cf64\u003e),\n    Blob(BitVec, Vec\u003cVec\u003cu8\u003e\u003e),\n}\n\nimpl\u003c'block\u003e BorrowedColumn\u003c'block\u003e {\n    pub fn get(\u0026self, index: usize) -\u003e BorrowedValue\u003c'block\u003e {\n        macro_rules! get_primitive {\n            ($target:ident, $nulls:expr, $values:expr) =\u003e {\n                paste::paste! {\n                    if $nulls.get_unchecked(index) {\n                        BorrowedValue::Null\n                    } else {\n                        BorrowedValue::$target(*unsafe { $values.get_unchecked(index) })\n                    }\n                }\n            };\n        }\n        match self {\n            Self::Null(_n) =\u003e BorrowedValue::Null,\n            Self::Bool(nulls, values) =\u003e get_primitive!(Bool, nulls, values),\n            Self::TinyInt(nulls, values) =\u003e get_primitive!(TinyInt, nulls, values),\n            Self::SmallInt(nulls, values) =\u003e get_primitive!(SmallInt, nulls, values),\n            Self::Int(nulls, values) =\u003e get_primitive!(Int, nulls, values),\n            Self::BigInt(nulls, values) =\u003e get_primitive!(BigInt, nulls, values),\n            Self::UTinyInt(nulls, values) =\u003e get_primitive!(UTinyInt, nulls, values),\n            Self::USmallInt(nulls, values) =\u003e get_primitive!(USmallInt, nulls, values),\n            Self::UInt(nulls, values) =\u003e get_primitive!(UInt, nulls, values),\n            Self::UBigInt(nulls, values) =\u003e get_primitive!(UBigInt, nulls, values),\n            Self::Float(nulls, values) =\u003e get_primitive!(Float, nulls, values),\n            Self::Double(nulls, values) =\u003e get_primitive!(Double, nulls, values),\n            Self::Timestamp(nulls, _values) =\u003e {\n                if nulls.get_unchecked(index) {\n                    BorrowedValue::Null\n                } else {\n                    // BorrowedValue::Timestamp(TimestampValue::new(*unsafe { values.get_unchecked(index) }, self.precision()))\n                    todo!()\n                }\n            }\n            Self::Binary(values) =\u003e match unsafe { values.get_unchecked(index) } {\n                Some(bytes) =\u003e {\n                    BorrowedValue::VarChar(unsafe { std::str::from_utf8_unchecked(bytes) })\n                }\n                None =\u003e BorrowedValue::Null,\n            },\n            Self::NChar(_values) =\u003e BorrowedValue::Null,\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl\u003c'block\u003e BorrowedColumn\u003c'block\u003e {\n    pub fn into_owned(self) -\u003e Column {\n        match self {\n            BorrowedColumn::Null(rows) =\u003e Column::Null(rows),\n            BorrowedColumn::Bool(is_nulls, slice) =\u003e Column::Bool(is_nulls, slice.to_owned()),\n            BorrowedColumn::TinyInt(is_nulls, slice) =\u003e Column::TinyInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::SmallInt(is_nulls, slice) =\u003e {\n                Column::SmallInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::Int(is_nulls, slice) =\u003e Column::Int(is_nulls, slice.to_owned()),\n            BorrowedColumn::BigInt(is_nulls, slice) =\u003e Column::BigInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::UTinyInt(is_nulls, slice) =\u003e {\n                Column::UTinyInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::USmallInt(is_nulls, slice) =\u003e {\n                Column::USmallInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::UInt(is_nulls, slice) =\u003e Column::UInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::UBigInt(is_nulls, slice) =\u003e Column::UBigInt(is_nulls, slice.to_owned()),\n\n            BorrowedColumn::Float(is_nulls, slice) =\u003e Column::Float(is_nulls, slice.to_owned()),\n            BorrowedColumn::Double(is_nulls, slice) =\u003e Column::Double(is_nulls, slice.to_owned()),\n            BorrowedColumn::Binary(binary) =\u003e Column::Binary(\n                binary\n                    .into_iter()\n                    .map(|val| val.map(ToOwned::to_owned))\n                    .collect_vec(),\n            ),\n            BorrowedColumn::NChar(binary) =\u003e Column::NChar(\n                binary\n                    .into_iter()\n                    .map(|val| val.map(|val| val.to_string()))\n                    .collect_vec(),\n            ),\n            BorrowedColumn::Timestamp(is_nulls, slice) =\u003e {\n                Column::Timestamp(is_nulls, slice.to_owned())\n            }\n            _ =\u003e unreachable!(\"unsupported data type\"),\n        }\n    }\n}\n\n#[test]\nfn test_serde() {\n    const N: usize = 100;\n    let nulls = BitVec::zeros(N);\n    let v: Vec\u003ci32\u003e = (0..N).map(|_| rand::random()).collect();\n    let ints = BorrowedColumn::Int(nulls, \u0026v);\n\n    let json = serde_json::to_string(\u0026ints).unwrap();\n\n    let ints2: Column = serde_json::from_str(\u0026json).unwrap();\n\n    println!(\"{ints:?}\");\n    println!(\"{ints2:?}\");\n}\n","traces":[{"line":57,"address":[2712096],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2712151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2712238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2712274,2714286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2712343,2714195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2712412,2714102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2714011,2712481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2713918,2712550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2712901,2713430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2712970,2713337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2713039,2713252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2713108,2713233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2712619,2713823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2713728,2712688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2712804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2713521,2712831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2713565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2713597,2712749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2713654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2713665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2713641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2712865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2719377,2717466,2714384],"length":1,"stats":{"Line":0},"fn_name":"into_owned"},{"line":104,"address":[2714429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2714752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2719011,2714788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2714974,2718881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2715160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2715298,2718751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2718621,2715346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2718491,2715532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2716480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2716618,2717767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2716666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2716792,2717637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2716840,2717507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2716996,2717339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2715718,2718361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2715904,2718231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2716122,2718145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2002976,2003029],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2717913,2716410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2003158,2003109,2003056,2003136],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2716192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2716330,2717999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2034976,2034981],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":147,"address":[2729871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[2035008,2035022],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":149,"address":[2730025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[2730214,2730291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[2730405,2730329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[2730450,2730517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[2730601],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":63},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","describe.rs"],"content":"use std::ops::{Deref, DerefMut};\n\nuse itertools::Itertools;\nuse serde::{Deserialize, Serialize};\n\nuse crate::helpers::ColumnMeta;\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Describe(pub(crate) Vec\u003cColumnMeta\u003e);\n\nimpl IntoIterator for Describe {\n    type Item = ColumnMeta;\n\n    type IntoIter = std::vec::IntoIter\u003cSelf::Item\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl FromIterator\u003cColumnMeta\u003e for Describe {\n    fn from_iter\u003cT: IntoIterator\u003cItem = ColumnMeta\u003e\u003e(iter: T) -\u003e Self {\n        Describe(iter.into_iter().collect())\n    }\n}\n\nimpl Deref for Describe {\n    type Target = Vec\u003cColumnMeta\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for Describe {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\nimpl Describe {\n    #[inline]\n    fn fields(\u0026self) -\u003e \u0026[ColumnMeta] {\n        \u0026self.0\n    }\n    pub fn is_stable(\u0026self) -\u003e bool {\n        self.fields().iter().any(|f| f.is_tag())\n    }\n    pub fn names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026str\u003e {\n        self.fields().iter().map(|f| f.field())\n    }\n\n    pub fn tag_names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026str\u003e {\n        self.fields()\n            .iter()\n            .filter(|f| f.is_tag())\n            .map(|f| f.field())\n    }\n    pub fn to_create_table_sql(\u0026self, table: \u0026str) -\u003e String {\n        let (cols, tags): (Vec\u003c_\u003e, Vec\u003c_\u003e) = self.fields().iter().partition(|f| !f.is_tag());\n        let col_sql = cols.into_iter().map(|f| f.sql_repr()).join(\",\");\n\n        if tags.is_empty() {\n            format!(\"create table if not exists {table} ({col_sql})\")\n        } else {\n            let tags_sql = tags.into_iter().map(|f| f.sql_repr()).join(\",\");\n            format!(\"create table if not exists {table} ({col_sql}) tags({tags_sql})\")\n        }\n    }\n}\n","traces":[{"line":16,"address":[8430160],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":17,"address":[8430172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[8430224],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":36,"address":[8430240],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":42,"address":[8430256],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":43,"address":[2276393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[8430304],"length":1,"stats":{"Line":0},"fn_name":"is_stable"},{"line":46,"address":[2824160,2824187],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":48,"address":[2276512],"length":1,"stats":{"Line":0},"fn_name":"names"},{"line":49,"address":[2276521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[8430496],"length":1,"stats":{"Line":0},"fn_name":"tag_names"},{"line":53,"address":[2276617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2278183,2276720,2277183],"length":1,"stats":{"Line":0},"fn_name":"to_create_table_sql"},{"line":59,"address":[2824224,2824238],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":60,"address":[8430983,8430875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2277246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2277339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2277273,2277614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2277755],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","field.rs"],"content":"use std::fmt::{Debug, Display};\n\nuse crate::util::{Inlinable, InlinableRead, InlinableWrite};\n\nuse super::ty::Ty;\n\n/// A `Field` represents the name and data type of one column or tag.\n///\n/// For example, a table as \"create table tb1 (ts timestamp, n nchar(100))\".\n///\n/// When query with \"select * from tb1\", you will get two fields:\n///\n/// 1. `{ name: \"ts\", ty: Timestamp, bytes: 8 }`, a `TIMESTAMP` field with name `ts`,\n///    bytes length 8 which is the byte-width of `i64`.\n/// 2. `{ name: \"n\", ty: NChar, bytes: 100 }`, a `NCHAR` filed with name `n`,\n///    bytes length 100 which is the length of the variable-length data.\n\n#[derive(Debug)]\npub struct Field {\n    name: String,\n    ty: Ty,\n    bytes: u32,\n}\n\nimpl Inlinable for Field {\n    fn write_inlined\u003cW: std::io::Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        let mut l = wtr.write_u8(self.ty as u8)?;\n        l += wtr.write_u32(self.bytes)?;\n        l += wtr.write_inlined_str::\u003c2\u003e(\u0026self.name)?;\n        Ok(l)\n    }\n\n    fn read_inlined\u003cR: std::io::Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        let ty = Ty::from(reader.read_u8()?);\n        let bytes = reader.read_u32()?;\n        let name = reader.read_inlined_str::\u003c2\u003e()?;\n        Ok(Self { name, ty, bytes })\n    }\n}\n\nimpl Field {\n    pub fn new(name: impl Into\u003cString\u003e, ty: Ty, bytes: u32) -\u003e Self {\n        let name = name.into();\n        Self { name, ty, bytes }\n    }\n\n    /// Field name.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// Data type of the field.\n    pub const fn ty(\u0026self) -\u003e Ty {\n        self.ty\n    }\n\n    /// Preset length of variable length data type.\n    ///\n    /// It's the byte-width in other types.\n    pub const fn bytes(\u0026self) -\u003e u32 {\n        self.bytes\n    }\n\n    /// Represent the data type in sql.\n    ///\n    /// For example: \"INT\", \"VARCHAR(100)\".\n    pub fn sql_repr(\u0026self) -\u003e String {\n        let ty = self.ty();\n        if ty.is_var_type() {\n            format!(\"{}({})\", ty.name(), self.bytes())\n        } else {\n            ty.name().to_string()\n        }\n    }\n}\n\nimpl Display for Field {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let ty = self.ty();\n        if ty.is_var_type() {\n            write!(f, \"({}: {}({}))\", self.name(), ty.name(), self.bytes())\n        } else {\n            write!(f, \"({}: {})\", self.name(), ty.name())\n        }\n    }\n}\n","traces":[{"line":26,"address":[3239260,3239980,3238560,3239280],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":27,"address":[3238595,3238730,3239362,3239315,3239450,3238642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3238702,3238967,3238945,3239422,3239687,3239515,3239665,3238795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3239924,3238950,3239227,3239204,3239742,3239670,3239022,3239947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[3239929,3239209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[3240000,3240723],"length":1,"stats":{"Line":0},"fn_name":"read_inlined\u003c\u0026mut \u0026[u8]\u003e"},{"line":34,"address":[3240076,3240191,3240032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[3240208,3240294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3240282,3240661,3240369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3240498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3240752],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026str\u003e"},{"line":43,"address":[8094800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2085200],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":49,"address":[2085209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2085248],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":54,"address":[2085253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[8158624],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":61,"address":[8158629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2085280],"length":1,"stats":{"Line":0},"fn_name":"sql_repr"},{"line":68,"address":[2085318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2085327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2085381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2085629,2085351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2085648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":79,"address":[2085681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2085693,2086290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2085756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2086077,2085725],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":28},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","itypes.rs"],"content":"use std::{fmt::Display, ops::Deref};\n\nuse derive_more::{Deref, DerefMut, Display, From};\n\nuse rust_decimal::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as Json;\n\nuse super::{Column, Ty, Value};\n\npub type INull = ();\npub type IBool = bool;\npub type ITinyInt = i8;\npub type ISmallInt = i16;\npub type IInt = i32;\npub type IBigInt = i64;\npub type IUTinyInt = u8;\npub type IUSmallInt = u16;\npub type IUInt = u32;\npub type IUBigInt = u64;\npub type IFloat = f32;\npub type IDouble = f64;\npub type IJson = Json;\npub type IDecimal = Decimal;\n\n#[derive(Debug, Clone, Copy, Deref, DerefMut, Deserialize, Serialize, Display, From)]\npub struct ITimestamp(pub i64);\n\n#[derive(Debug, Deref, DerefMut, Clone, Deserialize, Serialize)]\npub struct IVarChar(String);\n\n/// Alias of [IVarChar].\npub type IBinary = IVarChar;\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct INChar(String);\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IVarBinary(Vec\u003cu8\u003e);\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IMediumBlob(Vec\u003cu8\u003e);\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IBlob(Vec\u003cu8\u003e);\n\nimpl From\u003cString\u003e for IVarChar {\n    fn from(v: String) -\u003e Self {\n        Self(v)\n    }\n}\nimpl From\u003c\u0026str\u003e for IVarChar {\n    fn from(v: \u0026str) -\u003e Self {\n        Self(v.to_string())\n    }\n}\n\nimpl IVarChar {\n    pub const fn new() -\u003e Self {\n        Self(String::new())\n    }\n    pub fn with_capacity(cap: usize) -\u003e Self {\n        Self(String::with_capacity(cap))\n    }\n}\npub trait IsValue: Sized {\n    const TY: Ty;\n\n    fn is_null(\u0026self) -\u003e bool {\n        false\n    }\n\n    fn is_primitive(\u0026self) -\u003e bool {\n        std::mem::size_of::\u003cSelf\u003e() == Self::TY.fixed_length()\n    }\n\n    fn as_timestamp(\u0026self) -\u003e i64 {\n        debug_assert!(Self::TY == Ty::Timestamp);\n        unimplemented!()\n    }\n\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        debug_assert!(Self::TY == Ty::VarChar);\n        unimplemented!()\n    }\n\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        debug_assert!(Self::TY == Ty::NChar);\n        unimplemented!()\n    }\n\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8] {\n        debug_assert!(Self::TY == Ty::MediumBlob);\n        unimplemented!()\n    }\n\n    fn as_blob(\u0026self) -\u003e \u0026[u8] {\n        debug_assert!(Self::TY == Ty::Blob);\n        unimplemented!()\n    }\n}\n\nimpl\u003cT\u003e IsValue for Option\u003cT\u003e\nwhere\n    T: IsValue,\n{\n    const TY: Ty = T::TY;\n\n    fn is_null(\u0026self) -\u003e bool {\n        self.is_none()\n    }\n\n    fn is_primitive(\u0026self) -\u003e bool {\n        self.as_ref().unwrap().is_primitive()\n    }\n\n    fn as_timestamp(\u0026self) -\u003e i64 {\n        self.as_ref().unwrap().as_timestamp()\n    }\n\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        self.as_ref().unwrap().as_var_char()\n    }\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        self.as_ref().unwrap().as_nchar()\n    }\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8] {\n        self.as_ref().unwrap().as_medium_blob()\n    }\n    fn as_blob(\u0026self) -\u003e \u0026[u8] {\n        self.as_ref().unwrap().as_blob()\n    }\n}\n\npub trait IValue: Sized {\n    const TY: Ty;\n\n    type Inner: Sized;\n\n    fn is_null(\u0026self) -\u003e bool {\n        false\n    }\n\n    fn into_value(self) -\u003e Value;\n\n    fn into_inner(self) -\u003e Self::Inner;\n}\n\nimpl IValue for INull {\n    const TY: Ty = Ty::Null;\n\n    fn is_null(\u0026self) -\u003e bool {\n        true\n    }\n    fn into_value(self) -\u003e Value {\n        Value::Null\n    }\n\n    type Inner = ();\n\n    fn into_inner(self) -\u003e Self::Inner {\n        ()\n    }\n}\n\n/// Primitive type to TDengine data type.\nmacro_rules! impl_prim {\n    ($($ty:ident = $inner:ty)*) =\u003e {\n        $(paste::paste! {\n            impl IValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n                type Inner = $inner;\n\n                #[inline]\n                fn is_null(\u0026self) -\u003e bool {\n                    false\n                }\n\n                #[inline]\n                fn into_value(self) -\u003e Value {\n                    Value::$ty(self)\n                }\n\n                #[inline]\n                fn into_inner(self) -\u003e Self::Inner {\n                    self\n                }\n            }\n        })*\n    };\n}\n\nimpl_prim!(\n    Bool = bool\n    TinyInt = i8\n    SmallInt =  i16\n    Int = i32\n    BigInt = i64\n    UTinyInt = u8\n    USmallInt = u16\n    UInt = u32\n    UBigInt = u64\n    Float = f32\n    Double = f64\n    Decimal = Decimal\n    Json = Json\n);\n\npub trait IsPrimitive: Copy {\n    const TY: Ty;\n    fn is_primitive(\u0026self) -\u003e bool {\n        std::mem::size_of::\u003cSelf\u003e() == Self::TY.fixed_length()\n    }\n}\n\nmacro_rules! impl_is_primitive {\n    ($($ty:ident) *) =\u003e {\n        $(paste::paste! {\n            impl IsPrimitive for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n            }\n            impl IsValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n            }\n        })*\n    };\n}\n\nimpl_is_primitive!(\n    Bool TinyInt SmallInt Int BigInt\n    UTinyInt USmallInt UInt UBigInt\n    Float Double Decimal\n);\n\nimpl IsValue for ITimestamp {\n    const TY: Ty = Ty::Timestamp;\n\n    #[inline]\n    fn as_timestamp(\u0026self) -\u003e i64 {\n        self.0\n    }\n}\n\nimpl IsValue for IVarChar {\n    const TY: Ty = Ty::VarChar;\n\n    #[inline]\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\nimpl IsValue for INChar {\n    const TY: Ty = Ty::NChar;\n\n    #[inline]\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\npub trait IsVarChar {\n    fn as_var_char(\u0026self) -\u003e \u0026str;\n}\n\nimpl IsVarChar for IVarChar {\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\npub trait IsNChar {\n    fn as_nchar(\u0026self) -\u003e \u0026str;\n}\n\nimpl IsNChar for INChar {\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\npub trait IsJson {\n    fn to_json(\u0026self) -\u003e String;\n}\n\nimpl IsJson for IJson {\n    fn to_json(\u0026self) -\u003e String {\n        self.to_string()\n    }\n}\n\npub trait IsMediumBlob {\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8];\n}\n\nimpl IsMediumBlob for IMediumBlob {\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8] {\n        \u0026self\n    }\n}\n\npub trait IsBlob {\n    fn as_blob(\u0026self) -\u003e \u0026[u8];\n}\n\nimpl IsBlob for IBlob {\n    fn as_blob(\u0026self) -\u003e \u0026[u8] {\n        \u0026self\n    }\n}\n\nimpl IValue for ITimestamp {\n    const TY: Ty = Ty::Timestamp;\n\n    type Inner = i64;\n\n    fn into_value(self) -\u003e Value {\n        todo!()\n    }\n\n    fn into_inner(self) -\u003e Self::Inner {\n        self.0\n    }\n}\n\nmacro_rules! impl_wrapper_struct {\n    ($($ty:ident)*) =\u003e {\n        $(paste::paste! {\n            impl IValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n                #[inline]\n                fn into_value(self) -\u003e Value {\n                    Value::$ty(self.0)\n                }\n            }\n        })*\n    };\n    ($($ty:ident, $inner:ty;)*) =\u003e {\n        $(paste::paste! {\n            #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Deserialize, Serialize)]\n            pub struct [\u003cI $ty\u003e]($inner);\n\n            impl Deref for [\u003cI $ty\u003e] {\n                type Target = $inner;\n\n                #[inline]\n                fn deref(\u0026self) -\u003e \u0026Self::Target {\n                        \u0026self.0\n                }\n            }\n\n            impl IValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n                #[inline]\n                fn into_value(self) -\u003e Value {\n                    Value::$ty(self.0)\n                }\n            }\n        })*\n    };\n}\n","traces":[{"line":47,"address":[2815888],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":48,"address":[2815895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2815952],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":53,"address":[2815975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2816032],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":59,"address":[2816045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2816096],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":62,"address":[2816115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[2392336],"length":1,"stats":{"Line":0},"fn_name":"is_null\u003crust_decimal::decimal::Decimal\u003e"},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2392352],"length":1,"stats":{"Line":0},"fn_name":"is_primitive\u003crust_decimal::decimal::Decimal\u003e"},{"line":73,"address":[2392361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2470784,2470560,2471344,2471456,2470448,2471120,2471680,2471568,2470672,2471008,2470336,2471232,2470896],"length":1,"stats":{"Line":0},"fn_name":"as_timestamp\u003ci16\u003e"},{"line":77,"address":[2470569,2470793,2471528,2471017,2470520,2471304,2471640,2471465,2470632,2470968,2471353,2470457,2471689,2470408,2471752,2471241,2471416,2471129,2471577,2470905,2471080,2471192,2470856,2470744,2470681,2470345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2472016,2471792,2472128,2472688,2472800,2472240,2472912,2471904,2472352,2473136,2472464,2472576,2473024],"length":1,"stats":{"Line":0},"fn_name":"as_var_char\u003ci16\u003e"},{"line":82,"address":[2471864,2472424,2471913,2472312,2472872,2473033,2472809,2471976,2473208,2472361,2472648,2473145,2472921,2472200,2472697,2472984,2473096,2472585,2472088,2471801,2472137,2472249,2472760,2472473,2472025,2472536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[2473696,2473584,2474368,2474256,2473920,2474144,2474480,2474592,2474032,2473472,2473360,2473808,2473248],"length":1,"stats":{"Line":0},"fn_name":"as_nchar\u003cu8\u003e"},{"line":87,"address":[2473593,2474601,2474216,2474440,2474265,2473544,2473880,2473768,2473320,2474041,2474377,2474489,2474552,2474664,2473369,2473705,2473656,2473817,2473929,2474328,2474153,2473992,2473481,2473257,2473432,2474104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2474816,2474928,2475040,2475936,2476048,2475264,2476160,2475600,2475488,2475376,2475824,2475712,2475152,2474704],"length":1,"stats":{"Line":0},"fn_name":"as_medium_blob\u003cu8\u003e"},{"line":92,"address":[2392761,2392824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2392864],"length":1,"stats":{"Line":0},"fn_name":"as_blob\u003crust_decimal::decimal::Decimal\u003e"},{"line":97,"address":[2392873,2392936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2477840],"length":1,"stats":{"Line":0},"fn_name":"is_null\u003ctaos_query::common::itypes::ITimestamp\u003e"},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2816176],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":154,"address":[2816192],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":155,"address":[2816196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2816208],"length":1,"stats":{"Line":0},"fn_name":"into_inner"},{"line":174,"address":[2171264],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":179,"address":[2171280],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":180,"address":[2171287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2171376],"length":1,"stats":{"Line":0},"fn_name":"into_inner"},{"line":185,"address":[2171379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2392976],"length":1,"stats":{"Line":0},"fn_name":"is_primitive\u003crust_decimal::decimal::Decimal\u003e"},{"line":211,"address":[2392985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2816224],"length":1,"stats":{"Line":0},"fn_name":"as_timestamp"},{"line":239,"address":[2816229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2816240],"length":1,"stats":{"Line":0},"fn_name":"as_var_char"},{"line":248,"address":[2816249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2816304],"length":1,"stats":{"Line":0},"fn_name":"as_nchar"},{"line":257,"address":[2816313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2816368],"length":1,"stats":{"Line":0},"fn_name":"as_var_char"},{"line":267,"address":[2816377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2816432],"length":1,"stats":{"Line":0},"fn_name":"as_nchar"},{"line":277,"address":[2816441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2171216],"length":1,"stats":{"Line":0},"fn_name":"to_json"},{"line":287,"address":[2171233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[2816496],"length":1,"stats":{"Line":0},"fn_name":"as_medium_blob"},{"line":297,"address":[2816505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[2816560],"length":1,"stats":{"Line":0},"fn_name":"as_blob"},{"line":307,"address":[2816569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2816624],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":320,"address":[2816672],"length":1,"stats":{"Line":0},"fn_name":"into_inner"}],"covered":0,"coverable":67},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","mod.rs"],"content":"mod column;\nmod describe;\nmod field;\nmod opts;\nmod precision;\nmod raw;\nmod timestamp;\nmod ty;\nmod value;\n\npub use column::*;\npub use describe::*;\npub use field::*;\npub use opts::*;\npub use precision::*;\npub use raw::*;\npub use timestamp::*;\npub use ty::*;\npub use value::*;\n\npub mod itypes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","opts.rs"],"content":"use std::collections::BTreeMap;\n\nuse mdsn::Dsn;\n// use url::ParseError;\nuse mdsn::DsnError as Error;\n\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct TaosOpts {\n    pub host: Option\u003cString\u003e,\n    pub port: Option\u003cu16\u003e,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n    pub database: Option\u003cString\u003e,\n    pub params: BTreeMap\u003cString, String\u003e,\n}\n\nmacro_rules! _build_opt {\n    ($option:ident, $($doc:literal) *) =\u003e {\n        $(#[doc = $doc])*\n        pub fn $option\u003cT: Into\u003cString\u003e\u003e(mut self, $option: T) -\u003e Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n    ($option:ident, $ty:ty, $($doc:literal) *) =\u003e {\n        $(#[doc = $doc])*\n        pub fn $option\u003cT: Into\u003c$ty\u003e\u003e(mut self, $option: T) -\u003e Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n}\n\nimpl TaosOpts {\n    /// Default to [Default::default].\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn to_dsn_string(\u0026self) -\u003e String {\n        todo!()\n    }\n\n    /// Parse from a [DSN](https://en.wikipedia.org/wiki/Data_source_name) string.\n    ///\n    /// We use URL-described DSN style like this:\n    ///\n    /// ```text\n    /// \u003cdriver\u003e[+\u003cprotocol\u003e]://\u003cusername\u003e:\u003cpassword\u003e@\u003chost\u003e:\u003cport\u003e[,\u003chost2\u003e:\u003cport2\u003e]/\u003cdatabase\u003e?\u003cparams\u003e\n    /// ```\n    ///\n    /// - **driver**: to distinct from other data source, for TDengine, always use `taos`.\n    /// - **protocol**: additional information for connection, for TDengine, we have a plan to support\n    ///     taosc(the default protocol), http and websocket(with protocol identifier: `ws`).\n    /// - **username**: username for the connection\n    /// - **password**: password for the current user.\n    /// - **host**: host to TDengine server.\n    /// - **port**: port to TDengine server.\n    /// - **database**: default database for the connection, so that you don't need to write with full\n    ///     database name in sql like `select * from database.tb1`.\n    /// - **params**: in-query parameters are key-value pairs, drivers should be aware of the params list\n    ///     to support specific configuration for each driver or protocol.\n    ///\n    pub fn parse(dsn: \u0026str) -\u003e Result\u003cTaosOpts, Error\u003e {\n        if dsn.is_empty() {\n            return Ok(Self::new());\n        }\n        let _ = Dsn::parse(dsn)?;\n\n        Ok(Self::default())\n    }\n\n    _build_opt!(host, \"Set host name or ip address of TDengine server\");\n    _build_opt!(username, \"Set default username for TDengine connection\");\n    _build_opt!(password, \"Set default password for TDengine connection\");\n    _build_opt!(database, \"Set default database name of the connection\");\n    _build_opt!(port, u16, \"Set port to the TDengine server\");\n\n    /// Set other params by k-v pair.\n    pub fn with\u003cK: Into\u003cString\u003e, V: Into\u003cString\u003e\u003e(\n        mut self,\n        iter: impl Iterator\u003cItem = (K, V)\u003e,\n    ) -\u003e Self {\n        for (k, v) in iter {\n            self.set(k, v);\n        }\n        self\n    }\n\n    fn set(\u0026mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e \u0026mut Self {\n        self.params.insert(key.into(), value.into());\n        self\n    }\n}\n\n#[test]\nfn test_options() {\n    let opts = TaosOpts::parse(\"postgresql://root:pass@tcp(host1:123,host2:456)/somedb?target_session_attrs=any\u0026application_name=myapp\");\n    dbg!(opts);\n}\n\n#[test]\nfn test_options_builder_all() {\n    let opts = TaosOpts::new()\n        .host(\"localhost\")\n        .port(6030u16)\n        .username(\"root\")\n        .password(\"taosdata\");\n\n    assert_eq!(\n        opts,\n        TaosOpts {\n            host: Some(\"localhost\".to_string()),\n            port: Some(6030),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            database: None,\n            params: Default::default(),\n        },\n        \"builder pattern for TaosOpts\"\n    );\n}\n","traces":[{"line":20,"address":[2703301,2702464,2703040,2702752,2703013,2702719],"length":1,"stats":{"Line":3},"fn_name":"host\u003c\u0026str\u003e"},{"line":21,"address":[2702810,2702577,2702865,2703153,2702522,2703098],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[2702990,2703278,2702696],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[2703460,2703328],"length":1,"stats":{"Line":1},"fn_name":"port\u003cu16\u003e"},{"line":28,"address":[2703410,2703354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2703440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[3281664],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":37,"address":[3281672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[3281696],"length":1,"stats":{"Line":0},"fn_name":"to_dsn_string"},{"line":64,"address":[3281744],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":65,"address":[3281801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[3281845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3281904,3281829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[3282103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2703488,2703493],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":98,"address":[3284167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[3284225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2703525,2703520],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":104,"address":[3284839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[3285565,3285683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[3285368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[3285038,3284974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[3285070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[3285161,3285090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[3285193,3285261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[3285293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[3285305],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":30},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","precision.rs"],"content":"use std::{\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nuse serde::Deserialize;\n\n#[derive(Debug, thiserror::Error)]\npub enum PrecisionError {\n    #[error(\"invalid precision repr: {0}\")]\n    Invalid(String),\n}\n\n/// The precision of a timestamp or a database.\n#[repr(i32)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq, serde_repr::Serialize_repr)]\npub enum Precision {\n    Millisecond = 0,\n    Microsecond,\n    Nanosecond,\n}\n\nimpl PartialEq\u003cstr\u003e for Precision {\n    fn eq(\u0026self, other: \u0026str) -\u003e bool {\n        self.as_str() == other\n    }\n}\n\nimpl PartialEq\u003c\u0026str\u003e for Precision {\n    fn eq(\u0026self, other: \u0026\u0026str) -\u003e bool {\n        self.as_str() == *other\n    }\n}\n\nimpl Precision {\n    pub const fn as_str(\u0026self) -\u003e \u0026'static str {\n        use Precision::*;\n        match self {\n            Millisecond =\u003e \"ms\",\n            Microsecond =\u003e \"us\",\n            Nanosecond =\u003e \"ns\",\n        }\n    }\n\n    pub const fn as_u8(\u0026self) -\u003e u8 {\n        match self {\n            Self::Millisecond =\u003e 0,\n            Self::Microsecond =\u003e 1,\n            Self::Nanosecond =\u003e 2,\n        }\n    }\n    pub const fn from_u8(precision: u8) -\u003e Self {\n        match precision {\n            0 =\u003e Self::Millisecond,\n            1 =\u003e Self::Microsecond,\n            2 =\u003e Self::Nanosecond,\n            _ =\u003e panic!(\"precision integer only allow 0/1/2\"),\n        }\n    }\n}\n\nmacro_rules! _impl_from {\n    ($($ty:ty) *) =\u003e {\n        $(impl From\u003c$ty\u003e for Precision {\n            fn from(v: $ty) -\u003e Self {\n                Self::from_u8(v as _)\n            }\n        })*\n    }\n}\n\n_impl_from!(i8 i16 i32 i64 isize u8 u16 u32 u64 usize);\n\nimpl Display for Precision {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl FromStr for Precision {\n    type Err = PrecisionError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s {\n            \"ms\" =\u003e Ok(Precision::Millisecond),\n            \"us\" =\u003e Ok(Precision::Microsecond),\n            \"ns\" =\u003e Ok(Precision::Nanosecond),\n            s =\u003e Err(PrecisionError::Invalid(s.to_string())),\n        }\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Precision {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: serde::Deserializer\u003c'de\u003e,\n    {\n        struct PrecisionVisitor;\n\n        impl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for PrecisionVisitor {\n            type Value = Precision;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"expect integer 0/1/2 or string ms/us/ns\")\n            }\n\n            fn visit_i8\u003cE\u003e(self, v: i8) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n            fn visit_i16\u003cE\u003e(self, v: i16) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_i32\u003cE\u003e(self, v: i32) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Precision::try_from(v).map_err(\u003cE as serde::de::Error\u003e::custom)\n            }\n\n            fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u16\u003cE\u003e(self, v: u16) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u32\u003cE\u003e(self, v: u32) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Precision::from_str(v).map_err(\u003cE as serde::de::Error\u003e::custom)\n            }\n\n            fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Precision::Millisecond)\n            }\n\n            fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n            where\n                D: serde::Deserializer\u003c'de\u003e,\n            {\n                deserializer.deserialize_any(self)\n            }\n\n            fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Precision::Millisecond)\n            }\n        }\n\n        deserializer.deserialize_any(PrecisionVisitor)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{\n        de::{\n            value::{I32Deserializer, StrDeserializer, UnitDeserializer},\n            IntoDeserializer,\n        },\n        Deserialize,\n    };\n\n    use super::Precision;\n\n    #[test]\n    fn de() {\n        type SD\u003c'a\u003e = StrDeserializer\u003c'a, serde::de::value::Error\u003e;\n        let precision = Precision::deserialize::\u003cSD\u003e(\"ms\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n        let precision = Precision::deserialize::\u003cSD\u003e(\"us\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Microsecond);\n        let precision = Precision::deserialize::\u003cSD\u003e(\"ns\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Nanosecond);\n\n        type I32D = I32Deserializer\u003cserde::de::value::Error\u003e;\n        let precision = Precision::deserialize::\u003cI32D\u003e(0.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n        let precision = Precision::deserialize::\u003cI32D\u003e(1.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Microsecond);\n        let precision = Precision::deserialize::\u003cI32D\u003e(2.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Nanosecond);\n\n        type UnitD = UnitDeserializer\u003cserde::de::value::Error\u003e;\n        let precision = Precision::deserialize::\u003cUnitD\u003e(().into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n\n        let json = serde_json::to_string(\u0026precision).unwrap();\n        assert_eq!(json, \"0\");\n    }\n}\n","traces":[{"line":24,"address":[2833600],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":25,"address":[2833619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2833680],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":31,"address":[2833699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2833760],"length":1,"stats":{"Line":1},"fn_name":"as_str"},{"line":38,"address":[2833769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2833796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2833819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2833842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2833888],"length":1,"stats":{"Line":0},"fn_name":"as_u8"},{"line":46,"address":[2833897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2833922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2833929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2833936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2833952],"length":1,"stats":{"Line":1},"fn_name":"from_u8"},{"line":53,"address":[2833967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2834029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2834039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2834049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2834059,2833993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2835504,2835280,2835344,2835392,2835440,2835536,2835472,2835584,2835312,2835248],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":66,"address":[2835545,2835448,2835481,2835509,2835256,2835593,2835289,2835401,2835317,2835353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2834096],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":76,"address":[2834118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2834256],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":85,"address":[2834378,2834309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2834452,2834350,2834408],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[2834517,2834471,2834424],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[2834487,2834540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2891632,2891664,2891696,2891744],"length":1,"stats":{"Line":3},"fn_name":"deserialize\u003cserde::de::value::UnitDeserializer\u003cserde::de::value::Error\u003e\u003e"},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2834608],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":104,"address":[2834635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2891824],"length":1,"stats":{"Line":0},"fn_name":"visit_i8\u003cserde::de::value::Error\u003e"},{"line":111,"address":[2891843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2891872],"length":1,"stats":{"Line":0},"fn_name":"visit_i16\u003cserde::de::value::Error\u003e"},{"line":117,"address":[2891892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2891920],"length":1,"stats":{"Line":1},"fn_name":"visit_i32\u003cserde::de::value::Error\u003e"},{"line":124,"address":[2891949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[2891984],"length":1,"stats":{"Line":0},"fn_name":"visit_i64\u003cserde::de::value::Error\u003e"},{"line":131,"address":[2892000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2892016],"length":1,"stats":{"Line":0},"fn_name":"visit_u8\u003cserde::de::value::Error\u003e"},{"line":138,"address":[2892035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2892064],"length":1,"stats":{"Line":0},"fn_name":"visit_u16\u003cserde::de::value::Error\u003e"},{"line":145,"address":[2892084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2892112],"length":1,"stats":{"Line":0},"fn_name":"visit_u32\u003cserde::de::value::Error\u003e"},{"line":152,"address":[2892128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[2892144],"length":1,"stats":{"Line":0},"fn_name":"visit_u64\u003cserde::de::value::Error\u003e"},{"line":159,"address":[2892160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2892176],"length":1,"stats":{"Line":1},"fn_name":"visit_str\u003cserde::de::value::Error\u003e"},{"line":166,"address":[2892199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[2892240],"length":1,"stats":{"Line":0},"fn_name":"visit_none\u003cserde::de::value::Error\u003e"},{"line":173,"address":[2892247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2892288],"length":1,"stats":{"Line":0},"fn_name":"visit_some\u003cserde::__private::de::content::ContentDeserializer\u003cserde::de::value::Error\u003e\u003e"},{"line":180,"address":[2892300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2892368],"length":1,"stats":{"Line":1},"fn_name":"visit_unit\u003cserde::de::value::Error\u003e"},{"line":187,"address":[2892375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[2891680,2891717,2891644,2891755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[2815861,2815856],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":210,"address":[2835639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[2835885,2835729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[2835833,2835945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[2836141,2835985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[2836201,2836089],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[2836241,2836368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[2836342,2836416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[2836456,2836574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[2836548,2836622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[2836780,2836662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[2836828,2836754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[2836977,2836868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[2836960,2837021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[2837186,2837061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[2837153,2837230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[2837417,2837266,2837386],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":41,"coverable":76},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","raw","inner.rs"],"content":"use crate::{\n    common::{Column, Field, Precision, Timestamp, Ty, Value},\n    util::{Inlinable, InlinableRead, InlinableWrite},\n    BlockExt,\n};\nuse once_cell::unsync::OnceCell;\n\nuse core::slice;\nuse std::{fmt::Debug, mem::size_of, mem::transmute};\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\n#[repr(packed(2))] // use packed(2) because it's int16_t in raw block.\npub struct ColSchema {\n    ty: Ty,\n    len: u32,\n}\n\n#[test]\nfn col_schema() {\n    let col = ColSchema {\n        ty: Ty::BigInt,\n        len: 1,\n    };\n    let bytes: [u8; 6] = unsafe { std::mem::transmute_copy(\u0026col) };\n    dbg!(\u0026bytes);\n\n    let bytes: [u8; 6] = [4, 0, 1, 0, 0, 0];\n    let col2: ColSchema = unsafe { std::mem::transmute_copy(\u0026bytes) };\n    dbg!(col2);\n}\n#[test]\nfn test_bin() {\n    let v: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let ptr = v.as_ptr();\n\n    let v_u16 = unsafe { *transmute::\u003c*const u8, *const u16\u003e(ptr) };\n    println!(\"{v_u16:#x?}: {:?}\", v_u16.to_le_bytes());\n    #[derive(Debug, Clone, Copy)]\n    #[repr(packed)]\n    #[allow(dead_code)]\n    struct A {\n        a: u16,\n        b: u32,\n    }\n    println!(\"A size: {}\", std::mem::size_of::\u003cA\u003e());\n    let a: \u0026A = unsafe { transmute::\u003c*const u8, *const A\u003e(ptr).as_ref().unwrap() };\n    println!(\"{a:#x?}\");\n}\n\n/// Raw data block format (B for bytes):\n///\n/// ```text,ignore\n/// +-----+----------+---------------+-----------+-----------------------+-----------------+\n/// | len | group id | col_schema... | length... | (bitmap or offsets    | col data)   ... |\n/// | 4B  | 8B       | (2+4)B * cols | 4B * cols | (row+7)/8 or 4 * rows | length[col] ... |\n/// +-----+----------+---------------+-----------+-----------------------+-----------------+\n/// ```\n///\n/// The length of bitmap is decided by number of rows of this data block, and the length of each column data is\n/// recorded in the first segment, next to the struct header\n#[derive(Debug)]\npub struct RawBlock {\n    data: *mut u8,\n    len: usize,\n    cap: usize, // usually same to len.\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: OnceCell\u003cVec\u003c(Ty, isize, isize)\u003e\u003e,\n}\n\nimpl Default for RawBlock {\n    fn default() -\u003e Self {\n        Self {\n            data: std::ptr::null_mut(),\n            len: Default::default(),\n            cap: Default::default(),\n            rows: Default::default(),\n            cols: Default::default(),\n            precision: Precision::Millisecond,\n            offsets: Default::default(),\n        }\n    }\n}\n\nimpl Drop for RawBlock {\n    #[inline]\n    fn drop(\u0026mut self) {\n        unsafe { Vec::from_raw_parts(self.data, self.len, self.cap) };\n    }\n}\n\nimpl Inlinable for RawBlock {\n    /// **NOTE**: raw block bytes is not enough to parse data from.\n    /// You must call [with_rows](#method.with_rows)\n    fn read_inlined\u003cR: std::io::Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        let bytes = reader.read_inlined_bytes::\u003c4\u003e()?;\n        Ok(Self::new(bytes))\n    }\n\n    fn write_inlined\u003cW: std::io::Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_inlined_bytes::\u003c4\u003e(self.as_bytes())\n    }\n}\nimpl RawBlock {\n    #[inline]\n    pub fn new(mut vec: Vec\u003cu8\u003e) -\u003e Self {\n        let data = vec.as_mut_ptr();\n        let len = vec.len();\n        let cap = vec.capacity();\n        assert_eq!(len, cap);\n        std::mem::forget(vec);\n        Self {\n            data,\n            len,\n            cap,\n            rows: Default::default(),\n            cols: Default::default(),\n            precision: Precision::Millisecond,\n            offsets: Default::default(),\n        }\n    }\n\n    #[inline]\n    pub fn with_rows(\u0026mut self, rows: usize) -\u003e \u0026mut Self {\n        self.rows = rows;\n        self\n    }\n\n    #[inline]\n    pub fn with_cols(\u0026mut self, cols: usize) -\u003e \u0026mut Self {\n        self.cols = cols;\n        self\n    }\n\n    #[inline]\n    pub fn with_precision(\u0026mut self, precision: Precision) -\u003e \u0026mut Self {\n        self.precision = precision;\n        self\n    }\n\n    #[inline]\n    /// From raw data block.\n    pub unsafe fn from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -\u003e Self {\n        let len = *transmute::\u003c*const u8, *const u32\u003e(data) as usize;\n        let data = std::slice::from_raw_parts(data.offset(4), len).to_vec();\n        Self::from_bytes(data, rows, cols, precision)\n    }\n\n    #[inline]\n    /// Build inner block from bytes.\n    pub fn from_bytes(mut vec: Vec\u003cu8\u003e, rows: usize, cols: usize, precision: Precision) -\u003e Self {\n        let data = vec.as_mut_ptr();\n        let len = vec.len();\n        let cap = vec.capacity();\n        assert_eq!(len, cap);\n        std::mem::forget(vec);\n        Self {\n            data,\n            len,\n            cap,\n            rows,\n            cols,\n            precision,\n            offsets: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    /// The whole block slice length.\n    pub const fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    #[inline]\n    pub const fn nrows(\u0026self) -\u003e usize {\n        self.rows\n    }\n\n    #[inline]\n    pub const fn ncols(\u0026self) -\u003e usize {\n        self.cols\n    }\n\n    #[inline]\n    /// The group id of the raw block.\n    pub const fn group_id(\u0026self) -\u003e u64 {\n        unsafe { *std::mem::transmute::\u003c*const u8, *const u64\u003e(self.as_ptr()) }\n    }\n\n    /// Inner block as bytes slice.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        unsafe { std::slice::from_raw_parts(self.data, self.len) }\n    }\n\n    #[inline]\n    /// Raw data block bytes.\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        self.as_bytes().to_owned()\n    }\n\n    #[inline]\n    /// Raw data into block bytes.\n    pub fn into_vec(self) -\u003e Vec\u003cu8\u003e {\n        unsafe { Vec::from_raw_parts(self.data, self.len, self.cap) }\n    }\n\n    #[inline]\n    /// Pointer to raw block data slice.\n    const fn as_ptr(\u0026self) -\u003e *const u8 {\n        self.data\n    }\n\n    #[inline]\n    /// Offset to column schema start position.\n    const fn schema_offset(\u0026self) -\u003e isize {\n        // 4 = block data length.\n        // 8 = group id.\n        8\n    }\n\n    #[inline]\n    /// Offset to lengths start position.\n    const fn lengths_offset(\u0026self) -\u003e isize {\n        // 6 == size_of::\u003cColumnSchema\u003e()\n        self.schema_offset() + self.cols as isize * 6\n    }\n\n    #[inline]\n    /// Offset to column data start position.\n    const fn data_offset(\u0026self) -\u003e isize {\n        self.lengths_offset() + self.cols as isize * 4\n    }\n\n    /// Pointer to specific offset.\n    const unsafe fn offset(\u0026self, count: isize) -\u003e *const u8 {\n        self.as_ptr().offset(count)\n    }\n\n    /// Length of each bitmap block.\n    const fn bitmap_len(\u0026self) -\u003e usize {\n        (self.rows + 7) / 8\n    }\n\n    /// A lazy-init-ed index to each column.\n    ///\n    /// For each column, the index is a 3-element tuple:\n    ///\n    /// 0. Column data type represented as [Ty]\n    /// 1. Offset to column data start position relative to the block front.\n    ///   - For var-type, it's a `rows` length `i32` vector contains the offsets to each row.\n    ///   - For non-var-type, it's the is-null bitmap.\n    /// 2. Offset to the start position of real column data.\n    fn column_offsets(\u0026self) -\u003e \u0026[(Ty, isize, isize)] {\n        self.offsets.get_or_init(|| {\n            let lengths = self.lengths();\n            let mut data_offset = self.data_offset();\n            self.schemas()\n                .iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    assert!(data_offset \u003c self.len() as isize);\n                    if col.ty.is_var_type() {\n                        let o = (col.ty, data_offset, data_offset + 4 * self.rows as isize);\n                        data_offset = o.2 + lengths[i] as isize;\n                        o\n                    } else {\n                        let o = (\n                            col.ty,\n                            data_offset,\n                            data_offset + self.bitmap_len() as isize,\n                        );\n                        data_offset = o.2 + lengths[i] as isize;\n\n                        assert!(data_offset \u003c self.len() as isize);\n                        o\n                    }\n                })\n                .collect()\n        })\n    }\n\n    /// Column schema extractor.\n    #[inline]\n    pub const fn schemas(\u0026self) -\u003e \u0026[ColSchema] {\n        unsafe {\n            let ptr = self.offset(self.schema_offset());\n            slice::from_raw_parts(ptr as *mut ColSchema, self.cols)\n        }\n    }\n\n    /// Get column data type.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn get_type_of(\u0026self, col: usize) -\u003e Ty {\n        self.get_schema_of(col).ty\n    }\n\n    /// Get column schema which includes data type and bytes length.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn get_schema_of(\u0026self, col: usize) -\u003e \u0026ColSchema {\n        unsafe { self.schemas().get_unchecked(col) }\n    }\n\n    #[inline]\n    /// Lengths for each column raw data.\n    const fn lengths(\u0026self) -\u003e \u0026[i32] {\n        unsafe {\n            let ptr = self.offset(self.lengths_offset());\n            slice::from_raw_parts(ptr as *mut i32, self.cols)\n        }\n    }\n\n    #[inline]\n    /// Get one value at `(row, col)` of the block.\n    pub unsafe fn get_unchecked(\u0026self, row: usize, col: usize) -\u003e Value {\n        let (ty, o1, o2) = self.column_offsets().get_unchecked(col);\n\n        macro_rules! is_null {\n            ($bm:expr, $row:expr) =\u003e {{\n                (*$bm.offset($row as isize \u003e\u003e 3) \u003e\u003e (7 - ($row \u0026 7)) as u8) \u0026 0x1 == 1\n            }};\n        }\n\n        macro_rules! _primitive_value {\n            ($ty:ident, $native:ty) =\u003e {{\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003c$native\u003e()) as isize)\n                        as *const $native);\n                    Value::$ty(v)\n                }\n            }};\n        }\n\n        match ty {\n            Ty::Null =\u003e Value::Null,\n            Ty::Bool =\u003e _primitive_value!(Bool, bool),\n            Ty::TinyInt =\u003e _primitive_value!(TinyInt, i8),\n            Ty::SmallInt =\u003e _primitive_value!(SmallInt, i16),\n            Ty::Int =\u003e _primitive_value!(Int, i32),\n            Ty::BigInt =\u003e _primitive_value!(BigInt, i64),\n            Ty::Float =\u003e _primitive_value!(Float, f32),\n            Ty::Double =\u003e _primitive_value!(Double, f64),\n            Ty::VarChar =\u003e {\n                //\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    Value::VarChar(\n                        std::str::from_utf8_unchecked(slice::from_raw_parts(\n                            ptr.offset(2),\n                            len as usize,\n                        ))\n                        .to_string(),\n                    )\n                }\n            }\n            Ty::Timestamp =\u003e {\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003ci64\u003e()) as isize) as *const i64);\n                    Value::Timestamp(Timestamp::new(v, self.precision))\n                }\n            }\n            Ty::NChar =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n\n                    Value::NChar(\n                        slice::from_raw_parts(ptr.offset(2) as *mut char, len as usize / 4)\n                            .into_iter()\n                            .collect(),\n                    )\n                }\n            }\n            Ty::UTinyInt =\u003e _primitive_value!(UTinyInt, u8),\n            Ty::USmallInt =\u003e _primitive_value!(USmallInt, u16),\n            Ty::UInt =\u003e _primitive_value!(UInt, u32),\n            Ty::UBigInt =\u003e _primitive_value!(UBigInt, u64),\n            Ty::Json =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    debug_assert!(self.len() as isize \u003e= o1 + row as isize * 4 + len as isize);\n                    let chars_len = len / 4;\n                    let chars_ptr = ptr.offset(2) as *mut char;\n                    let chars = slice::from_raw_parts(chars_ptr, chars_len as usize);\n                    let json: String = chars.into_iter().collect();\n\n                    serde_json::from_str(\u0026json)\n                        .ok()\n                        .map(Value::Json)\n                        .unwrap_or(Value::Null)\n                }\n            }\n            ty =\u003e unreachable!(\"unsupported type: {ty}\"),\n        }\n    }\n}\n\n#[test]\nfn inner_block() {\n    use crate::common::Precision::Millisecond;\n    use crate::common::Timestamp::Milliseconds;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let block = unsafe { RawBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    assert_eq!(block.len(), bytes.len() - 4);\n    assert_eq!(block.as_bytes(), \u0026bytes[4..]);\n    assert_eq!(block.group_id(), 0);\n\n    use Value::*;\n    let values = vec![\n        vec![\n            Timestamp(Milliseconds(1655538138610)),\n            Bool(true),\n            Value::TinyInt(-1),\n            SmallInt(-1),\n            Int(-1),\n            BigInt(-1),\n            UTinyInt(1),\n            USmallInt(1),\n            UInt(1),\n            UBigInt(1),\n            Float(0.0),\n            Double(0.0),\n            VarChar(\"abc\".to_string()),\n            NChar(\"\".to_string()),\n        ],\n        {\n            Some(Timestamp(Milliseconds(1655538139610)))\n                .into_iter()\n                .chain(std::iter::repeat(Value::Null).take(14))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        },\n    ];\n    assert!(block.cols == 14);\n\n    for row in 0..rows {\n        for col in 0..block.cols {\n            let v = unsafe { block.get_unchecked(row, col) };\n            assert_eq!(v, values[row][col]);\n        }\n    }\n\n    let inlined = block.inlined();\n    assert!(inlined == bytes);\n}\n","traces":[{"line":20,"address":[3220304],"length":1,"stats":{"Line":3},"fn_name":"col_schema"},{"line":25,"address":[3220352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[3220408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[3220860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[3220916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[3220972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[3221440],"length":1,"stats":{"Line":3},"fn_name":"test_bin"},{"line":34,"address":[3221447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[3221527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[3221570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[3221607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[3221820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[3221930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[3222001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[3208928],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":77,"address":[3208976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3208986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[3208996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3209006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3209023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[2803424],"length":1,"stats":{"Line":1},"fn_name":"drop"},{"line":90,"address":[2803433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2076336,2076435],"length":1,"stats":{"Line":1},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":103,"address":[2076426,2076371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[3209136,3209684,3209715],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":109,"address":[3209249,3209166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[3209257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3209288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3209456,3209314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[3209396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[3209526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3209538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3209569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3209728],"length":1,"stats":{"Line":0},"fn_name":"with_rows"},{"line":127,"address":[3209744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[3209760],"length":1,"stats":{"Line":0},"fn_name":"with_cols"},{"line":133,"address":[3209776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3209792],"length":1,"stats":{"Line":0},"fn_name":"with_precision"},{"line":139,"address":[3209807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3209824],"length":1,"stats":{"Line":2},"fn_name":"from_ptr"},{"line":151,"address":[3209893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[3209994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[3210051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[3210690,3210112,3210659],"length":1,"stats":{"Line":2},"fn_name":"from_bytes"},{"line":159,"address":[3210181,3210264],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[3210272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[3210303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[3210329,3210471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3210411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3210548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[3210704],"length":1,"stats":{"Line":1},"fn_name":"len"},{"line":178,"address":[3210709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[3210720],"length":1,"stats":{"Line":1},"fn_name":"nrows"},{"line":183,"address":[3210725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[3210736],"length":1,"stats":{"Line":1},"fn_name":"ncols"},{"line":188,"address":[3210741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[3210752],"length":1,"stats":{"Line":1},"fn_name":"group_id"},{"line":194,"address":[3210761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[3222960],"length":1,"stats":{"Line":1},"fn_name":"as_bytes"},{"line":201,"address":[3222972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[3210816],"length":1,"stats":{"Line":0},"fn_name":"to_vec"},{"line":207,"address":[3210848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[3210896,3210978],"length":1,"stats":{"Line":0},"fn_name":"into_vec"},{"line":213,"address":[3210916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3211024],"length":1,"stats":{"Line":1},"fn_name":"as_ptr"},{"line":219,"address":[3211029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[3211040],"length":1,"stats":{"Line":1},"fn_name":"schema_offset"},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3211056],"length":1,"stats":{"Line":1},"fn_name":"lengths_offset"},{"line":234,"address":[3211070,3211172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[3211216],"length":1,"stats":{"Line":1},"fn_name":"data_offset"},{"line":240,"address":[3211230,3211332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[3211376],"length":1,"stats":{"Line":1},"fn_name":"offset"},{"line":245,"address":[3211395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[3211456],"length":1,"stats":{"Line":1},"fn_name":"bitmap_len"},{"line":250,"address":[3211499,3211465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[3211536],"length":1,"stats":{"Line":1},"fn_name":"column_offsets"},{"line":263,"address":[2076464],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":264,"address":[2076502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2076538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[2076553,2076666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[2076783,2076720,2076629],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":270,"address":[2076807,2076888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[2077799,2076925,2077385,2076874],"length":1,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[2077216,2077016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[2077387,2077267,2077182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[2077350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[2077495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[2076947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[2076953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[2076964,2077449,2077553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[2077604,2077705,2077519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[2077679,2077744,2077804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[2077764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[3211616],"length":1,"stats":{"Line":1},"fn_name":"schemas"},{"line":295,"address":[3211630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[3211675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[3223008],"length":1,"stats":{"Line":0},"fn_name":"get_type_of"},{"line":304,"address":[3223022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3223056],"length":1,"stats":{"Line":0},"fn_name":"get_schema_of"},{"line":311,"address":[3223075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3211712],"length":1,"stats":{"Line":1},"fn_name":"lengths"},{"line":318,"address":[3211726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[3211771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[3214002,3211808],"length":1,"stats":{"Line":1},"fn_name":"get_unchecked"},{"line":326,"address":[3211890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[3212021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[3212121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3212145,3219680,3219755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[3212190,3219378,3219303],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[3212235,3218887,3218974],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[3218549,3218462,3212280],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[3218121,3218034,3212325],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[3217603,3212370,3217690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[3217259,3212415,3217172],"length":1,"stats":{"Line":3},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[3216708,3212452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[3217159,3216887,3216838],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[3216884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[3216908,3216858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[3216937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[3217024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[3217020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[3212501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[3216687,3216220,3216307,3216473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[3216470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[3216478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[3216628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[3215750,3212538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[3216207,3215880,3215929],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[3215926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[3215900,3215950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[3215979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[3216062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[3215404,3212587,3215317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[3212632,3214976,3214889],"length":1,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[3214464,3214551,3212677],"length":1,"stats":{"Line":3},"fn_name":null},{"line":402,"address":[3212722,3214036,3214123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[3213002,3212759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[3213132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[3213178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[3213213,3213152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[3213250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[3213496,3213269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[3213481,3213534,3213620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[3213666,3213618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[3213674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[3213732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[3213792,3213976,3213875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[3213952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2078261,2078256],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":432,"address":[3223143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[3223166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[3223178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[3223190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[3223201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[3223338,3223597,3223275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[3223917,3223558,3223661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[3223972,3224113,3223886],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[3225945,3225716,3224082,3224213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[3225392,3224567,3224674,3224751,3224190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[3224271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[3224331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[3224347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[3224363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[3224381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[3224400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[3224420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[3224436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[3224454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[3224473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[3224493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[3224512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[3224532,3224599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[3224639,3224711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[3225849,3225912,3225577],"length":1,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[3225748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[3225756,3225927,3225888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[3226012,3226094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[3226180,3226030,3226296],"length":1,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[3226317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[3226528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[3226540,3226617,3226756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[3226286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[3226819,3226878,3226903],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":140,"coverable":213},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","raw","mod.rs"],"content":"mod inner;\n\nuse std::io::Write;\n\nuse super::{Column, Field, Precision};\n\nuse crate::util::*;\npub use inner::*;\n\nuse bitflags::bitflags;\nuse once_cell::unsync::OnceCell;\n\nbitflags! {\n    #[derive(Default)]\n    #[repr(transparent)]\n    struct Fx: u8 {\n        /// Has database name in the block.\n        const HAS_DB = 0b00000001;\n        /// Has table name in the block\n        const HAS_TB = 0b00000010;\n        /// Has fields data in the block\n        const HAS_FL = 0b00000100;\n        /// Has precision set.\n        const HAS_PC = 0b00001000;\n        /// Precision set as 'ms'(milliseconds).\n        const IS_MS  = 0b00001000;\n        /// Precision set as 'us'(microseconds).\n        const IS_US  = 0b00011000;\n        /// Precision set as 'ns'(nanoseconds).\n        const IS_NS  = 0b00101000;\n    }\n}\n\npub struct Block {\n    database: Option\u003cString\u003e,\n    table: Option\u003cString\u003e,\n    fields: Option\u003cVec\u003cField\u003e\u003e,\n    raw: OnceCell\u003cRawBlock\u003e,\n    columns: OnceCell\u003cVec\u003cColumn\u003e\u003e,\n}\n\nimpl Inlinable for Block {\n    #[inline]\n    fn read_inlined\u003cR: std::io::Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        let flags = Fx::from_bits(reader.read_u8()?).unwrap();\n        let database = if flags.contains(Fx::HAS_DB) {\n            Some(reader.read_inlined_str::\u003c2\u003e()?)\n        } else {\n            None\n        };\n        let table = if flags.contains(Fx::HAS_DB) {\n            Some(reader.read_inlined_str::\u003c2\u003e()?)\n        } else {\n            None\n        };\n        use itertools::Itertools;\n        let fields = if flags.contains(Fx::HAS_FL) {\n            Some(\n                (0..reader.read_u16()?)\n                    .map(|f| reader.read_inlinable::\u003cField\u003e())\n                    .try_collect()?,\n            )\n        } else {\n            None\n        };\n\n        let precision = if flags.contains(Fx::IS_MS) {\n            Precision::Millisecond\n        } else if flags.contains(Fx::IS_US) {\n            Precision::Microsecond\n        } else if flags.contains(Fx::IS_NS) {\n            Precision::Nanosecond\n        } else {\n            Precision::Millisecond\n        };\n\n        let rows = reader.read_u32()?;\n        let cols = reader.read_u32()?;\n\n        let bytes = reader.read_inlined_bytes::\u003c4\u003e()?;\n        let raw = OnceCell::new();\n        raw.try_insert(RawBlock::from_bytes(\n            bytes,\n            rows as usize,\n            cols as usize,\n            precision,\n        ))\n        .unwrap();\n\n        Ok(Self {\n            database,\n            table,\n            fields,\n            raw,\n            columns: OnceCell::new(),\n        })\n    }\n\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        let mut l = wtr.write_u8(self.flags().bits)?;\n\n        if let Some(name) = self.database.as_ref() {\n            l += wtr.write_inlined_bytes::\u003c2\u003e(name.as_bytes())?;\n        }\n        if let Some(name) = self.table.as_ref() {\n            l += wtr.write_inlined_bytes::\u003c2\u003e(name.as_bytes())?;\n        }\n        if let Some(fields) = self.fields.as_ref() {\n            l += wtr.write_len_with_width::\u003c2\u003e(fields.len())?;\n            for field in fields {\n                l += wtr.write_inlinable(field)?;\n            }\n        }\n        let raw = self.as_raw_block();\n        l += wtr.write_len_with_width::\u003c4\u003e(raw.nrows())?;\n        l += wtr.write_len_with_width::\u003c4\u003e(raw.ncols())?;\n        l += wtr.write_inlined_bytes::\u003c4\u003e(raw.as_bytes())?;\n        Ok(l)\n    }\n}\n\nimpl Block {\n    #[inline]\n    pub fn fields(\u0026self) -\u003e \u0026[Field] {\n        const FIELDS: [Field; 0] = [];\n        if let Some(f) = self.fields.as_ref() {\n            \u0026f\n        } else {\n            \u0026FIELDS\n        }\n    }\n\n    #[inline]\n    pub const fn has_database_name(\u0026self) -\u003e bool {\n        self.database.is_some()\n    }\n    #[inline]\n    pub const fn has_table_name(\u0026self) -\u003e bool {\n        self.table.is_some()\n    }\n\n    #[inline]\n    pub fn with_database_name(\u0026mut self, database: \u0026str) -\u003e \u0026mut Self {\n        self.database = Some(database.to_string());\n        self\n    }\n\n    #[inline]\n    pub fn with_table_name(\u0026mut self, table: \u0026str) -\u003e \u0026mut Self {\n        self.table = Some(table.to_string());\n        self\n    }\n\n    #[inline]\n    pub fn with_fields(\u0026mut self, fields: Vec\u003cField\u003e) -\u003e \u0026mut Self {\n        assert!(fields.len() \u003e 0);\n        self.fields = Some(fields);\n        self\n    }\n\n    #[inline]\n    pub fn from_raw_block(data: RawBlock) -\u003e Self {\n        let raw = OnceCell::new();\n        raw.try_insert(data).unwrap();\n        Self {\n            raw,\n            database: None,\n            table: None,\n            fields: None,\n            columns: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    pub fn from_raw_bytes(bytes: Vec\u003cu8\u003e, rows: usize, cols: usize, precision: Precision) -\u003e Self {\n        let data = RawBlock::from_bytes(bytes, rows, cols, precision);\n        Self::from_raw_block(data)\n    }\n\n    #[inline]\n    pub fn push_column(\u0026mut self, column: impl Into\u003cColumn\u003e) -\u003e \u0026mut Self {\n        if let Some(mut v) = self.columns.take() {\n            v.push(column.into());\n            self.columns.try_insert(v).unwrap();\n        } else {\n            let v = vec![column.into()];\n            self.columns.try_insert(v).unwrap();\n        }\n        self\n    }\n\n    #[inline]\n    pub fn as_raw_block(\u0026self) -\u003e \u0026RawBlock {\n        self.raw.get_or_init(|| todo!())\n    }\n\n    #[inline]\n    pub fn to_raw_vec(\u0026self) -\u003e std::io::Result\u003cVec\u003cu8\u003e\u003e {\n        let mut bytes = Vec::new();\n        bytes.write_inlinable(self)?;\n        Ok(bytes)\n    }\n\n    #[inline]\n    pub fn nrows(\u0026self) -\u003e usize {\n        self.as_raw_block().nrows()\n    }\n\n    #[inline]\n    pub fn ncols(\u0026self) -\u003e usize {\n        self.as_raw_block().ncols()\n    }\n\n    fn flags(\u0026self) -\u003e Fx {\n        let mut flags = Fx::default();\n        if self.has_database_name() {\n            flags |= Fx::HAS_DB;\n        }\n        if self.has_table_name() {\n            flags |= Fx::HAS_TB;\n        }\n        if self.fields.is_some() {\n            flags |= Fx::HAS_FL;\n        }\n        flags\n    }\n}\n\n#[test]\nfn inner_block() -\u003e anyhow::Result\u003c()\u003e {\n    use crate::common::Precision::Millisecond;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let raw = unsafe { RawBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    let mut block = Block::from_raw_block(raw);\n    block.with_database_name(\"abc\").with_table_name(\"n1\");\n\n    let a = block.printable_inlined();\n\n    let inlined = block.inlined();\n\n    anyhow::ensure!(\n        \u0026inlined[0..18] == b\"\\x03\\x03\\x00abc\\x02\\x00n1\\x02\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\"\n    );\n    assert!(\u0026inlined[18..] == bytes);\n\n    let block = Block::read_inlined(inlined.as_slice())?;\n    let b = block.printable_inlined();\n\n    assert_eq!(a, b);\n    Ok(())\n}\n","traces":[{"line":13,"address":[1929213,1929085,1929021,1928893,1929277,1928957,1929149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1925086,1925072],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":44,"address":[2707655,2707821,2704464],"length":1,"stats":{"Line":1},"fn_name":"read_inlined\u003c\u0026[u8]\u003e"},{"line":45,"address":[2704708,2704491,2704585],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[2704753,2704791,2704998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2704809,2705005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2704774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2705391,2705169,2705143,2705087],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[2705187,2705398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2705149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2705576,2705494,2705550,2706018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[2705594,2705690,2705791,2705814,2706041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2705682,2707840,2707864],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c\u0026[u8]\u003e"},{"line":61,"address":[2706025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2705556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[2706127,2706183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2706210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2706199,2706245,2706283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2706272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2706306,2706289,2706261,2706319],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[2706308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2706295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[2706234,2706337,2706412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2706400,2706580,2706505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2706779,2706568,2706658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2706764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2706911,2706991,2707063],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[2706919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[2706959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[2706963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2706967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2707349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[2707092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[2707126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2707166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[2707206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[2707302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2710428,2707888],"length":1,"stats":{"Line":1},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":101,"address":[2708125,2707994,2707946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2708524,2708201,2708098],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[2708516,2708529,2708251,2708340],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[2708888,2708569,2708282],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[2708880,2708619,2708893,2708704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2708650,2708934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2709220,2709045,2708989,2709245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2709576,2709228,2709288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2709581,2709398,2709568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2709619,2709009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[2709627,2709835,2709855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2709843,2709909,2710084,2710109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[2710366,2710168,2710395,2710092],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[2710374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1922608],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":127,"address":[1922740,1922617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1922664,1922730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1922685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1922752],"length":1,"stats":{"Line":1},"fn_name":"has_database_name"},{"line":136,"address":[1922761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1922800],"length":1,"stats":{"Line":1},"fn_name":"has_table_name"},{"line":140,"address":[1922809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1922848,1922940],"length":1,"stats":{"Line":1},"fn_name":"with_database_name"},{"line":145,"address":[1922973,1922872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1923008,1923105],"length":1,"stats":{"Line":1},"fn_name":"with_table_name"},{"line":151,"address":[1923032,1923138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1923184,1923471,1923495],"length":1,"stats":{"Line":0},"fn_name":"with_fields"},{"line":157,"address":[1923224,1923273,1923349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1923296,1923386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1923214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1923520,1924153,1924235],"length":1,"stats":{"Line":1},"fn_name":"from_raw_block"},{"line":164,"address":[1923542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1923624,1923765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1923901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1924272],"length":1,"stats":{"Line":0},"fn_name":"from_raw_bytes"},{"line":177,"address":[1924313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1924354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[1924416],"length":1,"stats":{"Line":1},"fn_name":"as_raw_block"},{"line":195,"address":[1924425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1924756,1924464],"length":1,"stats":{"Line":0},"fn_name":"to_raw_vec"},{"line":200,"address":[1924491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1924688,1924562,1924517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1924617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1924800],"length":1,"stats":{"Line":0},"fn_name":"nrows"},{"line":207,"address":[1924809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1924848],"length":1,"stats":{"Line":0},"fn_name":"ncols"},{"line":212,"address":[1924857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1924896],"length":1,"stats":{"Line":1},"fn_name":"flags"},{"line":216,"address":[1924910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1924924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1924959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1924948,1924980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1925006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1925027,1924991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1925042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1929328,1930861,1930779],"length":1,"stats":{"Line":3},"fn_name":"inner_block"},{"line":233,"address":[1929335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1929350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1929362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1929374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1929385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1929451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1929498,1929581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[1929616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1929639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1929714,1929822,1929994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1929690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1929938,1930111,1930189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[1930239,1930172,1930386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1930376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[1930686,1930732,1930562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1930692],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":119},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","timestamp.rs"],"content":"use std::fmt::{self, Debug, Display};\n\nuse serde::{Deserialize, Serialize};\n\nuse super::Precision;\n\n#[derive(Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\npub enum Timestamp {\n    Milliseconds(i64),\n    Microseconds(i64),\n    Nanoseconds(i64),\n}\n\nimpl Debug for Timestamp {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        if f.alternate() {\n            match self {\n                Self::Milliseconds(arg0) =\u003e f.debug_tuple(\"Milliseconds\").field(arg0).finish(),\n                Self::Microseconds(arg0) =\u003e f.debug_tuple(\"Microseconds\").field(arg0).finish(),\n                Self::Nanoseconds(arg0) =\u003e f.debug_tuple(\"Nanoseconds\").field(arg0).finish(),\n            }\n        } else {\n            Debug::fmt(\u0026self.to_naive_datetime(), f)\n        }\n    }\n}\n\nimpl Display for Timestamp {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        Display::fmt(\u0026self.to_naive_datetime(), f)\n    }\n}\n\nimpl Timestamp {\n    pub fn new(raw: i64, precision: Precision) -\u003e Self {\n        match precision {\n            Precision::Millisecond =\u003e Timestamp::Milliseconds(raw),\n            Precision::Microsecond =\u003e Timestamp::Microseconds(raw),\n            Precision::Nanosecond =\u003e Timestamp::Nanoseconds(raw),\n        }\n    }\n    pub fn as_raw_i64(\u0026self) -\u003e i64 {\n        match self {\n            Timestamp::Milliseconds(raw)\n            | Timestamp::Microseconds(raw)\n            | Timestamp::Nanoseconds(raw) =\u003e *raw,\n        }\n    }\n    pub fn to_naive_datetime(\u0026self) -\u003e chrono::NaiveDateTime {\n        let duration = match self {\n            Timestamp::Milliseconds(raw) =\u003e chrono::Duration::milliseconds(*raw),\n            Timestamp::Microseconds(raw) =\u003e chrono::Duration::microseconds(*raw),\n            Timestamp::Nanoseconds(raw) =\u003e chrono::Duration::nanoseconds(*raw),\n        };\n        chrono::NaiveDateTime::from_timestamp(0, 0)\n            .checked_add_signed(duration)\n            .unwrap()\n    }\n\n    // todo: support to tz.\n    pub fn to_datetime_with_tz(\u0026self) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ts_new() {\n        use Precision::*;\n        for prec in [Millisecond, Microsecond, Nanosecond] {\n            let ts = Timestamp::new(0, prec);\n            assert!(ts.as_raw_i64() == 0);\n            assert!(ts.to_naive_datetime() == chrono::NaiveDateTime::from_timestamp(0, 0));\n        }\n    }\n\n    #[test]\n    fn ts_debug() {\n        let ts = Timestamp::new(0, Precision::Millisecond);\n        assert_eq!(format!(\"{:?}\", ts), \"1970-01-01T00:00:00\");\n        assert_eq!(format!(\"{:#?}\", ts), \"Milliseconds(\\n    0,\\n)\");\n        assert_eq!(format!(\"{}\", ts), \"1970-01-01 00:00:00\");\n    }\n}\n","traces":[{"line":15,"address":[2699936],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":16,"address":[8227662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2700030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[2700072,2700339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2700127,2700292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[2700179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[2700384,2700007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2700416],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":30,"address":[2700441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2700496],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":36,"address":[2700513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2700546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[2700566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2700586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2700624],"length":1,"stats":{"Line":1},"fn_name":"as_raw_i64"},{"line":43,"address":[2700682,2700697,2700637],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[2700688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2700736],"length":1,"stats":{"Line":1},"fn_name":"to_naive_datetime"},{"line":50,"address":[2700760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[2700797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2700834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2700871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2700901,2700926],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[2700917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[2700976,2700981],"length":1,"stats":{"Line":0},"fn_name":"to_datetime_with_tz"},{"line":69,"address":[2458733,2458272],"length":1,"stats":{"Line":3},"fn_name":"ts_new"},{"line":71,"address":[2458279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2458506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2458610,2458557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2458654,2458603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2458768,2459170],"length":1,"stats":{"Line":3},"fn_name":"ts_debug"},{"line":80,"address":[2458775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[2458818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2459196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2459571],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":35},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","ty.rs"],"content":"use std::{\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nuse serde::de::Visitor;\n\n// todo: useful?\n// pub const TY_NULL: Ty = Ty::Null; // 1 bytes\n// pub const TY_BOOL: Ty = Ty::Bool; // 1 bytes\n// pub const TY_TINY_INT: Ty = Ty::TinyInt; // 1 byte\n// pub const TY_SMALL_INT: Ty = Ty::SmallInt; // 2 bytes\n// pub const TY_INT: Ty = Ty::Int; // 4 bytes\n// pub const TY_BIGINT: Ty = Ty::BigInt; // 8 bytes\n// pub const TY_FLOAT: Ty = Ty::Float; // 4 bytes\n// pub const TY_DOUBLE: Ty = Ty::Double; // 8 bytes\n// pub const TY_BINARY: Ty = Ty::VarChar; // string, alias for varchar\n// pub const TY_TIMESTAMP: Ty = Ty::Timestamp; // 8 bytes\n// pub const TY_NCHAR: Ty = Ty::NChar; // unicode string\n// pub const TY_U_TINY_INT: Ty = Ty::UTinyInt; // 1 byte\n// pub const TY_U_SMALL_INT: Ty = Ty::USmallInt; // 2 bytes\n// pub const TY_UINT: Ty = Ty::UInt; // 4 bytes\n// pub const TY_UBIGINT: Ty = Ty::UBigInt; // 8 bytes\n// pub const TY_JSON: Ty = Ty::Json; // json\n// pub const TY_VARCHAR: Ty = Ty::VarChar; // string\n// pub const TY_VAR_BINARY: Ty = Ty::VarBinary; // binary\n// pub const TY_DECIMAL: Ty = Ty::Decimal; // decimal\n// pub const TY_BLOB: Ty = Ty::Blob; // binary\n// pub const TY_MEDIUM_BLOB: Ty = Ty::MediumBlob; // binary\n\n/// TDengine data type enumeration.\n///\n/// | enum       | int | sql name         | rust type |\n/// | ----       |:---:| --------         |:---------:|\n/// | Null       | 0   | NULL             | None      |\n/// | Bool       | 1   | BOOL             | bool      |\n/// | TinyInt    | 2   | TINYINT          | i8        |\n/// | SmallInt   | 3   | SMALLINT         | i16       |\n/// | Int        | 4   | INT              | i32       |\n/// | BitInt     | 5   | BIGINT           | i64       |\n/// | Float      | 6   | FLOAT            | f32       |\n/// | Double     | 7   | DOUBLE           | f64       |\n/// | VarChar    | 8   | BINARY/VARCHAR   | str/String        |\n/// | Timestamp  | 9   | TIMESTAMP        | i64               |\n/// | NChar      | 10  | NCHAR            | str/String        |\n/// | UTinyInt   | 11  | TINYINT UNSIGNED | u8                |\n/// | USmallInt  | 12  | SMALLINT UNSIGNED| u16               |\n/// | UInt       | 13  | INT UNSIGNED     | u32               |\n/// | UBigInt    | 14  | BIGINT UNSIGNED  | u64               |\n/// | Json       | 15  | JSON             | serde_json::Value |\n/// | VarBinary  | 16  | VARBINARY        | Vec\u003cu8\u003e           |\n/// | Decimal    | 17  | DECIMAL          | ?                 |\n/// | Blob       | 18  | BLOB             | ?                 |\n/// | MediumBlob | 19  | MEDIUMBLOB       | ?                 |\n///\n/// Note:\n/// - VarChar sql name is BINARY in v2, and VARCHAR in v3.\n/// - Decimal/Blob/MediumBlob is not supported in 2.0/3.0 .\n#[derive(Debug, Clone, Copy, PartialEq, Eq, serde_repr::Serialize_repr)]\n#[repr(u8)]\n#[non_exhaustive]\npub enum Ty {\n    /// 0: Null is only a value, not a *real* type, a nullable data type could be represented as [Option\u003cT\u003e] in Rust.\n    Null = 0,\n    /// 1: Bool, `bool` type in sql, will be represented as [bool] in Rust.\n    Bool, // 1\n    /// 2: TinyInt, `tinyint` type in sql, will be represented in Rust as [i8].\n    TinyInt, // 2\n    /// 3: SmallInt, `smallint` type in sql, will be represented in Rust as [i16].\n    SmallInt, // 3\n    /// 4: Int, `int` type in sql, will be represented in Rust as [i32].\n    Int, // 4\n    /// 5: BigInt, `bigint` type in sql, will be represented in Rust as [i64].\n    BigInt, // 5\n    /// 6: Float, `float` type in sql, will be represented in Rust as [f32].\n    Float, // 6\n    /// 7: Double, `tinyint` type in sql, will be represented in Rust as [f64].\n    Double, // 7\n    /// 8: VarChar, `binary` type in sql for TDengine 2.x, `varchar` for TDengine 3.x,\n    ///  will be represented in Rust as [\u0026str] or [String]. This type of data be deserialized to [Vec\u003cu8\u003e].\n    VarChar,\n    /// 9: Timestamp, `timestamp` type in sql, will be represented as [i64] in Rust.\n    /// But can be deserialized to [chrono::naive::NaiveDateTime] or [String].\n    Timestamp, // 9\n    /// 10: NChar, `nchar` type in sql, the recommended way in TDengine to store utf-8 [String].\n    NChar, // 10\n    /// 11: UTinyInt, `tinyint unsigned` in sql, [u8] in Rust.\n    UTinyInt, // 11\n    /// 12: USmallInt, `smallint unsigned` in sql, [u16] in Rust.\n    USmallInt, // 12\n    /// 13: UInt, `int unsigned` in sql, [u32] in Rust.\n    UInt, // 13\n    /// 14: UBigInt, `bigint unsigned` in sql, [u64] in Rust.\n    UBigInt, // 14\n    /// 15: Json, `json` tag in sql, will be represented as [serde_json::value::Value] in Rust.\n    Json, // 15\n    /// 16, VarBinary, `varbinary` in sql, [Vec\u003cu8\u003e] in Rust, which is supported since TDengine 3.0.\n    VarBinary, // 16\n    /// 17, Not supported now.\n    Decimal, // 17\n    /// 18, Not supported now.\n    Blob, // 18\n    /// 19, Not supported now.\n    MediumBlob, // 19\n}\n\nimpl\u003c'de\u003e serde::Deserialize\u003c'de\u003e for Ty {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: serde::Deserializer\u003c'de\u003e,\n    {\n        struct TyVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for TyVisitor {\n            type Value = Ty;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"invalid TDengine type\")\n            }\n            fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v as u8))\n            }\n\n            fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v))\n            }\n\n            fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v as u8))\n            }\n\n            fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ty::from_str(v).map_err(\u003cE as serde::de::Error\u003e::custom)\n            }\n\n            fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::Null)\n            }\n\n            fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n            where\n                D: serde::Deserializer\u003c'de\u003e,\n            {\n                deserializer.deserialize_any(self)\n            }\n\n            fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::Null)\n            }\n        }\n\n        deserializer.deserialize_any(TyVisitor)\n    }\n}\n\n// todo: decimal/blob\nimpl FromStr for Ty {\n    type Err = \u0026'static str;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"timestamp\" =\u003e Ok(Ty::Timestamp),\n            \"bool\" =\u003e Ok(Ty::Bool),\n            \"tinyint\" =\u003e Ok(Ty::TinyInt),\n            \"smallint\" =\u003e Ok(Ty::SmallInt),\n            \"int\" =\u003e Ok(Ty::Int),\n            \"bigint\" =\u003e Ok(Ty::BigInt),\n            \"tinyint unsigned\" =\u003e Ok(Ty::UTinyInt),\n            \"smallint unsigned\" =\u003e Ok(Ty::USmallInt),\n            \"int unsigned\" =\u003e Ok(Ty::UInt),\n            \"bigint unsigned\" =\u003e Ok(Ty::UBigInt),\n            \"float\" =\u003e Ok(Ty::Float),\n            \"double\" =\u003e Ok(Ty::Double),\n            \"binary\" | \"varchar\" =\u003e Ok(Ty::VarChar),\n            \"nchar\" =\u003e Ok(Ty::NChar),\n            \"json\" =\u003e Ok(Ty::Json),\n            \"varbinary\" =\u003e Ok(Ty::VarBinary),\n            \"decimal\" =\u003e Ok(Ty::Decimal),\n            \"blob\" =\u003e Ok(Ty::Blob),\n            \"mediumblob\" =\u003e Ok(Ty::MediumBlob),\n            _ =\u003e Err(\"not a valid data type string\"),\n        }\n    }\n}\n\nimpl Ty {\n    /// Check if the data type is null or not.\n    pub const fn is_null(\u0026self) -\u003e bool {\n        matches!(self, Ty::Null)\n    }\n\n    /// Var type which is one of [Ty::VarChar], [Ty::VarBinary] or [Ty::NChar].\n    pub const fn is_var_type(\u0026self) -\u003e bool {\n        use Ty::*;\n        matches!(self, VarChar | VarBinary | NChar)\n    }\n\n    pub const fn is_primitive(\u0026self) -\u003e bool {\n        use Ty::*;\n        matches!(\n            self,\n            Bool | TinyInt\n                | SmallInt\n                | Int\n                | BigInt\n                | UTinyInt\n                | USmallInt\n                | UInt\n                | UBigInt\n                | Float\n                | Double\n                | Decimal\n        )\n    }\n\n    /// Fixed length if the type is primitive.\n    pub const fn fixed_length(\u0026self) -\u003e usize {\n        use Ty::*;\n        match self {\n            Bool =\u003e 1,\n            TinyInt =\u003e 1,\n            SmallInt =\u003e 2,\n            Int =\u003e 4,\n            BigInt =\u003e 8,\n            Float =\u003e 4,\n            Double =\u003e 8,\n            Timestamp =\u003e 8,\n            UTinyInt =\u003e 1,\n            USmallInt =\u003e 2,\n            UInt =\u003e 4,\n            UBigInt =\u003e 8,\n            Decimal =\u003e 16,\n            _ =\u003e panic!(\"not a fixed length type\"),\n        }\n    }\n\n    /// The sql name of type.\n    pub const fn name(\u0026self) -\u003e \u0026'static str {\n        use Ty::*;\n        match self {\n            Null =\u003e \"NULL\",\n            Bool =\u003e \"BOOL\",\n            TinyInt =\u003e \"TINYINT\",\n            SmallInt =\u003e \"SMALLINT\",\n            Int =\u003e \"INT\",\n            BigInt =\u003e \"BIGINT\",\n            Float =\u003e \"FLOAT\",\n            Double =\u003e \"DOUBLE\",\n            VarChar =\u003e \"BINARY\",\n            Timestamp =\u003e \"TIMESTAMP\",\n            NChar =\u003e \"NCHAR\",\n            UTinyInt =\u003e \"TINYINT UNSIGNED\",\n            USmallInt =\u003e \"SMALLINT UNSIGNED\",\n            UInt =\u003e \"INT UNSIGNED\",\n            UBigInt =\u003e \"BIGINT UNSIGNED\",\n            Json =\u003e \"JSON\",\n            VarBinary =\u003e \"VARBINARY\",\n            Decimal =\u003e \"DECIMAL\",\n            Blob =\u003e \"BLOB\",\n            MediumBlob =\u003e \"MEDIUMBLOB\",\n        }\n    }\n\n    /// The enum constants directly to str.\n    pub const fn as_variant_str(\u0026self) -\u003e \u0026'static str {\n        use Ty::*;\n        macro_rules! _var_str {\n          ($($v:ident) *) =\u003e {\n              match self {\n                $($v =\u003e stringify!($v),) *\n              }\n          }\n        }\n        return _var_str!(\n            Null Bool TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt\n            Float Double VarChar NChar Timestamp Json VarBinary Decimal Blob MediumBlob\n        );\n    }\n\n    pub fn from_u8(v: u8) -\u003e Self {\n        use Ty::*;\n        match v {\n            0 =\u003e Null,\n            1 =\u003e Bool,\n            2 =\u003e TinyInt,\n            3 =\u003e SmallInt,\n            4 =\u003e Int,\n            5 =\u003e BigInt,\n            6 =\u003e Float,\n            7 =\u003e Double,\n            8 =\u003e VarChar,\n            9 =\u003e Timestamp,\n            10 =\u003e NChar,\n            11 =\u003e UTinyInt,\n            12 =\u003e USmallInt,\n            13 =\u003e UInt,\n            14 =\u003e UBigInt,\n            15 =\u003e Json,\n            16 =\u003e VarBinary,\n            17 =\u003e Decimal,\n            18 =\u003e Blob,\n            19 =\u003e MediumBlob,\n            _ =\u003e unreachable!(\"unknown data type\"),\n        }\n    }\n}\nimpl From\u003cu8\u003e for Ty {\n    fn from(v: u8) -\u003e Self {\n        unsafe { std::mem::transmute(v) }\n    }\n}\n\nimpl Display for Ty {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.name())\n    }\n}\nmacro_rules! _impl_from_primitive {\n    ($($ty:ty) *) =\u003e {\n      $(\n         impl From\u003c$ty\u003e for Ty {\n           fn from(v: $ty) -\u003e Self {\n             Self::from_u8(v as _)\n           }\n         }\n      )*\n    }\n}\n\n_impl_from_primitive!(i8 i16 i32 i64 u16 u32 u64);\n","traces":[{"line":108,"address":[2638816,2638848],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003c\u0026mut serde_json::de::Deserializer\u003cserde_json::read::StrRead\u003e\u003e"},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2280560],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":118,"address":[2280587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2638912,2638976],"length":1,"stats":{"Line":0},"fn_name":"visit_i64\u003cserde::de::value::Error\u003e"},{"line":124,"address":[2638994,2638930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2639040],"length":1,"stats":{"Line":0},"fn_name":"visit_u8\u003cserde::de::value::Error\u003e"},{"line":131,"address":[2639061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2639168,2639104],"length":1,"stats":{"Line":1},"fn_name":"visit_u64\u003cserde_json::error::Error\u003e"},{"line":138,"address":[2639122,2639186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[2639232,2639296],"length":1,"stats":{"Line":0},"fn_name":"visit_str\u003cserde::de::value::Error\u003e"},{"line":145,"address":[2639256,2639320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2639360],"length":1,"stats":{"Line":0},"fn_name":"visit_none\u003cserde::de::value::Error\u003e"},{"line":152,"address":[2639367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2639392],"length":1,"stats":{"Line":0},"fn_name":"visit_unit\u003cserde_json::error::Error\u003e"},{"line":166,"address":[2639399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2638833,2638861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[2281912,2280624],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":178,"address":[2280651,2280732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2280748,2280819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[2280791,2280890,2280846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2280947,2280862,2280903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2280919,2280963,2281007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2280979,2281067,2281023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2281083,2281127,2281039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2281143,2281187,2281099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2281159,2281203,2281247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2281307,2281263,2281219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[2281279,2281323,2281367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2281383,2281339,2281427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[2281487,2281399,2281443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2281503,2281459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[2281579,2281650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2281666,2281710,2281622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2281770,2281682,2281726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2281830,2281742,2281786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2281890,2281846,2281802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2281906,2281862,2281972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[2281940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[2282000],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":206,"address":[2282009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2282048],"length":1,"stats":{"Line":1},"fn_name":"is_var_type"},{"line":212,"address":[2282057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[2282128],"length":1,"stats":{"Line":0},"fn_name":"is_primitive"},{"line":217,"address":[2282143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2282137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2282208],"length":1,"stats":{"Line":0},"fn_name":"fixed_length"},{"line":236,"address":[2282217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[2282291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2282305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2282319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[2282333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2282344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[2282355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2282366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2282377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[2282388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[2282399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2282410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[2282421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[2282432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[2282252,2282443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2282480],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":257,"address":[2282489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[2282518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[2282544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2282570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[2282596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2282622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2282648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[2282674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[2282700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2282726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[2282752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2282778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[2282804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[2282830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[2282856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2282882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2282905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2282928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2282951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2282974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[2282997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2283040],"length":1,"stats":{"Line":1},"fn_name":"as_variant_str"},{"line":291,"address":[2283049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[2283600],"length":1,"stats":{"Line":1},"fn_name":"from_u8"},{"line":299,"address":[2283617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[2283689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[2283699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[2283709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[2283719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[2283729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[2283739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[2283749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[2283759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[2283769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[2283779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2283789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[2283799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[2283809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2283819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[2283829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2283839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2283846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[2283853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2283860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[2283867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[2283984],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":326,"address":[2283995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[2284016],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":332,"address":[2284038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[2285056,2285120,2285024,2285168,2285200,2285232,2285088],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":340,"address":[2285177,2285065,2285129,2285205,2285093,2285032,2285241],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":117},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","borrowed.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl\u003c'b, 'de: 'b\u003e serde::de::EnumAccess\u003c'de\u003e for BorrowedValue\u003c'b\u003e {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let d = self.strict_as_str().into_deserializer();\n        seed.deserialize(d).map(|v| (v, UnitOnly))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer\u003c'b\u003e {\n    value: BorrowedValue\u003c'b\u003e,\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer\u003c'b\u003e {\n    value: BorrowedValue\u003c'b\u003e,\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumValueDeserializer\u003c'b\u003e {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        return seed\n            .deserialize(self.value.ty().as_variant_str().into_deserializer())\n            .map(|v| (v, self));\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e de::VariantAccess\u003c'de\u003e for EnumValueDeserializer\u003c'b\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nimpl\u003c'b, 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumTimestampDeserializer\u003c'b\u003e {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n\n        match \u0026self.value {\n            BorrowedValue::Timestamp(Timestamp::Microseconds(v)) =\u003e Ok((\n                seed.deserialize(\"Microseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            BorrowedValue::Timestamp(Timestamp::Milliseconds(v)) =\u003e Ok((\n                seed.deserialize(\"Milliseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            BorrowedValue::Timestamp(Timestamp::Nanoseconds(v)) =\u003e Ok((\n                seed.deserialize(\"Nanoseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::Deserializer\u003c'de\u003e for BorrowedValue\u003c'de\u003e {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use BorrowedValue::*;\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            VarChar(v) =\u003e visitor.visit_borrowed_str(v),\n            NChar(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e visitor.visit_borrowed_str(v),\n                Cow::Owned(v) =\u003e visitor.visit_string(v),\n            },\n            Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_any(visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_any(visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e visitor.visit_borrowed_bytes(v),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple identifier ignored_any\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str: {self:?}\");\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e visitor.visit_borrowed_str(\"\"), // todo: empty string or error?\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e std::str::from_utf8(v)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                    .and_then(|s| visitor.visit_borrowed_str(s)),\n                Cow::Owned(v) =\u003e String::from_utf8(v)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                    .and_then(|s| visitor.visit_string(s)),\n            },\n            VarChar(v) =\u003e visitor.visit_borrowed_str(v),\n            NChar(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e visitor.visit_borrowed_str(v),\n                Cow::Owned(v) =\u003e visitor.visit_str(\u0026v),\n            },\n            Timestamp(v) =\u003e visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"unsupported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use BorrowedValue::*;\n        macro_rules! _v_ {\n            ($v:expr) =\u003e {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e _v_!(v),\n            TinyInt(v) =\u003e _v_!(v),\n            SmallInt(v) =\u003e _v_!(v),\n            Int(v) =\u003e _v_!(v),\n            BigInt(v) =\u003e _v_!(v),\n            UTinyInt(v) =\u003e _v_!(v),\n            USmallInt(v) =\u003e _v_!(v),\n            UInt(v) =\u003e _v_!(v),\n            UBigInt(v) =\u003e _v_!(v),\n            Float(v) =\u003e _v_!(v),\n            Double(v) =\u003e _v_!(v),\n            VarChar(v) =\u003e _v_!(v),\n            NChar(v) =\u003e _v_!(v),\n            Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_newtype_struct(_name, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_newtype_struct(_name, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e visitor.visit_borrowed_bytes(v),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Vec::\u003cu8\u003e::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) =\u003e v.to_vec().into_deserializer().deserialize_seq(visitor),\n            Timestamp(_) =\u003e todo!(),\n            VarChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            NChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.to_vec().into_deserializer().deserialize_seq(visitor)\n            }\n            _ =\u003e todo!(),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize enum with name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" \u0026\u0026 variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" \u0026\u0026 variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            BorrowedValue::Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_struct(name, fields, visitor)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_struct(name, fields, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            BorrowedValue::Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_tuple_struct(name, len, visitor)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_tuple_struct(name, len, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl\u003c'de\u003e serde::de::IntoDeserializer\u003c'de, Error\u003e for BorrowedValue\u003c'de\u003e {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn de_value_as_inner() {\n        use BorrowedValue::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) =\u003e {\n                $(\n                    {\n                        let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option\u003cu8\u003e, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\"), String, \"\".to_string()\n            NChar(\"\".into()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(\u0026[0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            Blob(\u0026[0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            MediumBlob(\u0026[0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_borrowed_str() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            Json(json!({ \"name\": \"abc\"}).to_string().into_bytes().into()), is_err\n            Json(json!(1).to_string().into_bytes().into()), is_err\n            Json(json!(null).to_string().into_bytes().into()), is_err\n            Json(json!(\"abc\").to_string().into_bytes().into()), is_err\n            Timestamp(crate::Timestamp::Milliseconds(0)), is_err\n            ;\n            Null, \"\"\n            VarChar(\"String\"), \"String\"\n            VarChar(\"\"), \"\"\n        };\n    }\n    #[test]\n    fn de_string() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(String::deserialize(($v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(String::deserialize(($v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $tv:expr) *) =\u003e {\n                $(_de_str!($v, $tv);)*\n            };\n            ($($v2:expr, is_err) *; $($v:expr, $tv:expr) * ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\"), \"String\"\n            VarChar(\"\"), \"\"\n            Json(json!(\"abc\").to_string().into_bytes().into()), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"}).to_string().into_bytes().into()), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1).to_string().into_bytes().into()), json!(1).to_string()\n            Json(json!(null).to_string().into_bytes().into()), json!(null).to_string()\n        };\n    }\n\n    #[test]\n    fn de_json() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize(\n                    Json($v.to_string().into_bytes().into()).into_deserializer(),\n                )\n                .expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(json!(\"string\"), String, json!(\"string\").to_string());\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_json!(json!(\"string\"), JsonStr, JsonStr(\"string\".to_string()));\n    }\n\n    #[test]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use BorrowedValue::*;\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\").to_string().into_bytes().into()),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi\u003cT\u003e(T);\n        _de_ty!(\n            Json(json!(1).to_string().into_bytes().into()),\n            Primi\u003ci32\u003e,\n            Primi(1)\n        );\n        _de_ty!(TinyInt(1), Primi\u003ci8\u003e, Primi(1));\n        _de_ty!(SmallInt(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(Int(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(BigInt(1), Primi\u003ci64\u003e, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) =\u003e {\n                println!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::\u003c$ty\u003e()\n                );\n                _de_ty!($v($inner), Primi\u003c$ty\u003e, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) =\u003e {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) =\u003e {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () =\u003e {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[2952792,2952592],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":17,"address":[2952688,2952622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[2641200,2641211],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":37,"address":[2641556,2641232,2641583],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":41,"address":[2641500,2641262,2641415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2641445,2641519,2641294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2641600,2641624,2641453],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":50,"address":[2074704],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":51,"address":[2074708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[2641680],"length":1,"stats":{"Line":0},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003ci64\u003e\u003e"},{"line":58,"address":[2641694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2641744,2643081],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":92,"address":[2641766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2642640,2642020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2642481,2642690,2642037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[2642629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2641946,2642927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2641963,2642768,2642989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2642916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2642094,2642317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2642110,2642376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2642306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2958272,2955402,2972084,2952832,2978240,2989034,2972768,2983100,2975397,2985815,2970080,2986345,2986496,2991904,2960992,2969928,2980316,2966124,2991757,2983808,2957592,2975552,2963680,2958126,2969398,2972614,2974844,2977560,2963526,2955552,2980869,2967392,2978090,2981024,2962996,2960844,2960310,2988504,2989184,2991223,2993911,2994441,2967221,2983653,2954868],"length":1,"stats":{"Line":10},"fn_name":"deserialize_any\u003cserde::de::impls::{impl#53}::deserialize::PrimitiveVisitor\u003e"},{"line":117,"address":[2970436,2973124,2961159,2978489,2986745,2967559,2986852,2992260,2955801,2955908,2963937,2958521,2975574,2970102,2958294,2992153,2978262,2981191,2981380,2989540,2955574,2961014,2963840,2981046,2975719,2986663,2967641,2978407,2972790,2952999,2964062,2958628,2975908,2967748,2984057,2963695,2978596,2972935,2958439,2967414,2973017,2953188,2983830,2989433,2991926,2970329,2983975,2989206,2992071,2986518,2975801,2970247,2961348,2989351,2955719,2953081,2984164,2981273,2961241,2952854],"length":1,"stats":{"Line":30},"fn_name":null},{"line":120,"address":[2985097,2975864,2974109,2956904,2982427,2993224,2965327,2955864,2979581,2971431,2959593,2958584,2993193,2986808,2987847,2965293,2982365,2982396,2989496,2990567,2965259,2985128,2954184,2959624,2962312,2976872,2968712,2971400,2974171,2961304,2953144,2978552,2976903,2979612,2956873,2959655,2967704,2971369,2992216,2968743,2962343,2990536,2973080,2976841,2954153,2981336,2993255,2962281,2979643,2984120,2964009,2987816,2968681,2974140,2987785,2954215,2956935,2970392,2990505,2985159],"length":1,"stats":{"Line":10},"fn_name":null},{"line":121,"address":[2991679,2958048,2955324,2975319,2981570,2953378,2989730,2964265,2980791,2987042,2992450,2984354,2972536,2970626,2978786,2956098,2958818,2983575,2986267,2973314,2994363,2976098,2967121,2963448,2978012,2967938,2969850,2960766,2988956,2961538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2989758,2967966,2975314,2956126,2988951,2967084,2973346,2964311,2981602,2980786,2978818,2976126,2991674,2960761,2963443,2961566,2970654,2983570,2986262,2958043,2994358,2953406,2978007,2972531,2955319,2969845,2984382,2958846,2992478,2987070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2969840,2988946,2956170,2964373,2989802,2967047,2978002,2981650,2963438,2986257,2972526,2994353,2973394,2978866,2960756,2953450,2980781,2987114,2968010,2984426,2991669,2961610,2976170,2970698,2975309,2958038,2958890,2955314,2983565,2992522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2977997,2972521,2956216,2963433,2978912,2991664,2961652,2984468,2986252,2975304,2981696,2953496,2989848,2988941,2955309,2994348,2992564,2976212,2970740,2973440,2968052,2980776,2958033,2969835,2964433,2960751,2958936,2967010,2987156,2983560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[2964494,2968095,2984511,2956263,2958028,2969830,2994343,2960746,2976255,2966973,2963428,2973487,2992607,2981743,2975299,2953543,2958983,2988936,2989895,2980771,2978959,2970783,2977992,2986247,2991659,2983555,2987199,2972516,2961695,2955304],"length":1,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[2960741,2969825,2968133,2976293,2992645,2977987,2953585,2956305,2984549,2959025,2989937,2973529,2966936,2975294,2991654,2981785,2983550,2979001,2958023,2987237,2961733,2970821,2964550,2972511,2994338,2988931,2955299,2980766,2963423,2986242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2964936,2969543,2982106,2988649,2980469,2991368,2992950,2956614,2976598,2984854,2959334,2971126,2960455,2968438,2983253,2994056,2957737,2977705,2985960,2979322,2973850,2963141,2955013,2990246,2966417,2974997,2953894,2987542,2962038,2972229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2977700,2992992,2962080,2959380,2994051,2953940,2960450,2973896,2963136,2964996,2979368,2971168,2974992,2957732,2956660,2982152,2983248,2972224,2955008,2990292,2968480,2969538,2984896,2987584,2991363,2976640,2980464,2985955,2966380,2988644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[2968523,2965057,2979415,2960445,2959427,2988639,2953987,2982199,2973943,2987627,2957727,2980459,2974987,2983243,2976683,2985950,2962123,2990339,2955003,2969533,2971211,2966343,2977695,2963131,2956707,2984939,2993035,2994046,2972219,2991358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[2979457,2965113,2985945,2982241,2954998,2987665,2991353,2974982,2959469,2960440,2988634,2956749,2983238,2971249,2973985,2954029,2969528,2968561,2976721,2980454,2994041,2962161,2984977,2993073,2977690,2957722,2966306,2963126,2972214,2990381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[2953629,2992685,2970861,2959069,2963418,2983545,2979045,2988926,2991649,2966899,2989981,2960736,2980761,2987277,2956349,2973573,2984589,2981829,2986237,2976333,2994333,2964608,2968173,2975289,2969820,2958018,2955294,2972506,2977982,2961773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[2966862,2969815,2973619,2975284,2959111,2992727,2961815,2955289,2964668,2994328,2972501,2980756,2984631,2988921,2991644,2976375,2958013,2981875,2979091,2977977,2968215,2990023,2956391,2953671,2987319,2960731,2963413,2983540,2986232,2970903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[2956433,2990065,2977972,2973665,2986227,2966825,2969810,2972496,2992769,2955284,2960726,2968257,2964728,2988916,2979137,2980751,2984673,2976417,2991639,2983535,2981921,2963408,2994323,2959153,2953713,2961857,2970945,2987361,2958008,2975279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2972234,2982040,2991373,2984788,2994061,2985965,2973784,2983258,2992884,2961972,2963146,2964872,2956548,2957742,2979256,2990180,2969548,2959268,2953828,2966438,2977710,2987476,2975002,2968372,2976532,2980474,2988654,2971060,2960460,2955018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[2988661,2957922,2986145,2991553,2994241,2980665,2966440,2994068,2966673,2985972,2983449,2972414,2988834,2960467,2957749,2975009,2980481,2983265,2991380,2963153,2963326,2960640,2969728,2975193,2977717,2977890,2955198,2955025,2972241,2969555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2983324,2957915,2980540,2963205,2969721,2972293,2975186,2977883,2986024,2988827,2991546,2983442,2994234,2955077,2988713,2986138,2969607,2975068,2994120,2966504,2963319,2966642,2991432,2972407,2977769,2980658,2960519,2957801,2955191,2960633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2965171,2968596,2976756,2954068,2957024,2962196,2987700,2959508,2987936,2959742,2974024,2974264,2971516,2968830,2985247,2985012,2979496,2956788,2954300,2979736,2993108,2965465,2962428,2993343,2976992,2990420,2990655,2982520,2971284,2982280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2954972,2960414,2962430,2991263,2993345,2957696,2985919,2974944,2954302,2976994,2980340,2954908,2966221,2980416,2965467,2968832,2957632,2990657,2974868,2983200,2982522,2971518,2988544,2966148,2959744,2963100,2977600,2983124,2988608,2991327,2985249,2969502,2993951,2994015,2979738,2957026,2972188,2963036,2985855,2960350,2987938,2974266,2969438,2972124,2977664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2980332,2983116,2993927,2977576,2972100,2988520,2974860,2969414,2963012,2957608,2991239,2985831,2966140,2954884,2960326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2980367,2974963,2960357,2969509,2969445,2966268,2960421,2966172,2983151,2985862,2994022,2957703,2983219,2993958,2972131,2972195,2988551,2991334,2954915,2954979,2991270,2985926,2957639,2977671,2963043,2977607,2963107,2980435,2988615,2974895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2980130,2974435,2954356,2957418,2965866,2969352,2977386,2965931,2980246,2985769,2985418,2971687,2993737,2974320,2988330,2962484,2957195,2960136,2965648,2985303,2969224,2959798,2985641,2971910,2962822,2979792,2974774,2974658,2987992,2983030,2991177,2965521,2977048,2979907,2959913,2968886,2990826,2991049,2990711,2988107,2954822,2993399,2957546,2977163,2977514,2971572,2982691,2982914,2966029,2960264,2969001,2982576,2962950,2993865,2972038,2988458,2954471,2954694,2962599,2957080,2993514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[2954662,2993705,2971878,2965834,2982882,2960104,2991017,2977354,2985609,2957386,2974626,2969192,2988298,2980098,2962790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2969328,2972014,2957522,2954798,2980238,2966021,2983022,2993841,2962926,2991153,2977490,2960240,2985745,2974766,2988434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[2974825,2960150,2969238,2974381,2957432,2985364,2983081,2988485,2962836,2966105,2965588,2977109,2985655,2991063,2993892,2962545,2954417,2962977,2959859,2968947,2972065,2977541,2980148,2990772,2993751,2985796,2977400,2991204,2971633,2980297,2982932,2988344,2957141,2957573,2960291,2969379,2982637,2954849,2974676,2988053,2965947,2954708,2965894,2971924,2979853,2993460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2973716,2992816,2955200,2970992,2977892,2979188,2961904,2983451,2994243,2968304,2986147,2972416,2956480,2959200,2987408,2988836,2960642,2963328,2976464,2980667,2953760,2957924,2964798,2966691,2990112,2981972,2991555,2975195,2984720,2969730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[2990543,2985214,2990622,2979588,2979557,2982372,2962395,2993231,2956880,2965235,2956849,2954160,2956911,2971345,2982403,2959600,2976959,2993169,2990512,2974227,2990481,2982341,2971376,2974085,2976817,2979699,2959569,2968719,2956991,2976848,2962288,2968657,2976879,2954129,2965380,2974147,2985104,2954191,2982483,2962257,2993310,2954267,2968688,2979619,2985135,2987823,2959631,2987903,2971407,2965303,2987761,2985073,2993200,2968797,2959709,2987792,2965269,2971483,2974116,2962319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[2968760,2964223,2990584,2976920,2985176,2961497,2958777,2956952,2981529,2956057,2974188,2984313,2987001,2962360,2978745,2979660,2953337,2971448,2976057,2982444,2992409,2989689,2965345,2987864,2959672,2967897,2954232,2993272,2970585,2973273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[3001395,2999520,2998991,2994592,2996901,3001766,2997056,2999366,2996526],"length":1,"stats":{"Line":3},"fn_name":"deserialize_str\u003cchrono::naive::datetime::serde::NaiveDateTimeVisitor\u003e"},{"line":168,"address":[2999777,2994956,2997313,2999542,2999695,2994849,2994614,2997078,2997231,2997420,2994767,2999884],"length":1,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[2997376,2994912,2999840],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[3001689,3000074,2997610,2995146,2996824,2999289],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[2997653,3000113,2995189,2999284,2996819,3001684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3001679,2997701,2995237,3000157,2999279,2996814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[3000199,2997747,3001674,2995283,2996809,2999274],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[3000242,3001669,2997794,2996804,2995330,2999269],"length":1,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[2999264,2997836,3000280,3001664,2996799,2995372],"length":1,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[3000588,2998736,3001148,2995696,2996271,2998160],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[2996266,3000630,2998206,2995742,3001143,2998731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[2996261,3000673,2995789,2998726,3001138,2998253],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[2996256,3001133,3000711,2998721,2995831,2998295],"length":1,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[2999259,3000320,2996794,2997880,2995416,3001659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3000362,3001654,2997926,2996789,2999254,2995462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2998432,3000746,2995967,2995870,2998334,3000844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[2995969,2998712,2996199,2996247,2998434,2998664,3000846,3001076,3001124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2643168,2643120,2643142,2643190,2643238,2643216],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cchrono::naive::datetime::serde::NaiveDateTimeVisitor\u003e"},{"line":187,"address":[2996137,3001062,2996023,3001014,3000900,2998602,2998488,2998650,2996185],"length":1,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2643264,2643328,2643275,2643339,2643392,2643403],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}\u003cserde::de::impls::StringVisitor\u003e"},{"line":191,"address":[2999249,2997972,3000404,2996784,3001649,2995508],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[2998094,3001153,3000522,2998741,2996276,2995630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[2998748,3001160,2999034,2996569,2996283,3001438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[3001210,2996337,2998802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3001589,2996720,2995559,2998023,2999185,3000451],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[2995615,2999077,3000507,3001481,2998079,2996612],"length":1,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2995934,2995105,2997569,3000033,3000810,2998398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[3002373,3001920,3002400],"length":1,"stats":{"Line":2},"fn_name":"deserialize_string\u003cserde::de::impls::StringVisitor\u003e"},{"line":211,"address":[3002051,3001942,3002249,3002130],"length":1,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[3002183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[3004071,3003568,3004098,3004144,3002919,3002416,3002992,3003522,3004647,3002946,3004674,3003495],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option\u003cserde::de::impls::OptionVisitor\u003cchrono::naive::datetime::NaiveDateTime\u003e\u003e"},{"line":219,"address":[3004166,3002626,3004354,3003014,3002438,3004275,3003202,3003590,3003123,3004413,3002547,3003699,3003837,3003778,3002685,3003261],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[3003826,3002783,3003935,3004511,3003359,3004402,3002674,3003250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[3004022,3002870,3003446,3004598],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[3002799,3003375,3003951,3004055,3004527,3003479,3002903,3004631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[3039139,3040560,3043140,3016720,3011136,3008559,3019140,3031140,3012557,3024720,3007138,3028557,3008720,3028720,3040720,3024560,3036720,3023139,3012720,3044561,3004720,3016559,3027136,3020720,3032561,3015138,3020561,3036561,3032720,3035140],"length":1,"stats":{"Line":10},"fn_name":"deserialize_newtype_struct\u003ctaos_query::common::value::de::borrowed::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor\u003cu16\u003e\u003e"},{"line":235,"address":[3005230,3016767,3008767,3025016,3029016,3013113,3012767,3004767,3021230,3032767,3033113,3037113,3024767,3020767,3029113,3033016,3037016,3041016,3041230,3009016,3013016,3009113,3037230,3009230,3029230,3033230,3005113,3036767,3025230,3017113,3021113,3041113,3005016,3025113,3040767,3021016,3013230,3017016,3017230,3028767],"length":1,"stats":{"Line":30},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[3022418,3026418,3026384,3022384,3026452,3010384,3030452,3034418,3006452,3018418,3038418,3042418,3042384,3009185,3006418,3037185,3030418,3021185,3033185,3010418,3010452,3018384,3025185,3014418,3029185,3034384,3034452,3038452,3042452,3030384,3041185,3005185,3014452,3014384,3038384,3013185,3018452,3006384,3022452,3017185],"length":1,"stats":{"Line":10},"fn_name":null},{"line":244,"address":[3040476,3036477,3037441,3029441,3012473,3028473,3033441,3025441,3013441,3044477,3008475,3032477,3021441,3020477,3017441,3024476,3016475,3009441,3005441,3041441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[3008387,3044389,3040388,3032389,3028385,3021467,3024388,3037467,3005467,3033467,3012385,3029467,3013467,3017467,3016387,3009467,3020389,3025467,3036389,3041467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[3017521,3036304,3033521,3041521,3029521,3025521,3009521,3008302,3024303,3037521,3013521,3040303,3028300,3005521,3016302,3021521,3032304,3012300,3044304,3020304],"length":1,"stats":{"Line":8},"fn_name":null},{"line":247,"address":[3005573,3021573,3009573,3032218,3044218,3037573,3024217,3016216,3017573,3025573,3013573,3008216,3041573,3012214,3040217,3033573,3028214,3029573,3020218,3036218],"length":1,"stats":{"Line":8},"fn_name":null},{"line":248,"address":[3032136,3025627,3033627,3024135,3041627,3040135,3009627,3029627,3005627,3021627,3012132,3017627,3013627,3016134,3036136,3037627,3008134,3020136,3028132,3044136],"length":1,"stats":{"Line":8},"fn_name":null},{"line":249,"address":[3036053,3008051,3009675,3016051,3017675,3005675,3013675,3028049,3020053,3033675,3037675,3044053,3029675,3025675,3012049,3024052,3040052,3021675,3041675,3032053],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[3042091,3014091,3015541,3031543,3011539,3006091,3026091,3027539,3038091,3039542,3035543,3034091,3010091,3018091,3007541,3019543,3023542,3030091,3022091,3043543],"length":1,"stats":{"Line":8},"fn_name":null},{"line":251,"address":[3039456,3027453,3043457,3019457,3042143,3011453,3034143,3035457,3022143,3023456,3018143,3010143,3014143,3030143,3031457,3007455,3006143,3026143,3015455,3038143],"length":1,"stats":{"Line":8},"fn_name":null},{"line":252,"address":[3007373,3011371,3014197,3030197,3010197,3031375,3022197,3038197,3019375,3018197,3027371,3034197,3023374,3006197,3035375,3039374,3042197,3026197,3015373,3043375],"length":1,"stats":{"Line":8},"fn_name":null},{"line":253,"address":[3023291,3019292,3030245,3026245,3027288,3031292,3015290,3006245,3010245,3007290,3034245,3039291,3038245,3011288,3014245,3042245,3018245,3035292,3043292,3022245],"length":1,"stats":{"Line":8},"fn_name":null},{"line":254,"address":[3025726,3019969,3031969,3033726,3021726,3023968,3009726,3007967,3013726,3017726,3015967,3035969,3039968,3037726,3043969,3029726,3027965,3005726,3041726,3011965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3029780,3027881,3023884,3039884,3025780,3043885,3033780,3041780,3007883,3005780,3019885,3017780,3011881,3031885,3037780,3021780,3013780,3035885,3009780,3015883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[3037834,3027793,3029834,3043797,3007795,3013834,3005834,3019797,3039796,3015795,3009834,3017834,3041834,3035797,3021834,3025834,3011793,3023796,3033834,3031797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[3039627,3041977,3009977,3033977,3037977,3007626,3017977,3043628,3023627,3029977,3021977,3011624,3025977,3031628,3015626,3035628,3019628,3013977,3005977,3027624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[3042547,3010296,3034296,3030547,3038296,3026296,3006545,3034547,3026543,3022546,3010543,3042296,3018547,3006296,3022296,3030296,3014296,3014545,3018296,3038546],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[3019263,3026545,3011259,3007261,3007194,3014547,3023195,3031196,3039262,3018549,3042549,3027259,3022548,3023262,3011192,3027192,3034549,3006547,3010545,3031263,3015261,3035196,3035263,3043196,3015194,3019196,3043263,3039195,3030549,3038548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[3023155,3007154,3027152,3035156,3019156,3039155,3043156,3015154,3011152,3031156],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[3007268,3027199,3023202,3031203,3031270,3035203,3015201,3011266,3019203,3019270,3023269,3007201,3035270,3027266,3039269,3039202,3011199,3015268,3043203,3043270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[3006601,3039090,3010714,3038602,3034718,3018603,3011087,3038717,3042603,3018944,3018718,3014601,3015089,3006716,3038943,3010599,3027087,3007089,3023090,3022717,3026714,3022602,3026599,3006942,3042718,3014716,3034944,3043091,3014942,3031091,3030718,3019091,3030944,3034603,3035091,3042944,3022943,3030603,3010940,3026940],"length":1,"stats":{"Line":9},"fn_name":null},{"line":263,"address":[3018912,3010908,3030912,3026908,3022911,3006910,3042912,3034912,3038911,3014910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3015049,3035051,3007049,3031051,3039050,3011047,3027047,3043051,3023050,3019051],"length":1,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[3015119,3014956,3022663,3027117,3034664,3023120,3035121,3031121,3019121,3010954,3043121,3039120,3018664,3030958,3042958,3006956,3038957,3018958,3006662,3026954,3042664,3011117,3010660,3030664,3007119,3022957,3038663,3034958,3014662,3026660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[3019714,3029906,3027710,3005906,3007712,3021906,3033906,3023713,3025906,3041906,3011710,3015712,3031714,3017906,3037906,3013906,3043714,3035714,3039713,3009906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3006394,3014512,3006512,3038428,3010360,3010510,3014360,3042394,3022513,3034514,3026510,3038513,3006428,3010428,3022394,3018428,3034360,3014394,3026394,3026428,3038360,3022360,3042360,3034428,3006360,3042428,3030394,3026360,3018394,3018360,3038394,3042514,3022428,3010394,3014428,3030360,3030428,3034394,3030514,3018514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3038472,3037397,3009397,3017397,3030472,3025397,3033397,3042472,3041397,3013397,3021397,3005397,3026472,3010472,3022472,3029397,3018472,3014472,3034472,3006472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3044720,3045825,3046225],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq\u003cserde::de::impls::{impl#19}::deserialize::VecVisitor\u003cu8\u003e\u003e"},{"line":288,"address":[3044879,3044961,3044742,3045059],"length":1,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[3045543,3045024,3045574,3045512],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[3045198,3046179,3046151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[3046163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3045679,3045419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3046060,3046123,3045225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[3046107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[3045350,3046021,3045958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[3046028,3046005,3045836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[3045488,3045519,3045550],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[3045578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[3047412,3047439,3046304],"length":1,"stats":{"Line":1},"fn_name":"deserialize_enum\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":322,"address":[3046467,3046549,3046352,3046637],"length":1,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[3046607,3046874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[3046983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[3046943,3047116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[3047274,3047325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[3047282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[3047195,3047393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[3048363,3048524,3047456],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct\u003ctaos_query::common::value::de::borrowed::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":346,"address":[3047530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[3047753,3047576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[3048481,3047755,3048420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3048399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[3048488,3048427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[3047912,3047803,3048135,3048317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[3048103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3048293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[3048344,3047858,3048149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[3047625,3047732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[1945264],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":390,"address":[1945272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[2411801,2411792],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":402,"address":[2896060,2892768,2896087],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":415,"address":[2897843,2893242,2892783,2894012,2895046,2895615,2896306,2896661,2897036,2895784,2897388,2896877,2895327,2897946,2892991,2894782,2896071,2897128,2893753,2893496,2894525,2897491,2897583,2898038,2894267,2896199],"length":1,"stats":{"Line":21},"fn_name":null},{"line":416,"address":[2892775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[2892975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[2893224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[2893477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[2893732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[2893996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[2894249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[2894506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[2894762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[2895021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[2895302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2895580,2895758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[2896102,2896280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[2896597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2897085,2896842,2897024],"length":1,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[2897540,2897479,2897353],"length":1,"stats":{"Line":3},"fn_name":null},{"line":432,"address":[2897808,2897934,2897995],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[2411840,2411849],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":437,"address":[2898416,2898558],"length":1,"stats":{"Line":1},"fn_name":"de_borrowed_str"},{"line":464,"address":[2898588,2899349,2900844,2898447,2898612,2899720,2899901,2900449,2900609,2901391,2901917,2898797,2898983,2899534,2901150,2902167,2901005,2901306,2902698,2901541,2901743,2900694,2899165,2898423,2902441,2900299],"length":1,"stats":{"Line":18},"fn_name":null},{"line":465,"address":[2898431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[2898594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[2898778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[2898963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[2899149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[2899331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[2899515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[2899700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[2900359,2899931,2899886],"length":1,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[2900639,2900754,2900587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[2901035,2900982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[2901336,2901451,2901284],"length":1,"stats":{"Line":3},"fn_name":null},{"line":477,"address":[2901679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[2901909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2902132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[2902406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[2411897,2411888],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":485,"address":[2902896,2903067],"length":1,"stats":{"Line":1},"fn_name":"de_string"},{"line":508,"address":[2904896,2907134,2903124,2904106,2908016,2903713,2906194,2903321,2908166,2903519,2908260,2905582,2907221,2907630,2905950,2903100,2902903,2908805,2908361,2906295,2906100,2904304,2908913,2902935,2905242,2904490,2906984,2903909],"length":1,"stats":{"Line":18},"fn_name":null},{"line":510,"address":[2902919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[2903106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[2903302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[2903499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[2903697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[2903891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[2904087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[2904284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2904482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2904832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[2905207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[2905547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[2905875,2906010,2906172,2906238],"length":1,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[2907214,2906603,2907044,2907265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[2908076,2908238,2907941,2908304],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[2908887,2908669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[2411945,2411936],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":532,"address":[2909666,2909344],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":546,"address":[2909351,2909692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[2910448,2910823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[2910094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[2910783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[2910756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[2911035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[2420752,2420761],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":566,"address":[2912512,2912841],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":577,"address":[2912750,2912971,2912600,2912875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[2912525,2912660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[2912904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[2913425,2913683,2913275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[2913200,2913335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[2913948,2913628,2913727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[2914215,2913891,2913992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[2914259,2914157,2914483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[2914739,2914527,2914424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[2914783,2914692,2944490],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":156,"coverable":248},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","mod.rs"],"content":"//! Value de-serialization.\n//!\n//! All values queried from TDengine sql could be deserialized to a Rust type.\n//! Commonly, you can deserialize a value directly into a [crate::common::Value].\n//!\nuse serde::de::value::Error;\nuse serde::{de, forward_to_deserialize_any};\n\nconst TIMESTAMP_VARIANTS: [\u0026str; 3] = [\"Milliseconds\", \"Microseconds\", \"Nanoseconds\"];\nconst VALUE_VARIANTS: [\u0026str; 20] = [\n    \"Null\",\n    \"Bool\",\n    \"TinyInt\",\n    \"SmallInt\",\n    \"Int\",\n    \"BigInt\",\n    \"Float\",\n    \"Double\",\n    \"VarChar\",\n    \"Timestamp\",\n    \"NChar\",\n    \"UTinyInt\",\n    \"USmallInt\",\n    \"UInt\",\n    \"UBigInt\",\n    \"Json\",\n    \"VarBinary\",\n    \"Decimal\",\n    \"Blob\",\n    \"MediumBlob\",\n];\n\npub struct UnitOnly;\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for UnitOnly {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            \u0026\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            \u0026\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            \u0026\"struct variant\",\n        ))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct VariantTimestampDeserializer {\n    value: i64,\n}\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for VariantTimestampDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_i64(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for VariantTimestampDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nmod borrowed;\nmod ref_value;\n\nmod value;\n","traces":[{"line":38,"address":[2770144],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":39,"address":[2770148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2396667,2395723,2395360,2396304,2396410,2395867,2396267,2396976,2395591,2395904,2396811,2396704,2396848,2396432,2397120,2397225,2395232,2395338,2396135,2396954,2396560,2397355,2397248,2395488,2395616,2396010,2397083,2396160,2396032,2396535,2395465,2395760],"length":1,"stats":{"Line":0},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003cu32\u003e\u003e"},{"line":46,"address":[2396122,2396522,2396322,2395506,2396650,2395250,2396994,2395578,2395994,2395322,2396450,2395450,2396938,2396050,2395706,2395378,2396578,2395634,2395922,2396178,2397066,2397338,2395778,2397210,2396794,2395850,2396866,2397266,2396722,2396250,2396394,2397138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2397133,2396861,2395773,2396045,2396717,2396173,2395373,2396573,2397261,2396317,2395629,2396989,2396445,2395245,2395501,2395917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2397424,2397648,2397520,2397552,2397456,2397680,2397872,2397840,2397392,2397744,2397712,2397616,2397776,2397808,2397584,2397488],"length":1,"stats":{"Line":1},"fn_name":"deserialize_any\u003cserde::de::impls::BoolVisitor\u003e"},{"line":88,"address":[2397728,2397824,2397568,2397472,2397664,2397696,2397440,2397792,2397856,2397888,2397536,2397600,2397632,2397504,2397408,2397760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2770176],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":102,"address":[2770185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2398384,2398064,2397968,2398160,2398352,2397936,2398224,2398256,2398000,2398032,2398128,2398192,2398096,2397904,2398288,2398320],"length":1,"stats":{"Line":1},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003cu64\u003e\u003e"},{"line":109,"address":[2397920,2398400,2398304,2398176,2397952,2397984,2398368,2398048,2398144,2398112,2398336,2398272,2398208,2398016,2398240,2398080],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":18},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","ref_value.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl\u003c'de, 'v\u003e serde::de::EnumAccess\u003c'de\u003e for \u0026'v Value {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let s = self.strict_as_str();\n        return Ok((\n            seed.deserialize(StringDeserializer {\n                input: s.to_string(),\n            })?,\n            UnitOnly,\n        ));\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer\u003c'v\u003e {\n    value: \u0026'v Value,\n}\n\nimpl\u003c'v, 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumTimestampDeserializer\u003c'v\u003e {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n        match self.value {\n            Value::Timestamp(Timestamp::Microseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Microseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            Value::Timestamp(Timestamp::Milliseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Milliseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            Value::Timestamp(Timestamp::Nanoseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Nanoseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer\u003c'v\u003e {\n    value: \u0026'v Value,\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\nimpl\u003c'de, 'v: 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumValueDeserializer\u003c'v\u003e {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let variant = self.value.ty().as_variant_str();\n\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: variant.to_string(),\n            })\n            .expect(\"\"),\n            self,\n        ))\n    }\n}\n\nimpl\u003c'de, 'v: 'de\u003e de::VariantAccess\u003c'de\u003e for EnumValueDeserializer\u003c'v\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nimpl\u003c'de, 'v: 'de\u003e serde::de::Deserializer\u003c'de\u003e for \u0026'v Value {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use Value::*;\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e visitor.visit_bool(*v),\n            TinyInt(v) =\u003e visitor.visit_i8(*v),\n            SmallInt(v) =\u003e visitor.visit_i16(*v),\n            Int(v) =\u003e visitor.visit_i32(*v),\n            BigInt(v) =\u003e visitor.visit_i64(*v),\n            UTinyInt(v) =\u003e visitor.visit_u8(*v),\n            USmallInt(v) =\u003e visitor.visit_u16(*v),\n            UInt(v) =\u003e visitor.visit_u32(*v),\n            UBigInt(v) =\u003e visitor.visit_u64(*v),\n            Float(v) =\u003e visitor.visit_f32(*v),\n            Double(v) =\u003e visitor.visit_f64(*v),\n            VarChar(v) =\u003e visitor.visit_borrowed_str(v),\n            NChar(v) =\u003e visitor.visit_borrowed_str(v),\n            Json(v) =\u003e v\n                .clone()\n                .into_deserializer()\n                .deserialize_any(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e visitor.visit_borrowed_bytes(v),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    serde::forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple_struct tuple identifier ignored_any\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str\");\n        use Value::*;\n        match self {\n            Null =\u003e visitor.visit_borrowed_str(\"\"), // todo: empty string or error?\n            Bool(v) =\u003e visitor.visit_bool(*v),\n            TinyInt(v) =\u003e visitor.visit_i8(*v),\n            SmallInt(v) =\u003e visitor.visit_i16(*v),\n            Int(v) =\u003e visitor.visit_i32(*v),\n            BigInt(v) =\u003e visitor.visit_i64(*v),\n            UTinyInt(v) =\u003e visitor.visit_u8(*v),\n            USmallInt(v) =\u003e visitor.visit_u16(*v),\n            UInt(v) =\u003e visitor.visit_u32(*v),\n            UBigInt(v) =\u003e visitor.visit_u64(*v),\n            Float(v) =\u003e visitor.visit_f32(*v),\n            Double(v) =\u003e visitor.visit_f64(*v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_borrowed_str(v),\n            Json(v) =\u003e visitor.visit_string(v.to_string()),\n            Timestamp(v) =\u003e visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use Value::*;\n        macro_rules! _v_ {\n            ($v:expr) =\u003e {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e _v_!(v),\n            TinyInt(v) =\u003e _v_!(v),\n            SmallInt(v) =\u003e _v_!(v),\n            Int(v) =\u003e _v_!(v),\n            BigInt(v) =\u003e _v_!(v),\n            UTinyInt(v) =\u003e _v_!(v),\n            USmallInt(v) =\u003e _v_!(v),\n            UInt(v) =\u003e _v_!(v),\n            UBigInt(v) =\u003e _v_!(v),\n            Float(v) =\u003e _v_!(v),\n            Double(v) =\u003e _v_!(v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_newtype_struct(v.as_str().into_deserializer()),\n            Json(v) =\u003e visitor\n                .visit_newtype_struct(v.clone().into_deserializer())\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e _v_!(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                visitor.visit_newtype_struct(v.as_slice().into_deserializer())\n            }\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use Value::*;\n        match self {\n            Null =\u003e Vec::\u003cu8\u003e::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) =\u003e v\n                .clone()\n                .into_deserializer()\n                .deserialize_seq(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            VarChar(v) | NChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.clone().into_deserializer().deserialize_any(visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" \u0026\u0026 variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" \u0026\u0026 variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            Value::Json(json) =\u003e json\n                .clone()\n                .into_deserializer()\n                .deserialize_struct(name, fields, visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::IntoDeserializer\u003c'de, Error\u003e for \u0026'b Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn value_de_value_ref() {\n        use std::cmp::PartialEq;\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr) *) =\u003e {\n                $(\n                    {\n                        let v = \u0026$v;\n                        let d = Value::deserialize(v.into_deserializer()).expect(\"\");\n                        assert!(dbg!(d).eq(\u0026$v));\n                    }\n                )*\n            }\n        }\n        _de_value!(\n            Null Bool(true) TinyInt(0xf) SmallInt(0xfff) Int(0xffff) BigInt(-1) Float(1.0) Double(1.0)\n            UTinyInt(0xf) USmallInt(0xfff) UInt(0xffff) UBigInt(0xffffffff)\n            Timestamp(crate::common::timestamp::Timestamp::Milliseconds(0)) VarChar(\"anything\".to_string())\n            NChar(\"\".to_string()) VarBinary(vec![1,2,3]) Blob(vec![1,2, 3]) MediumBlob(vec![1,2,3])\n            Json(serde_json::json!({\"name\": \"ABC\"}))\n        );\n    }\n\n    #[test]\n    fn de_value_as_inner() {\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) =\u003e {\n                $(\n                    {\n                        let v = \u0026$v;\n                        let d = \u003c$ty\u003e::deserialize(v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option\u003cu8\u003e, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\".to_string()), String, \"\".to_string()\n            NChar(\"\".to_string()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            Blob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            MediumBlob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_borrowed_str() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(\u003c\u0026str\u003e::deserialize((\u0026$v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(\u003c\u0026str\u003e::deserialize((\u0026$v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            Json(json!({ \"name\": \"abc\"})), is_err\n            Json(json!(1)), is_err\n            Json(json!(null)), is_err\n            Json(json!(\"abc\")), is_err\n            Timestamp(crate::Timestamp::Milliseconds(0)), is_err\n            ;\n            Null, \"\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"\".to_string()), \"\"\n        };\n    }\n    #[test]\n    fn de_string() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(String::deserialize((\u0026$v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(String::deserialize((\u0026$v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(String::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"\".to_string()), \"\"\n            Json(json!(\"abc\")), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"})), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1)), json!(1).to_string()\n            Json(json!(null)), json!(null).to_string()\n        };\n    }\n\n    #[test(log_level = \"trace\")]\n    fn de_json() {\n        use Value::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let v = \u0026Json($v);\n                let d = \u003c$ty\u003e::deserialize(v.into_deserializer()).expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(\n            serde_json::json!(\"string\"),\n            String,\n            \"\\\"string\\\"\".to_string()\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            serde_json::json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n    }\n\n    #[test(log_level = \"trace\")]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize((\u0026$v).into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\")),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi\u003cT\u003e(T);\n        _de_ty!(Json(json!(1)), Primi\u003ci32\u003e, Primi(1));\n        _de_ty!(TinyInt(1), Primi\u003ci8\u003e, Primi(1));\n        _de_ty!(SmallInt(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(Int(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(BigInt(1), Primi\u003ci64\u003e, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) =\u003e {\n                log::info!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::\u003c$ty\u003e()\n                );\n                _de_ty!($v($inner), Primi\u003c$ty\u003e, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) =\u003e {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) =\u003e {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () =\u003e {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[3049019,3049056,3048608,3049467],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::value::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":17,"address":[3048736,3049092,3049184,3048644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3049377,3048929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3048898,3049017,3049334,3048976,3049424,3049465,3048886,3048817,3049200,3049346,3049265,3048752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3049224,3048776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2733444,2733472,2732352,2734564],"length":1,"stats":{"Line":2},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":43,"address":[2733502,2732382],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[2733708,2734283,2732588,2733163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2732605,2734157,2733725,2734219,2733099,2733037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2732621,2733741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2734272,2733152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2733640,2732520,2733387,2734507],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2733657,2734369,2733249,2734440,2733320,2732537],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[2732553,2733673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2734496,2733376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2732656,2733776,2734055,2732935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2732673,2733793,2733917,2732797,2733988,2732868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2732689,2733809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2734044,2732924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2734656,2734592],"length":1,"stats":{"Line":3},"fn_name":"deserialize_any\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__FieldVisitor\u003e"},{"line":87,"address":[2734667,2734603],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[2734720,2735136,2735529,2735113],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::value::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":105,"address":[2734758,2735174,2734838,2735254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[2735070,2735486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[2734890,2734955,2735011,2735371,2735306,2735427],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2734911,2735327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2833104],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":121,"address":[2833113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[2735776,2735552,2735648,2735584,2735712,2735680,2735744,2735616,2735904,2735808,2735872,2735968,2735936,2736000,2736032,2735840],"length":1,"stats":{"Line":15},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003ci8\u003e\u003e"},{"line":128,"address":[2735568,2735664,2735824,2735696,2735600,2735920,2735760,2735888,2735952,2735856,2736016,2736048,2735792,2735984,2735632,2735728],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[3080402,3049504,3055629,3065910,3067964,3070096,3061730,3063786,3051568,3068000,3059776,3053581,3070049,3072096,3078302,3072055,3061776,3074142,3074192,3055664,3057674,3051518,3059726,3078352,3053616,3057712,3065952,3076240,3063824,3076288],"length":1,"stats":{"Line":12},"fn_name":"deserialize_any\u003ctaos_query::common::value::de::ref_value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":157,"address":[3064074,3074555,3051736,3068363,3072127,3076456,3070261,3063855,3059804,3072264,3060136,3068168,3049867,3055695,3055914,3066315,3066120,3068031,3051931,3053866,3049754,3063992,3057880,3064187,3078602,3074360,3076538,3049535,3066202,3053647,3061807,3051818,3055832,3072346,3074223,3062026,3070343,3056027,3070456,3053784,3076319,3059941,3076651,3078520,3072459,3070124,3078715,3062139,3057962,3078383,3074442,3068250,3058075,3061944,3051599,3060023,3049672,3057743,3065983,3053979],"length":1,"stats":{"Line":36},"fn_name":null},{"line":160,"address":[3050926,3059090,3069432,3060081,3073528,3050882,3057064,3067374,3075646,3052968,3079806,3061159,3077688,3057086,3073550,3073506,3074500,3077666,3072404,3069454,3067330,3052946,3055972,3063198,3065250,3070401,3059112,3052990,3058020,3065294,3079762,3076596,3050904,3065272,3077710,3064132,3059134,3057042,3078660,3061137,3075624,3063154,3067352,3071457,3054994,3063176,3062084,3051876,3053924,3055016,3055038,3068308,3049812,3069410,3075602,3061115,3066260,3071435,3079784,3071479],"length":1,"stats":{"Line":12},"fn_name":null},{"line":161,"address":[3074137,3076235,3057669,3051513,3056220,3064380,3066508,3061725,3072050,3053576,3065905,3067959,3059721,3058268,3080397,3054172,3068556,3050060,3078297,3062332,3072652,3074748,3052124,3078908,3063781,3070044,3055624,3060326,3070646,3076844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3057664,3050086,3078292,3051508,3052150,3072045,3064410,3067954,3053571,3060349,3055619,3068582,3059716,3070039,3061720,3072678,3078934,3058294,3056246,3080392,3074132,3066534,3063776,3054198,3062358,3070669,3076230,3065900,3076870,3074774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3056299,3050139,3064467,3054251,3058347,3065895,3057659,3078287,3080387,3074127,3078987,3072040,3076225,3053566,3059711,3060399,3055614,3066587,3061715,3051503,3062411,3074827,3070034,3076923,3072731,3063771,3070719,3052203,3068635,3067949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3080382,3070769,3059706,3070029,3068692,3078282,3061710,3065890,3055609,3062464,3067944,3074122,3054304,3050192,3057654,3060449,3072035,3076220,3052256,3064524,3053561,3076976,3066640,3058400,3051498,3072788,3079044,3074884,3063766,3056352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3074117,3056405,3072845,3072030,3062517,3074941,3070024,3055604,3066693,3052309,3063761,3065885,3078277,3060499,3064581,3053556,3079101,3050245,3051493,3054357,3057649,3058453,3067939,3061705,3068749,3080377,3076215,3059701,3077029,3070819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[3072901,3072025,3056457,3068805,3061700,3079157,3059696,3077081,3070868,3078272,3058505,3057644,3066745,3067934,3070019,3054409,3055599,3051488,3050297,3062569,3064637,3074112,3063756,3060548,3052361,3065880,3076210,3053551,3074997,3080372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[3071760,3067660,3077405,3059422,3067069,3065594,3077998,3054733,3075325,3079485,3073229,3061435,3055325,3057370,3050621,3073834,3064973,3063482,3080094,3056781,3069741,3058829,3052685,3053277,3060863,3069133,3062893,3071183,3051214,3075932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3052738,3060913,3077458,3080089,3071233,3073286,3067122,3073829,3051209,3053272,3057365,3075382,3071755,3058882,3069736,3050674,3054786,3056834,3062946,3065030,3069190,3075927,3077993,3061430,3065589,3059417,3063477,3055320,3067655,3079542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[3067175,3069731,3059412,3069247,3051204,3071750,3077988,3061425,3079599,3052791,3056887,3054839,3063472,3075439,3067650,3073824,3050727,3073343,3065087,3075922,3080084,3057360,3077511,3065584,3058935,3062999,3071283,3053267,3055315,3060963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[3077983,3075495,3065143,3075917,3057355,3067227,3079655,3056939,3063467,3058987,3061012,3069726,3065579,3073399,3073819,3067645,3053262,3050779,3069303,3080079,3054891,3059407,3061420,3077563,3051199,3055310,3052843,3063051,3071332,3071745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3063751,3050350,3055594,3062622,3053546,3074107,3054462,3059691,3078267,3060598,3065875,3067929,3057639,3064694,3072020,3051483,3058558,3070918,3061695,3077134,3079214,3070014,3056510,3072958,3066798,3076205,3075054,3080367,3052414,3068862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[3076200,3074102,3065870,3051478,3068916,3073012,3079268,3064752,3054516,3050404,3063746,3062676,3072015,3075108,3077188,3080362,3059686,3061690,3060649,3055589,3056564,3053541,3057634,3058612,3066852,3070969,3067924,3070009,3052468,3078262],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[3059598,3065778,3071015,3067836,3057546,3052514,3080274,3056610,3077234,3050450,3062722,3078174,3074014,3061605,3071930,3066898,3076112,3060695,3073058,3064802,3053453,3058658,3068962,3063658,3051390,3075154,3069921,3054562,3055501,3079314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3079421,3062829,3055330,3065599,3058765,3073165,3057375,3053282,3063487,3073839,3061440,3060802,3078003,3054669,3075261,3051219,3080099,3069746,3064909,3069069,3052621,3067665,3077341,3059427,3056717,3067005,3071122,3071765,3075937,3050557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[3054936,3050824,3063381,3067610,3069691,3073733,3051164,3057320,3063096,3067559,3063432,3059372,3069352,3069640,3073784,3079704,3080044,3059032,3057269,3065192,3052888,3065485,3067272,3059321,3071377,3071658,3073448,3075882,3077897,3051113,3077608,3079993,3055275,3056984,3061057,3077948,3071709,3075831,3075544,3061337,3065520,3061388,3055224,3053227,3053176],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[3077924,3073760,3057296,3075858,3051140,3067586,3071685,3053203,3080020,3059348,3055251,3061364,3063408,3065512,3069667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3063575,3065691,3055418,3051307,3054618,3050506,3075210,3056666,3066954,3078091,3077290,3069018,3060751,3073114,3064858,3067753,3062778,3069834,3080187,3061525,3073927,3059515,3076025,3057463,3052570,3053370,3058714,3079370,3071850,3071071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3054996,3057136,3065252,3077646,3079764,3069412,3065348,3071437,3077764,3077690,3073600,3063134,3057044,3050862,3071415,3059114,3075626,3052926,3054974,3079786,3063156,3050980,3052948,3059070,3053043,3073486,3073508,3075604,3071459,3055018,3073530,3052970,3067354,3071530,3069507,3075698,3061117,3077668,3075582,3050906,3057066,3059092,3063178,3055091,3069390,3069434,3079860,3063248,3057022,3067426,3079742,3067332,3061139,3065230,3059188,3065274,3050884,3061095,3061209,3067310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3054128,3078864,3070605,3074704,3050946,3075666,3057106,3059154,3060285,3052080,3063218,3069474,3068512,3073570,3065314,3053010,3061176,3064336,3062288,3058224,3067394,3071496,3056176,3050016,3055058,3076800,3072608,3079826,3077730,3066464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3080448,3082120,3082160,3081966,3083734,3083892],"length":1,"stats":{"Line":2},"fn_name":"deserialize_str\u003cserde::de::impls::StrVisitor\u003e"},{"line":200,"address":[3082307,3080595,3082386,3082469,3080674,3080478,3080757,3082190],"length":1,"stats":{"Line":6},"fn_name":null},{"line":202,"address":[3081350,3080722,3083021,3082434,3081277,3083094],"length":1,"stats":{"Line":5},"fn_name":null},{"line":203,"address":[3082613,3083887,3082115,3080901],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[3082110,3080940,3082656,3083882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3080987,3082105,3083877,3082707],"length":1,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[3081034,3083872,3082100,3082758],"length":1,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[3083867,3081081,3082095,3082809],"length":1,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[3081127,3083862,3082090,3082859],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[3083109,3083493,3081365,3081729],"length":1,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[3081412,3083160,3083491,3081727],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[3081459,3081725,3083211,3083489],"length":1,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[3081723,3083261,3083487,3081505],"length":1,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[3081174,3082085,3082910,3083857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3082080,3081222,3083852,3082962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[3083009,3081995,3083763,3083082,3081731,3083495,3081265,3081338],"length":1,"stats":{"Line":5},"fn_name":null},{"line":216,"address":[3083307,3081547,3083403,3081643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[3081287,3083688,3083031,3081924],"length":1,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[3081323,3083580,3081816,3083067],"length":1,"stats":{"Line":4},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[3081609,3082572,3083369,3080860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3083936,3084313],"length":1,"stats":{"Line":1},"fn_name":"deserialize_string\u003cserde::de::impls::StringVisitor\u003e"},{"line":232,"address":[3083966,3084206,3084059,3084138],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[3084191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[3084336,3084767],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option\u003cserde::de::impls::OptionVisitor\u003cu8\u003e\u003e"},{"line":240,"address":[3084597,3084459,3084366,3084538],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[3084586,3084695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[3084731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[3084765,3084711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[3107145,3091141,3097584,3103945,3110384,3087984,3107184,3100784,3100744,3084784,3094384,3094341,3103984,3087943,3091184,3113543,3097545,3110344],"length":1,"stats":{"Line":9},"fn_name":"deserialize_newtype_struct\u003ctaos_query::common::value::de::ref_value::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor\u003cu16\u003e\u003e"},{"line":256,"address":[3097864,3088264,3097961,3107678,3104478,3085064,3088039,3088361,3094761,3091678,3097639,3101161,3107239,3084839,3110439,3104361,3107561,3110761,3091464,3091561,3091239,3094878,3101278,3094439,3094664,3110664,3110878,3100839,3098078,3101064,3107464,3085278,3104039,3085161,3104264,3088478],"length":1,"stats":{"Line":27},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3098757,3101957,3089233,3092741,3108763,3105585,3111633,3095985,3099185,3102385,3086385,3088433,3099141,3108741,3111963,3086363,3102033,3107633,3111985,3089541,3089563,3110833,3101233,3104433,3111557,3091633,3099163,3094833,3102341,3092763,3102363,3089157,3085957,3105157,3105233,3105563,3108357,3108785,3092785,3086033,3095633,3108433,3111941,3089585,3092357,3095557,3095941,3092433,3105541,3086341,3085233,3098033,3098833,3095963],"length":1,"stats":{"Line":9},"fn_name":null},{"line":264,"address":[3095101,3100739,3094336,3107901,3085501,3091901,3107140,3098301,3104701,3087938,3097540,3110339,3091136,3101501,3088701,3103940,3113538,3111101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3095127,3091927,3085527,3113447,3104727,3111127,3091045,3101527,3087847,3088727,3110248,3107049,3107927,3100648,3098327,3094245,3103849,3097449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[3103761,3097361,3085587,3107987,3088787,3104787,3095187,3100560,3091987,3101587,3110160,3111187,3113359,3090957,3094157,3087759,3106961,3098387],"length":1,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[3087670,3111247,3113270,3110071,3101647,3095247,3106872,3085647,3097272,3094068,3090868,3088847,3104847,3103672,3108047,3100471,3092047,3098447],"length":1,"stats":{"Line":8},"fn_name":null},{"line":268,"address":[3085708,3095308,3111308,3093983,3101708,3088908,3097187,3109986,3104908,3100386,3106787,3087585,3108108,3113185,3092108,3090783,3098508,3103587],"length":1,"stats":{"Line":8},"fn_name":null},{"line":269,"address":[3095367,3100303,3087502,3106704,3085767,3103504,3104967,3111367,3108167,3109903,3093900,3098567,3088967,3113102,3101767,3092167,3097104,3090700],"length":1,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[3099787,3102988,3089246,3105246,3098846,3090184,3096588,3109387,3086986,3086046,3111646,3112586,3092446,3108446,3093384,3102046,3106188,3095646],"length":1,"stats":{"Line":8},"fn_name":null},{"line":271,"address":[3102902,3112500,3111703,3093298,3099701,3089303,3096502,3106102,3095703,3092503,3086900,3109301,3086103,3108503,3098903,3102103,3090098,3105303],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[3090016,3112418,3108561,3092561,3102820,3089361,3095761,3109219,3111761,3106020,3105361,3099619,3102161,3086818,3093216,3096420,3098961,3086161],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[3102217,3089933,3099536,3105417,3093133,3105937,3109136,3095817,3102737,3108617,3111817,3086735,3089417,3092617,3086217,3112335,3099017,3096337],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[3100219,3089025,3101825,3105025,3090616,3109819,3098625,3103420,3106620,3087418,3092225,3097020,3095425,3108225,3111425,3113018,3085825,3093816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[3111485,3089085,3090532,3092285,3108285,3085885,3100135,3109735,3096936,3093732,3105085,3103336,3095485,3106536,3087334,3098685,3101885,3112934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[3093469,3100016,3095545,3102021,3105145,3106273,3090269,3092345,3101945,3085945,3108421,3109472,3093613,3090413,3089221,3096673,3106417,3109616,3112671,3087071,3105221,3095621,3099872,3098745,3086021,3096817,3098821,3112815,3087215,3089145,3103217,3108345,3092421,3111545,3103073,3111621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[3095875,3096265,3096332,3093128,3105475,3086730,3093061,3105932,3089928,3093116,3086718,3099075,3105920,3112318,3109131,3089916,3089475,3109064,3089861,3102720,3099464,3086275,3102665,3105865,3112263,3092675,3099519,3099531,3102275,3111875,3102732,3096320,3108675,3109119,3112330,3086663],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[3086311,3102601,3112199,3086702,3089923,3111911,3112302,3092997,3093123,3099111,3105801,3096201,3102727,3108711,3109126,3105511,3089511,3109103,3105927,3099400,3109000,3093100,3099526,3096304,3112325,3089900,3102311,3096327,3092711,3086599,3099503,3105904,3102704,3086725,3089797,3095911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3111570,3092370,3098770,3106317,3103117,3109516,3099916,3089170,3087115,3090313,3093513,3085970,3096717,3101970,3105170,3095570,3108370,3112715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3105551,3108729,3108773,3105573,3095929,3089573,3099129,3108751,3111973,3092751,3092773,3092729,3086351,3089551,3086329,3099151,3095951,3102373,3089529,3105529,3111951,3095973,3099173,3102329,3102351,3086373,3111929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3096045,3105796,3086443,3099244,3108844,3102445,3089792,3099395,3102596,3086594,3112043,3108995,3105645,3089641,3096196,3112194,3092992,3092841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3092811,3108811,3095051,3096011,3088651,3111051,3089611,3112011,3101451,3085451,3099211,3104651,3086411,3098251,3091851,3102411,3107851,3105611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[3114494,3113584],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq\u003cserde::de::impls::{impl#19}::deserialize::VecVisitor\u003cu8\u003e\u003e"},{"line":302,"address":[3113614,3113869,3113707,3113786],"length":1,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[3113834,3114033,3114112,3114131,3114150,3114055],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[3114482,3113994,3114454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[3114466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[3114065,3114298,3114247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3114274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3114426,3114021,3114330,3114043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[3114410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[3114100,3114138,3114119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[3114167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[3113976,3114152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[3116274,3115378,3115408,3114512],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":334,"address":[3114571,3115566,3114840,3115467,3115648,3115736,3114670,3114752],"length":1,"stats":{"Line":6},"fn_name":null},{"line":336,"address":[3115706,3114810,3115077,3115973],"length":1,"stats":{"Line":5},"fn_name":null},{"line":337,"address":[3116079,3115183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[3116042,3115146,3116129,3115233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[3115337,3116233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[3115312,3116208,3116269,3115373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3116304,3116601],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct\u003ctaos_query::common::value::de::ref_value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":358,"address":[3116385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[3116517,3116415,3116575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[3116557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[3116449,3116502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1945296],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[2545140,2545136],"length":1,"stats":{"Line":4},"fn_name":"value_de_value_ref"},{"line":385,"address":[2545280,2546131],"length":1,"stats":{"Line":1},"fn_name":"value_de_value_ref"},{"line":399,"address":[2557573,2565241,2562220,2563351,2559699,2558521,2561231,2563482,2564815,2560827,2545293,2562089,2558751,2559611,2564045,2558433,2546165,2557495,2559969,2560958,2562493],"length":1,"stats":{"Line":13},"fn_name":null},{"line":402,"address":[2557525,2558398,2558465,2557468],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[2562129,2561119,2562381,2559643,2559857,2562066,2560867,2558678,2559576,2563328,2560804,2563391],"length":1,"stats":{"Line":12},"fn_name":null},{"line":404,"address":[2563643,2564800,2564847],"length":1,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[2565408,2565412],"length":1,"stats":{"Line":4},"fn_name":"de_value_as_inner"},{"line":409,"address":[2568921,2565552,2568876],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":423,"address":[2569848,2568887,2569008,2569715,2568600,2571257,2570089,2569997,2570673,2568447,2565559,2570438,2569158,2571165,2571022,2570581,2568355],"length":1,"stats":{"Line":10},"fn_name":null},{"line":435,"address":[2568313,2568399,2568574],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[2569132,2568936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[2569985,2569767,2569674,2570046],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[2570332,2570569,2570630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[2571214,2571153,2570916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":444,"address":[2571520,2571524],"length":1,"stats":{"Line":4},"fn_name":"de_borrowed_str"},{"line":445,"address":[2571664,2571810],"length":1,"stats":{"Line":1},"fn_name":"de_borrowed_str"},{"line":472,"address":[2571671,2571843,2574343,2573738,2574959,2575051,2573522,2575435,2573103,2573844,2574237],"length":1,"stats":{"Line":7},"fn_name":null},{"line":481,"address":[2573088,2573133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[2573768,2573716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":484,"address":[2574267,2574215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[2575003,2574922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[2575362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[2575764,2575760],"length":1,"stats":{"Line":4},"fn_name":"de_string"},{"line":493,"address":[2576058,2575904],"length":1,"stats":{"Line":1},"fn_name":"de_string"},{"line":520,"address":[2580849,2580985,2578959,2579905,2581086,2579196,2578060,2580443,2581494,2579095,2580034,2576091,2578498,2575911],"length":1,"stats":{"Line":7},"fn_name":null},{"line":534,"address":[2577987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[2578425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2579139,2578863,2579073],"length":1,"stats":{"Line":3},"fn_name":null},{"line":537,"address":[2580027,2580078,2579503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[2580963,2580753,2581029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":539,"address":[2581468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[2581780,2581776],"length":1,"stats":{"Line":4},"fn_name":"de_json"},{"line":544,"address":[2582472,2581936,2582430],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":555,"address":[2582441,2582172,2581996,2581943],"length":1,"stats":{"Line":3},"fn_name":null},{"line":556,"address":[2581951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[2582145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[2582838,2583043,2583115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[2582487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[2583075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[2583008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[2583744,2583748],"length":1,"stats":{"Line":4},"fn_name":"de_newtype_struct"},{"line":575,"address":[2584145,2583904],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":587,"address":[2584013,2584179,2584275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[2583917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[2584208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[2584504,2584888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[2584940,2585134,2584850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":597,"address":[2585096,2585186,2585381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[2585628,2585343,2585433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":599,"address":[2585590,2585894,2585680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[2593334,2598667,2601997,2608665,2617997,2620661,2599333,2589335,2621327,2609331,2618663,2599999,2625326,2627952,2628421,2588669,2607999,2606666,2607333,2611995,2612661,2615329,2626660,2616663,2619329,2594668,2604665,2617330,2586671,2591333,2592000,2601331,2603331,2622659,2596669,2613328,2624659,2590667,2585837,2613995,2602664,2594001,2585945,2609997,2625993,2627327,2587337,2588003,2619995,2596002,2623325,2600665,2590001,2592667,2614662,2615996,2621993,2605999,2605332,2598001,2595335,2610663,2603998,2597335,2586005,2623992,2611329],"length":1,"stats":{"Line":66},"fn_name":null}],"covered":136,"coverable":200},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","value.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl\u003c'de, 'b\u003e serde::de::EnumAccess\u003c'de\u003e for Value {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let s = self.strict_as_str();\n        return Ok((\n            seed.deserialize(StringDeserializer {\n                input: s.to_string(),\n            })?,\n            UnitOnly,\n        ));\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer {\n    value: Value,\n}\n\nimpl\u003c'b, 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumTimestampDeserializer {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n        match self.value {\n            Value::Timestamp(Timestamp::Microseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Microseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            Value::Timestamp(Timestamp::Milliseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Milliseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            Value::Timestamp(Timestamp::Nanoseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Nanoseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer {\n    value: Value,\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\nimpl\u003c'de, 'b: 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumValueDeserializer {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let variant = self.value.ty().as_variant_str();\n\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: variant.to_string(),\n            })\n            .expect(\"\"),\n            self,\n        ))\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e de::VariantAccess\u003c'de\u003e for EnumValueDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::Deserializer\u003c'de\u003e for Value {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use Value::*;\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            VarChar(v) =\u003e visitor.visit_string(v),\n            NChar(v) =\u003e visitor.visit_string(v),\n            Json(v) =\u003e v\n                .into_deserializer()\n                .deserialize_any(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.into_deserializer().deserialize_any(visitor)\n            }\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    serde::forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple_struct tuple identifier ignored_any\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str\");\n        use Value::*;\n        match self {\n            Null =\u003e visitor.visit_str(\"\"), // todo: empty string or error?\n            // Null =\u003e Err(Self::Error::from_string(\n            // \"expect non-optional String, but value is null\",\n            // )),\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_string(v),\n            Json(v) =\u003e visitor.visit_string(v.to_string()),\n            Timestamp(v) =\u003e visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use Value::*;\n        macro_rules! _v_ {\n            ($v:expr) =\u003e {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e _v_!(v),\n            TinyInt(v) =\u003e _v_!(v),\n            SmallInt(v) =\u003e _v_!(v),\n            Int(v) =\u003e _v_!(v),\n            BigInt(v) =\u003e _v_!(v),\n            UTinyInt(v) =\u003e _v_!(v),\n            USmallInt(v) =\u003e _v_!(v),\n            UInt(v) =\u003e _v_!(v),\n            UBigInt(v) =\u003e _v_!(v),\n            Float(v) =\u003e _v_!(v),\n            Double(v) =\u003e _v_!(v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_newtype_struct(v.as_str().into_deserializer()),\n            Json(v) =\u003e visitor\n                .visit_newtype_struct(v.into_deserializer())\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e _v_!(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                visitor.visit_newtype_struct(v.as_slice().into_deserializer())\n            }\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use Value::*;\n        match self {\n            Null =\u003e Vec::\u003cu8\u003e::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) =\u003e v\n                .into_deserializer()\n                .deserialize_seq(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            VarChar(v) | NChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.into_deserializer().deserialize_seq(visitor)\n            }\n            _ =\u003e todo!(),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" \u0026\u0026 variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" \u0026\u0026 variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            Value::Json(json) =\u003e json\n                .into_deserializer()\n                .deserialize_struct(name, fields, visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::IntoDeserializer\u003c'de, Error\u003e for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn value_de_value() {\n        use std::cmp::PartialEq;\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr) *) =\u003e {\n                $(\n                    {\n                        let v = $v;\n                        let d = Value::deserialize(v.clone().into_deserializer()).expect(\"\");\n                        assert!(v.eq(\u0026d));\n                    }\n                )*\n            }\n        }\n        _de_value!(\n                Null Bool(true) TinyInt(0xf) SmallInt(0xfff) Int(0xffff) BigInt(-1) Float(1.0) Double(1.0)\n                UTinyInt(0xf) USmallInt(0xfff) UInt(0xffff) UBigInt(0xffffffff)\n                Timestamp(crate::common::timestamp::Timestamp::Milliseconds(0)) VarChar(\"anything\".to_string())\n                NChar(\"\".to_string()) VarBinary(vec![1,2,3]) Blob(vec![1,2, 3]) MediumBlob(vec![1,2,3])\n                Json(serde_json::json!({\"name\": \"ABC\"}))\n        );\n    }\n\n    #[test]\n    fn de_value_as_inner() {\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) =\u003e {\n                $(\n                    {\n                        let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option\u003cu8\u003e, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\".to_string()), String, \"\".to_string()\n            NChar(\"\".to_string()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            Blob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            MediumBlob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_str() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(String::deserialize($v.into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(String::deserialize($v.into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(String::deserialize($v.into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"\".to_string()), \"\"\n            Json(json!(\"abc\")), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"})), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1)), json!(1).to_string()\n            Json(json!(null)), json!(null).to_string()\n        };\n    }\n\n    #[test]\n    fn de_json() {\n        use Value::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let v = Json($v);\n                let d = \u003c$ty\u003e::deserialize(v.clone().into_deserializer()).expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(\n            serde_json::json!(\"string\"),\n            String,\n            \"\\\"string\\\"\".to_string()\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            serde_json::json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\")),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi\u003cT\u003e(T);\n        _de_ty!(Json(json!(1)), Primi\u003ci32\u003e, Primi(1));\n        _de_ty!(TinyInt(1), Primi\u003ci8\u003e, Primi(1));\n        _de_ty!(SmallInt(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(Int(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(BigInt(1), Primi\u003ci64\u003e, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) =\u003e {\n                log::debug!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::\u003c$ty\u003e()\n                );\n                _de_ty!($v($inner), Primi\u003c$ty\u003e, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) =\u003e {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) =\u003e {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () =\u003e {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[3117498,3117088,3116624,3117034],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":17,"address":[3116652,3117116,3117208,3116744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3116931,3117395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3116900,3117352,3116760,3117224,3117286,3116888,3117442,3116822,3117483,3117364,3117019,3116978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3117245,3116781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1960672,1961808,1961757,1962893],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":43,"address":[1960694,1961830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1960934,1962070,1962601,1961465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1961404,1962540,1962087,1960951,1961342,1962478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1962103,1960967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1962593,1961457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1962002,1961686,1962822,1960866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1962019,1962687,1961622,1962758,1961551,1960883],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[1960899,1962035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1961678,1962814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[1961238,1962138,1962374,1961002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1962155,1961019,1962239,1962310,1961103,1961174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1961035,1962171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1961230,1962366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1963008,1962944],"length":1,"stats":{"Line":2},"fn_name":"deserialize_any\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__FieldVisitor\u003e"},{"line":87,"address":[1962955,1963019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[1964030,1963534,1963072,1963568],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":105,"address":[1963598,1963182,1963102,1963678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1963936,1963440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1963234,1963306,1963802,1963730,1963870,1963374],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[1963754,1963258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1963418,1963914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[2711072],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":121,"address":[2711076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1964448,1964128,1964256,1964320,1964832,1964896,1964512,1964640,1964704,1964768,1964064,1964384,1964576,1965024,1964960,1964192],"length":1,"stats":{"Line":15},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003cu64\u003e\u003e"},{"line":128,"address":[1964782,1964910,1964526,1964718,1964846,1964398,1964654,1964974,1964142,1964334,1965038,1964590,1964462,1964206,1964078,1964270],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[3146986,3136933,3117552,3132118,3142384,3144516,3141929,3120096,3149383,3122229,3129509,3122116,3127154,3127488,3129952,3132005,3144403,3151954,3124580,3147328,3151841,3137376,3122560,3139432,3119754,3134912,3134581,3127041,3125024,3137046,3129622,3134468,3132448,3139545,3142042,3146873,3139872,3149824,3149496,3124693,3119641,3144848],"length":1,"stats":{"Line":12},"fn_name":"deserialize_any\u003cserde::de::impls::{impl#49}::deserialize::PrimitiveVisitor\u003e"},{"line":157,"address":[3137677,3135317,3142406,3122965,3130171,3127893,3120397,3132470,3125429,3125325,3137595,3127707,3142603,3147547,3129974,3140277,3150043,3125243,3127510,3130357,3134934,3144870,3127789,3137398,3132667,3139894,3122582,3145149,3147629,3147733,3147350,3120315,3145067,3132749,3122861,3130253,3117574,3135131,3145253,3149846,3135213,3150125,3140173,3120118,3117771,3142685,3120501,3132853,3137781,3142789,3150229,3122779,3125046,3117957,3140091,3117853],"length":1,"stats":{"Line":36},"fn_name":null},{"line":160,"address":[3121630,3138993,3121681,3141489,3145209,3146382,3150185,3151358,3128968,3143969,3119088,3132809,3130313,3136497,3148945,3143864,3129022,3126504,3117913,3136392,3136446,3124145,3138888,3138942,3141384,3121576,3126558,3129073,3133928,3141438,3125385,3127849,3143918,3119142,3140233,3119193,3120457,3124094,3131464,3134033,3142745,3146433,3147689,3148894,3151304,3151409,3131569,3146328,3148840,3122921,3133982,3124040,3126609,3135273,3137737,3131518],"length":1,"stats":{"Line":12},"fn_name":null},{"line":161,"address":[3144304,3139333,3118144,3145440,3123152,3140464,3134369,3129410,3141830,3142976,3133040,3150416,3136834,3125616,3120688,3135504,3146774,3119542,3128080,3130544,3122017,3131906,3137968,3151742,3149284,3124481,3126942,3147920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3134364,3137996,3133068,3124476,3139328,3135532,3119537,3130572,3140492,3145468,3147948,3126937,3143004,3151737,3146769,3128108,3123180,3141825,3129405,3122012,3144299,3149279,3125644,3150444,3118176,3120716,3136829,3131901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3146764,3141820,3133112,3123224,3118224,3134359,3136824,3144294,3126932,3128152,3131896,3149274,3135576,3139323,3138040,3140536,3130616,3124471,3120760,3145512,3150488,3119532,3129400,3147992,3151732,3122007,3125688,3143048],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3148038,3123266,3124466,3151727,3144289,3146759,3149269,3120802,3131891,3119527,3126927,3133154,3118270,3130662,3135618,3145554,3134354,3128194,3138086,3136819,3122002,3139318,3140582,3125730,3141815,3129395,3143090,3150530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3125773,3138133,3123309,3146754,3149264,3150573,3141810,3151722,3129390,3135661,3145597,3126922,3140629,3121997,3128237,3143133,3119522,3124461,3133197,3118317,3148085,3120845,3134349,3130709,3144284,3131886,3136814,3139313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[3125811,3151717,3146749,3140671,3144279,3120883,3118359,3130751,3135699,3123347,3136809,3141805,3119517,3131881,3124456,3128275,3145635,3148127,3139308,3129385,3138175,3121992,3126917,3133235,3134344,3149259,3150611,3143171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[3123739,3146027,3148523,3151003,3121887,3151612,3143563,3118771,3131772,3144174,3121275,3129280,3136091,3128667,3124351,3133627,3149150,3146644,3126203,3139199,3119408,3126812,3131147,3134239,3138571,3141067,3141696,3136704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3123781,3141113,3146639,3148569,3136699,3138617,3149145,3119403,3121882,3151607,3143605,3134234,3124346,3121317,3126807,3129275,3126245,3133669,3144169,3146069,3131193,3139194,3131767,3141691,3136133,3128709,3151045,3118817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[3146634,3129270,3131762,3136176,3121877,3139189,3134229,3121360,3123824,3124341,3136694,3133712,3141686,3144164,3126802,3146112,3151088,3118864,3138664,3143648,3151602,3126288,3131240,3141160,3148616,3149140,3119398,3128752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[3141681,3148658,3118906,3121872,3124336,3129265,3143686,3133750,3121398,3131282,3146629,3151126,3138706,3151597,3126797,3126326,3134224,3119393,3136214,3136689,3139184,3128790,3123862,3131757,3144159,3146150,3149135,3141202],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3125851,3135739,3139303,3141800,3121987,3138219,3144274,3128315,3146744,3148171,3129380,3124451,3131876,3149254,3120923,3143211,3119512,3136804,3118403,3126912,3140715,3151712,3134339,3123387,3130795,3145675,3133275,3150651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[3119507,3125893,3131871,3136799,3130837,3143253,3144269,3146739,3124446,3148213,3149249,3150693,3151707,3145717,3121982,3118449,3123429,3129375,3133317,3120965,3126907,3128357,3134334,3140757,3135781,3138261,3139298,3141795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[3145759,3121007,3125935,3133359,3124441,3139293,3121977,3118495,3140799,3144264,3136794,3138303,3130879,3129370,3143295,3131866,3148255,3149244,3119502,3126902,3150735,3141790,3128399,3146734,3151702,3123471,3134329,3135823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3121892,3146649,3143463,3148423,3149155,3134244,3151617,3140967,3131777,3150903,3124356,3141701,3121175,3135991,3131047,3136709,3138471,3118667,3126103,3119413,3123639,3126817,3128567,3129285,3133527,3139204,3144179,3145927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[3119337,3146593,3148697,3151161,3126765,3146185,3131725,3138745,3129233,3141649,3139152,3118945,3134192,3131321,3121840,3133785,3136249,3144127,3149103,3151565,3126361,3123897,3124304,3136657,3121433,3143721,3141241,3128825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[3119329,3124280,3131701,3146569,3149079,3126741,3139128,3144103,3121816,3129209,3136633,3141625,3151541,3134168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[3121102,3129290,3135918,3140894,3123566,3130974,3121897,3133454,3141706,3145854,3146654,3139209,3131782,3126822,3118594,3128494,3136714,3119418,3124361,3134249,3138398,3126030,3143390,3148350,3149160,3150830,3151622,3144184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3124050,3151314,3133989,3146389,3131525,3146284,3121532,3121637,3136402,3128978,3131420,3141340,3151260,3143820,3126514,3136453,3141445,3148901,3136348,3138844,3129029,3151365,3141394,3119098,3133884,3143874,3119044,3128924,3146338,3138898,3148796,3131474,3121586,3148850,3143925,3123996,3126565,3119149,3133938,3138949,3126460,3124101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3141540,3126656,3119244,3139043,3144018,3136548,3121731,3124195,3151456,3148994,3146484,3129124,3134083,3131616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[3135463,3136514,3140423,3141506,3121698,3145399,3150375,3131586,3123111,3129090,3151426,3124162,3134050,3132999,3137927,3146450,3143986,3119210,3139010,3125575,3126626,3118103,3142935,3120647,3147879,3130503,3148962,3128039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3152288,3153723,3154232],"length":1,"stats":{"Line":1},"fn_name":"deserialize_str\u003cserde::de::impls::StringVisitor\u003e"},{"line":201,"address":[3152310,3152546,3152467,3152629],"length":1,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[3152594,3153168,3153293],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[3152767,3154074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[3154069,3152810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3152858,3154064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[3152904,3154059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[3152951,3154054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[3152993,3154049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[3153308,3153749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[3153744,3153354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[3153401,3153739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[3153443,3153734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[3153037,3154044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3153083,3154039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[3153249,3153124,3153759,3154034],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[3153482,3153606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[3153178,3153970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[3153862,3153234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[3153572,3152726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3154432,3154885,3154912],"length":1,"stats":{"Line":1},"fn_name":"deserialize_string\u003cserde::de::impls::StringVisitor\u003e"},{"line":236,"address":[3154761,3154454,3154563,3154642],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[3154695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[3154928,3155431,3155458],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option\u003cserde::de::impls::OptionVisitor\u003cu8\u003e\u003e"},{"line":244,"address":[3154950,3155059,3155138,3155197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[3155186,3155295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[3155382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[3155311,3155415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[3171341,3169873,3175904,3187660,3157631,3175421,3188144,3167744,3186192,3190269,3155504,3165793,3159584,3163664,3159099,3171824,3163180,3178031,3191737,3179499,3161712,3173953,3183577,3167261,3179984,3182109,3184064],"length":1,"stats":{"Line":9},"fn_name":"deserialize_newtype_struct\u003ctaos_query::common::value::de::value::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor\u003ci16\u003e\u003e"},{"line":260,"address":[3176486,3188512,3159952,3160049,3155551,3155872,3172406,3176369,3155969,3167791,3168326,3180449,3188726,3164032,3188191,3180031,3160166,3176272,3180566,3156086,3172192,3172289,3175951,3168209,3184529,3180352,3164246,3184432,3188609,3164129,3159631,3171871,3163711,3168112,3184111,3184646],"length":1,"stats":{"Line":27},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[3188681,3169129,3156041,3176441,3189401,3189909,3157326,3160841,3172361,3177780,3173646,3184601,3169566,3177669,3161406,3173700,3161460,3177161,3181749,3185829,3169620,3185321,3164201,3189529,3189966,3156889,3168281,3169509,3169001,3157269,3181806,3160969,3165429,3156761,3181241,3160121,3177726,3181860,3161349,3164921,3185886,3173081,3190020,3165049,3177289,3165540,3157380,3185449,3180521,3173209,3165486,3185940,3181369,3173589],"length":1,"stats":{"Line":9},"fn_name":null},{"line":268,"address":[3167156,3179394,3183472,3172629,3163075,3180789,3188949,3191632,3158994,3164469,3187555,3171236,3176709,3160389,3156309,3168549,3184869,3175316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3158903,3191541,3184895,3164495,3168575,3188975,3167065,3162984,3180815,3187464,3156335,3176735,3160415,3171145,3175225,3179303,3172655,3183381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3191453,3179215,3176792,3162896,3160472,3180872,3171057,3164552,3166977,3184952,3183293,3156392,3172712,3187376,3158815,3168632,3189032,3175137],"length":1,"stats":{"Line":8},"fn_name":null},{"line":271,"address":[3176847,3183204,3175048,3158726,3185007,3156447,3160527,3162807,3172767,3187287,3179126,3166888,3191364,3189087,3170968,3168687,3180927,3164607],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[3160584,3158641,3185064,3176904,3187202,3189144,3156504,3164664,3179041,3168744,3183119,3166803,3191279,3162722,3172824,3174963,3170883,3180984],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[3172875,3189195,3164715,3176955,3158555,3181035,3166717,3191193,3156555,3178955,3160635,3170797,3187116,3168795,3185115,3162636,3183033,3174877],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[3190640,3158002,3182480,3165062,3169142,3173222,3174324,3166164,3170244,3178402,3177302,3181382,3185462,3189542,3160982,3186563,3156902,3162083],"length":1,"stats":{"Line":8},"fn_name":null},{"line":275,"address":[3161034,3190554,3156954,3174238,3185514,3165114,3161997,3166078,3189594,3178316,3157916,3181434,3173274,3170158,3169194,3186477,3182394,3177354],"length":1,"stats":{"Line":8},"fn_name":null},{"line":276,"address":[3173328,3182312,3169248,3178234,3157008,3177408,3165996,3174156,3181488,3189648,3190472,3161915,3165168,3157834,3161088,3170076,3185568,3186395],"length":1,"stats":{"Line":8},"fn_name":null},{"line":277,"address":[3177456,3174073,3165216,3181536,3173376,3169296,3157056,3186312,3161832,3182229,3189696,3161136,3169993,3157751,3178151,3185616,3165913,3190389],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[3162552,3187032,3158471,3182949,3160689,3191109,3156609,3178871,3189249,3177009,3174793,3172929,3164769,3181089,3185169,3168849,3166633,3170713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[3186948,3168903,3191025,3182865,3156663,3189303,3174709,3164823,3170629,3160743,3162468,3158387,3177063,3181143,3166549,3178787,3185223,3172983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3168957,3158087,3177245,3190869,3166249,3185405,3174409,3174553,3177117,3164877,3160797,3181197,3186792,3160925,3170473,3165005,3166393,3185277,3189357,3186648,3156717,3182565,3170329,3173165,3182709,3158231,3173037,3162312,3189485,3162168,3156845,3190725,3178631,3169085,3181325,3178487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3186295,3178134,3178146,3157679,3161187,3186307,3178079,3165841,3161760,3173427,3157746,3182224,3182212,3190317,3169988,3174001,3169347,3157734,3161827,3169921,3165267,3189747,3157107,3165908,3174068,3185667,3186240,3165896,3190372,3174056,3161815,3169976,3181587,3190384,3182157,3177507],"length":1,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[3161235,3174063,3190356,3165880,3173475,3169983,3182219,3161723,3169395,3169884,3165804,3161822,3157718,3182120,3157155,3186279,3190280,3182196,3157642,3186302,3178118,3181635,3173964,3161799,3190379,3165315,3189795,3186203,3157741,3165903,3169960,3185715,3174040,3177555,3178042,3178141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3156774,3164934,3158131,3169014,3166293,3177174,3185334,3182609,3189414,3170373,3174453,3181254,3160854,3162212,3178531,3173094,3186692,3190769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3189976,3189922,3173545,3173602,3157336,3161362,3165385,3165442,3165496,3157225,3169465,3169522,3181705,3169576,3181762,3181816,3185842,3161305,3173656,3157282,3189865,3185785,3161416,3177625,3177682,3177736,3185896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3165600,3178029,3173760,3165791,3185999,3190076,3169680,3157629,3169871,3182107,3161519,3157438,3190267,3161710,3177838,3186190,3173951,3181916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[3177806,3164419,3173726,3165566,3156259,3176659,3172579,3185966,3168499,3160339,3181886,3161486,3169646,3157406,3180739,3184819,3188899,3190046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[3193433,3192224,3193544],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq\u003cserde::de::impls::{impl#19}::deserialize::VecVisitor\u003cu8\u003e\u003e"},{"line":306,"address":[3192246,3192435,3192597,3192514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[3192798,3193056,3193005,3193107,3192852,3192562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[3193488,3192727,3193460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3193472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[3192862,3193233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[3193209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3193341,3192754,3192808,3193270,3193404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[3193287,3193411,3193388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3193063,3192961,3193012],"length":1,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[3193111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[3196036,3194928,3193776,3196063,3194911,3194884],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":337,"address":[3194021,3195261,3194109,3194976,3195091,3193939,3193824,3195173],"length":1,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[3194079,3195231,3194346,3195498],"length":1,"stats":{"Line":4},"fn_name":null},{"line":340,"address":[3194455,3195607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[3194415,3195567,3194588,3195740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[3194746,3195898,3194797,3195949],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[3195906,3194754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[3194865,3194667,3196017,3195819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[3196527,3196080,3196486],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct\u003ctaos_query::common::value::de::value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":361,"address":[3196154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[3196200,3196446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[3196425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3196284,3196384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[1945312],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":375,"address":[1945320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[2102512,2102516],"length":1,"stats":{"Line":4},"fn_name":"value_de_value"},{"line":387,"address":[2102935,2102958,2102656],"length":1,"stats":{"Line":1},"fn_name":"value_de_value"},{"line":401,"address":[2108972,2102946,2105765,2104534,2103005,2105458,2107904,2103612,2106426,2104227,2105152,2107518,2103306,2102695,2104848,2106074,2103919,2102669,2106779,2107132,2108290],"length":1,"stats":{"Line":21},"fn_name":null},{"line":402,"address":[2102973,2103884,2104499,2103274,2104191,2104816,2103578,2102677],"length":1,"stats":{"Line":8},"fn_name":null},{"line":403,"address":[2105730,2106042,2105120,2105424],"length":1,"stats":{"Line":4},"fn_name":null},{"line":404,"address":[2106698,2106346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[2108176,2107051,2107404,2107790],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[2108562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[2109268,2109264],"length":1,"stats":{"Line":4},"fn_name":"de_value_as_inner"},{"line":411,"address":[2112751,2112778,2109408],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":424,"address":[2109429,2112268,2114875,2113899,2112873,2114341,2114967,2110658,2112475,2109637,2110913,2111171,2110142,2113704,2113807,2111428,2110399,2112980,2109888,2114238,2111973,2112368,2113335,2111692,2112762,2113566,2114433,2114772],"length":1,"stats":{"Line":21},"fn_name":null},{"line":425,"address":[2109421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[2109621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2109870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[2110123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[2110378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2110642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[2110895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[2111152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[2111408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[2111667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[2111948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[2112226,2112312,2112449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":437,"address":[2112793,2112954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[2113271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[2113528,2113856,2113795,2113615],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[2114124,2114329,2114390],"length":1,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[2114658,2114863,2114924],"length":1,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[2115200,2115204],"length":1,"stats":{"Line":4},"fn_name":"de_str"},{"line":446,"address":[2115344,2115515],"length":1,"stats":{"Line":1},"fn_name":"de_str"},{"line":473,"address":[2115572,2116357,2119493,2119590,2115383,2120411,2116938,2116161,2117344,2115967,2118128,2115769,2115548,2120515,2120985,2116752,2121093,2118541,2118645,2119999,2115351,2116554,2118746,2120616,2117736],"length":1,"stats":{"Line":18},"fn_name":null},{"line":474,"address":[2115367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[2115554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[2115750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[2115947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[2116145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[2116339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2116535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[2116732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[2116930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[2117280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[2117655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[2118047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[2118623,2118689,2118421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[2119035,2119634,2119583],"length":1,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[2120291,2120559,2120493],"length":1,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[2120905,2121067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[2121376,2121380],"length":1,"stats":{"Line":4},"fn_name":"de_json"},{"line":496,"address":[2122071,2121520,2122029],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":507,"address":[2121771,2121527,2121574,2122040],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[2121535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[2121744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[2122663,2122735,2122437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[2122086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2122695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2122628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[2123364,2123360],"length":1,"stats":{"Line":4},"fn_name":"de_newtype_struct"},{"line":527,"address":[2123504,2124042,2124068],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":539,"address":[2124053,2123637,2123826,2123754],"length":1,"stats":{"Line":3},"fn_name":null},{"line":540,"address":[2123517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[2123719,2123786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[2124443,2124083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[2124708,2124487,2124388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[2124752,2124651,2124975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[2125019,2124917,2125243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[2125287,2125184,2125509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[2141387,2129044,2131102,2148932,2138646,2147564,2142074,2129729,2131786,2145503,2167447,2150305,2139333,2128361,2126988,2133847,2137960,2144819,2150988,2125452,2155791,2156475,2159904,2153730,2157161,2137275,2142758,2166763,2163331,2125560,2127674,2149618,2164018,2153046,2155103,2132472,2161277,2126303,2135904,2136592,2154416,2164702,2165388,2166075,2140701,2169254,2125620,2146189,2158536,2135217,2143444,2133159,2152359,2161960,2162645,2168127,2146876,2168760,2130415,2148247,2140016,2151673,2160590,2144131,2159219,2134531,2157848],"length":1,"stats":{"Line":66},"fn_name":null}],"covered":155,"coverable":216},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value.rs"],"content":"use std::{borrow::Cow, fmt::Display, str::Utf8Error};\n\nuse rust_decimal::prelude::*;\nuse serde::{Deserialize, Serialize};\n\nuse super::{Timestamp, Ty};\n\n#[derive(Debug, Clone)]\npub enum BorrowedValue\u003c'b\u003e {\n    Null,        // 0\n    Bool(bool),  // 1\n    TinyInt(i8), // 2\n    SmallInt(i16),\n    Int(i32),\n    BigInt(i64),\n    Float(f32),\n    Double(f64),\n    VarChar(\u0026'b str),\n    Timestamp(Timestamp),\n    NChar(Cow\u003c'b, str\u003e),\n    UTinyInt(u8),\n    USmallInt(u16),\n    UInt(u32),\n    UBigInt(u64), // 14\n    Json(Cow\u003c'b, [u8]\u003e),\n    VarBinary(\u0026'b [u8]),\n    Decimal(Decimal),\n    Blob(\u0026'b [u8]),\n    MediumBlob(\u0026'b [u8]),\n}\n\nimpl\u003c'b\u003e BorrowedValue\u003c'b\u003e {\n    /// The data type of this value.\n    pub const fn ty(\u0026self) -\u003e Ty {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Ty::Null,\n            Bool(_) =\u003e Ty::Bool,\n            TinyInt(_) =\u003e Ty::TinyInt,\n            SmallInt(_) =\u003e Ty::SmallInt,\n            Int(_) =\u003e Ty::Int,\n            BigInt(_) =\u003e Ty::BigInt,\n            UTinyInt(_) =\u003e Ty::UTinyInt,\n            USmallInt(_) =\u003e Ty::USmallInt,\n            UInt(_) =\u003e Ty::UInt,\n            UBigInt(_) =\u003e Ty::UBigInt,\n            Float(_) =\u003e Ty::Float,\n            Double(_) =\u003e Ty::Double,\n            VarChar(_) =\u003e Ty::VarChar,\n            Timestamp(_) =\u003e Ty::Timestamp,\n            Json(_) =\u003e Ty::Json,\n            NChar(_) =\u003e Ty::NChar,\n            VarBinary(_) =\u003e Ty::VarBinary,\n            Decimal(_) =\u003e Ty::Decimal,\n            Blob(_) =\u003e Ty::Blob,\n            MediumBlob(_) =\u003e Ty::MediumBlob,\n        }\n    }\n\n    /// Check if the value is null.\n    pub const fn is_null(\u0026self) -\u003e bool {\n        matches!(self, BorrowedValue::Null)\n    }\n    /// Only VarChar, NChar, Json could be treated as [\u0026str].\n    fn strict_as_str(\u0026self) -\u003e \u0026str {\n        use BorrowedValue::*;\n        match self {\n            VarChar(v) =\u003e *v,\n            NChar(v) =\u003e \u0026v,\n            Null =\u003e panic!(\"expect str but value is null\"),\n            Timestamp(_) =\u003e panic!(\"expect str but value is timestamp\"),\n            _ =\u003e panic!(\"expect str but only varchar/binary/nchar is supported\"),\n        }\n    }\n    pub fn to_string(\u0026self) -\u003e Result\u003cString, Utf8Error\u003e {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Ok(String::new()),\n            VarChar(v) =\u003e Ok(v.to_string()),\n            Json(v) =\u003e Ok(unsafe { std::str::from_utf8_unchecked(v) }.to_string()),\n            NChar(v) =\u003e Ok(v.to_string()),\n            TinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            SmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            Int(v) =\u003e Ok(format!(\"{v}\")),\n            BigInt(v) =\u003e Ok(format!(\"{v}\")),\n            UTinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            USmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            UInt(v) =\u003e Ok(format!(\"{v}\")),\n            UBigInt(v) =\u003e Ok(format!(\"{v}\")),\n            Float(v) =\u003e Ok(format!(\"{v}\")),\n            Double(v) =\u003e Ok(format!(\"{v}\")),\n            Timestamp(v) =\u003e Ok(v\n                .to_naive_datetime()\n                .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                .to_string()),\n            _ =\u003e unreachable!(\"un supported type to string\"),\n        }\n    }\n\n    pub fn to_value(\u0026self) -\u003e Value {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Value::Null,\n            Bool(v) =\u003e Value::Bool(*v),\n            TinyInt(v) =\u003e Value::TinyInt(*v),\n            SmallInt(v) =\u003e Value::SmallInt(*v),\n            Int(v) =\u003e Value::Int(*v),\n            BigInt(v) =\u003e Value::BigInt(*v),\n            UTinyInt(v) =\u003e Value::UTinyInt(*v),\n            USmallInt(v) =\u003e Value::USmallInt(*v),\n            UInt(v) =\u003e Value::UInt(*v),\n            UBigInt(v) =\u003e Value::UBigInt(*v),\n            Float(v) =\u003e Value::Float(*v),\n            Double(v) =\u003e Value::Double(*v),\n            VarChar(v) =\u003e Value::VarChar(v.to_string()),\n            Timestamp(v) =\u003e Value::Timestamp(*v),\n            Json(v) =\u003e {\n                Value::Json(serde_json::from_slice(v).expect(\"json should always be deserialized\"))\n            }\n            NChar(str) =\u003e Value::NChar(str.to_string()),\n            VarBinary(_) =\u003e todo!(),\n            Decimal(_) =\u003e todo!(),\n            Blob(_) =\u003e todo!(),\n            MediumBlob(_) =\u003e todo!(),\n        }\n    }\n\n    #[inline]\n    pub fn into_value(self) -\u003e Value {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Value::Null,\n            Bool(v) =\u003e Value::Bool(v),\n            TinyInt(v) =\u003e Value::TinyInt(v),\n            SmallInt(v) =\u003e Value::SmallInt(v),\n            Int(v) =\u003e Value::Int(v),\n            BigInt(v) =\u003e Value::BigInt(v),\n            UTinyInt(v) =\u003e Value::UTinyInt(v),\n            USmallInt(v) =\u003e Value::USmallInt(v),\n            UInt(v) =\u003e Value::UInt(v),\n            UBigInt(v) =\u003e Value::UBigInt(v),\n            Float(v) =\u003e Value::Float(v),\n            Double(v) =\u003e Value::Double(v),\n            VarChar(v) =\u003e Value::VarChar(v.to_string()),\n            Timestamp(v) =\u003e Value::Timestamp(v),\n            Json(v) =\u003e {\n                Value::Json(serde_json::from_slice(\u0026v).expect(\"json should always be deserialized\"))\n            }\n            NChar(str) =\u003e Value::NChar(str.to_string()),\n            VarBinary(_) =\u003e todo!(),\n            Decimal(_) =\u003e todo!(),\n            Blob(_) =\u003e todo!(),\n            MediumBlob(_) =\u003e todo!(),\n        }\n    }\n}\n\nunsafe impl\u003c'b\u003e Send for BorrowedValue\u003c'b\u003e {}\n\n// #[derive(Debug, Clone)]\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\npub enum Value {\n    Null,        // 0\n    Bool(bool),  // 1\n    TinyInt(i8), // 2\n    SmallInt(i16),\n    Int(i32),\n    BigInt(i64),\n    Float(f32),\n    Double(f64),\n    VarChar(String),\n    Timestamp(Timestamp),\n    NChar(String),\n    UTinyInt(u8),\n    USmallInt(u16),\n    UInt(u32),\n    UBigInt(u64), // 14\n    Json(serde_json::Value),\n    VarBinary(Vec\u003cu8\u003e),\n    Decimal(Decimal),\n    Blob(Vec\u003cu8\u003e),\n    MediumBlob(Vec\u003cu8\u003e),\n}\n\nimpl Display for Value {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        todo!()\n    }\n}\n\nimpl Value {\n    /// The data type of this value.\n    pub const fn ty(\u0026self) -\u003e Ty {\n        use Value::*;\n        match self {\n            Null =\u003e Ty::Null,\n            Bool(_) =\u003e Ty::Bool,\n            TinyInt(_) =\u003e Ty::TinyInt,\n            SmallInt(_) =\u003e Ty::SmallInt,\n            Int(_) =\u003e Ty::Int,\n            BigInt(_) =\u003e Ty::BigInt,\n            UTinyInt(_) =\u003e Ty::UTinyInt,\n            USmallInt(_) =\u003e Ty::USmallInt,\n            UInt(_) =\u003e Ty::UInt,\n            UBigInt(_) =\u003e Ty::UBigInt,\n            Float(_) =\u003e Ty::Float,\n            Double(_) =\u003e Ty::Double,\n            VarChar(_) =\u003e Ty::VarChar,\n            Timestamp(_) =\u003e Ty::Timestamp,\n            Json(_) =\u003e Ty::Json,\n            NChar(_) =\u003e Ty::NChar,\n            VarBinary(_) =\u003e Ty::VarBinary,\n            Decimal(_) =\u003e Ty::Decimal,\n            Blob(_) =\u003e Ty::Blob,\n            MediumBlob(_) =\u003e Ty::MediumBlob,\n        }\n    }\n\n    pub fn to_borrowed_value(\u0026self) -\u003e BorrowedValue {\n        use Value::*;\n        match self {\n            Null =\u003e BorrowedValue::Null,\n            Bool(v) =\u003e BorrowedValue::Bool(*v),\n            TinyInt(v) =\u003e BorrowedValue::TinyInt(*v),\n            SmallInt(v) =\u003e BorrowedValue::SmallInt(*v),\n            Int(v) =\u003e BorrowedValue::Int(*v),\n            BigInt(v) =\u003e BorrowedValue::BigInt(*v),\n            UTinyInt(v) =\u003e BorrowedValue::UTinyInt(*v),\n            USmallInt(v) =\u003e BorrowedValue::USmallInt(*v),\n            UInt(v) =\u003e BorrowedValue::UInt(*v),\n            UBigInt(v) =\u003e BorrowedValue::UBigInt(*v),\n            Float(v) =\u003e BorrowedValue::Float(*v),\n            Double(v) =\u003e BorrowedValue::Double(*v),\n            VarChar(v) =\u003e BorrowedValue::VarChar(v),\n            Timestamp(v) =\u003e BorrowedValue::Timestamp(*v),\n            Json(j) =\u003e BorrowedValue::Json(j.to_string().into_bytes().into()),\n            NChar(v) =\u003e BorrowedValue::NChar(v.as_str().into()),\n            VarBinary(v) =\u003e BorrowedValue::VarBinary(v),\n            Decimal(v) =\u003e BorrowedValue::Decimal(*v),\n            Blob(v) =\u003e BorrowedValue::Blob(v),\n            MediumBlob(v) =\u003e BorrowedValue::MediumBlob(v),\n        }\n    }\n\n    /// Check if the value is null.\n    pub const fn is_null(\u0026self) -\u003e bool {\n        matches!(self, Value::Null)\n    }\n    /// Only VarChar, NChar, Json could be treated as [\u0026str].\n    pub fn strict_as_str(\u0026self) -\u003e \u0026str {\n        use Value::*;\n        match self {\n            VarChar(v) =\u003e v.as_str(),\n            NChar(v) =\u003e v.as_str(),\n            Json(v) =\u003e v.as_str().expect(\"invalid str type\"),\n            Null =\u003e \"Null\",\n            Timestamp(_) =\u003e panic!(\"expect str but value is timestamp\"),\n            _ =\u003e panic!(\"expect str but only varchar/binary/json/nchar is supported\"),\n        }\n    }\n\n    pub fn to_sql_value(\u0026self) -\u003e String {\n        use Value::*;\n        match self {\n            Null =\u003e \"NULL\".to_string(),\n            Bool(v) =\u003e format!(\"{v}\"),\n            TinyInt(v) =\u003e format!(\"{v}\"),\n            SmallInt(v) =\u003e format!(\"{v}\"),\n            Int(v) =\u003e format!(\"{v}\"),\n            BigInt(v) =\u003e format!(\"{v}\"),\n            Float(v) =\u003e format!(\"{v}\"),\n            Double(v) =\u003e format!(\"{v}\"),\n            VarChar(v) =\u003e format!(\"\\\"{}\\\"\", v.escape_debug()),\n            Timestamp(v) =\u003e format!(\"{}\", v.as_raw_i64()),\n            NChar(v) =\u003e format!(\"\\\"{}\\\"\", v.escape_debug()),\n            UTinyInt(v) =\u003e format!(\"{v}\"),\n            USmallInt(v) =\u003e format!(\"{v}\"),\n            UInt(v) =\u003e format!(\"{v}\"),\n            UBigInt(v) =\u003e format!(\"{v}\"),\n            Json(v) =\u003e format!(\"\\\"{}\\\"\", v),\n            VarBinary(_) =\u003e todo!(),\n            Decimal(_) =\u003e todo!(),\n            Blob(_) =\u003e todo!(),\n            MediumBlob(_) =\u003e todo!(),\n        }\n    }\n\n    pub fn to_string(\u0026self) -\u003e Result\u003cString, Utf8Error\u003e {\n        use Value::*;\n        match self {\n            Null =\u003e Ok(String::new()),\n            VarChar(v) =\u003e Ok(v.to_string()),\n            Json(v) =\u003e Ok(v.to_string()),\n            NChar(v) =\u003e Ok(v.to_string()),\n            TinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            SmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            Int(v) =\u003e Ok(format!(\"{v}\")),\n            BigInt(v) =\u003e Ok(format!(\"{v}\")),\n            UTinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            USmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            UInt(v) =\u003e Ok(format!(\"{v}\")),\n            UBigInt(v) =\u003e Ok(format!(\"{v}\")),\n            Float(v) =\u003e Ok(format!(\"{v}\")),\n            Double(v) =\u003e Ok(format!(\"{v}\")),\n            Timestamp(v) =\u003e Ok(v\n                .to_naive_datetime()\n                .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                .to_string()),\n            _ =\u003e unreachable!(\"un supported type to string\"),\n        }\n    }\n}\n\nmod de;\n","traces":[{"line":34,"address":[1930880],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":36,"address":[1930889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1930918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1930928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1930935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[1930942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1930949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1930956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1930998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1931005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1931012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1931019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1930963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1930970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1930977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1930984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1931026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1930991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1931033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1931040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1931047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1931054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1931072],"length":1,"stats":{"Line":1},"fn_name":"is_null"},{"line":62,"address":[1931081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1931120],"length":1,"stats":{"Line":0},"fn_name":"strict_as_str"},{"line":67,"address":[1931351,1931140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1931261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1931337,1931403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1931454,1931217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1931296,1931431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1931175,1931368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1933506,1931488],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":77,"address":[1931527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1931610,1934754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1933540,1931960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1932424,1932271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1932037,1933287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1934568,1931636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1934374,1931691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1931746,1934180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1933986,1931801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1932075,1933101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1932124,1932913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1932173,1932725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1932222,1932537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1933792,1931856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1931911,1933598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1931999,1933335,1933444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1933487,1933395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1934816],"length":1,"stats":{"Line":0},"fn_name":"to_value"},{"line":102,"address":[1934846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1934882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1934900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1934942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1934981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1935022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1935061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1935305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1935344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1935385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1935424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1935102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1935145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1935772,1935183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1935221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1935460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1935618,1935472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1935265,1935726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1935808,1936747],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":131,"address":[1935830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1935866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1935884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1935923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1935954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1935988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1936019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1936276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1936307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1936341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1936372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1936053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1936090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1936122,1936892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1936171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1936401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1936619,1936419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1936786,1936216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1936928],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":193,"address":[1936976],"length":1,"stats":{"Line":1},"fn_name":"ty"},{"line":195,"address":[1936985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1937014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1937024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1937031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1937038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1937045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1937052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1937094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1937101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1937108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1937115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1937059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1937066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1937073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1937080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1937122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1937087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1937129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1937136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1937143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[1937150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1937168],"length":1,"stats":{"Line":0},"fn_name":"to_borrowed_value"},{"line":221,"address":[1937198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1937234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1937252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1937294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1937333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1937374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1937413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1937663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1937702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[1937743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1937782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1937454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1937497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[1937535,1938326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1937577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1938128,1937818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1937621,1938236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1938115,1937854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[1937897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1937970,1938087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[1938005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1938352],"length":1,"stats":{"Line":1},"fn_name":"is_null"},{"line":247,"address":[1938361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1938400],"length":1,"stats":{"Line":0},"fn_name":"strict_as_str"},{"line":252,"address":[1938420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[1938835,1938528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1938790,1938604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1938707,1938641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1938497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1938802,1938560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1938671,1938455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1938848],"length":1,"stats":{"Line":0},"fn_name":"to_sql_value"},{"line":264,"address":[1938887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1938932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[1941886,1938962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[1939017,1941748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1939072,1941610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[1939127,1941472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1941334,1939182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[1939237,1941196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1939292,1941058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1940870,1939347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1939393,1940698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1939431,1940526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1939477,1940388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[1940253,1939529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1940121,1939578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1939989,1939627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1939676,1939844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1943971,1942016],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":290,"address":[1942055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1942138,1945207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1942476,1944005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[1942933,1942786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1942552,1943752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[1942164,1945021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1942219,1944827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1944633,1942274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1944439,1942329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[1942590,1943566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1942639,1943378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[1942688,1943190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1943002,1942737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[1942378,1944251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1944063,1942427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1943909,1942514,1943800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[1943860,1943952],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":25,"coverable":180},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","de","mod.rs"],"content":"use std::any::type_name;\nuse std::marker::PhantomData;\n\nuse serde::de::{DeserializeSeed, IntoDeserializer, MapAccess, SeqAccess, Visitor};\nuse serde::Deserializer;\n\nuse serde::de::value::Error;\n\nuse crate::common::BorrowedValue;\nuse crate::Field;\n\n/// Row-based deserializer helper.\n///\n/// 'b: field lifetime may go across the whole query.\npub(crate) struct RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    inner: \u003cR as IntoIterator\u003e::IntoIter,\n    value: Option\u003cBorrowedValue\u003c'b\u003e\u003e,\n    _marker: PhantomData\u003c\u0026'b u8\u003e,\n}\n\nimpl\u003c'b, R\u003e From\u003cR\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    fn from(input: R) -\u003e Self {\n        Self {\n            inner: input.into_iter(),\n            value: None,\n            _marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'b, R\u003e RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    fn next_value(\u0026mut self) -\u003e Option\u003cBorrowedValue\u003c'b\u003e\u003e {\n        self.inner.next().map(|(_, v)| v)\n    }\n}\n\nimpl\u003c'de, 'b: 'de, R\u003e MapAccess\u003c'de\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.inner.next() {\n            Some((field, value)) =\u003e {\n                self.value = Some(value);\n                let field = \u0026*field;\n                seed.deserialize(field.name().into_deserializer()).map(Some)\n            }\n            _ =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let value = self.value.take().unwrap(); // always be here, so it's safe to unwrap\n\n        log::trace!(\"target value: {:?}\", type_name::\u003cV::Value\u003e());\n        seed.deserialize(value)\n            .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n    }\n}\n\nimpl\u003c'de, 'b: 'de, R\u003e SeqAccess\u003c'de\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    type Error = Error;\n\n    fn next_element_seed\u003cS\u003e(\u0026mut self, seed: S) -\u003e Result\u003cOption\u003cS::Value\u003e, Self::Error\u003e\n    where\n        S: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.inner.next() {\n            Some((_, v)) =\u003e seed\n                .deserialize(v)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                .map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de, R\u003e Deserializer\u003c'de\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    type Error = Error;\n\n    // Look at the input data to decide what Serde data model type to\n    // deserialize as. Not all data formats are able to support this operation.\n    // Formats that support `deserialize_any` are known as self-describing.\n    fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize any for \u003c{}\u003e\", type_name::\u003cV\u003e());\n        match self.next_value() {\n            Some(v) =\u003e v\n                .deserialize_any(visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            None =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"expect value, not none\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char bytes byte_buf enum\n        identifier ignored_any\n    }\n\n    // Refer to the \"Understanding deserializer lifetimes\" page for information\n    // about the three deserialization flavors of strings in Serde.\n    fn deserialize_str\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str for \u003c{}\u003e\", type_name::\u003cV\u003e());\n        match self.next_value() {\n            Some(v) =\u003e v\n                .deserialize_str(visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            None =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"expect value, not none\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::debug!(\"call deserialize_option for \u003c{}\u003e\", type_name::\u003cV\u003e());\n        match self.next_value() {\n            Some(v) =\u003e {\n                if v.is_null() {\n                    visitor.visit_none()\n                } else {\n                    visitor\n                        .visit_some(v)\n                        .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                }\n            }\n            _ =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"expect next value\",\n            )),\n        }\n    }\n\n    // In Serde, unit means an anonymous value containing no data.\n    fn deserialize_unit\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.next_value() {\n            Some(_v) =\u003e visitor.visit_unit(),\n            _ =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"there's no enough value\",\n            )),\n        }\n    }\n\n    // Unit struct means a named value containing no data.\n    fn deserialize_unit_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    // As is done here, serializers are encouraged to treat newtype structs as\n    // insignificant wrappers around the data they contain. That means not\n    // parsing anything other than the contained value.\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::debug!(\"deserialize_newtype_struct: {}\", _name);\n        visitor.visit_newtype_struct(self)\n    }\n\n    // Deserialization of compound types like sequences and maps happens by\n    // passing the visitor an \"Access\" object that gives it the ability to\n    // iterate through the data contained in the sequence.\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_seq(self)\n    }\n\n    // Tuples look just like sequences.\n    fn deserialize_tuple\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        // self.deserialize_any(visitor)\n        visitor.visit_seq(self)\n    }\n\n    // Tuple structs look just like sequences.\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        _len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    // Much like `deserialize_seq` but calls the visitors `visit_map` method\n    // with a `MapAccess` implementation, rather than the visitor's `visit_seq`\n    // method with a `SeqAccess` implementation.\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        // let value = visitor.visit_map(self);\n        // unimplemented!();\n        log::trace!(\"visit map for {}\", type_name::\u003cV::Value\u003e());\n        visitor.visit_map(self)\n    }\n\n    // Structs look just like maps in JSON.\n    //\n    // Notice the `fields` parameter - a \"struct\" in the Serde data model means\n    // that the `Deserialize` implementation is required to know what the fields\n    // are before even looking at the input data. Any key-value pairing in which\n    // the fields cannot be known ahead of time is probably a map.\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        _fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::debug!(\"name: {_name}, fields: {_fields:?}\");\n        self.deserialize_map(visitor)\n    }\n}\n","traces":[{"line":28,"address":[2189120,2189216],"length":1,"stats":{"Line":2},"fn_name":"from\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e"},{"line":30,"address":[3800066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[3788259,3789104,3789059,3789904,3787504,3788304],"length":1,"stats":{"Line":0},"fn_name":"next_key_seed\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos::impls::SyncBlock\u003e, core::marker::PhantomData\u003ctaos_query::helpers::describe::{impl#4}::deserialize::Meta\u003e\u003e"},{"line":56,"address":[3788423,3789134,3789223,3788334,3787534,3787623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3787667,3789267,3788467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3787729,3787904,3788704,3788529,3789549,3789329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3788796,3787996,3789641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3788846,3788004,3789649,3789691,3788046,3788804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2190429,2191242,2189658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2197601,2197632,2193894,2193168,2196896,2192377,2191680,2192416,2194633,2195424,2196160,2198337,2196865,2194672,2193936,2195388,2196129,2193132],"length":1,"stats":{"Line":0},"fn_name":"next_value_seed\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, core::marker::PhantomData\u003ctaos_query::common::ty::Ty\u003e\u003e"},{"line":70,"address":[2192441,2196266,2192525,2191786,2191705,2194781,2196921,2195530,2193961,2196185,2195449,2197002,2197657,2193186,2193270,2197738,2194042,2194697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2193614,2194981,2197770,2193305,2192725,2195863,2192560,2198071,2195120,2197850,2194074,2196599,2197034,2194375,2195642,2194236,2194154,2192119,2191980,2194816,2197196,2195562,2192643,2192864,2195724,2197335,2193470,2197932,2191898,2194899,2191818,2193388,2196298,2197114,2196378,2196460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2192334,2194590,2195782,2192038,2193832,2193528,2196810,2192783,2196074,2196518,2195333,2193077,2197546,2197990,2194294,2198282,2195039,2197254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2200032,2200762,2198718,2199632,2201172,2199557,2198800,2199232,2198368,2199150,2199957,2200356,2200432,2200848],"length":1,"stats":{"Line":5},"fn_name":"next_element_seed\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, core::marker::PhantomData\u003calloc::string::String\u003e\u003e"},{"line":88,"address":[2200872,2200456,2199256,2199656,2200125,2200941,2199325,2198824,2198893,2200525,2198461,2198392,2199725,2200056],"length":1,"stats":{"Line":12},"fn_name":null},{"line":89,"address":[2199528,2198977,2198672,2199104,2199481,2199070,2200737,2201147,2199388,2201100,2200331,2198545,2198638,2199788,2200597,2200690,2199881,2200284,2199928,2201007,2200191],"length":1,"stats":{"Line":18},"fn_name":null},{"line":90,"address":[2199015,2199826,2199426,2201045,2200229,2198583,2200635],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[2199349,2200149,2200549,2198485,2200965,2199749,2198917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[2201248,2201376,2201312],"length":1,"stats":{"Line":2},"fn_name":"deserialize_tuple\u003ctaos_query::iter::RowInBlock\u003ctaos_query::tests::Block\u003e, serde::de::impls::{impl#173}::deserialize::TupleVisitor\u003calloc::string::String, \u0026str, u8\u003e\u003e"},{"line":228,"address":[2201395,2201331,2201267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2202004,2202031,2202656,2202612,2203220,2203247,2202048,2201440,2202639],"length":1,"stats":{"Line":0},"fn_name":"deserialize_map\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, taos_query::helpers::describe::{impl#4}::deserialize::MetaVisitor\u003e"},{"line":253,"address":[2201784,2201650,2202070,2202678,2202787,2203000,2202392,2202258,2202866,2201462,2202179,2201571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[2202919,2201703,2202311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2203264,2203937,2203952,2204598,2204625,2203910],"length":1,"stats":{"Line":0},"fn_name":"deserialize_struct\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, taos_query::helpers::topic::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":272,"address":[2203997,2203424,2204343,2203506,2204194,2204112,2203309,2203655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2203574,2204262],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":65},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","database.rs"],"content":"use chrono::NaiveDateTime;\nuse paste::paste;\nuse serde::{Deserialize, Serialize};\n\nuse std::{fmt::Display, str::FromStr};\n\nuse crate::common::Precision;\n\n#[derive(Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct DatabaseProperties {\n    pub vgroups: Option\u003cu64\u003e,\n    pub replica: Option\u003cu16\u003e,\n    pub quorum: Option\u003cu16\u003e,\n    pub days: Option\u003cu16\u003e,\n    pub keep: Option\u003cString\u003e,\n    #[serde(rename = \"cache(MB)\")]\n    pub cache: Option\u003cu32\u003e,\n    pub blocks: Option\u003cu32\u003e,\n    pub minrows: Option\u003cu32\u003e,\n    pub maxrows: Option\u003cu32\u003e,\n    #[serde(rename = \"wallevel\")]\n    pub wal: Option\u003cu8\u003e,\n    pub fsync: Option\u003cu32\u003e,\n    pub comp: Option\u003cu8\u003e,\n    pub cachelast: Option\u003cu8\u003e,\n    pub precision: Option\u003cPrecision\u003e,\n    pub update: Option\u003cu8\u003e,\n}\n\nmacro_rules! _prop_builder {\n    ($($f:ident)*, $ty:ty) =\u003e {\n        $(pub fn $f(mut self, $f: $ty) -\u003e Self {\n            self.$f = Some($f);\n            self\n        })*\n    };\n}\nimpl DatabaseProperties {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    _prop_builder!(vgroups, u64);\n    _prop_builder!(cache blocks minrows maxrows fsync, u32);\n    _prop_builder!(replica quorum days, u16);\n    _prop_builder!(wal comp cachelast update, u8);\n    _prop_builder!(precision, Precision);\n    _prop_builder!(keep, String);\n}\n\nimpl Display for DatabaseProperties {\n    #[inline]\n    #[allow(unused_assignments)]\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut has_wrote = false;\n\n        macro_rules! _write_if {\n            ($($f:ident) *) =\u003e {\n                $(if let Some($f) = \u0026self.$f {\n                    if has_wrote {\n                        write!(f, \" {} {}\", paste!(stringify!([\u003c$f:upper\u003e])), $f)?;\n                    } else {\n                        write!(f, \"{} {}\", paste!(stringify!([\u003c$f:upper\u003e])), $f)?;\n                        has_wrote = true;\n                    }\n                })*\n            };\n            ('str $($s:ident) *) =\u003e {\n                $(if let Some($s) = \u0026self.$s {\n                    if has_wrote {\n                        write!(f, \" {} '{}'\", paste!(stringify!([\u003c$s:upper\u003e])), $s)?;\n                    } else {\n                        write!(f, \"{} '{}'\", paste!(stringify!([\u003c$s:upper\u003e])), $s)?;\n                        has_wrote = true;\n                    }\n                })*\n            };\n            ($($f:ident) *; 'str $($s:ident) *) =\u003e {\n                _write_if!($($f) *);\n                _write_if!('str $($s) *)\n            };\n            ($($f:ident) *; 'str $($s:ident) *; $($f2:ident) *) =\u003e {\n                _write_if!($($f) *; 'str $($s) *);\n                _write_if!($($f2) *)\n            };\n        }\n\n        // todo: keep now may fail\n        _write_if!(vgroups replica quorum days keep cache blocks minrows\n                   maxrows wal fsync comp cachelast; 'str precision; update);\n        Ok(())\n    }\n}\n\nimpl FromStr for DatabaseProperties {\n    type Err = anyhow::Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        // CREATE DATABASE log REPLICA 1 QUORUM 1 DAYS 10 KEEP 30 CACHE 1 BLOCKS 3 MINROWS 100 MAXROWS 4096 WAL 1 FSYNC 3000 COMP 2 CACHELAST 0 PRECISION 'us' UPDATE 0\n        use nom::branch::alt;\n        use nom::character::complete::*;\n        use nom::character::complete::{multispace0, multispace1};\n        use nom::character::streaming;\n        use nom::multi::many0;\n        use nom::sequence::*;\n        use nom::{bytes::complete::tag, IResult};\n\n        let mut repr = Self::new();\n\n        fn parse_name(s: \u0026str) -\u003e IResult\u003c\u0026str, \u0026str\u003e {\n            preceded(\n                tuple((multispace0, tag(\"CREATE DATABASE\"), multispace1)),\n                alphanumeric1,\n            )(s)\n        }\n\n        let s = parse_name(s).map(|s| s.0).unwrap_or(s);\n\n        fn parse_props(s: \u0026str) -\u003e IResult\u003c\u0026str, Vec\u003c(\u0026str, \u0026str)\u003e\u003e {\n            many0(separated_pair(\n                preceded(multispace0, alphanumeric1),\n                streaming::char(' '),\n                alt((\n                    alphanumeric1,\n                    delimited(char('\\''), alphanumeric1, char('\\'')),\n                )),\n            ))(s)\n        }\n\n        if let Ok((_s, props)) = dbg!(parse_props(s)) {\n            for (prop, value) in props {\n                macro_rules! _parse {\n                    ($($($f:ident) +, $t:ident);*) =\u003e {\n                        paste::paste! {\n                            match prop.to_lowercase() {\n                                $($(s if s == stringify!($f) =\u003e {\n                                    repr = repr.$f($t::from_str(value)?);\n                                },)*)*\n                                _ =\u003e (),\n                            }\n                        }\n                    }\n                }\n                _parse!(vgroups, u64;\n                        cache blocks minrows maxrows fsync, u32;\n                        replica quorum days, u16;\n                        wal comp cachelast  update, u8;\n                        keep, String;\n                        precision, Precision);\n            }\n            Ok(repr)\n        } else {\n            Ok(repr)\n        }\n    }\n}\n\n#[test]\nfn db_prop_from_str() {\n    let s = \"REPLICA 1 QUORUM 1 DAYS 10 KEEP 30 CACHE 1 BLOCKS 3 MINROWS 100 MAXROWS 4096 WAL 1 FSYNC 3000 COMP 2 CACHELAST 0 PRECISION 'us' UPDATE 0\";\n\n    let db = DatabaseProperties::from_str(s).unwrap();\n\n    let t = db.to_string();\n\n    dbg!(db);\n\n    assert_eq!(s, t);\n}\n\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct DatabaseRepr {\n    pub name: String,\n    #[serde(flatten)]\n    pub props: DatabaseProperties,\n}\n\n/// A show database representation struct.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct ShowDatabase {\n    pub name: String,\n    pub created_time: Option\u003cNaiveDateTime\u003e,\n    pub ntables: Option\u003cusize\u003e,\n    #[serde(flatten)]\n    pub props: DatabaseProperties,\n    pub status: Option\u003cString\u003e,\n}\n\nunsafe impl Send for ShowDatabase {}\n","traces":[{"line":32,"address":[8412512,8412736,8413306,8412880,8413120,8412256,8412576,8412384,8412656,8412944,8412176,8413072,8413008,8412320,8412816,8412448],"length":1,"stats":{"Line":14},"fn_name":"vgroups"},{"line":33,"address":[8413259,8412399,8412527,8412756,8412898,8412271,8412596,8412676,8412962,8412335,8412834,8412193,8413026,8413147,8412463,8413088],"length":1,"stats":{"Line":15},"fn_name":null},{"line":34,"address":[2380569,2380834,2380432,2380761,2380994,2381132,2380633,2380697,2381196,2381307,2381068,2380505,2380914,2381260,2381490],"length":1,"stats":{"Line":14},"fn_name":null},{"line":35,"address":[8412503,8413222,8413067,8412939,8412311,8412375,8412239,8412641,8412439,8413301,8412721,8412567,8412875,8413114,8412801,8413003],"length":1,"stats":{"Line":14},"fn_name":null},{"line":39,"address":[8383552],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":40,"address":[8383560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[8383584],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":55,"address":[8383629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8383637,8384055,8392735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2361216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[2361744,2362354],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":108,"address":[2361805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[8406464],"length":1,"stats":{"Line":1},"fn_name":"parse_name"},{"line":117,"address":[8393499,8393550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[8406672],"length":1,"stats":{"Line":1},"fn_name":"parse_props"},{"line":130,"address":[2362155,2362380,2362914,2374611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2362986,2363196,2374508,2364089],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[8394975,8395640,8406074,8406281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[2374532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[2363048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[2224752,2224757],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":160,"address":[2381543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[2381578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[2381659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[2381707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[2382669,2382553],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":48},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","describe.rs"],"content":"use std::{\n    fmt,\n    ops::{Deref, DerefMut},\n    str::FromStr,\n};\n\nuse serde::{\n    de::{self, MapAccess, SeqAccess, Visitor},\n    Deserialize, Deserializer, Serialize,\n};\n\nuse crate::common::Ty;\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]\npub struct Described {\n    pub field: String,\n    #[serde(rename = \"type\")]\n    pub ty: Ty,\n    pub length: usize,\n}\n\nimpl Described {\n    /// Represent the data type in sql.\n    ///\n    /// For example: \"INT\", \"VARCHAR(100)\".\n    pub fn sql_repr(\u0026self) -\u003e String {\n        let ty = self.ty;\n        if ty.is_var_type() {\n            format!(\"{} {}({})\", self.field, ty, self.length)\n        } else {\n            format!(\"{} {}\", self.field, self.ty)\n        }\n    }\n}\n#[derive(Debug, Serialize, PartialEq, Eq, Clone)]\n#[serde(tag = \"note\")]\npub enum ColumnMeta {\n    Column(Described),\n    Tag(Described),\n}\n\nimpl Deref for ColumnMeta {\n    type Target = Described;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        match self {\n            ColumnMeta::Column(v) =\u003e v,\n            ColumnMeta::Tag(v) =\u003e v,\n        }\n    }\n}\n\nimpl DerefMut for ColumnMeta {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        match self {\n            ColumnMeta::Column(v) =\u003e v,\n            ColumnMeta::Tag(v) =\u003e v,\n        }\n    }\n}\nunsafe impl Send for ColumnMeta {}\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for ColumnMeta {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        enum Meta {\n            Field,\n            Type,\n            Length,\n            Note,\n        }\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Meta {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cMeta, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Meta;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`field`, `type`, `length` or `note`\")\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cMeta, E\u003e\n                    where\n                        E: de::Error,\n                    {\n                        match value.to_lowercase().as_str() {\n                            \"field\" =\u003e Ok(Meta::Field),\n                            \"type\" =\u003e Ok(Meta::Type),\n                            \"length\" =\u003e Ok(Meta::Length),\n                            \"note\" =\u003e Ok(Meta::Note),\n                            _ =\u003e Err(de::Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct MetaVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for MetaVisitor {\n            type Value = ColumnMeta;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct ColumnMeta\")\n            }\n\n            fn visit_seq\u003cV\u003e(self, mut seq: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n            where\n                V: SeqAccess\u003c'de\u003e,\n            {\n                let field = dbg!(seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(0, \u0026self))?);\n                let ty = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(1, \u0026self))\n                    .and_then(|s| Ty::from_str(s).map_err(de::Error::custom))?;\n                let length = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(2, \u0026self))?;\n                let note: String = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(3, \u0026self))?;\n                let desc = Described { field, ty, length };\n                if note.is_empty() {\n                    Ok(ColumnMeta::Column(desc))\n                } else {\n                    Ok(ColumnMeta::Tag(desc))\n                }\n            }\n\n            fn visit_map\u003cV\u003e(self, mut map: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                let mut field = None;\n                let mut ty = None;\n                let mut length = None;\n                let mut note = None;\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Meta::Field =\u003e {\n                            if field.is_some() {\n                                return Err(de::Error::duplicate_field(\"field\"));\n                            }\n                            field = Some(map.next_value()?);\n                        }\n                        Meta::Type =\u003e {\n                            if ty.is_some() {\n                                return Err(de::Error::duplicate_field(\"type\"));\n                            }\n                            let t: Ty = map.next_value()?;\n                            ty = Some(t);\n                        }\n                        Meta::Length =\u003e {\n                            if length.is_some() {\n                                return Err(de::Error::duplicate_field(\"length\"));\n                            }\n                            length = Some(map.next_value()?);\n                        }\n                        Meta::Note =\u003e {\n                            if note.is_some() {\n                                return Err(de::Error::duplicate_field(\"note\"));\n                            }\n                            let t: String = map.next_value()?;\n                            note = Some(t.is_empty() || t == \"Column\")\n                        }\n                    }\n                }\n                let field = field.ok_or_else(|| de::Error::missing_field(\"field\"))?;\n                let ty = ty.ok_or_else(|| de::Error::missing_field(\"type\"))?;\n                let length = length.ok_or_else(|| de::Error::missing_field(\"length\"))?;\n                let desc = Described { field, ty, length };\n                let note = note.ok_or_else(|| de::Error::missing_field(\"note\"))?;\n                if note {\n                    Ok(ColumnMeta::Column(desc))\n                } else {\n                    Ok(ColumnMeta::Tag(desc))\n                }\n            }\n        }\n\n        const FIELDS: \u0026[\u0026str] = \u0026[\"field\", \"type\", \"length\", \"note\"];\n        deserializer.deserialize_struct(\"ColumnMeta\", FIELDS, MetaVisitor)\n    }\n}\nimpl ColumnMeta {\n    pub fn field(\u0026self) -\u003e \u0026str {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) =\u003e desc.field.as_str(),\n        }\n    }\n    pub fn ty(\u0026self) -\u003e Ty {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) =\u003e desc.ty,\n        }\n    }\n    pub fn length(\u0026self) -\u003e usize {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) =\u003e desc.length,\n        }\n    }\n    pub fn note(\u0026self) -\u003e \u0026str {\n        match self {\n            ColumnMeta::Tag(_) =\u003e \"TAG\",\n            _ =\u003e \"\",\n        }\n    }\n    pub fn is_tag(\u0026self) -\u003e bool {\n        matches!(self, ColumnMeta::Tag(_))\n    }\n}\n\n#[test]\nfn serde_meta() {\n    let meta = ColumnMeta::Column(Described {\n        field: \"name\".to_string(),\n        ty: Ty::BigInt,\n        length: 8,\n    });\n\n    let a = serde_json::to_string(\u0026meta).unwrap();\n\n    let d: ColumnMeta = serde_json::from_str(\u0026a).unwrap();\n\n    assert_eq!(meta, d);\n}\n//erive(Debug, Clone, Deserialize)]\n// pub struct ColumnMeta {\n//     pub name: String,\n//     pub type_: Ty,\n//     pub bytes: i16,\n// }\n// #[derive(Debug)]\n// pub struct TaosQueryData {\n//     pub column_meta: Vec\u003cColumnMeta\u003e,\n//     pub rows: Vec\u003cVec\u003cField\u003e\u003e,\n// }\n\n// #[derive(Debug)]\n// pub struct TaosDescribe {\n//     pub cols: Vec\u003cColumnMeta\u003e,\n//     pub tags: Vec\u003cColumnMeta\u003e,\n// }\n\n// impl TaosDescribe {\n//     pub fn names(\u0026self) -\u003e Vec\u003c\u0026String\u003e {\n//         self.cols\n//             .iter()\n//             .chain(self.tags.iter())\n//             .map(|t| \u0026t.name)\n//             .collect_vec()\n//     }\n\n//     pub fn col_names(\u0026self) -\u003e Vec\u003c\u0026String\u003e {\n//         self.cols.iter().map(|t| \u0026t.name).collect_vec()\n//     }\n//     pub fn tag_names(\u0026self) -\u003e Vec\u003c\u0026String\u003e {\n//         self.tags.iter().map(|t| \u0026t.name).collect_vec()\n//     }\n// }\n// impl FromStr for Ty {\n//     type Err = \u0026'static str;\n//     fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n//         match s.to_lowercase().as_str() {\n//             \"timestamp\" =\u003e Ok(Ty::Timestamp),\n//             \"bool\" =\u003e Ok(Ty::Bool),\n//             \"tinyint\" =\u003e Ok(Ty::TinyInt),\n//             \"smallint\" =\u003e Ok(Ty::SmallInt),\n//             \"int\" =\u003e Ok(Ty::Int),\n//             \"bigint\" =\u003e Ok(Ty::BigInt),\n//             \"tinyint unsigned\" =\u003e Ok(Ty::UTinyInt),\n//             \"smallint unsigned\" =\u003e Ok(Ty::USmallInt),\n//             \"int unsigned\" =\u003e Ok(Ty::UInt),\n//             \"bigint unsigned\" =\u003e Ok(Ty::UBigInt),\n//             \"float\" =\u003e Ok(Ty::Float),\n//             \"double\" =\u003e Ok(Ty::Double),\n//             \"binary\" =\u003e Ok(Ty::Binary),\n//             \"nchar\" =\u003e Ok(Ty::NChar),\n//             _ =\u003e Err(\"not a valid data type string\"),\n//         }\n//     }\n// }\n// impl From\u003cTaosQueryData\u003e for TaosDescribe {\n//     fn from(rhs: TaosQueryData) -\u003e Self {\n//         let (cols, tags): (Vec\u003c_\u003e, Vec\u003c_\u003e) = rhs\n//             .rows\n//             .iter()\n//             .partition(|row| row[3] != Field::Binary(\"TAG\".into()));\n//         Self {\n//             cols: cols\n//                 .into_iter()\n//                 .map(|row| ColumnMeta {\n//                     name: row[0].to_string(),\n//                     type_: Ty::from_str(\u0026row[1].to_string()).expect(\"from describe\"),\n//                     bytes: *row[2].as_int().unwrap() as _,\n//                 })\n//                 .collect_vec(),\n//             tags: tags\n//                 .into_iter()\n//                 .map(|row| ColumnMeta {\n//                     name: row[0].to_string(),\n//                     type_: Ty::from_str(\u0026row[1].to_string()).expect(\"from describe\"),\n//                     bytes: *row[2].as_int().unwrap() as _,\n//                 })\n//                 .collect_vec(),\n//         }\n//     }\n// }\n// impl TaosQueryData {\n//     /// Total rows count of query result\n//     pub fn rows(\u0026self) -\u003e usize {\n//         self.rows.len()\n//     }\n// }\n\n// #[derive(Debug, PartialEq, Clone)]\n// pub enum Field {\n//     Null,        // 0\n//     Bool(bool),  // 1\n//     TinyInt(i8), // 2\n//     SmallInt(i16),\n//     Int(i32),\n//     BigInt(i64),\n//     Float(f32),\n//     Double(f64),\n//     Binary(BString),\n//     Timestamp(Timestamp),\n//     NChar(String),\n//     UTinyInt(u8),\n//     USmallInt(u16),\n//     UInt(u32),\n//     UBigInt(u64), // 14\n//     Json(serde_json::Value),\n// }\n\n// impl fmt::Display for Field {\n//     fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n//         match self {\n//             Field::Null =\u003e write!(f, \"NULL\"),\n//             Field::Bool(v) =\u003e write!(f, \"{}\", v),\n//             Field::TinyInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::SmallInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::Int(v) =\u003e write!(f, \"{}\", v),\n//             Field::BigInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::Float(v) =\u003e write!(f, \"{}\", v),\n//             Field::Double(v) =\u003e write!(f, \"{}\", v),\n//             Field::Binary(v) =\u003e write!(f, \"{}\", v),\n//             Field::NChar(v) =\u003e write!(f, \"{}\", v),\n//             Field::Timestamp(v) =\u003e write!(f, \"{}\", v),\n//             Field::UTinyInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::USmallInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::UInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::UBigInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::Json(v) =\u003e write!(f, \"{}\", v),\n//         }\n//     }\n// }\n\n// impl Field {\n//     pub fn as_bool(\u0026self) -\u003e Option\u003c\u0026bool\u003e {\n//         match self {\n//             Field::Bool(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_tiny_int(\u0026self) -\u003e Option\u003c\u0026i8\u003e {\n//         match self {\n//             Field::TinyInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_small_int(\u0026self) -\u003e Option\u003c\u0026i16\u003e {\n//         match self {\n//             Field::SmallInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_int(\u0026self) -\u003e Option\u003c\u0026i32\u003e {\n//         match self {\n//             Field::Int(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_big_int(\u0026self) -\u003e Option\u003c\u0026i64\u003e {\n//         match self {\n//             Field::BigInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_float(\u0026self) -\u003e Option\u003c\u0026f32\u003e {\n//         match self {\n//             Field::Float(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_double(\u0026self) -\u003e Option\u003c\u0026f64\u003e {\n//         match self {\n//             Field::Double(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_binary(\u0026self) -\u003e Option\u003c\u0026BStr\u003e {\n//         match self {\n//             Field::Binary(v) =\u003e Some(v.as_ref()),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_nchar(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n//         match self {\n//             Field::NChar(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n\n//     /// BINARY or NCHAR typed string reference\n//     pub fn as_string(\u0026self) -\u003e Option\u003cString\u003e {\n//         match self {\n//             Field::Binary(v) =\u003e Some(v.to_string()),\n//             Field::NChar(v) =\u003e Some(v.to_string()),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_timestamp(\u0026self) -\u003e Option\u003c\u0026Timestamp\u003e {\n//         match self {\n//             Field::Timestamp(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_raw_timestamp(\u0026self) -\u003e Option\u003ci64\u003e {\n//         match self {\n//             Field::Timestamp(v) =\u003e Some(v.as_raw_timestamp()),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_tiny_int(\u0026self) -\u003e Option\u003c\u0026u8\u003e {\n//         match self {\n//             Field::UTinyInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_samll_int(\u0026self) -\u003e Option\u003c\u0026u16\u003e {\n//         match self {\n//             Field::USmallInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_int(\u0026self) -\u003e Option\u003c\u0026u32\u003e {\n//         match self {\n//             Field::UInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_big_int(\u0026self) -\u003e Option\u003c\u0026u64\u003e {\n//         match self {\n//             Field::UBigInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n\n//     pub fn as_json(\u0026self) -\u003e Option\u003c\u0026serde_json::Value\u003e {\n//         match self {\n//             Field::Json(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n\n//     pub fn data_type(\u0026self) -\u003e Ty {\n//         match self {\n//             Field::Null =\u003e Ty::Null,\n//             Field::Bool(_v) =\u003e Ty::Bool,\n//             Field::TinyInt(_v) =\u003e Ty::TinyInt,\n//             Field::SmallInt(_v) =\u003e Ty::SmallInt,\n//             Field::Int(_v) =\u003e Ty::Int,\n//             Field::BigInt(_v) =\u003e Ty::BigInt,\n//             Field::Float(_v) =\u003e Ty::Float,\n//             Field::Double(_v) =\u003e Ty::Double,\n//             Field::Binary(_v) =\u003e Ty::Binary,\n//             Field::NChar(_v) =\u003e Ty::NChar,\n//             Field::Timestamp(_v) =\u003e Ty::Timestamp,\n//             Field::UTinyInt(_v) =\u003e Ty::UTinyInt,\n//             Field::USmallInt(_v) =\u003e Ty::USmallInt,\n//             Field::UInt(_v) =\u003e Ty::UInt,\n//             Field::UBigInt(_v) =\u003e Ty::UBigInt,\n//             Field::Json(_v) =\u003e Ty::Json,\n//         }\n//     }\n// }\n\n// pub trait IntoField {\n//     fn into_field(self) -\u003e Field;\n// }\n\n// macro_rules! _impl_primitive_type {\n//     ($ty:ty, $target:ident, $v:expr) =\u003e {\n//         impl IntoField for $ty {\n//             fn into_field(self) -\u003e Field {\n//                 Field::$target(self)\n//             }\n//         }\n//         paste! {\n//             #[test]\n//             fn [\u003ctest_ $ty:snake\u003e]() {\n//                 let v: $ty = $v;\n//                 assert_eq!(v.clone().into_field(), Field::$target(v));\n//             }\n//         }\n//     };\n// }\n\n// _impl_primitive_type!(bool, Bool, true);\n// _impl_primitive_type!(i8, TinyInt, 0);\n// _impl_primitive_type!(i16, SmallInt, 0);\n// _impl_primitive_type!(i32, Int, 0);\n// _impl_primitive_type!(i64, BigInt, 0);\n// _impl_primitive_type!(u8, UTinyInt, 0);\n// _impl_primitive_type!(u16, USmallInt, 0);\n// _impl_primitive_type!(u32, UInt, 0);\n// _impl_primitive_type!(u64, UBigInt, 0);\n// _impl_primitive_type!(f32, Float, 0.);\n// _impl_primitive_type!(f64, Double, 0.);\n// _impl_primitive_type!(BString, Binary, \"A\".into());\n// _impl_primitive_type!(String, NChar, \"A\".into());\n// // _impl_primitive_type!(serde_json::Value, Json, );\n\n// impl IntoField for \u0026BStr {\n//     fn into_field(self) -\u003e Field {\n//         self.to_owned().into_field()\n//     }\n// }\n// impl IntoField for \u0026str {\n//     fn into_field(self) -\u003e Field {\n//         self.to_owned().into_field()\n//     }\n// }\n\n// #[cfg(test)]\n// mod test {\n//     use crate::test::taos;\n//     use crate::*;\n\n//     #[tokio::test]\n//     #[proc_test_catalog::test_catalogue]\n//     /// Test describe sql\n//     async fn test_describe() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{}\", db);\n//         let taos = taos()?;\n//         let desc = taos.describe(\"log.dn\").await?;\n//         assert_eq!(desc.cols.len(), 15);\n//         assert_eq!(desc.tags.len(), 2);\n//         Ok(())\n//     }\n// }\n","traces":[{"line":26,"address":[3292352],"length":1,"stats":{"Line":0},"fn_name":"sql_repr"},{"line":27,"address":[3292382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3292389,3292859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3292444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3292418,3292692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3292864],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":46,"address":[3292877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3292895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3292915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3292944],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":55,"address":[3293009,3292957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3292975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3292995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3341280,3341360],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3341424,3341472],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003cserde::de::value::StrDeserializer\u003cserde::de::value::Error\u003e\u003e"},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3293024],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":85,"address":[3293051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3341991,3342507,3342032,3341504],"length":1,"stats":{"Line":1},"fn_name":"visit_str\u003cserde::de::value::Error\u003e"},{"line":92,"address":[3341547,3342159,3342075,3341631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[3341647,3341718,3342246,3342175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[3342218,3341753,3342325,3341797,3342281,3341690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[3341769,3341862,3341818,3342346,3342390,3342297],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[3341941,3342414,3342465,3342362,3341834,3341886],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[3341975,3341902,3342430,3342495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3341445,3341489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3293088],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":112,"address":[3293115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3343707,3345387,3342560],"length":1,"stats":{"Line":0},"fn_name":"visit_seq\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":119,"address":[3343194,3342782,3342837,3342878,3342602,3342676,3342901,3343253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3342821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3342851,3342774,3343208,3353584,3353596,3343178],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":122,"address":[3343775,3343700,3343896,3343937,3344080,3343960,3343849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3345420,3343841,3345408],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":125,"address":[3345456,3345480,3344094,3344064,3343910],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":126,"address":[3344326,3344164,3344238,3344285,3344349,3344049,3344451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3344435,3344465,3345532,3344299,3344230,3345520],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":129,"address":[3344420,3344619,3344715,3344513,3344738,3344970,3344674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3344688,3344611,3345580,3345568,3344954,3344984],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":132,"address":[3344840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3344935,3345073,3345218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3345220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3345105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3350203,3345616,3352229,3348774,3348800,3346920],"length":1,"stats":{"Line":1},"fn_name":"visit_map\u003cserde_json::de::MapAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":144,"address":[3348822,3345646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[3345679,3348855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[3345684,3348863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[3345696,3348875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[3351088,3349126,3345717,3348896,3345781,3345928,3347758,3348960],"length":1,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[3347239,3350532,3349140,3345942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[3352205,3348750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[3347241,3350534,3351666,3348269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[3351692,3348295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[3352078,3348288,3348365,3351685,3351758,3348629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[3350565,3348033,3347269,3351397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[3348059,3351423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[3351584,3348203,3351416,3351507,3348129,3348052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[3348175,3351553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[3351305,3347957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[3351097,3347283,3350579,3347767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3351123,3347793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3347786,3347967,3351116,3351191,3347863,3351315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3350605,3347309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[3347362,3350658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3347355,3347432,3350860,3350651,3347546,3350726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[3347656,3347530,3350986,3351077,3347747,3350844],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[3352256,3345976,3352260,3352304,3352308,3346172,3349174,3349383],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}\u003cserde_json::de::MapAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":179,"address":[3346301,3352352,3352400,3349528,3352356,3349614,3346147,3346387,3352404,3349352],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":180,"address":[3352500,3352496,3352448,3349708,3346351,3346481,3349578,3352452,3346653,3349900],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":181,"address":[3346538,3349785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[3350112,3352592,3350018,3346625,3352596,3352544,3346845,3346771,3352548,3349872],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":183,"address":[3350384,3350094,3346827,3347101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[3347103,3350386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[3346994,3350277],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3341294,3341377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[3293152],"length":1,"stats":{"Line":0},"fn_name":"field"},{"line":197,"address":[3293194,3293166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3293185,3293201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3293248],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":202,"address":[3293261,3293288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3293279,3293294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3293328],"length":1,"stats":{"Line":0},"fn_name":"length"},{"line":207,"address":[3293341,3293368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3293374,3293359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[3293408],"length":1,"stats":{"Line":0},"fn_name":"note"},{"line":212,"address":[3293417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[3293423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3293445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[3293488],"length":1,"stats":{"Line":0},"fn_name":"is_tag"},{"line":218,"address":[3293497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[3295488,3296058,3296016],"length":1,"stats":{"Line":3},"fn_name":"serde_meta"},{"line":224,"address":[3295520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[3295495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[3295662,3295618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[3295776,3295700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[3295970,3295818,3295939],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":42,"coverable":102},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","mod.rs"],"content":"mod database;\nmod describe;\nmod topic;\n\npub use database::*;\npub use describe::*;\npub use topic::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","topic.rs"],"content":"use chrono::NaiveDateTime;\nuse paste::paste;\nuse serde::{Deserialize, Serialize};\n\nuse std::{fmt::Display, str::FromStr};\n\nuse crate::common::{Precision, Timestamp};\n\n/// Information for `show topics` record.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct Topic {\n    topic_name: String,\n    db_name: String,\n    create_time: Timestamp,\n    sql: String,\n}\n\nimpl Topic {\n    /// Topic name.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.topic_name\n    }\n\n    /// Database name of the topic.\n    pub fn db_name(\u0026self) -\u003e \u0026str {\n        \u0026self.db_name\n    }\n\n    /// Created time of the topic\n    pub fn create_time(\u0026self) -\u003e NaiveDateTime {\n        self.create_time.to_naive_datetime()\n    }\n\n    /// The create sql for the topic\n    pub fn sql(\u0026self) -\u003e \u0026str {\n        \u0026self.sql\n    }\n\n    /// Check if the topic is a database-scope topic, otherwise is table-scope topic.\n    pub fn is_db_topic(\u0026self) -\u003e bool {\n        self.sql.contains(\"as database\")\n    }\n\n    pub fn is_stable_topic(\u0026self) -\u003e bool {\n        self.sql.contains(\"as stable\")\n    }\n}\n","traces":[{"line":20,"address":[2385296],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":21,"address":[2385305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2385344],"length":1,"stats":{"Line":0},"fn_name":"db_name"},{"line":26,"address":[2385353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2385392],"length":1,"stats":{"Line":0},"fn_name":"create_time"},{"line":31,"address":[2385409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2385440],"length":1,"stats":{"Line":0},"fn_name":"sql"},{"line":36,"address":[2385449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2385488],"length":1,"stats":{"Line":0},"fn_name":"is_db_topic"},{"line":41,"address":[2385497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2385568],"length":1,"stats":{"Line":0},"fn_name":"is_stable_topic"},{"line":45,"address":[2385577],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","insert","mod.rs"],"content":"use std::fmt::Debug;\n\npub trait Insertable: Debug {\n    type Error;\n    fn insert(\u0026self, sql: \u0026str) -\u003e Result\u003cusize, Self::Error\u003e;\n\n    fn insert_raw(\u0026self, table: \u0026str, raw: \u0026[u8]) -\u003e Result\u003cusize, Self::Error\u003e;\n\n    fn insert_named\u003c'a\u003e(\u0026self, table: \u0026str, fields: [\u0026dyn IntoNamedField\u003c'a\u003e]);\n\n    // fn insert_many\u003cT: Any\u003e(\u0026self, table: \u0026str, records: \u0026[dyn Any]) -\u003e Result\u003cusize, Self::Error\u003e;\n\n    // fn insert_progressive(\u0026self, stable: \u0026str, ) -\u003e Inserter;\n}\n\npub trait IntoField: Debug {}\n\nimpl IntoField for i32 {}\nimpl IntoField for f32 {}\nimpl IntoField for f64 {}\n\npub trait IntoNamedField\u003c'a\u003e: IntoField {\n    fn name(\u0026'a self) -\u003e \u0026'a str;\n}\nimpl\u003cT: IntoField\u003e IntoField for (\u0026str, T) {}\n\nimpl\u003c'a, T: IntoField\u003e IntoNamedField\u003c'a\u003e for (\u0026str, T) {\n    fn name(\u0026'a self) -\u003e \u0026'a str {\n        self.0\n    }\n}\n\n/// Insert macros.\n///\n/// insert! {\n///    \"ts\" =\u003e [\"2022-10-10T10:10:10.000\", \"2022-10-10T10:10:11\", \"2022-10-10T10:10:12\"],\n///    \"n\" =\u003e [0, 1, 2],\n///    \"f\" =\u003e [0.1, 0.2, 0.3],\n///    \"g\" =\u003e [\"abc\", \"def\", \"desc\"]: VarChar,\n/// }\n// macro_rules! {\n//     ($conn:expr, $sql:expr, $raw: )\n// }\n\n#[test]\nfn obj() {\n    fn t1(_fields: \u0026[\u0026dyn IntoField]) {}\n\n    let v = vec![\u002610 as _, \u00260.0 as _];\n    t1(\u0026v);\n\n    fn insert_named\u003c'a\u003e(_fields: \u0026[\u0026dyn IntoNamedField\u003c'a\u003e]) {}\n\n    let v = vec![\u0026(\"a\", 0) as _, \u0026(\"b\", 0.0) as _];\n    insert_named(\u0026v);\n\n    for e in v {\n        dbg!(e.name());\n    }\n}\n","traces":[{"line":28,"address":[2640688,2640704],"length":1,"stats":{"Line":2},"fn_name":"name\u003ci32\u003e"},{"line":29,"address":[2640693,2640709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[2209049,2207808,2209101],"length":1,"stats":{"Line":3},"fn_name":"obj"},{"line":47,"address":[2209149,2209136],"length":1,"stats":{"Line":2},"fn_name":"t1"},{"line":49,"address":[2207815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2208005,2207926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2209181,2209168],"length":1,"stats":{"Line":2},"fn_name":"insert_named"},{"line":54,"address":[2208022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2208124,2208204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2209044,2208211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2208516],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","iter","mod.rs"],"content":"use super::*;\n\npub struct CellIter\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    row: usize,\n    col: usize,\n}\n\nimpl\u003c'b, T: BlockExt\u003e Iterator for CellIter\u003c'b, T\u003e {\n    type Item = (\u0026'b Field, BorrowedValue\u003c'b\u003e);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let col = self.col;\n        if col \u003c self.block.field_count() {\n            self.col += 1;\n            Some(unsafe { self.block.cell_unchecked(self.row, col) })\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RowInBlock\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    row: usize,\n}\n\nimpl\u003c'b, T\u003e IntoIterator for RowInBlock\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = (\u0026'b Field, BorrowedValue\u003c'b\u003e);\n\n    type IntoIter = CellIter\u003c'b, T\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        CellIter {\n            block: self.block,\n            row: self.row,\n            col: 0,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RowsIter\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    row: usize,\n}\n\nimpl\u003c'b, T\u003e RowsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: \u0026'b T) -\u003e Self {\n        Self { block, row: 0 }\n    }\n}\n\nimpl\u003c'b, T\u003e Iterator for RowsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = RowInBlock\u003c'b, T\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let row = self.row;\n\n        if row \u003c self.block.num_of_rows() {\n            self.row += 1;\n            Some(RowInBlock {\n                block: self.block,\n                row,\n            })\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct IntoRowsIter\u003cT: BlockExt\u003e {\n    block: Rc\u003cT\u003e,\n    row: usize,\n}\n\nimpl\u003cT\u003e IntoRowsIter\u003cT\u003e\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: T) -\u003e Self {\n        Self {\n            block: Rc::new(block),\n            row: 0,\n        }\n    }\n}\n\npub struct QueryRowIter\u003cT: BlockExt\u003e {\n    block: Rc\u003cT\u003e,\n    row: usize,\n}\n\nimpl\u003c'b, T\u003e IntoIterator for \u0026'b QueryRowIter\u003cT\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = (\u0026'b Field, BorrowedValue\u003c'b\u003e);\n\n    type IntoIter = CellIter\u003c'b, T\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        CellIter {\n            block: \u0026self.block,\n            row: self.row,\n            col: 0,\n        }\n    }\n}\n\nimpl\u003cT\u003e Iterator for IntoRowsIter\u003cT\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = QueryRowIter\u003cT\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let row = self.row;\n\n        if row \u003c self.block.num_of_rows() {\n            self.row += 1;\n            Some(QueryRowIter {\n                block: self.block.clone(),\n                row,\n            })\n        } else {\n            None\n        }\n    }\n}\n\npub struct ColsIter\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    col: usize,\n}\nimpl\u003c'b, T\u003e ColsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: \u0026'b T) -\u003e Self {\n        Self { block, col: 0 }\n    }\n}\n\nimpl\u003c'b, T\u003e Iterator for ColsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = BorrowedColumn\u003c'b\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.col \u003e= self.block.field_count() {\n            return None;\n        }\n\n        let v = unsafe { self.block.get_col_unchecked(self.col) };\n        self.col += 1;\n        Some(v)\n    }\n}\n","traces":[{"line":12,"address":[3737888],"length":1,"stats":{"Line":2},"fn_name":"next\u003ctaos::impls::SyncBlock\u003e"},{"line":13,"address":[3737912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[3737964,3737926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[3738030,3737971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[3738065,3738010],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[3737960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3738528],"length":1,"stats":{"Line":2},"fn_name":"into_iter\u003ctaos::impls::SyncBlock\u003e"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3737152],"length":1,"stats":{"Line":2},"fn_name":"new\u003ctaos::impls::SyncBlock\u003e"},{"line":67,"address":[3738096],"length":1,"stats":{"Line":2},"fn_name":"next\u003ctaos::impls::SyncBlock\u003e"},{"line":68,"address":[2182110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2182161,2182240,2182124],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[2182168,2182242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[2182210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2182207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3738153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[3737200],"length":1,"stats":{"Line":0},"fn_name":"new\u003ctaos::impls::SyncBlock\u003e"},{"line":94,"address":[3737207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2182336],"length":1,"stats":{"Line":0},"fn_name":"into_iter\u003ctaos_query::tests::Block\u003e"},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3737066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[2182448],"length":1,"stats":{"Line":0},"fn_name":"next\u003ctaos_query::tests::Block\u003e"},{"line":129,"address":[2182462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2182539,2182505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2182546,2182592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2182632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2182580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2182530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2182688],"length":1,"stats":{"Line":0},"fn_name":"new\u003ctaos_query::tests::Block\u003e"},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":38},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","lib.rs"],"content":"//! This is the common query traits/types for TDengine connectors.\n//!\n#![cfg_attr(nightly, feature(const_slice_from_raw_parts))]\n#![cfg_attr(nightly, feature(const_slice_index))]\n\nuse futures::stream::TryStreamExt;\nuse itertools::Itertools;\nuse mdsn::IntoDsn;\npub use mdsn::{Address, Dsn, DsnError};\nuse serde::de::{value::Error as DeError, DeserializeOwned};\nuse std::{fmt::Debug, marker::PhantomData, rc::Rc};\n\npub mod common;\nmod de;\npub mod helpers;\nmod insert;\n\nmod iter;\npub(crate) mod util;\n\npub use iter::*;\n\nuse async_trait::async_trait;\nuse common::*;\nuse helpers::*;\n\npub enum CodecOpts {\n    Raw,\n    Parquet,\n}\n\npub trait BlockCodec {\n    fn encode(\u0026self, _codec: CodecOpts) -\u003e Vec\u003cu8\u003e;\n    fn decode(from: \u0026[u8], _codec: CodecOpts) -\u003e Self;\n}\n\ntype DeserializeIter\u003c'b, B, T\u003e =\n    std::iter::Map\u003cRowsIter\u003c'b, B\u003e, fn(RowInBlock\u003c'b, B\u003e) -\u003e Result\u003cT, DeError\u003e\u003e;\n\n/// Trait to define a data `Block` to fetch records bulky.\n///\n/// If query performance is not your main concern, you can just use the deserialize method from result set.\npub trait BlockExt: Debug + Sized {\n    /// A block should container number of rows.\n    fn num_of_rows(\u0026self) -\u003e usize;\n\n    /// Fields can be queried from a block.\n    fn fields(\u0026self) -\u003e \u0026[Field];\n\n    /// Number of fields.\n    fn field_count(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n\n    fn precision(\u0026self) -\u003e Precision;\n\n    fn is_null(\u0026self, row: usize, col: usize) -\u003e bool;\n\n    /// Get field without column index check.\n    ///\n    /// # Safety\n    ///\n    /// This should not be called manually, please use [get_field](#method.get_field).\n    unsafe fn get_field_unchecked(\u0026self, col: usize) -\u003e \u0026Field {\n        self.fields().get_unchecked(col)\n    }\n\n    /// Get field of one column.\n    fn get_field(\u0026self, col: usize) -\u003e Option\u003c\u0026Field\u003e {\n        self.fields().get(col)\n    }\n\n    /// # Safety\n    ///\n    /// **DO NOT** call it directly.\n    unsafe fn cell_unchecked(\u0026self, row: usize, col: usize) -\u003e (\u0026Field, BorrowedValue);\n\n    unsafe fn get_col_unchecked(\u0026self, col: usize) -\u003e BorrowedColumn;\n\n    /// Query by rows.\n    fn iter_rows(\u0026self) -\u003e RowsIter\u003c'_, Self\u003e {\n        RowsIter::new(self)\n    }\n\n    /// Consume self into rows.\n    fn into_iter_rows(self) -\u003e IntoRowsIter\u003cSelf\u003e {\n        IntoRowsIter::new(self)\n    }\n\n    /// Columns iterator with borrowed data from block.\n    fn columns_iter(\u0026self) -\u003e ColsIter\u003c'_, Self\u003e {\n        ColsIter::new(self)\n    }\n\n    fn to_records(\u0026self) -\u003e Vec\u003cVec\u003cValue\u003e\u003e {\n        self.iter_rows()\n            .map(|row| row.into_iter().map(|(f, v)| v.into_value()).collect_vec())\n            .collect_vec()\n    }\n\n    /// Deserialize a row to a record type(primitive type or a struct).\n    ///\n    /// Any record could borrow data from the block, so that \u0026[u8], \u0026[str] could be used as record element (if valid).\n    fn deserialize\u003c'b, T\u003e(\u0026'b self) -\u003e DeserializeIter\u003c'b, Self, T\u003e\n    where\n        T: serde::de::Deserialize\u003c'b\u003e,\n    {\n        self.iter_rows().map(|row| {\n            let de = de::RecordDeserializer::from(row);\n            T::deserialize(de)\n        })\n    }\n\n    /// Deserialize a row to a record type(primitive type or a struct).\n    ///\n    /// Any record could borrow data from the block, so that \u0026[u8], \u0026[str] could be used as record element (if valid).\n    fn deserialize_into\u003cT\u003e(\n        self,\n    ) -\u003e std::iter::Map\u003cIntoRowsIter\u003cSelf\u003e, fn(QueryRowIter\u003cSelf\u003e) -\u003e Result\u003cT, DeError\u003e\u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.into_iter_rows().map(|row| {\n            let de = de::RecordDeserializer::from(\u0026row);\n            T::deserialize(de)\n        })\n    }\n\n    /// Shortcut version to `.deserialize_into.collect::\u003cVec\u003cT\u003e\u003e()`\n    fn deserialize_into_vec\u003cT\u003e(self) -\u003e Vec\u003cResult\u003cT, DeError\u003e\u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.deserialize_into().collect()\n    }\n\n    /// Rows as [futures::stream::Stream].\n    fn rows_stream(\u0026self) -\u003e futures::stream::Iter\u003cRowsIter\u003c'_, Self\u003e\u003e {\n        futures::stream::iter(Self::iter_rows(self))\n    }\n\n    /// Owned version to rows stream.\n    fn into_rows_stream(self) -\u003e futures::stream::Iter\u003cIntoRowsIter\u003cSelf\u003e\u003e {\n        futures::stream::iter(Self::into_iter_rows(self))\n    }\n\n    /// Rows stream to deserialized record.\n    fn deserialize_stream\u003c'b, T\u003e(\u0026'b self) -\u003e futures::stream::Iter\u003cDeserializeIter\u003c'b, Self, T\u003e\u003e\n    where\n        T: serde::de::Deserialize\u003c'b\u003e,\n    {\n        futures::stream::iter(Self::deserialize(self))\n    }\n}\n\npub trait Fetchable\nwhere\n    Self: Sized,\n    for\u003c'r\u003e \u0026'r mut Self: Iterator,\n    for\u003c'b, 'r\u003e \u003c\u0026'r mut Self as Iterator\u003e::Item: BlockExt,\n{\n    // type Block: for\u003c'b\u003e BlockExt;\n\n    fn affected_rows(\u0026self) -\u003e i32;\n\n    fn precision(\u0026self) -\u003e Precision;\n\n    fn fields(\u0026self) -\u003e \u0026[Field];\n\n    fn num_of_fields(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n\n    fn summary(\u0026self) -\u003e (usize, usize);\n\n    fn blocks_iter(\u0026mut self) -\u003e \u0026mut Self {\n        self\n    }\n\n    fn to_rows_vec(\u0026mut self) -\u003e Vec\u003cVec\u003cValue\u003e\u003e {\n        self.rows_iter()\n            .map(|row| row.into_iter().map(|(_, v)| v.into_value()).collect())\n            .collect()\n    }\n\n    fn rows_iter\u003c'r\u003e(\n        \u0026'r mut self,\n    ) -\u003e std::iter::FlatMap\u003c\n        \u0026'r mut Self,\n        IntoRowsIter\u003c\u003c\u0026'r mut Self as Iterator\u003e::Item\u003e,\n        fn(\u003c\u0026'r mut Self as Iterator\u003e::Item) -\u003e IntoRowsIter\u003c\u003c\u0026'r mut Self as Iterator\u003e::Item\u003e,\n    \u003e {\n        self.flat_map(|block| block.into_iter_rows())\n    }\n\n    fn deserialize\u003cT\u003e(\n        \u0026mut self,\n    ) -\u003e std::iter::FlatMap\u003c\n        \u0026mut Self,\n        Vec\u003cResult\u003cT, DeError\u003e\u003e,\n        fn(\u003c\u0026mut Self as Iterator\u003e::Item) -\u003e Vec\u003cResult\u003cT, DeError\u003e\u003e,\n    \u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.flat_map(|block| block.deserialize_into_vec())\n    }\n}\n\n/// The synchronous query trait for TDengine connection.\npub trait Queryable\u003c'q\u003e: Debug\nwhere\n    for\u003c'r\u003e \u0026'r mut Self::ResultSet: Iterator,\n    for\u003c'b, 'r\u003e \u003c\u0026'r mut Self::ResultSet as Iterator\u003e::Item: BlockExt,\n{\n    type Error: Debug + From\u003cserde::de::value::Error\u003e;\n    // type B: for\u003c'b\u003e BlockExt\u003c'b, 'b\u003e;\n    type ResultSet: Fetchable;\n\n    fn query\u003cT: AsRef\u003cstr\u003e\u003e(\u0026'q self, sql: T) -\u003e Result\u003cSelf::ResultSet, Self::Error\u003e;\n\n    fn exec\u003cT: AsRef\u003cstr\u003e\u003e(\u0026'q self, sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n        self.query(sql).map(|res| res.affected_rows() as _)\n    }\n\n    fn exec_many\u003cT: AsRef\u003cstr\u003e, I: IntoIterator\u003cItem = T\u003e\u003e(\n        \u0026'q self,\n        input: I,\n    ) -\u003e Result\u003cusize, Self::Error\u003e {\n        input\n            .into_iter()\n            .map(|sql| self.exec(sql))\n            .try_fold(0, |mut acc, aff| {\n                acc += aff?;\n                Ok(acc)\n            })\n    }\n\n    fn query_one\u003cT: AsRef\u003cstr\u003e, O: DeserializeOwned\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cOption\u003cO\u003e, Self::Error\u003e {\n        self.query(sql)?\n            .deserialize::\u003cO\u003e()\n            .next()\n            .map_or(Ok(None), |v| v.map(Some).map_err(Into::into))\n    }\n\n    fn create_topic(\n        \u0026'q self,\n        name: impl AsRef\u003cstr\u003e,\n        sql: impl AsRef\u003cstr\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let (name, sql) = (name.as_ref(), sql.as_ref());\n        let query = format!(\"create topic if not exists {name} as {sql}\");\n\n        self.query(\u0026query)?;\n        Ok(())\n    }\n\n    fn create_topic_as_database(\n        \u0026'q self,\n        name: impl AsRef\u003cstr\u003e,\n        db: impl std::fmt::Display,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let name = name.as_ref();\n        let query = format!(\"create topic if not exists {name} as database {db}\");\n\n        self.exec(\u0026query)?;\n        Ok(())\n    }\n\n    fn databases(\u0026'q self) -\u003e Result\u003cVec\u003cShowDatabase\u003e, Self::Error\u003e {\n        self.query(\"show databases\")?\n            .deserialize()\n            .try_collect()\n            .map_err(Into::into)\n    }\n\n    /// Topics information by `show topics` sql.\n    ///\n    /// ## Compatibility\n    ///\n    /// This is a 3.x-only API.\n    fn topics(\u0026'q self) -\u003e Result\u003cVec\u003cTopic\u003e, Self::Error\u003e {\n        self.query(\"show topics\")?\n            .deserialize()\n            .try_collect()\n            .map_err(Into::into)\n    }\n\n    fn describe(\u0026'q self, table: \u0026str) -\u003e Result\u003cDescribe, Self::Error\u003e {\n        Ok(Describe(\n            self.query(format!(\"describe {table}\"))?\n                .deserialize()\n                .try_collect()?,\n        ))\n    }\n}\n\npub trait AsyncFetchable\nwhere\n    Self: Sized + Send,\n    Self::BlockStream: futures::stream::Stream + Send,\n    \u003cSelf::BlockStream as futures::stream::Stream\u003e::Item: BlockExt + Send,\n{\n    type BlockStream;\n    // type Block: for\u003c'b\u003e BlockExt;\n\n    fn affected_rows(\u0026self) -\u003e i32;\n\n    fn precision(\u0026self) -\u003e Precision;\n\n    fn fields(\u0026self) -\u003e \u0026[Field];\n\n    fn num_of_fields(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n\n    fn summary(\u0026self) -\u003e (usize, usize);\n\n    fn blocks_iter(\u0026mut self) -\u003e \u0026mut Self {\n        self\n    }\n\n    fn block_stream(\u0026mut self) -\u003e Self::BlockStream;\n\n    fn into_blocks(mut self) -\u003e Self::BlockStream {\n        self.block_stream()\n    }\n\n    /// Records is a row-based 2-dimension matrix of values.\n    fn to_records(\u0026mut self) -\u003e Vec\u003cVec\u003cValue\u003e\u003e {\n        futures::executor::block_on_stream(Box::pin(self.block_stream()))\n            .flat_map(|block| block.to_records())\n            .collect()\n    }\n\n    fn deserialize_stream\u003cT\u003e(\n        \u0026mut self,\n    ) -\u003e futures::stream::FlatMap\u003c\n        \u003cSelf as AsyncFetchable\u003e::BlockStream,\n        futures::stream::Iter\u003cstd::vec::IntoIter\u003cResult\u003cT, DeError\u003e\u003e\u003e,\n        fn(\n            \u003cSelf::BlockStream as futures::stream::Stream\u003e::Item,\n        ) -\u003e futures::stream::Iter\u003cstd::vec::IntoIter\u003cResult\u003cT, DeError\u003e\u003e\u003e,\n    \u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        // self.blocks_iter()\n        use futures::stream::StreamExt;\n        self.block_stream()\n            .flat_map(|block| futures::stream::iter(block.deserialize_into_vec::\u003cT\u003e()))\n    }\n}\n\n/// The synchronous query trait for TDengine connection.\n#[async_trait]\npub trait AsyncQueryable\u003c'q\u003e: Send + Sync\nwhere\n    \u003cSelf::AsyncResultSet as AsyncFetchable\u003e::BlockStream: 'q + futures::stream::Stream,\n    for\u003c'b\u003e \u003c\u003cSelf::AsyncResultSet as AsyncFetchable\u003e::BlockStream as futures::stream::Stream\u003e::Item:\n        BlockExt + Send,\n{\n    type Error: Debug + From\u003cserde::de::value::Error\u003e + Send;\n    // type B: for\u003c'b\u003e BlockExt\u003c'b, 'b\u003e;\n    type AsyncResultSet: AsyncFetchable;\n\n    async fn query\u003cT: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cSelf::AsyncResultSet, Self::Error\u003e;\n\n    async fn exec\u003cT: AsRef\u003cstr\u003e + Send\u003e(\u0026'q self, sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n        let sql = sql.as_ref();\n        log::trace!(\"exec sql: {sql}\");\n        self.query(sql).await.map(|res| res.affected_rows() as _)\n    }\n\n    async fn exec_many\u003cT, I\u003e(\u0026'q self, input: I) -\u003e Result\u003cusize, Self::Error\u003e\n    where\n        T: AsRef\u003cstr\u003e + Send,\n        I::IntoIter: Send,\n        I: IntoIterator\u003cItem = T\u003e + Send,\n    {\n        let mut aff = 0;\n        for sql in input {\n            aff += self.exec(sql).await?;\n        }\n        Ok(aff)\n    }\n\n    /// To conveniently get first row of the result, useful for queries like\n    ///\n    /// - `select count(*) from ...`\n    /// - `select last(*) from ...`\n    ///\n    /// Type `T` could be `Vec\u003ctaos::query::common::Value\u003e`, a tuple, or a struct with serde support.\n    ///\n    /// ## Example\n    ///\n    /// ```rust,ignore\n    /// let count: u32 = taos.query_one(\"select count(*) from table1\")?.unwrap_or(0);\n    ///\n    /// let one: (i32, String, Timestamp) =\n    ///    taos.query_one(\"select c1,c2,c3 from table1 limit 1\")?.unwrap_or_default();\n    /// ```\n    async fn query_one\u003cT: AsRef\u003cstr\u003e + Send, O: DeserializeOwned + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cOption\u003cO\u003e, Self::Error\u003e {\n        use futures::StreamExt;\n        self.query(sql)\n            .await?\n            .deserialize_stream::\u003cO\u003e()\n            .take(1)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .await\n            .into_iter()\n            .next()\n            .map_or(Ok(None), |v| v.map(Some).map_err(Into::into))\n    }\n\n    async fn create_topic\u003cN: AsRef\u003cstr\u003e + Send, S: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        name: N,\n        sql: S,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let (name, sql) = (name.as_ref(), sql.as_ref());\n        let query = format!(\"create topic if not exists {name} as {sql}\");\n\n        self.query(query).await?;\n        Ok(())\n    }\n\n    async fn create_topic_as_database(\n        \u0026'q self,\n        name: impl AsRef\u003cstr\u003e + Send + 'async_trait,\n        db: impl std::fmt::Display + Send + 'async_trait,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let name = name.as_ref();\n        let query = format!(\"create topic if not exists {name} as database {db}\");\n\n        self.exec(\u0026query).await?;\n        Ok(())\n    }\n\n    async fn databases(\u0026'q self) -\u003e Result\u003cVec\u003cShowDatabase\u003e, Self::Error\u003e {\n        use futures::stream::TryStreamExt;\n        Ok(self\n            .query(\"show databases\")\n            .await?\n            .deserialize_stream()\n            .try_collect()\n            .await?)\n    }\n\n    /// Topics information by `show topics` sql.\n    ///\n    /// ## Compatibility\n    ///\n    /// This is a 3.x-only API.\n    async fn topics(\u0026'q self) -\u003e Result\u003cVec\u003cTopic\u003e, Self::Error\u003e {\n        Ok(self\n            .query(\"show topics\")\n            .await?\n            .deserialize_stream()\n            .try_collect()\n            .await?)\n    }\n\n    async fn describe(\u0026'q self, table: \u0026str) -\u003e Result\u003cDescribe, Self::Error\u003e {\n        Ok(Describe(\n            self.query(format!(\"describe {table}\"))\n                .await?\n                .deserialize_stream()\n                .try_collect()\n                .await?,\n        ))\n    }\n\n    fn exec_sync\u003cT: AsRef\u003cstr\u003e + Send\u003e(\u0026'q self, sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n        futures::executor::block_on(self.exec(sql))\n    }\n\n    fn query_sync\u003cT: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cSelf::AsyncResultSet, Self::Error\u003e {\n        futures::executor::block_on(self.query(sql))\n    }\n}\n\npub trait FromDsn: Sized + 'static {\n    type Err: std::error::Error;\n\n    /// Validate or hygienize the DSN.\n    ///\n    /// ## Error\n    ///\n    /// When there're multi addresses, validate all addresses for connection,\n    /// and filter success addresses. When all addresses of DSN are invalid,\n    /// return last error. When success, it will return a pair of DSN and\n    /// filtered addresses.\n    fn hygienize(dsn: Dsn) -\u003e Result\u003c(Dsn, Vec\u003cAddress\u003e), DsnError\u003e;\n\n    /// Generate a connection object from DSN.\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Err\u003e;\n\n    /// Is the connection available?\n    fn ping(dsn: \u0026Dsn) -\u003e Result\u003c(), Self::Err\u003e;\n}\n\n/// This is how we manage connections.\npub struct Manager\u003cT: FromDsn\u003e {\n    dsn: Dsn,\n    marker: PhantomData\u003cT\u003e,\n}\n\nimpl\u003cT: FromDsn\u003e Default for Manager\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self {\n            dsn: Dsn {\n                driver: \"taos\".to_string(),\n                ..Default::default()\n            },\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl\u003cT: FromDsn + Send + Sync\u003e Manager\u003cT\u003e {\n    /// Build a connection manager from a DSN.\n    #[inline]\n    pub fn new(dsn: Dsn) -\u003e Result\u003cSelf, DsnError\u003e {\n        let (dsn, _) = T::hygienize(dsn)?;\n\n        Ok(Self {\n            dsn,\n            marker: PhantomData,\n        })\n    }\n\n    /// Parse a DSN format from str.\n    #[inline]\n    pub fn parse(dsn: impl AsRef\u003cstr\u003e) -\u003e Result\u003cSelf, DsnError\u003e {\n        let dsn = Dsn::parse(dsn)?;\n        Self::new(dsn)\n    }\n\n    #[inline]\n    pub fn from_dsn(dsn: impl IntoDsn) -\u003e Result\u003cSelf, DsnError\u003e {\n        let dsn = dsn.into_dsn()?;\n        Self::new(dsn)\n    }\n\n    /// Open a connection to TDengine.\n    #[inline]\n    pub fn connect(\u0026self) -\u003e Result\u003cT, \u003cT as FromDsn\u003e::Err\u003e {\n        T::from_dsn(\u0026self.dsn)\n    }\n\n    #[cfg(feature = \"r2d2\")]\n    #[inline]\n    pub fn into_pool(self) -\u003e Result\u003cPool\u003cT\u003e, r2d2::Error\u003e {\n        r2d2::Pool::new(self)\n    }\n\n    #[cfg(feature = \"r2d2\")]\n    #[inline]\n    pub fn into_pool_with_builder(\n        self,\n        builder: r2d2::Builder\u003cSelf\u003e,\n    ) -\u003e Result\u003cPool\u003cT\u003e, r2d2::Error\u003e {\n        builder.build(self)\n    }\n}\n\n#[cfg(feature = \"r2d2\")]\npub type Pool\u003cT\u003e = r2d2::Pool\u003cManager\u003cT\u003e\u003e;\n\n#[cfg(feature = \"r2d2\")]\nimpl\u003cT: FromDsn + Send + Sync + 'static\u003e r2d2::ManageConnection for Manager\u003cT\u003e {\n    type Connection = T;\n    type Error = \u003cT as FromDsn\u003e::Err;\n\n    #[inline]\n    fn connect(\u0026self) -\u003e Result\u003cSelf::Connection, Self::Error\u003e {\n        self.connect()\n    }\n\n    #[inline]\n    fn is_valid(\u0026self, _: \u0026mut Self::Connection) -\u003e Result\u003c(), Self::Error\u003e {\n        \u003cT as FromDsn\u003e::ping(\u0026self.dsn)\n    }\n\n    #[inline]\n    fn has_broken(\u0026self, _: \u0026mut Self::Connection) -\u003e bool {\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::forward_to_deserialize_any;\n    use std::marker::PhantomData;\n\n    use super::*;\n    #[derive(Debug)]\n    struct Conn;\n\n    #[derive(Debug)]\n    struct Value\u003c's\u003e(\u0026's str);\n\n    struct Deserializer;\n\n    impl\u003c'de\u003e serde::de::Deserializer\u003c'de\u003e for Deserializer {\n        type Error = serde::de::value::Error;\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_i32(1)\n        }\n\n        forward_to_deserialize_any! {\n            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n            seq bytes byte_buf map unit_struct newtype_struct\n            tuple_struct struct tuple enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, 's: 'de\u003e serde::de::Deserializer\u003c'de\u003e for Value\u003c's\u003e {\n        type Error = serde::de::value::Error;\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_i32(1)\n        }\n\n        forward_to_deserialize_any! {\n            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char unit option\n            seq byte_buf map unit_struct newtype_struct\n            tuple_struct struct tuple enum identifier ignored_any\n        }\n\n        fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_borrowed_str(self.0)\n        }\n        fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            self.deserialize_str(visitor)\n        }\n        fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            const V: u32 = 0x0f0f0f0f;\n            let v: \u0026[u8; 4] = unsafe { std::mem::transmute(\u0026V) };\n            visitor.visit_borrowed_bytes(v)\n        }\n    }\n\n    #[derive(Debug)]\n    struct MyResultSet\u003c'q\u003e(PhantomData\u003c\u0026'q u8\u003e);\n\n    #[derive(Debug)]\n    struct Block\u003c'r, 'q\u003e(PhantomData\u003c(\u0026'r u8, \u0026'q u8)\u003e);\n\n    impl\u003c'b, 'r, 'q\u003e BlockExt for Block\u003c'r, 'q\u003e {\n        fn num_of_rows(\u0026self) -\u003e usize {\n            1\n        }\n\n        fn fields(\u0026self) -\u003e \u0026[Field] {\n            static mut FIELDS: Vec\u003cField\u003e = Vec::new();\n            unsafe {\n                if FIELDS.len() == 0 {\n                    FIELDS.push(Field::new(\"ts\", Ty::Timestamp, 8));\n                    FIELDS.push(Field::new(\"bin10\", Ty::VarChar, 10));\n                    FIELDS.push(Field::new(\"int32\", Ty::Int, 4));\n                }\n                \u0026FIELDS\n            }\n        }\n\n        fn precision(\u0026self) -\u003e Precision {\n            Precision::Microsecond\n        }\n\n        fn is_null(\u0026self, _row: usize, _col: usize) -\u003e bool {\n            false\n        }\n\n        fn field_count(\u0026self) -\u003e usize {\n            3\n        }\n\n        unsafe fn cell_unchecked(\u0026self, _row: usize, col: usize) -\u003e (\u0026Field, BorrowedValue) {\n            match col {\n                0 =\u003e (\n                    self.get_field_unchecked(col) as _,\n                    BorrowedValue::Timestamp(crate::Timestamp::Milliseconds(0)),\n                ),\n                2 =\u003e (self.get_field_unchecked(col) as _, BorrowedValue::Int(32)),\n                1 =\u003e (\n                    self.get_field_unchecked(col) as _,\n                    BorrowedValue::VarChar(\"str\"),\n                ),\n                _ =\u003e (self.get_field_unchecked(col) as _, BorrowedValue::Int(32)),\n            }\n        }\n\n        unsafe fn get_col_unchecked(\u0026self, _col: usize) -\u003e BorrowedColumn {\n            todo!()\n        }\n    }\n\n    impl\u003c'r, 'q\u003e Iterator for \u0026'r mut MyResultSet\u003c'q\u003e {\n        type Item = Block\u003c'r, 'q\u003e;\n\n        fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n            static mut AVAILABLE: bool = true;\n            if unsafe { AVAILABLE } {\n                unsafe { AVAILABLE = false };\n\n                Some(Block(PhantomData))\n            } else {\n                None\n            }\n        }\n    }\n\n    impl\u003c'r, 'q\u003e crate::Fetchable for MyResultSet\u003c'q\u003e {\n        fn fields(\u0026self) -\u003e \u0026[Field] {\n            todo!()\n        }\n\n        fn precision(\u0026self) -\u003e Precision {\n            todo!()\n        }\n\n        fn summary(\u0026self) -\u003e (usize, usize) {\n            todo!()\n        }\n\n        fn affected_rows(\u0026self) -\u003e i32 {\n            todo!()\n        }\n    }\n\n    #[derive(Debug)]\n    struct Error;\n\n    impl\u003c'q\u003e Queryable\u003c'q\u003e for Conn {\n        type Error = anyhow::Error;\n\n        type ResultSet = MyResultSet\u003c'q\u003e;\n\n        fn query\u003cT: AsRef\u003cstr\u003e\u003e(\u0026'q self, _sql: T) -\u003e Result\u003cMyResultSet, Self::Error\u003e {\n            Ok(MyResultSet(PhantomData))\n        }\n\n        fn exec\u003cT: AsRef\u003cstr\u003e\u003e(\u0026self, _sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n            Ok(1)\n        }\n    }\n    #[test]\n    fn query_deserialize() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut rs = conn.query(\"abc\").unwrap();\n\n        for record in rs.deserialize::\u003c(i32, String, u8)\u003e() {\n            dbg!(record.unwrap());\n        }\n    }\n    #[test]\n    fn block_deserialize_borrowed() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n        for block in \u0026mut set {\n            for record in block.deserialize::\u003c(i32, \u0026str, u8)\u003e() {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[test]\n    fn block_deserialize_borrowed_bytes() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        for block in \u0026mut set {\n            for record in block.deserialize::\u003c(String, \u0026str, u8)\u003e() {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[tokio::test]\n    async fn block_deserialize_borrowed_bytes_stream() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        use futures::stream::*;\n\n        for block in \u0026mut set {\n            for record in block\n                .deserialize_stream::\u003c(String, \u0026str, u8)\u003e()\n                .next()\n                .await\n            {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[test]\n    fn with_iter() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        for block in \u0026mut set {\n            // todo\n            for row in block.iter_rows() {\n                for value in row {\n                    println!(\"{:?}\", value);\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":51,"address":[3759920],"length":1,"stats":{"Line":0},"fn_name":"field_count\u003ctaos::impls::SyncBlock\u003e"},{"line":52,"address":[3759929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3329088],"length":1,"stats":{"Line":2},"fn_name":"get_field_unchecked\u003ctaos_query::tests::Block\u003e"},{"line":65,"address":[3329107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[3329168],"length":1,"stats":{"Line":0},"fn_name":"get_field\u003ctaos_query::tests::Block\u003e"},{"line":70,"address":[3329187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3329248],"length":1,"stats":{"Line":2},"fn_name":"iter_rows\u003ctaos_query::tests::Block\u003e"},{"line":82,"address":[3329257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[3329296],"length":1,"stats":{"Line":0},"fn_name":"into_iter_rows\u003ctaos_query::tests::Block\u003e"},{"line":87,"address":[3329300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3329328],"length":1,"stats":{"Line":0},"fn_name":"columns_iter\u003ctaos_query::tests::Block\u003e"},{"line":92,"address":[3329337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3329376],"length":1,"stats":{"Line":0},"fn_name":"to_records\u003ctaos_query::tests::Block\u003e"},{"line":96,"address":[3329408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2814224,2814254,2814112,2814165],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::Block\u003e"},{"line":104,"address":[3329584,3329488],"length":1,"stats":{"Line":2},"fn_name":"deserialize\u003ctaos_query::tests::Block, (i32, \u0026str, u8)\u003e"},{"line":108,"address":[2814336,2814464],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003ctaos_query::tests::Block, (i32, \u0026str, u8)\u003e"},{"line":109,"address":[2814529,2814401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2814411,2814539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[3329808,3329680,3329872,3329744],"length":1,"stats":{"Line":0},"fn_name":"deserialize_into\u003ctaos_query::tests::Block, (i32, alloc::string::String, u8)\u003e"},{"line":123,"address":[2815167,2814751,2814592,2814959,2815008,2815375,2814800,2815216],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::Block, (i32, alloc::string::String, u8)\u003e"},{"line":124,"address":[2815260,2814636,2814844,2815052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2815305,2815097,2814681,2814889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3330128,3329936,3330064,3330000],"length":1,"stats":{"Line":0},"fn_name":"deserialize_into_vec\u003ctaos_query::tests::Block, taos_query::helpers::describe::ColumnMeta\u003e"},{"line":134,"address":[3329950,3330078,3330142,3330014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3330192],"length":1,"stats":{"Line":0},"fn_name":"rows_stream\u003ctaos_query::tests::Block\u003e"},{"line":139,"address":[3330201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[3330256],"length":1,"stats":{"Line":0},"fn_name":"into_rows_stream\u003ctaos_query::tests::Block\u003e"},{"line":144,"address":[3330260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[3330320],"length":1,"stats":{"Line":0},"fn_name":"deserialize_stream\u003ctaos_query::tests::Block, (alloc::string::String, \u0026str, u8)\u003e"},{"line":152,"address":[3330339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3330384],"length":1,"stats":{"Line":0},"fn_name":"num_of_fields\u003ctaos_query::tests::MyResultSet\u003e"},{"line":171,"address":[3330393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[3330416],"length":1,"stats":{"Line":0},"fn_name":"blocks_iter\u003ctaos_query::tests::MyResultSet\u003e"},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3330432],"length":1,"stats":{"Line":0},"fn_name":"to_rows_vec\u003ctaos_query::tests::MyResultSet\u003e"},{"line":181,"address":[3330450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2815616,2815462,2815584,2815424],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::MyResultSet\u003e"},{"line":186,"address":[3330512],"length":1,"stats":{"Line":0},"fn_name":"rows_iter\u003ctaos_query::tests::MyResultSet\u003e"},{"line":193,"address":[2815680,2815689],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::MyResultSet\u003e"},{"line":196,"address":[3330656,3330608,3330704,3330560],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003ctaos_query::tests::MyResultSet, taos_query::helpers::topic::Topic\u003e"},{"line":206,"address":[2815744,2815776,2815728,2815824,2815808,2815840,2815760,2815792],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}\u003ctaos_query::tests::MyResultSet, (i32, alloc::string::String, u8)\u003e"},{"line":222,"address":[3778352],"length":1,"stats":{"Line":0},"fn_name":"exec\u003ctaos::Taos, alloc::string::String\u003e"},{"line":223,"address":[3414185,3414176],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos::Taos, alloc::string::String\u003e"},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[3330981,3330752],"length":1,"stats":{"Line":0},"fn_name":"databases\u003ctaos_query::tests::Conn\u003e"},{"line":274,"address":[3330788,3330955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3331237,3331008],"length":1,"stats":{"Line":0},"fn_name":"topics\u003ctaos_query::tests::Conn\u003e"},{"line":286,"address":[3331044,3331211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[3331264,3331914],"length":1,"stats":{"Line":0},"fn_name":"describe\u003ctaos_query::tests::Conn\u003e"},{"line":293,"address":[3331765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3331304,3331868,3331627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3331836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3759584],"length":1,"stats":{"Line":0},"fn_name":"num_of_fields\u003ctaos::impls::ResultSet\u003e"},{"line":317,"address":[3759593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[3759456],"length":1,"stats":{"Line":0},"fn_name":"blocks_iter\u003ctaos::impls::ResultSet\u003e"},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[3759541,3759472],"length":1,"stats":{"Line":0},"fn_name":"into_blocks\u003ctaos::impls::ResultSet\u003e"},{"line":329,"address":[3759489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3759200],"length":1,"stats":{"Line":0},"fn_name":"to_records\u003ctaos::impls::ResultSet\u003e"},{"line":334,"address":[3759388,3759225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3406032,3406060],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos::impls::ResultSet\u003e"},{"line":339,"address":[3759744,3759680,3759616],"length":1,"stats":{"Line":0},"fn_name":"deserialize_stream\u003ctaos::impls::ResultSet, taos_query::helpers::describe::ColumnMeta\u003e"},{"line":353,"address":[3759699,3759635,3759763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3406286,3406190,3406256,3406160,3406382,3406352],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos::impls::ResultSet, taos_query::helpers::database::ShowDatabase\u003e"},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3411001,3411145,3410688,3410743,3411442,3412662],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}\u003ctaos::Taos\u003e"},{"line":451,"address":[3411599,3411377,3411205,3411814,3412145,3412270,3412485,3411498,3411867,3412070,3411919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[3410963,3411453,3411272,3410881,3411399,3411533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[3411738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[3412092,3410899,3411946,3412209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[3412453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[3406905,3408422,3407202,3406503,3406761,3406448],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}\u003ctaos::Taos\u003e"},{"line":465,"address":[3408030,3408245,3407830,3406965,3407679,3407359,3407258,3407574,3407627,3407137,3407905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[3406641,3406723,3407032,3407159,3407213,3407293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[3407498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[3407969,3406659,3407852,3407706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[3408213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[3410653,3408783,3408464,3408927,3409400,3408519],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}\u003ctaos::Taos\u003e"},{"line":474,"address":[3410350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[3408657,3409070,3409411,3410028,3409772,3409877,3410104,3410476,3408742,3409825,3410229,3409015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[3409696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[3410051,3408675,3409904,3410168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[3410444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[1846160],"length":1,"stats":{"Line":2},"fn_name":"num_of_rows"},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[1846176],"length":1,"stats":{"Line":2},"fn_name":"fields"},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[1846191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":686,"address":[1846219,1846285],"length":1,"stats":{"Line":4},"fn_name":null},{"line":687,"address":[1846302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[1846357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[1846259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":694,"address":[1846448],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":695,"address":[1846457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[1846480],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[1846512],"length":1,"stats":{"Line":2},"fn_name":"field_count"},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[1846528],"length":1,"stats":{"Line":2},"fn_name":"cell_unchecked"},{"line":707,"address":[1846579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":708,"address":[1846946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[1846644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[1846903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":712,"address":[1846669,1846853],"length":1,"stats":{"Line":4},"fn_name":null},{"line":713,"address":[1846816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[1846694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[1846781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":717,"address":[1846622,1846715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[1846976],"length":1,"stats":{"Line":0},"fn_name":"get_col_unchecked"},{"line":729,"address":[1847024],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[1847047,1847033],"length":1,"stats":{"Line":3},"fn_name":null},{"line":732,"address":[1847049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":734,"address":[1847056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":736,"address":[1847042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[1847088],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":746,"address":[1847136],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":750,"address":[1847184],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":754,"address":[1847232],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":767,"address":[3332000,3331952],"length":1,"stats":{"Line":2},"fn_name":"query\u003calloc::string::String\u003e"},{"line":768,"address":[3332019,3331972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":771,"address":[3332048],"length":1,"stats":{"Line":1},"fn_name":"exec\u003c\u0026str\u003e"},{"line":772,"address":[3332074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[1848990,1849006,1847792],"length":1,"stats":{"Line":3},"fn_name":"query_deserialize"},{"line":779,"address":[1847799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[1847860,1848003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[1848059,1847952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[1849001,1848071,1848372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[1848294,1848399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[1849040],"length":1,"stats":{"Line":3},"fn_name":"block_deserialize_borrowed"},{"line":792,"address":[1849047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[1849224,1849102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[1849277,1849185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[1849289,1849505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":797,"address":[1849510,1849368,1850132],"length":1,"stats":{"Line":3},"fn_name":null},{"line":798,"address":[1849574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[1851337,1850144],"length":1,"stats":{"Line":3},"fn_name":"block_deserialize_borrowed_bytes"},{"line":806,"address":[1850151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[1850212,1850355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":809,"address":[1850304,1850411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[1850645,1850423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":812,"address":[1851363,1850508,1850650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":813,"address":[1850676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[1851376,1851696,1851723,1851383],"length":1,"stats":{"Line":6},"fn_name":"block_deserialize_borrowed_bytes_stream"},{"line":821,"address":[3332341,3332577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[3332634,3332771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[3332835,3332728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[1851490,1851403],"length":1,"stats":{"Line":3},"fn_name":null},{"line":829,"address":[3333000,3333097,3333363,3334315,3333654,3333172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[3332395,3333331,3333136,3333049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[3333681,3333560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[1852564,1851760],"length":1,"stats":{"Line":3},"fn_name":"with_iter"},{"line":842,"address":[1851767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[1851932,1851816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":845,"address":[1851985,1851893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[1851997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[1852076,1852345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[1852350,1852240,1852590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[1852406,1852473],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":65,"coverable":233},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","inline_bytes.rs"],"content":"use std::fmt;\n\n#[repr(C)]\n#[repr(packed(1))]\npub struct InlineBytes\u003cT = u16\u003e {\n    len: T,\n    data: [u8; 0],\n}\n\nmacro_rules! _impl_inline_lines {\n    ($($ty:ty) *) =\u003e {\n        $(\n\n            impl fmt::Debug for InlineBytes\u003c$ty\u003e {\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.debug_struct(\"InlineBytes\")\n                        .field(\"len\", \u0026self.len())\n                        .field(\"data\", \u0026self.as_bytes())\n                        .finish()\n                }\n            }\n\n            impl fmt::Display for InlineBytes\u003c$ty\u003e {\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.write_str(\u0026self.printable())\n                }\n            }\n\n            impl AsRef\u003c[u8]\u003e for InlineBytes\u003c$ty\u003e {\n                fn as_ref(\u0026self) -\u003e \u0026[u8] {\n                    self.as_bytes()\n                }\n            }\n\n            impl InlineBytes\u003c$ty\u003e {\n                #[inline]\n                pub fn from_ptr\u003c'a\u003e(ptr: *const u8) -\u003e \u0026'a Self {\n                    unsafe { std::mem::transmute::\u003c*const u8, \u0026InlineBytes\u003c$ty\u003e\u003e(ptr) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n                    unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n                }\n\n                #[inline]\n                pub fn printable(\u0026self) -\u003e String {\n                    String::from_utf8(self.as_bytes().iter().flat_map(|b| b.escape_ascii().into_iter()).collect()).expect(\"\")\n                }\n\n                #[inline]\n                pub const fn len(\u0026self) -\u003e usize {\n                    self.len as _\n                }\n\n                #[inline]\n                pub fn encode(v: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n                    let len = v.len() as $ty;\n                    let mut vec = Vec::with_capacity(v.len() + std::mem::size_of::\u003c$ty\u003e());\n                    vec.extend(len.to_le_bytes());\n                    vec.extend(v);\n                    vec\n                }\n            }\n        )*\n    };\n}\n_impl_inline_lines!(u8 u16 u32 u64 usize);\n\nmacro_rules! _impl_test_inline_lines {\n    ($ty:ty, $bytes:literal) =\u003e {{\n        let bytes = $bytes;\n        let inline = InlineBytes::\u003c$ty\u003e::from_ptr(bytes.as_ptr());\n        dbg!(inline);\n        assert_eq!(inline.len(), 4);\n        assert_eq!(inline.as_ref(), b\"abcd\");\n        assert_eq!(inline.to_string(), \"abcd\");\n        assert_eq!(InlineBytes::\u003c$ty\u003e::encode(b\"abcd\"), bytes);\n    }};\n}\n\n#[test]\nfn test_inline_lines() {\n    _impl_test_inline_lines!(u8, b\"\\x04abcd\");\n    _impl_test_inline_lines!(u16, b\"\\x04\\x00abcd\");\n    _impl_test_inline_lines!(u32, b\"\\x04\\x00\\x00\\x00abcd\");\n    _impl_test_inline_lines!(u64, b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcd\");\n}\n","traces":[{"line":15,"address":[2761216,2762128,2763040,2759360,2760288],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":16,"address":[2760307,2763102,2760415,2759379,2759487,2761235,2759422,2761343,2762147,2763167,2760350,2763059,2762190,2761278,2762255],"length":1,"stats":{"Line":12},"fn_name":null},{"line":17,"address":[2759407,2762175,2761263,2763087,2760335],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2762230,2761318,2760390,2763142,2759462],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[2762320,2759552,2762452,2760612,2763364,2759684,2761408,2761540,2763232,2760480],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":25,"address":[2760505,2763257,2763336,2762345,2762424,2759656,2759577,2760584,2761433,2761512],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[2762496,2761584,2760656,2763408,2759728],"length":1,"stats":{"Line":4},"fn_name":"as_ref"},{"line":31,"address":[2760665,2761593,2762505,2759737,2763417],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[2762544,2763456,2759776,2760704,2761632],"length":1,"stats":{"Line":4},"fn_name":"from_ptr"},{"line":38,"address":[2763465,2761641,2759785,2762553,2760713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[2764240,2764144,2764336,2763952,2764048],"length":1,"stats":{"Line":4},"fn_name":"as_bytes"},{"line":43,"address":[2764254,2764350,2763966,2764158,2764062],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[2762576,2760736,2763488,2759808,2761664],"length":1,"stats":{"Line":4},"fn_name":"printable"},{"line":48,"address":[2759846,2763526,2761702,2760774,2762614],"length":1,"stats":{"Line":12},"fn_name":null},{"line":52,"address":[2761856,2763680,2762768,2760000,2760928],"length":1,"stats":{"Line":4},"fn_name":"len"},{"line":53,"address":[2760005,2762773,2763685,2761861,2760933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[2761872,2763016,2762104,2763696,2763928,2760944,2760252,2760016,2761189,2762784],"length":1,"stats":{"Line":4},"fn_name":"encode"},{"line":58,"address":[2760978,2760050,2762818,2761906,2763730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[2762828,2760065,2760996,2761921,2763740],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[2763809,2762897,2761122,2763861,2762041,2762949,2761065,2760133,2761989,2760188],"length":1,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[2761168,2762995,2762083,2763907,2760231],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2401264,2401269],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":84,"address":[2765644,2764439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[2765899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2767337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[2768775],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","inline_str.rs"],"content":"use std::fmt;\n\nuse super::Inlinable;\n\n#[repr(C)]\n#[repr(packed(1))]\npub struct InlineStr\u003cT = u16\u003e {\n    len: T,\n    data: [u8; 0],\n}\n// #[repr(C)]\n// #[repr(packed(1))]\n// struct InlineStr\u003cT: AsUsize\u003e {\n//     len: T,\n//     data: [u8; 0],\n// }\n\n// pub trait AsUsize: Copy {\n//     fn as_usize(\u0026self) -\u003e usize;\n// }\n\n// impl AsUsize for u8 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u16 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u32 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u64 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n// impl AsUsize for usize {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl\u003cT: AsUsize\u003e InlineStr\u003cT\u003e {\n//     #[inline]\n//     pub fn from_ptr\u003c'a\u003e(ptr: *const u8) -\u003e \u0026'a Self {\n//         unsafe { std::mem::transmute::\u003c*const u8, \u0026Self\u003e(ptr) }\n//     }\n//     #[inline]\n//     #[rustversion::attr(nightly, const)]\n//     pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n//         unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n//     }\n//     #[inline]\n//     #[rustversion::attr(nightly, const)]\n//     pub fn as_str(\u0026self) -\u003e \u0026str {\n//         unsafe { std::str::from_utf8_unchecked(self.as_bytes()) }\n//     }\n\n//     #[inline]\n//     #[allow(unaligned_references)]\n//     pub fn len(\u0026self) -\u003e usize {\n//         self.len.as_usize()\n//     }\n// }\n\nmacro_rules! _impl_inline_str {\n    ($($ty:ty) *) =\u003e {\n        $(\n\n            impl fmt::Debug for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.debug_struct(\"InlineStr\")\n                        .field(\"len\", \u0026self.len())\n                        .field(\"data\", \u0026self.as_str())\n                        .finish()\n                }\n            }\n\n            impl fmt::Display for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.write_str(self.as_str())\n                }\n            }\n\n            impl AsRef\u003cstr\u003e for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn as_ref(\u0026self) -\u003e \u0026str {\n                    self.as_str()\n                }\n            }\n\n            impl Inlinable for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn write_inlined\u003cW: std::io::Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n                    let l = wtr.write(\u0026self.len.to_le_bytes())?;\n                    Ok(l + wtr.write(self.as_bytes())?)\n                }\n\n                #[inline]\n                fn read_inlined\u003cR: std::io::Read\u003e(_: R) -\u003e std::io::Result\u003cSelf\u003e {\n                    Err(std::io::Error::new(std::io::ErrorKind::Other, \"can't read into a inlined string\"))\n                }\n            }\n\n            impl InlineStr\u003c$ty\u003e {\n                #[inline]\n                pub fn from_ptr\u003c'a\u003e(ptr: *const u8) -\u003e \u0026'a Self {\n                    unsafe { std::mem::transmute::\u003c*const u8, \u0026InlineStr\u003c$ty\u003e\u003e(ptr) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n                    unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_str(\u0026self) -\u003e \u0026str {\n                    unsafe { std::str::from_utf8_unchecked(self.as_bytes()) }\n                }\n\n                #[inline]\n                pub const fn len(\u0026self) -\u003e usize {\n                    self.len as _\n                }\n            }\n        )*\n    };\n}\n_impl_inline_str!(u8 u16 u32 u64 usize);\n\nmacro_rules! _impl_test_inline_str {\n    ($ty:ty, $bytes:literal, $print:literal) =\u003e {{\n        let bytes = $bytes;\n        let inline = InlineStr::\u003c$ty\u003e::from_ptr(bytes.as_ptr());\n        dbg!(inline);\n        assert_eq!(inline.len(), 4);\n        assert_eq!(inline.as_ref(), \"abcd\");\n        assert_eq!(format!(\"{}\", inline), \"abcd\");\n        assert_eq!(inline.inlined(), bytes);\n        assert_eq!(inline.printable_inlined(), $print);\n    }};\n}\n\n#[test]\nfn test_inline_str() {\n    _impl_test_inline_str!(u8, b\"\\x04abcd\", \"\\\\x04abcd\");\n    _impl_test_inline_str!(u16, b\"\\x04\\x00abcd\", \"\\\\x04\\\\x00abcd\");\n    _impl_test_inline_str!(u32, b\"\\x04\\x00\\x00\\x00abcd\", \"\\\\x04\\\\x00\\\\x00\\\\x00abcd\");\n    _impl_test_inline_str!(\n        u64,\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcd\",\n        \"\\\\x04\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00abcd\"\n    );\n}\n","traces":[{"line":80,"address":[2445952,2446320,2445216,2445584,2444848],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":81,"address":[2446447,2445971,2445343,2444975,2446079,2444910,2445278,2445646,2446339,2445603,2446382,2445235,2444867,2446014,2445711],"length":1,"stats":{"Line":12},"fn_name":null},{"line":82,"address":[2445631,2445999,2446367,2445263,2444895],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2444950,2445318,2446054,2446422,2445686],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[2446144,2445040,2445408,2446512,2445776],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":91,"address":[2445059,2445427,2445795,2446163,2446531],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[2445120,2445488,2445856,2446224,2446592],"length":1,"stats":{"Line":4},"fn_name":"as_ref"},{"line":98,"address":[2445497,2446601,2445129,2445865,2446233],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[2186148,2185599,2185072,2186176,2187812,2185616,2187280,2186702,2186720,2187252],"length":1,"stats":{"Line":4},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":105,"address":[2187315,2185651,2186944,2185291,2185698,2186211,2185152,2185107,2187504,2186255,2187362,2186394,2186802,2185840,2186755],"length":1,"stats":{"Line":8},"fn_name":null},{"line":106,"address":[2185915,2187220,2185554,2187019,2185269,2187579,2186670,2186372,2186657,2186469,2186922,2187780,2185366,2187767,2185818,2187207,2186103,2185567,2186116,2187482],"length":1,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[2445904,2445536,2445168,2446272,2446640],"length":1,"stats":{"Line":4},"fn_name":"from_ptr"},{"line":118,"address":[2445177,2445545,2445913,2446281,2446649],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[2447008,2447168,2446848,2447328,2446688],"length":1,"stats":{"Line":4},"fn_name":"as_bytes"},{"line":123,"address":[2446702,2447022,2447182,2446862,2447342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[2447264,2446944,2447104,2447424,2446784],"length":1,"stats":{"Line":4},"fn_name":"as_str"},{"line":128,"address":[2447273,2446953,2447433,2446793,2447113],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[2446672,2445200,2445568,2445936,2446304],"length":1,"stats":{"Line":4},"fn_name":"len"},{"line":133,"address":[2445573,2445941,2446309,2445205,2446677],"length":1,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[2187840,2187845],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":156,"address":[2447501,2448829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[2449330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[2451137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[2452959],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","mod.rs"],"content":"mod inline_bytes;\nmod inline_str;\n\nuse std::{\n    io::{Read, Write},\n    mem::size_of,\n};\n\npub use inline_bytes::InlineBytes;\npub use inline_str::InlineStr;\n\npub trait InlinableWrite: Write {\n    #[inline]\n    /// Write `usize` length as little endian `N` bytes.\n    fn write_len_with_width\u003cconst N: usize\u003e(\u0026mut self, len: usize) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026len.to_le_bytes()[0..N])?;\n        Ok(N)\n    }\n\n    #[inline]\n    /// Write a [u8] value to writer.\n    fn write_u8(\u0026mut self, value: u8) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026[value])?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u16] value to writer.\n    fn write_u16(\u0026mut self, value: u16) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u32] value to writer.\n    fn write_u32(\u0026mut self, value: u32) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u64] value to writer.\n    fn write_u64(\u0026mut self, value: u64) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u128] value to writer.\n    fn write_u128(\u0026mut self, value: u128) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write inlined bytes to writer with specific length width `N`.\n    ///\n    /// The inlined bytes are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    ///  ## Safety\n    ///\n    ///  Write inlined bytes may not be safe if the input bytes length overflows to the width.\n    ///  For example, write `256` bytes with length width `1` is not safe.\n    fn write_inlined_bytes\u003cconst N: usize\u003e(\u0026mut self, bytes: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        let l = self.write(\u0026bytes.len().to_le_bytes()[0..N])?;\n        Ok(l + self.write(bytes)?)\n    }\n\n    #[inline]\n    /// Write inlined string with specific length width `N`.\n    fn write_inlined_str\u003cconst N: usize\u003e(\u0026mut self, s: \u0026str) -\u003e std::io::Result\u003cusize\u003e {\n        self.write_inlined_bytes::\u003cN\u003e(s.as_bytes())\n    }\n\n    #[inline]\n    /// Write an inlinable object.\n    fn write_inlinable\u003cT: Inlinable\u003e(\u0026mut self, value: \u0026T) -\u003e std::io::Result\u003cusize\u003e {\n        value.write_inlined(self)\n    }\n}\n\nimpl\u003cT\u003e InlinableWrite for T where T: Write {}\n\nmacro_rules! _impl_read_exact {\n    ($ty: ty, $N: literal) =\u003e {\n        paste::paste! {\n            fn [\u003cread_ $ty\u003e](\u0026mut self) -\u003e std::io::Result\u003c$ty\u003e {\n                let mut bytes = [0; $N];\n                self.read_exact(\u0026mut bytes)?;\n                Ok($ty::from_le_bytes(bytes))\n            }\n        }\n    };\n}\npub trait InlinableRead: Read {\n    #[inline]\n    /// Read `N` bytes as `usize`.\n    ///\n    /// Only 1/2/4/8 is valid as `N`.\n    fn read_len_with_width\u003cconst N: usize\u003e(\u0026mut self) -\u003e std::io::Result\u003cusize\u003e {\n        let mut bytes: [u8; N] = [0; N];\n        self.read_exact(\u0026mut bytes)?;\n        let len = match N {\n            1 =\u003e bytes[0] as usize,\n            2 =\u003e unsafe { *std::mem::transmute::\u003c*const u8, *const u16\u003e(bytes.as_ptr()) as usize },\n            4 =\u003e unsafe { *std::mem::transmute::\u003c*const u8, *const u32\u003e(bytes.as_ptr()) as usize },\n            8 =\u003e unsafe { *std::mem::transmute::\u003c*const u8, *const u64\u003e(bytes.as_ptr()) as usize },\n            _ =\u003e unreachable!(),\n        };\n        Ok(len)\n    }\n\n    fn read_f32(\u0026mut self) -\u003e std::io::Result\u003cf32\u003e {\n        let mut bytes = [0; 4];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(f32::from_le_bytes(bytes))\n    }\n\n    fn read_f64(\u0026mut self) -\u003e std::io::Result\u003cf64\u003e {\n        let mut bytes = [0; 8];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(f64::from_le_bytes(bytes))\n    }\n\n    fn read_u8(\u0026mut self) -\u003e std::io::Result\u003cu8\u003e {\n        let mut bytes = [0; 1];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u8::from_le_bytes(bytes))\n    }\n    fn read_u16(\u0026mut self) -\u003e std::io::Result\u003cu16\u003e {\n        let mut bytes = [0; 2];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u16::from_le_bytes(bytes))\n    }\n\n    fn read_u32(\u0026mut self) -\u003e std::io::Result\u003cu32\u003e {\n        let mut bytes = [0; 4];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u32::from_le_bytes(bytes))\n    }\n\n    fn read_u64(\u0026mut self) -\u003e std::io::Result\u003cu64\u003e {\n        let mut bytes = [0; 8];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u64::from_le_bytes(bytes))\n    }\n\n    fn read_u128(\u0026mut self) -\u003e std::io::Result\u003cu128\u003e {\n        let mut bytes = [0; 16];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u128::from_le_bytes(bytes))\n    }\n\n    #[inline]\n    /// Read inlined bytes with specific length width `N`.\n    ///\n    /// The inlined bytes are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    fn read_inlined_bytes\u003cconst N: usize\u003e(\u0026mut self) -\u003e std::io::Result\u003cVec\u003cu8\u003e\u003e {\n        let len = self.read_len_with_width::\u003cN\u003e()?;\n        let mut buf = Vec::with_capacity(len);\n        unsafe { buf.set_len(len) };\n        self.read_exact(\u0026mut buf)?;\n        Ok(buf)\n    }\n\n    #[inline]\n    /// Read inlined string with specific length width `N`.\n    ///\n    /// The inlined string are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    fn read_inlined_str\u003cconst N: usize\u003e(\u0026mut self) -\u003e std::io::Result\u003cString\u003e {\n        self.read_inlined_bytes::\u003cN\u003e().and_then(|vec| {\n            String::from_utf8(vec)\n                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))\n        })\n    }\n\n    #[inline]\n    /// Read some bytes into inlinable object.\n    fn read_inlinable\u003cT: Inlinable\u003e(\u0026mut self) -\u003e std::io::Result\u003cT\u003e {\n        T::read_inlined(self)\n    }\n}\n\nimpl\u003cT\u003e InlinableRead for T where T: Read {}\n\n/// If one struct could be serialized/flattened to bytes array, we call it **inlinable**.\npub trait Inlinable: Sized {\n    /// Read inlined bytes into object.\n    fn read_inlined\u003cR: Read\u003e(reader: R) -\u003e std::io::Result\u003cSelf\u003e;\n\n    /// Write inlined bytes to a writer.\n    fn write_inlined\u003cW: Write\u003e(\u0026self, wtr: W) -\u003e std::io::Result\u003cusize\u003e;\n\n    #[inline]\n    /// Get inlined bytes as vector.\n    fn inlined(\u0026self) -\u003e Vec\u003cu8\u003e {\n        let mut buf = Vec::new();\n        self.write_inlined(\u0026mut buf)\n            .expect(\"write to vec should always be success\");\n        buf\n    }\n\n    #[inline]\n    /// Get inlined bytes as printable string, all the bytes will displayed with escaped ascii code.\n    fn printable_inlined(\u0026self) -\u003e String {\n        self.inlined().escape_ascii().to_string()\n    }\n}\n\nimpl Inlinable for u8 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u8(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u8()\n    }\n}\n\nimpl Inlinable for u16 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u16(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u16()\n    }\n}\n\nimpl Inlinable for u32 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u32(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u32()\n    }\n}\n\nimpl Inlinable for u64 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u64(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u64()\n    }\n}\n\n#[test]\nfn inlined_bytes() -\u003e std::io::Result\u003c()\u003e {\n    let s = \"abcd\";\n    let mut vec: Vec\u003cu8\u003e = Vec::new();\n    let bytes = vec.write_inlined_bytes::\u003c1\u003e(s.as_bytes())?;\n    assert_eq!(bytes, 5);\n    assert_eq!(\u0026vec, b\"\\x04abcd\");\n\n    let r = vec.as_slice().read_inlined_str::\u003c1\u003e()?;\n    assert_eq!(r, \"abcd\");\n    Ok(())\n}\n","traces":[{"line":15,"address":[1910384,1910656],"length":1,"stats":{"Line":1},"fn_name":"write_len_with_width\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, 4\u003e"},{"line":16,"address":[1910881,1910429,1910609,1910701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1910587,1910859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1910928,1911088],"length":1,"stats":{"Line":1},"fn_name":"write_u8\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":23,"address":[1911044,1911112,1911204,1910952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1911023,1911183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1911248],"length":1,"stats":{"Line":0},"fn_name":"write_u16\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":30,"address":[1911280,1911398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1911376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1911440,1911632],"length":1,"stats":{"Line":0},"fn_name":"write_u32\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":37,"address":[1911589,1911670,1911478,1911781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1911759,1911567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1911824],"length":1,"stats":{"Line":0},"fn_name":"write_u64\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":44,"address":[1911981,1911866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1911959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1912496,1912976,1913456,1912016],"length":1,"stats":{"Line":3},"fn_name":"write_inlined_bytes\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, 2\u003e"},{"line":71,"address":[1913722,1912282,1912762,1912080,1912560,1913242,1913040,1913520],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[1912462,1912741,1913701,1913886,1913902,1912803,1912446,1913422,1913221,1913763,1912261,1912942,1913283,1912323,1913406,1912926],"length":1,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[1913936,1914048],"length":1,"stats":{"Line":0},"fn_name":"write_inlined_str\u003c\u0026mut \u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, 2\u003e"},{"line":78,"address":[1914030,1914142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1914224,1914160],"length":1,"stats":{"Line":0},"fn_name":"write_inlinable\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, taos_query::common::field::Field\u003e"},{"line":84,"address":[1914259,1914195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2805024,2803632,2804560,2804096],"length":1,"stats":{"Line":3},"fn_name":"read_len_with_width\u003c\u0026mut \u0026[u8], 2\u003e"},{"line":107,"address":[2803659,2805051,2804123,2804587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[2803681,2803781,2804242,2805073,2804609,2805173,2804145,2804709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2805143,2803751,2804679,2804212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[2805465,2804313,2804534,2804780,2804073,2805244,2803852,2805001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[2804785,2804965,2804037,2805429,2805249,2804318,2804498,2803857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[2804811,2804344,2804925,2803883,2805275,2804458,2803997,2805389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[2803906,2804367,2805298,2804834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2805363,2803971,2804432,2804899],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2805680,2805488],"length":1,"stats":{"Line":1},"fn_name":"read_u8\u003c\u0026[u8]\u003e"},{"line":132,"address":[2805704,2805512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[2805621,2805813,2805534,2805726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[2805592,2805856,2805784,2805664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[2805872],"length":1,"stats":{"Line":0},"fn_name":"read_u16\u003c\u0026[u8]\u003e"},{"line":137,"address":[2805896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2805918,2806008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2806052,2805976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2806256,2806064],"length":1,"stats":{"Line":1},"fn_name":"read_u32\u003c\u0026[u8]\u003e"},{"line":143,"address":[2806280,2806088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[2806388,2806302,2806196,2806110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[2806239,2806168,2806360,2806431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[2806448,2806976,2806942,2808526,2807998,2807470,2808032,2807504],"length":1,"stats":{"Line":3},"fn_name":"read_inlined_bytes\u003c\u0026mut \u0026[u8], 2\u003e"},{"line":172,"address":[2807092,2807534,2807620,2808148,2808062,2807006,2806478,2806564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[2807602,2808130,2807074,2806546],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[2807666,2806610,2808194,2807138],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[2806868,2807924,2808452,2807396,2808251,2807195,2806667,2807723],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[2806776,2807304,2808360,2807832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[2808624,2808560,2808688],"length":1,"stats":{"Line":2},"fn_name":"read_inlined_str\u003c\u0026[u8], 1\u003e"},{"line":191,"address":[2808912,2808706,2808578,2808752,2808832,2808642],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003c\u0026[u8], 1\u003e"},{"line":192,"address":[2808766,2808846,2808926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[2809120,2808992,2809127,2808999,2809063,2809056],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c\u0026[u8], 1\u003e"},{"line":199,"address":[2809184],"length":1,"stats":{"Line":0},"fn_name":"read_inlinable\u003c\u0026[u8], taos_query::common::field::Field\u003e"},{"line":200,"address":[2809201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[2077840,2077972],"length":1,"stats":{"Line":6},"fn_name":"inlined\u003ctaos_query::common::raw::inner::RawBlock\u003e"},{"line":217,"address":[2077867],"length":1,"stats":{"Line":6},"fn_name":null},{"line":218,"address":[2077927,2077888],"length":1,"stats":{"Line":12},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[2078000,2078147],"length":1,"stats":{"Line":5},"fn_name":"printable_inlined\u003ctaos_query::common::raw::inner::RawBlock\u003e"},{"line":226,"address":[2078019,2078097],"length":1,"stats":{"Line":10},"fn_name":null},{"line":232,"address":[2810624,2810680],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":233,"address":[2810645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2810760,2810704],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":245,"address":[2810725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2810784,2810839],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":257,"address":[2810805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2810864,2810920],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":269,"address":[2810885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[2810944,2810953],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":280,"address":[2950151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[2950178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[2950497,2950328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[2950405,2950696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[2950750,2950594,2950788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[2950761,2950842,2951077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[2950998,2951217,2951261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[2951223],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":48,"coverable":105},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","benches","is_null.rs"],"content":"#![feature(test)]\n\nextern crate test;\nuse bitvec::prelude::*;\n\nunsafe fn is_null_bit_slice(ptr: *const u8, row: usize) -\u003e bool {\n    let len = 1;\n    let slice = std::slice::from_raw_parts(ptr, len);\n    let is_nulls: \u0026BitSlice\u003cu8, Msb0\u003e = \u0026BitSlice::from_slice_unchecked(slice);\n    is_nulls[row]\n}\n\nunsafe fn is_null(ptr: *const u8, row: usize) -\u003e bool {\n    macro_rules! is_null {\n        ($bm:expr, $row:expr) =\u003e {\n            *$bm.offset($row as isize \u003e\u003e 3) \u003e\u003e (7 - ($row \u0026 7)) \u0026 0x1 == 1\n        };\n    }\n    is_null!(ptr, row)\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn test() {\n        let ptr = [0b11110000; 1].as_ptr();\n        for i in 0..8 {\n            assert_eq!(\n                unsafe { is_null_bit_slice(ptr, i) },\n                unsafe { is_null(ptr, i) },\n                \" in row: {}\",\n                i\n            );\n        }\n    }\n\n    #[bench]\n    fn bench_bit_slice(b: \u0026mut Bencher) {\n        let slice = [0b1010101; 6];\n        b.iter(|| {\n            for i in 0..8 {\n                let _ = unsafe { is_null_bit_slice(slice.as_ptr(), i) };\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_macro(b: \u0026mut Bencher) {\n        let slice = [0b1010101; 6];\n        b.iter(|| {\n            for i in 0..8 {\n                let _ = unsafe { is_null(slice.as_ptr(), i) };\n            }\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","build.rs"],"content":"use std::env;\nuse std::ffi::OsString;\nuse std::fmt::Display;\n\nfn get_env(name: \u0026str) -\u003e Option\u003cOsString\u003e {\n    let var = env::var_os(name);\n    println!(\"cargo:rerun-if-env-changed={}\", name);\n\n    match var {\n        Some(ref v) =\u003e println!(\"{} = {}\", name, v.to_string_lossy()),\n        None =\u003e println!(\"{} unset\", name),\n    }\n\n    var\n}\n\nfn version2features\u003cV: Into\u003cVersion\u003e\u003e(version: V) -\u003e Vec\u003c\u0026'static str\u003e {\n    let version = version.into();\n    let mut feats = Vec::new();\n    if version.mainline == 3 {\n        feats.push(\"v3\");\n        feats.push(\"tmq\");\n        feats.push(\"fetch_raw_block\");\n        feats.push(\"fetch_block_s\");\n    } else if version.mainline == 2 {\n        feats.push(\"v2\");\n        if version \u003e= Version::new(2, 4, 0, 4) {\n            feats.push(\"result_block\");\n        }\n        if version \u003e= Version::new(2, 4, 0, 0) {\n            feats.push(\"json_tag\");\n            feats.push(\"set_config\");\n            feats.push(\"is_update_query\");\n            feats.push(\"reset_db\");\n            feats.push(\"sml\");\n            feats.push(\"parse_time\");\n        }\n    } else {\n        panic!(\"unsupported TDengine client version {version}\")\n    }\n    feats\n}\nfn taos_version() -\u003e String {\n    let lib_env = \"TAOS_LIBRARY_PATH\";\n    if let Some(path) = get_env(lib_env) {\n        println!(\"cargo:rustc-link-search={}\", path.to_string_lossy());\n    }\n    if cfg!(target_os = \"windows\") {\n        println!(\"cargo:rustc-link-search=C:\\\\TDengine\\\\driver\");\n    }\n    let lib_name = if cfg!(target_os = \"windows\") {\n        \"taos.dll\"\n    } else if cfg!(target_os = \"linux\") {\n        \"libtaos.so\"\n    } else if cfg!(target_os = \"darwin\") {\n        \"libtaos.dylib\"\n    } else {\n        unreachable!(\"the current os is not supported\");\n    };\n    let lib = unsafe { libloading::Library::new(lib_name).unwrap() };\n    let version = unsafe {\n        let version: libloading::Symbol\u003cunsafe extern \"C\" fn() -\u003e *const std::os::raw::c_char\u003e =\n            lib.get(b\"taos_get_client_info\\0\").unwrap();\n        std::ffi::CStr::from_ptr(version()).to_string_lossy()\n    };\n    println!(\"cargo:rustc-cfg=taos_version=\\\"v{}\\\"\", version);\n    let parsed_version = Version::parse(\u0026version).expect(\"invalid version of taos\");\n    for feat in version2features(parsed_version) {\n        println!(\"cargo:rustc-cfg=taos_{feat}\");\n    }\n    return version.to_string();\n}\n\n#[derive(Debug, PartialEq, PartialOrd)]\nstruct Version {\n    mainline: u8,\n    major: u8,\n    minor: u8,\n    patch: u8,\n}\n\nimpl Display for Version {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let Version {\n            mainline,\n            major,\n            minor,\n            patch,\n        } = self;\n        f.write_fmt(format_args!(\"{mainline}.{major}.{minor}.{patch}\"))\n    }\n}\n\nimpl Version {\n    fn new(mainline: u8, major: u8, minor: u8, patch: u8) -\u003e Self {\n        Self {\n            mainline,\n            major,\n            minor,\n            patch,\n        }\n    }\n    fn parse(version: \u0026str) -\u003e Result\u003cSelf, Box\u003cdyn std::error::Error\u003e\u003e {\n        let version_items: Vec\u003c_\u003e = version.split('.').collect();\n        let items = version_items.len();\n        if items == 0 || items \u003e 4 {\n            Err(\"parse version error: {version}\")?\n        }\n\n        let mainline = version_items[0].parse()?;\n        let major = version_items\n            .get(1)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n        let minor = version_items\n            .get(2)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n        let patch = version_items\n            .get(3)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n\n        Ok(Self::new(mainline, major, minor, patch))\n    }\n}\n\nfn main() {\n    taos_version();\n    println!(\"cargo:rustc-link-lib=taos\");\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","ffi.rs"],"content":"use std::os::raw::*;\nuse taos_macros::c_cfg;\n\nuse crate::types::*;\n\npub type TAOS = c_void;\npub type TAOS_STMT = c_void;\npub type TAOS_RES = c_void;\npub type TAOS_STREAM = c_void;\npub type TAOS_SUB = c_void;\npub type TAOS_ROW = *mut *mut c_void;\n\npub type taos_subscribe_cb =\n    unsafe extern \"C\" fn(sub: *mut TAOS_SUB, res: *mut TAOS_RES, param: *mut c_void, code: c_int);\n\npub type taos_stream_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut TAOS_RES, row: TAOS_ROW);\n\npub type taos_stream_close_cb = unsafe extern \"C\" fn(param: *mut c_void);\n\nextern \"C\" {\n    pub fn taos_cleanup();\n\n    pub fn taos_options(option: TSDB_OPTION, arg: *const c_void, ...) -\u003e c_int;\n\n    pub fn taos_get_client_info() -\u003e *const c_char;\n\n    pub fn taos_data_type(type_: c_int) -\u003e *const c_char;\n}\n\n#[c_cfg(taos_parse_time)]\nextern \"C\" {\n    pub fn taos_parse_time(\n        time_str: *const c_char,\n        time: *mut i64,\n        len: i32,\n        time_precision: Precision,\n        daylight: i8, // if in daylight saving time (DST) { 1 } else { 0 }\n    ) -\u003e i32;\n}\n\nextern \"C\" {\n    pub fn taos_connect(\n        ip: *const c_char,\n        user: *const c_char,\n        pass: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e *mut TAOS;\n\n    pub fn taos_connect_auth(\n        ip: *const c_char,\n        user: *const c_char,\n        auth: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e *mut TAOS;\n\n    pub fn taos_close(taos: *mut TAOS);\n\n}\n\npub type taos_async_fetch_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut c_void, rows: c_int);\n\npub type taos_async_query_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut c_void, code: c_int);\n\nextern \"C\" {\n    pub fn taos_fetch_rows_a(res: *mut TAOS_RES, fp: taos_async_fetch_cb, param: *mut c_void);\n\n    pub fn taos_query_a(\n        taos: *mut TAOS,\n        sql: *const c_char,\n        fp: taos_async_query_cb,\n        param: *mut c_void,\n    );\n}\n\nextern \"C\" {\n    pub fn taos_load_table_info(taos: *mut TAOS, tableNameList: *const c_char) -\u003e c_int;\n\n    pub fn taos_stmt_init(taos: *mut TAOS) -\u003e *mut TAOS_STMT;\n\n    pub fn taos_stmt_prepare(stmt: *mut TAOS_STMT, sql: *const c_char, length: c_ulong) -\u003e c_int;\n\n    pub fn taos_stmt_set_tbname_tags(\n        stmt: *mut TAOS_STMT,\n        name: *const c_char,\n        tags: *mut TaosBind,\n    ) -\u003e c_int;\n\n    pub fn taos_stmt_set_tbname(stmt: *mut TAOS_STMT, name: *const c_char) -\u003e c_int;\n\n    pub fn taos_stmt_set_sub_tbname(stmt: *mut TAOS_STMT, name: *const c_char) -\u003e c_int;\n\n    pub fn taos_stmt_is_insert(stmt: *mut TAOS_STMT, insert: *mut c_int) -\u003e c_int;\n\n    pub fn taos_stmt_num_params(stmt: *mut TAOS_STMT, nums: *mut c_int) -\u003e c_int;\n\n    pub fn taos_stmt_get_param(\n        stmt: *mut TAOS_STMT,\n        idx: c_int,\n        type_: *mut c_int,\n        bytes: *mut c_int,\n    ) -\u003e c_int;\n\n    pub fn taos_stmt_bind_param(stmt: *mut TAOS_STMT, bind: *const TaosBind) -\u003e c_int;\n\n    pub fn taos_stmt_bind_param_batch(stmt: *mut TAOS_STMT, bind: *const TaosMultiBind) -\u003e c_int;\n\n    pub fn taos_stmt_bind_single_param_batch(\n        stmt: *mut TAOS_STMT,\n        bind: *const TaosMultiBind,\n        colIdx: c_int,\n    ) -\u003e c_int;\n\n    pub fn taos_stmt_add_batch(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_execute(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_affected_rows(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_use_result(stmt: *mut TAOS_STMT) -\u003e *mut TAOS_RES;\n\n    pub fn taos_stmt_close(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_errstr(stmt: *mut TAOS_STMT) -\u003e *const c_char;\n}\n\nextern \"C\" {\n    pub fn taos_query(taos: *mut TAOS, sql: *const c_char) -\u003e *mut TAOS_RES;\n\n    pub fn taos_fetch_row(res: *mut TAOS_RES) -\u003e TAOS_ROW;\n\n    pub fn taos_result_precision(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_free_result(res: *mut TAOS_RES);\n\n    pub fn taos_field_count(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_num_fields(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_affected_rows(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_fetch_fields(res: *mut TAOS_RES) -\u003e *mut TAOS_FIELD;\n\n    pub fn taos_select_db(taos: *mut TAOS, db: *const c_char) -\u003e c_int;\n\n    pub fn taos_print_row(\n        str_: *mut c_char,\n        row: TAOS_ROW,\n        fields: *mut TAOS_FIELD,\n        num_fields: c_int,\n    ) -\u003e c_int;\n\n    pub fn taos_stop_query(res: *mut TAOS_RES);\n\n    pub fn taos_is_null(res: *mut TAOS_RES, row: i32, col: i32) -\u003e bool;\n\n    pub fn taos_is_update_query(res: *mut TAOS_RES) -\u003e bool;\n\n    pub fn taos_fetch_block(res: *mut TAOS_RES, rows: *mut TAOS_ROW) -\u003e c_int;\n\n    pub fn taos_fetch_lengths(res: *mut TAOS_RES) -\u003e *mut c_int;\n\n    pub fn taos_validate_sql(taos: *mut TAOS, sql: *const c_char) -\u003e c_int;\n\n    pub fn taos_reset_current_db(taos: *mut TAOS);\n\n    pub fn taos_get_server_info(taos: *mut TAOS) -\u003e *mut c_char;\n\n    pub fn taos_errstr(tres: *mut TAOS_RES) -\u003e *mut c_char;\n\n    pub fn taos_errno(tres: *mut TAOS_RES) -\u003e c_int;\n\n}\n\n#[c_cfg(taos_v3)]\nextern \"C\" {\n    pub fn taos_get_column_data_offset(res: *mut TAOS_RES, col: i32) -\u003e *mut i32;\n\n    pub fn taos_fetch_raw_block(res: *mut TAOS_RES, num: *mut i32, data: *mut *mut c_void)\n        -\u003e c_int;\n\n    pub fn taos_fetch_raw_block_a(res: *mut TAOS_RES, fp: taos_async_fetch_cb, param: *mut c_void);\n\n    pub fn taos_get_raw_block(taos: *mut TAOS_RES) -\u003e *mut c_void;\n}\n\n#[c_cfg(taos_result_block)]\nextern \"C\" {\n    pub fn taos_result_block(res: *mut TAOS_RES) -\u003e *mut TAOS_ROW;\n}\n\n#[cfg(taos_fetch_block_s)]\nextern \"C\" {\n    pub fn taos_fetch_block_s(\n        res: *mut TAOS_RES,\n        num_of_rows: *mut c_int,\n        rows: *mut TAOS_ROW,\n    ) -\u003e c_int;\n}\n\n#[cfg(not(taos_fetch_block_s))]\n#[no_mangle]\npub unsafe extern \"C\" fn taos_fetch_block_s(\n    res: *mut TAOS_RES,\n    num_of_rows: *mut c_int,\n    rows: *mut TAOS_ROW,\n) -\u003e c_int {\n    *num_of_rows = taos_fetch_block(res, rows);\n    return 0;\n}\n\nextern \"C\" {\n    pub fn taos_subscribe(\n        taos: *mut TAOS,\n        restart: c_int,\n        topic: *const c_char,\n        sql: *const c_char,\n        fp: Option\u003ctaos_subscribe_cb\u003e,\n        param: *mut c_void,\n        interval: c_int,\n    ) -\u003e *mut TAOS_SUB;\n\n    pub fn taos_consume(tsub: *mut TAOS_SUB) -\u003e *mut TAOS_RES;\n\n    pub fn taos_unsubscribe(tsub: *mut TAOS_SUB, keep_progress: c_int);\n}\n\nextern \"C\" {\n    pub fn taos_open_stream(\n        taos: *mut TAOS,\n        sql: *const c_char,\n        fp: Option\u003ctaos_stream_cb\u003e,\n        stime: i64,\n        param: *mut c_void,\n        callback: Option\u003ctaos_stream_close_cb\u003e,\n    ) -\u003e *mut TAOS_STREAM;\n\n    pub fn taos_close_stream(stream: *mut TAOS_STREAM);\n}\n","traces":[{"line":31,"address":[8095165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[8095136],"length":1,"stats":{"Line":0},"fn_name":"taos_parse_time"},{"line":191,"address":[8095241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8095232],"length":1,"stats":{"Line":0},"fn_name":"taos_result_block"}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","into_c_str.rs"],"content":"use std::borrow::Cow;\nuse std::ffi::{c_void, CStr, CString};\nuse std::os::raw::c_char;\n\n/// Helper trait to auto convert Rust strings to CStr.\npub trait IntoCStr\u003c'a\u003e {\n    fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e;\n}\n\nmacro_rules! _impl_for_raw {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoCStr\u003c'a\u003e for $t {\n            fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n                Cow::from(self)\n            }\n        }\n    };\n}\n_impl_for_raw!(CString);\n_impl_for_raw!(\u0026'a CStr);\n_impl_for_raw!(\u0026'a CString);\n\nmacro_rules! _impl_for_ref {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoCStr\u003c'a\u003e for \u0026'a $t {\n            fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n                self.as_c_str().into_c_str()\n            }\n        }\n    };\n}\n_impl_for_ref!(\u0026CString);\n_impl_for_ref!(\u0026\u0026CString);\n\nimpl\u003c'a\u003e IntoCStr\u003c'a\u003e for \u0026\u0026'a CStr {\n    fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n        Cow::from(*self)\n    }\n}\n\nimpl\u003c'a\u003e IntoCStr\u003c'a\u003e for String {\n    fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n        let v = self.into_bytes();\n        Cow::from(unsafe { CString::from_vec_unchecked(v) })\n    }\n}\n\nmacro_rules! _impl_for_str {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoCStr\u003c'a\u003e for \u0026'a $t {\n            fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n                self.to_owned().into_c_str()\n            }\n        }\n    };\n}\n\n_impl_for_str!(String);\n_impl_for_str!(str);\n_impl_for_str!(\u0026str);\n\npub struct NullableCStr\u003c'a\u003e(Option\u003cCow\u003c'a, CStr\u003e\u003e);\n\nimpl\u003c'a\u003e NullableCStr\u003c'a\u003e {\n    pub fn as_ptr(\u0026self) -\u003e *const c_char {\n        match self.0.as_ref() {\n            Some(c) =\u003e c.as_ptr(),\n            None =\u003e std::ptr::null(),\n        }\n    }\n}\n\npub trait IntoNullableCStr\u003c'a\u003e {\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e;\n}\n\nimpl\u003c'a, T\u003e IntoNullableCStr\u003c'a\u003e for T\nwhere\n    T: IntoCStr\u003c'a\u003e,\n{\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(Some(self.into_c_str()))\n    }\n}\n\nimpl\u003c'a, T\u003e IntoNullableCStr\u003c'a\u003e for Option\u003cT\u003e\nwhere\n    T: IntoCStr\u003c'a\u003e,\n{\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(self.map(IntoCStr::into_c_str))\n    }\n}\n\nimpl\u003c'a, T\u003e IntoNullableCStr\u003c'a\u003e for \u0026'a Option\u003cT\u003e\nwhere\n    \u0026'a T: IntoCStr\u003c'a\u003e,\n{\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(self.as_ref().map(|c| c.into_c_str()))\n    }\n}\n\nimpl\u003c'a\u003e IntoNullableCStr\u003c'a\u003e for () {\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(None)\n    }\n}\n\nimpl\u003c'a, T\u003e From\u003cT\u003e for NullableCStr\u003c'a\u003e\nwhere\n    T: IntoNullableCStr\u003c'a\u003e,\n{\n    fn from(rhs: T) -\u003e NullableCStr\u003c'a\u003e {\n        rhs.into_nullable_c_str()\n    }\n}\n\nmacro_rules! _impl_for_ptr {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoNullableCStr\u003c'a\u003e for $t {\n            fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n                NullableCStr(if self.is_null() {\n                    None\n                } else {\n                    Some(Cow::from(unsafe { CStr::from_ptr(self as _) }))\n                })\n            }\n        }\n    };\n}\n\n_impl_for_ptr!(*const i8);\n_impl_for_ptr!(*mut i8);\n_impl_for_ptr!(*const u8);\n_impl_for_ptr!(*mut u8);\n_impl_for_ptr!(*mut c_void);\n\n#[cfg(test)]\nmod test_into_c_str {\n    use std::{\n        borrow::Borrow,\n        ffi::{CStr, CString},\n    };\n\n    use super::*;\n\n    fn from_c_str\u003c'a\u003e(_: impl IntoCStr\u003c'a\u003e) {}\n\n    #[test]\n    fn c_str_to_c_str() {\n        let s = CStr::from_bytes_with_nul(b\"abc\\0\").unwrap();\n        from_c_str(\u0026s);\n        from_c_str(s);\n    }\n    #[test]\n    fn c_string_to_c_str() {\n        let s = CString::new(\"abc\").unwrap();\n        from_c_str(\u0026s);\n        from_c_str(s);\n    }\n    #[test]\n    fn str_to_c_str() {\n        let s = \"abc\";\n        from_c_str(\u0026s);\n        from_c_str(s);\n    }\n    #[test]\n    fn string_to_c_str() {\n        let s = String::from(\"abc\");\n        from_c_str(\u0026s);\n        from_c_str(s.as_str());\n        from_c_str(s);\n    }\n\n    #[test]\n    fn option_string_to_c_str() {\n        let s = Some(String::from(\"abc\"));\n        let _ = s.borrow().into_nullable_c_str();\n        let _ = s.as_ref().into_nullable_c_str();\n        let _ = s.into_nullable_c_str();\n    }\n    #[test]\n    fn option_cstring_to_c_str() {\n        let s = Some(CString::new(\"abc\").unwrap());\n        let _ = s.borrow().into_nullable_c_str();\n        let _ = s.as_ref().into_nullable_c_str();\n        let _ = s.into_nullable_c_str();\n    }\n}\n","traces":[{"line":13,"address":[8062448],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":14,"address":[8128753,8128709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[8128768,8128848],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":27,"address":[8128786,8128866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8062400],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":37,"address":[8062420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[8092928],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":43,"address":[8092942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[8092983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[8093072],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":52,"address":[8115872,8115799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[8115584],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":66,"address":[8115593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[8115662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[8115655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3446912],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str\u003calloc::string::String\u003e"},{"line":100,"address":[3446944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[8115728],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str"},{"line":106,"address":[8115735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[3454864],"length":1,"stats":{"Line":0},"fn_name":"from\u003c\u0026core::option::Option\u003calloc::string::String\u003e\u003e"},{"line":115,"address":[3454881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8115920,8116448,8116272,8116096],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str"},{"line":123,"address":[8116480,8116540,8116092,8116620,8116364,8116128,8116444,8116304,8115952,8116012,8116188,8116268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8116521,8116345,8115993,8116169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8116228,8115977,8116052,8116505,8116404,8116329,8116153,8116580],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","lib.rs"],"content":"#![feature(const_slice_from_raw_parts)]\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\n#![allow(unused_variables)]\n\nuse std::{ffi::CStr, marker::PhantomData, ops::Deref, os::raw::*, sync::Arc};\n\nuse into_c_str::IntoCStr;\nuse once_cell::sync::OnceCell;\nuse taos_error::{Code, Error};\nuse taos_query::common::{Field, Ty};\n\npub(crate) mod types;\npub use types::*;\npub mod ffi;\nuse ffi::*;\n\nmod set_config;\npub use set_config::*;\n\npub use ffi::taos_options;\n\nmod schemaless;\npub use schemaless::*;\n\nmod tmq;\npub use tmq::*;\n\nmacro_rules! err_or {\n    ($res:ident, $code:expr, $ret:expr) =\u003e {\n        unsafe {\n            let code: Code = { $code }.into();\n            if code.success() {\n                Ok($ret)\n            } else {\n                Err(Error::new(code, $res.err_as_str()))\n            }\n        }\n    };\n\n    ($res:ident, $code:expr) =\u003e {{\n        err_or!($res, $code, ())\n    }};\n    ($code:expr, $ret:expr) =\u003e {\n        unsafe {\n            let code: Code = { $code }.into();\n            if code.success() {\n                Ok($ret)\n            } else {\n                Err(Error::from_code(code))\n            }\n        }\n    };\n\n    ($code:expr) =\u003e {\n        err_or!($code, ())\n    };\n}\n\n#[derive(Debug)]\n#[repr(transparent)]\npub struct RawTaos(*mut TAOS);\n\nimpl Drop for RawTaos {\n    fn drop(\u0026mut self) {\n        self.close()\n    }\n}\n\nimpl RawTaos {\n    /// Client version.\n    pub fn version() -\u003e \u0026'static CStr {\n        unsafe { CStr::from_ptr(taos_get_client_info()) }\n    }\n\n    #[inline]\n    pub fn connect(\n        host: *const c_char,\n        user: *const c_char,\n        pass: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let ptr = unsafe { taos_connect(host, user, pass, db, port) };\n        let null = std::ptr::null_mut();\n        let code = unsafe { taos_errno(null) };\n        if code != 0 {\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            let err = Error::new(code, err);\n            log::trace!(\"error: {err}\");\n        }\n\n        if ptr.is_null() {\n            let null = std::ptr::null_mut();\n            let code = unsafe { taos_errno(null) };\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            Err(Error::new(code, err))\n        } else {\n            Ok(RawTaos(ptr))\n        }\n    }\n    #[inline]\n    pub fn connect_auth(\n        host: *const c_char,\n        user: *const c_char,\n        auth: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let ptr = unsafe { taos_connect_auth(host, user, auth, db, port) };\n        if ptr.is_null() {\n            let null = std::ptr::null_mut();\n            let code = unsafe { taos_errno(null) };\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            Err(Error::new(code, err))\n        } else {\n            Ok(RawTaos(ptr))\n        }\n    }\n\n    #[inline]\n    pub fn as_ptr(\u0026self) -\u003e *mut TAOS {\n        self.0\n    }\n\n    #[inline]\n    pub fn query\u003c'a, S: IntoCStr\u003c'a\u003e\u003e(\u0026self, sql: S) -\u003e Result\u003cDroppableRawRes, Error\u003e {\n        RawRes::from_ptr(unsafe { taos_query(self.as_ptr(), sql.into_c_str().as_ptr()) })\n            .map(DroppableRawRes::new)\n    }\n\n    #[inline]\n    pub fn query_a(\u0026self, sql: *const i8, fp: taos_async_query_cb, param: *mut c_void) {\n        unsafe { taos_query_a(self.as_ptr(), sql, fp, param) }\n    }\n\n    #[inline]\n    pub fn validate_sql(self, sql: *const c_char) -\u003e Result\u003c(), Error\u003e {\n        let code: Code = unsafe { taos_validate_sql(self.as_ptr(), sql) }.into();\n        if code.success() {\n            return Ok(());\n        } else {\n            let err = unsafe { taos_errstr(std::ptr::null_mut()) };\n            let err = unsafe { std::str::from_utf8_unchecked(CStr::from_ptr(err).to_bytes()) };\n            return Err(Error::new(code, err));\n        }\n    }\n\n    #[inline]\n    pub fn reset_current_db(\u0026self) {\n        unsafe { taos_reset_current_db(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn server_version(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(taos_get_server_info(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn load_table_info(\u0026self, list: *const c_char) -\u003e Result\u003c(), Error\u003e {\n        err_or!(taos_load_table_info(self.as_ptr(), list))\n    }\n\n    #[inline]\n    pub fn close(\u0026mut self) {\n        unsafe { taos_close(self.as_ptr()) }\n    }\n}\n\n#[derive(Debug)]\npub struct RawRes {\n    ptr: *mut TAOS_RES,\n    fields: OnceCell\u003cVec\u003cField\u003e\u003e,\n}\n\nunsafe impl Send for RawRes {}\nunsafe impl Sync for RawRes {}\n\n#[derive(Debug)]\npub struct DroppableRawRes {\n    raw: Arc\u003cRawRes\u003e,\n}\n\nimpl Deref for DroppableRawRes {\n    type Target = RawRes;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.raw\n    }\n}\n\nimpl DroppableRawRes {\n    pub fn new(raw: RawRes) -\u003e Self {\n        Self { raw: Arc::new(raw) }\n    }\n\n    pub fn from_ptr_with_code(ptr: *mut TAOS_RES, code: Code) -\u003e Result\u003cSelf, Error\u003e {\n        RawRes::from_ptr_with_code(ptr, code).map(Self::new)\n    }\n\n    pub fn raw(\u0026self) -\u003e Arc\u003cRawRes\u003e {\n        self.raw.clone()\n    }\n}\n\npub type VGroupId = i32;\n\nimpl Drop for DroppableRawRes {\n    fn drop(\u0026mut self) {\n        if let Some(raw) = Arc::get_mut(\u0026mut self.raw) {\n            raw.free_result();\n        } else {\n            log::error!(\"there's other result pointer in-use, please check\");\n            // todo: safely drop result pointer.\n            // panic!(\"there's other result pointer in-use, please check\");\n        }\n    }\n}\n\nimpl RawRes {\n    #[inline]\n    pub fn as_ptr(\u0026self) -\u003e *mut TAOS_RES {\n        self.ptr\n    }\n\n    #[inline]\n    pub fn errno(\u0026self) -\u003e Code {\n        unsafe { taos_errno(self.as_ptr()) \u0026 0xffff }.into()\n    }\n    #[inline]\n    pub fn errstr(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(taos_errstr(self.as_ptr())) }\n    }\n    #[inline]\n    pub fn err_as_str(\u0026self) -\u003e \u0026'static str {\n        unsafe {\n            std::str::from_utf8_unchecked(CStr::from_ptr(taos_errstr(self.as_ptr())).to_bytes())\n        }\n    }\n\n    #[inline]\n    pub fn from_ptr(ptr: *mut TAOS_RES) -\u003e Result\u003cRawRes, Error\u003e {\n        let raw = unsafe { Self::from_ptr_unchecked(ptr) };\n        let code = raw.errno();\n        raw.with_code(code)\n    }\n\n    #[inline]\n    pub const unsafe fn from_ptr_unchecked(ptr: *mut TAOS_RES) -\u003e RawRes {\n        RawRes {\n            ptr,\n            fields: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    pub fn from_ptr_with_code(ptr: *mut TAOS_RES, code: Code) -\u003e Result\u003cRawRes, Error\u003e {\n        unsafe { RawRes::from_ptr_unchecked(ptr) }.with_code(code)\n    }\n\n    #[inline]\n    fn with_code(self, code: Code) -\u003e Result\u003cSelf, Error\u003e {\n        if code.success() {\n            Ok(self)\n        } else {\n            Err(Error::new(code, self.err_as_str()))\n        }\n    }\n\n    #[inline]\n    pub fn num_fields(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n    #[inline]\n    pub fn fields\u003c'any\u003e(\u0026self) -\u003e \u0026[Field] {\n        let fields = self.fields.get_or_init(|| {\n            let len = unsafe { taos_num_fields(self.as_ptr()) };\n            from_raw_fields(unsafe { taos_fetch_fields(self.as_ptr()) }, len as usize)\n        });\n        \u0026fields\n    }\n\n    pub fn fetch_fields(\u0026self) -\u003e Vec\u003cField\u003e {\n        let len = unsafe { taos_num_fields(self.as_ptr()) };\n        from_raw_fields(unsafe { taos_fetch_fields(self.as_ptr()) }, len as usize)\n    }\n\n    #[inline]\n    pub fn fetch_lengths(\u0026self) -\u003e *const i32 {\n        unsafe { taos_fetch_lengths(self.as_ptr()) }\n    }\n    #[inline]\n    unsafe fn fetch_lengths_raw(\u0026self) -\u003e *const i32 {\n        taos_fetch_lengths(self.as_ptr())\n    }\n\n    #[inline]\n    pub fn fetch_block(\u0026self) -\u003e Result\u003cOption\u003c(TAOS_ROW, i32, *const i32)\u003e, Error\u003e {\n        let block = Box::into_raw(Box::new(std::ptr::null_mut()));\n        let mut num = 0;\n        err_or!(\n            self,\n            taos_fetch_block_s(self.as_ptr(), \u0026mut num, block),\n            if num \u003e 0 {\n                Some((*block, num, self.fetch_lengths_raw()))\n            } else {\n                None\n            }\n        )\n    }\n\n    #[inline]\n    pub fn get_column_data_offset(\u0026self, col: usize) -\u003e *const i32 {\n        unsafe { taos_get_column_data_offset(self.as_ptr(), col as i32) }\n    }\n\n    #[inline]\n    pub fn fetch_raw_block(\u0026self) -\u003e Result\u003c(*mut u8, u32), Error\u003e {\n        let block = Box::into_raw(Box::new(std::ptr::null_mut()));\n        let mut num = 0;\n        err_or!(\n            self,\n            taos_fetch_raw_block(self.as_ptr(), \u0026mut num as _, block),\n            (*block as _, num as _)\n        )\n    }\n\n    #[inline]\n    pub fn is_update_query(\u0026self) -\u003e bool {\n        unsafe { taos_is_update_query(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn is_null(\u0026self, row: i32, col: i32) -\u003e bool {\n        unsafe { taos_is_null(self.as_ptr(), row, col) }\n    }\n\n    #[inline]\n    pub fn stop_query(\u0026self) {\n        unsafe { taos_stop_query(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn select_db(\u0026self, db: *const i8) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_select_db(self.as_ptr(), db))\n    }\n\n    #[inline]\n    pub fn affected_rows(\u0026self) -\u003e i32 {\n        unsafe { taos_affected_rows(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn field_count(\u0026self) -\u003e i32 {\n        unsafe { taos_field_count(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn free_result(\u0026mut self) {\n        unsafe { taos_free_result(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn precision(\u0026self) -\u003e Precision {\n        unsafe { taos_result_precision(self.as_ptr()) }.into()\n    }\n\n    #[inline]\n    pub fn fetch_row(\u0026self) -\u003e TAOS_ROW {\n        unsafe { taos_fetch_row(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn fetch_rows_a(\u0026self, fp: taos_async_fetch_cb, param: *mut c_void) {\n        unsafe { taos_fetch_rows_a(self.as_ptr(), fp, param) }\n    }\n\n    #[inline]\n    pub fn block(\u0026self) -\u003e *mut *mut c_void {\n        unsafe { taos_result_block(self.as_ptr()).read() }\n    }\n\n    #[inline]\n    pub fn tmq_topic_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        unsafe {\n            let c = tmq_get_topic_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n    #[inline]\n    pub fn tmq_vgroup_id(\u0026self) -\u003e Option\u003cVGroupId\u003e {\n        unsafe {\n            let c = tmq_get_vgroup_id(self.as_ptr());\n            if c == -1 {\n                None\n            } else {\n                Some(c)\n            }\n        }\n    }\n\n    #[inline]\n    pub fn tmq_table_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        unsafe {\n            let c = tmq_get_table_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n    #[inline]\n    pub fn tmq_db_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        unsafe {\n            let c = tmq_get_db_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n}\n\npub mod into_c_str;\npub mod stmt;\n\n// #[derive(Debug, Clone, Copy)]\n// #[repr(C)]\n// enum BlockVer {\n//     V2 = 0,\n//     V3,\n// }\n// #[derive(Debug, Clone, Copy)]\n// #[repr(C)]\n\n// enum BlockCodec {\n//     Bytes,\n// }\n\n// #[derive(Debug)]\n// enum BlockType\u003c'a\u003e {\n//     V2(*mut *mut c_void),\n//     Bytes(Cow\u003c'a, [u8]\u003e),\n// }\n\n// struct RawCodec\u003c'a\u003e {\n//     version: BlockVer,\n//     method: BlockCodec,\n//     precision: Precision,\n//     fields: Cow\u003c'a, [Field]\u003e,\n// }\n\n// #[derive(Debug)]\n// pub struct RawBlock\u003c'a\u003e {\n//     version: BlockVer,\n//     codec: BlockCodec,\n//     precision: Precision,\n//     fields: Cow\u003c'a, [Field]\u003e,\n//     num_of_rows: usize,\n//     data: BlockType\u003c'a\u003e,\n// }\n\n// impl\u003c'a\u003e RawBlock\u003c'a\u003e {\n//     fn precision(\u0026self) -\u003e Precision {\n//         self.precision\n//     }\n\n//     fn to_bytes(\u0026self) -\u003e Cow\u003c[u8]\u003e {\n//         todo!()\n//     }\n\n//     fn write\u003cT: Write\u003e(\u0026self, mut wtr: T) -\u003e std::io::Result\u003cusize\u003e {\n//         wtr.write(\u0026self.to_bytes())\n//     }\n\n//     fn write_all\u003cT: Write\u003e(\u0026self, mut wtr: T) -\u003e std::io::Result\u003cusize\u003e {\n//         wtr.write(\u0026self.to_bytes())\n//     }\n// }\n","traces":[{"line":65,"address":[8102144],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":66,"address":[8102149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[8053616],"length":1,"stats":{"Line":0},"fn_name":"version"},{"line":73,"address":[8053620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3857520,3857970],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":84,"address":[3857663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3857751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[3857767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[3857788,3858522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3857824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3858038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[3858273,3858191,3858353,3858105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3858999,3858602,3857801,3858553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3858650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[3858663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3858685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3858879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3858575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[8055616,8055184],"length":1,"stats":{"Line":0},"fn_name":"connect_auth"},{"line":114,"address":[8055297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8055333,8055390,8055795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[8055438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[8055451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[8055473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[8055684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[8055363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3857504],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":129,"address":[3857509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3898496,3898839,3898863],"length":1,"stats":{"Line":0},"fn_name":"query\u003c\u0026str\u003e"},{"line":134,"address":[3898746,3898560,3898639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3859040],"length":1,"stats":{"Line":0},"fn_name":"query_a"},{"line":140,"address":[3859079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8056369,8055936],"length":1,"stats":{"Line":0},"fn_name":"validate_sql"},{"line":145,"address":[8055976,8056039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[8056081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[8056166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8056194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[8056223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[8056318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[8056416],"length":1,"stats":{"Line":0},"fn_name":"reset_current_db"},{"line":157,"address":[8056425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8056464],"length":1,"stats":{"Line":0},"fn_name":"server_version"},{"line":162,"address":[8056473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[8056544],"length":1,"stats":{"Line":0},"fn_name":"load_table_info"},{"line":167,"address":[8056699,8056586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[8056720],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":172,"address":[8056729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8056768],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":194,"address":[8056777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[8056800],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":200,"address":[8056807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[8056864],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code"},{"line":204,"address":[8056887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[8056928],"length":1,"stats":{"Line":0},"fn_name":"raw"},{"line":208,"address":[8056937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8102160],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":216,"address":[8102172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[8102216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[8102308,8102223,8102357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3856688],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":229,"address":[3856693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[3856624],"length":1,"stats":{"Line":0},"fn_name":"errno"},{"line":234,"address":[3856633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8057040],"length":1,"stats":{"Line":0},"fn_name":"errstr"},{"line":238,"address":[8057049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[3855120],"length":1,"stats":{"Line":0},"fn_name":"err_as_str"},{"line":243,"address":[3855129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[3856864,3857065,3857034],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":249,"address":[3856886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3856911,3856962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3856969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3856320],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_unchecked"},{"line":258,"address":[3856344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3856416],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code"},{"line":264,"address":[3856443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[3857152,3857439],"length":1,"stats":{"Line":0},"fn_name":"with_code"},{"line":269,"address":[3857437,3857178,3857259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3857300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[3857385,3857270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[8058000],"length":1,"stats":{"Line":0},"fn_name":"num_fields"},{"line":278,"address":[8058009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3856704],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":282,"address":[3856716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[8130560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[8130594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3856744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[8058112],"length":1,"stats":{"Line":0},"fn_name":"fetch_fields"},{"line":290,"address":[8058144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[8058178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[3856064],"length":1,"stats":{"Line":0},"fn_name":"fetch_lengths"},{"line":296,"address":[3856073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[3856272],"length":1,"stats":{"Line":0},"fn_name":"fetch_lengths_raw"},{"line":300,"address":[3856281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[3855248],"length":1,"stats":{"Line":0},"fn_name":"fetch_block"},{"line":305,"address":[3855415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[3855439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[3855486,3855714,3855796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[3855447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3855573,3855554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3855588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3855561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[3856496],"length":1,"stats":{"Line":0},"fn_name":"get_column_data_offset"},{"line":320,"address":[3856515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8059008],"length":1,"stats":{"Line":0},"fn_name":"fetch_raw_block"},{"line":325,"address":[8059175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[8059199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8059387,8059246,8059337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[8059207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[8059321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[8059440],"length":1,"stats":{"Line":0},"fn_name":"is_update_query"},{"line":336,"address":[8059449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[3856784],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":341,"address":[3856809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[8059568],"length":1,"stats":{"Line":0},"fn_name":"stop_query"},{"line":346,"address":[8059577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[8059616],"length":1,"stats":{"Line":0},"fn_name":"select_db"},{"line":351,"address":[8059802,8059664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[3856016],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":356,"address":[3856025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[8059888],"length":1,"stats":{"Line":0},"fn_name":"field_count"},{"line":361,"address":[8059897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[8059936],"length":1,"stats":{"Line":0},"fn_name":"free_result"},{"line":366,"address":[8059945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3857088],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":371,"address":[3857097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[8060048],"length":1,"stats":{"Line":0},"fn_name":"fetch_row"},{"line":376,"address":[8060057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[8060096],"length":1,"stats":{"Line":0},"fn_name":"fetch_rows_a"},{"line":381,"address":[8060125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[3856560],"length":1,"stats":{"Line":0},"fn_name":"block"},{"line":386,"address":[3856569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8060240],"length":1,"stats":{"Line":0},"fn_name":"tmq_topic_name"},{"line":392,"address":[8060249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[8060285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[8060327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[8060310,8060361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8060400],"length":1,"stats":{"Line":0},"fn_name":"tmq_vgroup_id"},{"line":403,"address":[8060409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8060455,8060442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8060447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8060461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[3856112],"length":1,"stats":{"Line":0},"fn_name":"tmq_table_name"},{"line":415,"address":[3856121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[3856157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[3856199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[3856233,3856182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[3855856],"length":1,"stats":{"Line":0},"fn_name":"tmq_db_name"},{"line":426,"address":[3855865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[3855901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[3855943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[3855977,3855926],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":154},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","schemaless.rs"],"content":"use crate::{TAOS, TAOS_RES};\nuse std::os::raw::*;\n\n///\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum SchemalessProtocol {\n    #[non_exhaustive]\n    Unknown = 0,\n    Line,\n    Telnet,\n    Json,\n}\npub type TSDB_SML_PROTOCOL_TYPE = SchemalessProtocol;\npub const TSDB_SML_UNKNOWN_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Unknown;\npub const TSDB_SML_LINE_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Line;\npub const TSDB_SML_TELNET_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Telnet;\npub const TSDB_SML_JSON_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Json;\n\n/// Timestamp precision to parse from schemaless input.\n///\n/// Accepted timestamp precision options are:\n/// - NonConfigured: let the parse detect precision from input\n/// - Hours/minutes/seconds/milliseconds/microseconds/nanoseconds: specified precision to use\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum SchemalessPrecision {\n    NonConfigured = 0,\n    Hours,\n    Minutes,\n    Seconds,\n    Milliseconds,\n    Microseconds,\n    Nanoseconds,\n}\npub type TSDB_SML_TIMESTAMP_TYPE = SchemalessPrecision;\npub const TSDB_SML_TIMESTAMP_NOT_CONFIGURED: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::NonConfigured;\npub const TSDB_SML_TIMESTAMP_HOURS: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Hours;\npub const TSDB_SML_TIMESTAMP_MINUTES: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Minutes;\npub const TSDB_SML_TIMESTAMP_SECONDS: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Seconds;\npub const TSDB_SML_TIMESTAMP_MILLISECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Milliseconds;\npub const TSDB_SML_TIMESTAMP_MICROSECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Microseconds;\npub const TSDB_SML_TIMESTAMP_NANOSECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Nanoseconds;\n\nextern \"C\" {\n    pub fn taos_schemaless_insert(\n        taos: *mut TAOS,\n        lines: *mut *mut c_char,\n        numLines: c_int,\n        protocol: SchemalessProtocol,\n        precision: TSDB_SML_TIMESTAMP_TYPE,\n    ) -\u003e *mut TAOS_RES;\n}\n\n#[test]\n#[cfg(taos_v2)] // TODO: SML in v3 is unimplemented.\nfn test_sml() {\n    use std::ptr;\n    unsafe {\n        let null = ptr::null();\n        let mut lines = [\n            b\"st,t1=4i64,t3=\\\"t4\\\",t2=5f64,t4=5f64 c1=3i64,c3=L\\\"a, abc\\\",c2=true,c4=5f64,c5=5f64,c6=7u64 1626006933640000000\\0\\0\" as *const u8 as *mut c_char\n        ];\n        let taos = crate::taos_connect(ptr::null(), ptr::null(), null, null, 0);\n        let res = crate::taos_query(taos, b\"create database _rs_sml_\\0\" as *const u8 as _);\n        crate::taos_free_result(res);\n        let _ = crate::taos_query(taos, b\"use _rs_sml_\\0\" as *const u8 as _);\n\n        let res = crate::taos_schemaless_insert(\n            taos,\n            \u0026mut lines as _,\n            1,\n            SchemalessProtocol::Line,\n            TSDB_SML_TIMESTAMP_TYPE::NonConfigured,\n        );\n        assert!(crate::taos_errno(res) == 0);\n        crate::taos_free_result(res);\n        let res = crate::taos_query(taos, b\"select * from st\\0\" as *const u8 as _);\n\n        crate::taos_free_result(res);\n        assert!(!taos.is_null());\n        crate::taos_close(taos);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","set_config.rs"],"content":"use std::os::raw::*;\n\npub const SET_CONF_RET_SUCC: SET_CONF_RET_CODE = SET_CONF_RET_CODE::Succ;\npub const SET_CONF_RET_ERR_PART: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrPart;\npub const SET_CONF_RET_ERR_INNER: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrInner;\npub const SET_CONF_RET_ERR_JSON_INVALID: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrJsonInvalid;\npub const SET_CONF_RET_ERR_JSON_PARSE: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrJsonParse;\npub const SET_CONF_RET_ERR_ONLY_ONCE: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrOnlyOnce;\npub const SET_CONF_RET_ERR_TOO_LONG: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrTooLong;\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct SetConfRet {\n    pub code: SET_CONF_RET_CODE,\n    pub msg: [c_char; 1024usize],\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum SET_CONF_RET_CODE {\n    Succ = 0,\n    ErrPart = -1,\n    ErrInner = -2,\n    ErrJsonInvalid = -3,\n    ErrJsonParse = -4,\n    ErrOnlyOnce = -5,\n    ErrTooLong = -6,\n}\n\nextern \"C\" {\n    pub fn taos_set_config(config: *const c_char) -\u003e SetConfRet;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","bind.rs"],"content":"use taos_query::common::{itypes::IsValue, Ty};\n\nuse crate::{BindFrom, TaosBind, TaosBindV2, TaosBindV3};\n\nfn box_into_raw\u003cT\u003e(v: T) -\u003e *mut T {\n    Box::into_raw(Box::new(v))\n}\n\nimpl\u003cT\u003e From\u003c\u0026T\u003e for TaosBindV2\nwhere\n    T: IsValue,\n{\n    #[inline(always)]\n    fn from(v: \u0026T) -\u003e Self {\n        macro_rules! as_is {\n            () =\u003e {\n                Self::from_primitive(v)\n            };\n        }\n\n        match T::TY {\n            Ty::Null =\u003e Self::null(),\n            Ty::Bool =\u003e as_is!(),\n            Ty::TinyInt =\u003e as_is!(),\n            Ty::SmallInt =\u003e as_is!(),\n            Ty::Int =\u003e as_is!(),\n            Ty::BigInt =\u003e as_is!(),\n            Ty::UTinyInt =\u003e as_is!(),\n            Ty::USmallInt =\u003e as_is!(),\n            Ty::UInt =\u003e as_is!(),\n            Ty::UBigInt =\u003e as_is!(),\n            Ty::Float =\u003e as_is!(),\n            Ty::Double =\u003e as_is!(),\n            Ty::Timestamp =\u003e Self::from_timestamp(v.as_timestamp()),\n            Ty::VarChar =\u003e Self::from_varchar(v.as_var_char()),\n            Ty::NChar =\u003e Self::from_nchar(v.as_nchar()),\n            Ty::Json =\u003e todo!(),\n            _ =\u003e Self::null(),\n        }\n    }\n}\n\nimpl\u003cT\u003e From\u003c\u0026T\u003e for TaosBindV3\nwhere\n    T: IsValue,\n{\n    #[inline(always)]\n    fn from(v: \u0026T) -\u003e Self {\n        macro_rules! as_is {\n            () =\u003e {\n                Self::from_primitive(v)\n            };\n        }\n\n        match T::TY {\n            Ty::Null =\u003e Self::null(),\n            Ty::Bool =\u003e as_is!(),\n            Ty::TinyInt =\u003e as_is!(),\n            Ty::SmallInt =\u003e as_is!(),\n            Ty::Int =\u003e as_is!(),\n            Ty::BigInt =\u003e as_is!(),\n            Ty::UTinyInt =\u003e as_is!(),\n            Ty::USmallInt =\u003e as_is!(),\n            Ty::UInt =\u003e as_is!(),\n            Ty::UBigInt =\u003e as_is!(),\n            Ty::Float =\u003e as_is!(),\n            Ty::Double =\u003e as_is!(),\n            Ty::Timestamp =\u003e Self::from_timestamp(v.as_timestamp()),\n            Ty::VarChar =\u003e Self::from_varchar(v.as_var_char()),\n            Ty::NChar =\u003e Self::from_nchar(v.as_nchar()),\n            Ty::Json =\u003e todo!(),\n            _ =\u003e Self::null(),\n        }\n    }\n}\n\npub trait ToBind: IsValue {\n    fn to_bind(\u0026self) -\u003e TaosBind {\n        macro_rules! as_is {\n            () =\u003e {\n                TaosBind::from_primitive(self)\n            };\n        }\n\n        if self.is_null() {\n            return TaosBind::null();\n        }\n\n        match Self::TY {\n            Ty::Null =\u003e TaosBind::null(),\n            Ty::Bool =\u003e as_is!(),\n            Ty::TinyInt =\u003e as_is!(),\n            Ty::SmallInt =\u003e as_is!(),\n            Ty::Int =\u003e as_is!(),\n            Ty::BigInt =\u003e as_is!(),\n            Ty::UTinyInt =\u003e as_is!(),\n            Ty::USmallInt =\u003e as_is!(),\n            Ty::UInt =\u003e as_is!(),\n            Ty::UBigInt =\u003e as_is!(),\n            Ty::Float =\u003e as_is!(),\n            Ty::Double =\u003e as_is!(),\n            Ty::Timestamp =\u003e TaosBind::from_timestamp(self.as_timestamp()),\n            Ty::VarChar =\u003e TaosBind::from_varchar(self.as_var_char()),\n            Ty::NChar =\u003e TaosBind::from_nchar(self.as_nchar()),\n            Ty::Json =\u003e todo!(),\n            _ =\u003e TaosBind::null(),\n        }\n    }\n}\n\nimpl\u003cT: IsValue\u003e ToBind for T {}\n\n#[cfg(test)]\nmod tests_v2 {\n    use std::ffi::CStr;\n\n    use taos_query::common::itypes::IVarChar;\n\n    use super::*;\n    use crate::TaosBindV2 as TaosBind;\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false] {\n            let bind = TaosBind::from(\u0026v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const bool).read() };\n            assert!(v1 == v);\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n    #[test]\n    fn bind_var_char() {\n        for v in [IVarChar::from(\"abc\")].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n\n            let v1 =\n                unsafe { std::str::from_utf8(std::slice::from_raw_parts(bind.buffer() as _, 3)) }\n                    .unwrap();\n\n            dbg!(v1);\n            assert!(v1 == v.as_str());\n        }\n    }\n}\n#[cfg(test)]\nmod tests_v3 {\n    use std::ffi::CStr;\n\n    use crate::TaosBindV3 as TaosBind;\n    use taos_query::common::itypes::IVarChar;\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer() as *const bool).read() };\n            assert!(v1.eq(v));\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer() as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n    #[test]\n    fn bind_var_char() {\n        for v in [IVarChar::from(\"abc\")].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 =\n                unsafe { std::str::from_utf8(std::slice::from_raw_parts(bind.buffer() as _, 3)) }\n                    .unwrap();\n\n            dbg!(v1);\n            assert!(v1 == v.as_str());\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":67},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","mod.rs"],"content":"use crate::{ffi::*, into_c_str::IntoCStr, RawRes, RawTaos};\n\nuse std::{ffi::CStr, os::raw::*};\n\nuse taos_error::{Code, Error};\nuse taos_query::common::{itypes::ITimestamp, Ty};\n\nuse crate::types::*;\n\nmod bind;\nmod multi;\n\n#[derive(Debug)]\npub struct RawStmt(*mut TAOS_STMT);\n\nimpl Drop for RawStmt {\n    fn drop(\u0026mut self) {\n        let _ = self.close();\n    }\n}\n\nimpl RawStmt {\n    #[inline(always)]\n    fn ok(\u0026self, code: impl Into\u003cCode\u003e) -\u003e Result\u003c(), Error\u003e {\n        let code = code.into();\n\n        if code.success() {\n            Ok(())\n        } else {\n            Err(Error::from_string(self.err_as_str()))\n        }\n    }\n\n    #[inline]\n    pub unsafe fn as_ptr(\u0026self) -\u003e *mut TAOS_STMT {\n        self.0\n    }\n\n    #[inline]\n    pub fn errstr(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(taos_stmt_errstr(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn err_as_str(\u0026self) -\u003e String {\n        unsafe {\n            CStr::from_ptr(taos_stmt_errstr(self.as_ptr()))\n                .to_string_lossy()\n                .to_string()\n        }\n    }\n\n    #[inline]\n    pub fn from_raw_taos(taos: \u0026RawTaos) -\u003e RawStmt {\n        RawStmt(unsafe { taos_stmt_init(taos.as_ptr()) })\n    }\n    #[inline]\n    pub fn close(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_close(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn prepare\u003c'c\u003e(\u0026mut self, sql: impl IntoCStr\u003c'c\u003e) -\u003e Result\u003c(), Error\u003e {\n        let sql = sql.into_c_str();\n        self.ok(unsafe {\n            taos_stmt_prepare(self.as_ptr(), sql.as_ptr(), sql.to_bytes().len() as _)\n        })\n    }\n\n    pub fn set_tbname_tags_v3\u003c'a\u003e(\n        \u0026mut self,\n        name: impl IntoCStr\u003c'a\u003e,\n        tags: \u0026[TaosBind],\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe {\n            taos_stmt_set_tbname_tags(\n                self.as_ptr(),\n                name.into_c_str().as_ptr(),\n                tags.as_ptr() as _,\n            )\n        })\n    }\n\n    #[inline]\n    pub fn set_tbname\u003c'c\u003e(\u0026mut self, name: impl IntoCStr\u003c'c\u003e) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe { taos_stmt_set_tbname(self.as_ptr(), name.into_c_str().as_ptr()) })\n    }\n\n    #[inline]\n    pub fn set_sub_tbname\u003c'c\u003e(\u0026mut self, name: impl IntoCStr\u003c'c\u003e) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe { taos_stmt_set_sub_tbname(self.as_ptr(), name.into_c_str().as_ptr()) })\n    }\n\n    #[inline]\n    pub fn use_result(\u0026mut self) -\u003e RawRes {\n        unsafe { RawRes::from_ptr_unchecked(taos_stmt_use_result(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn affected_rows(\u0026self) -\u003e i32 {\n        unsafe { taos_stmt_affected_rows(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn execute(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_execute(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn add_batch(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_add_batch(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn is_insert(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n        let mut is_insert = 0;\n        err_or!(\n            self,\n            taos_stmt_is_insert(self.as_ptr(), \u0026mut is_insert as _),\n            is_insert != 0\n        )\n    }\n\n    #[inline]\n    pub fn num_params(\u0026self) -\u003e Result\u003cusize, Error\u003e {\n        let mut num = 0i32;\n        err_or!(\n            self,\n            taos_stmt_num_params(self.as_ptr(), \u0026mut num as _),\n            num as usize\n        )\n    }\n\n    #[inline]\n    pub fn get_param(\u0026mut self, idx: i32) -\u003e Result\u003c(Ty, i32), Error\u003e {\n        let (mut type_, mut bytes) = (0, 0);\n        err_or!(\n            self,\n            taos_stmt_get_param(self.as_ptr(), idx, \u0026mut type_ as _, \u0026mut bytes as _),\n            ((type_ as u8).into(), bytes)\n        )\n    }\n    #[inline]\n    pub fn bind_param(\u0026mut self, bind: \u0026[TaosBind]) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_bind_param(self.as_ptr(), bind.as_ptr()))\n    }\n\n    #[inline]\n    pub fn bind_param_batch(\u0026mut self, bind: \u0026[TaosMultiBind]) -\u003e Result\u003c(), Error\u003e {\n        err_or!(\n            self,\n            taos_stmt_bind_param_batch(self.as_ptr(), bind.as_ptr())\n        )\n    }\n\n    #[inline]\n    pub fn bind_single_param_batch(\u0026self, bind: \u0026TaosMultiBind, col: i32) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe {\n            taos_stmt_bind_single_param_batch(self.as_ptr(), bind as *const _ as _, col)\n        })\n    }\n}\n\n#[test]\nfn test_tbname_tags() -\u003e Result\u003c(), Error\u003e {\n    use std::ptr::null;\n    let host = null();\n    let user = null();\n    let pass = null();\n    let db = null();\n    let port = 0;\n    let taos = RawTaos::connect(host, user, pass, db, port)?;\n    taos.query(\"drop database if exists stt1\")?;\n    taos.query(\"create database if not exists stt1 keep 36500\")?;\n    taos.query(\"use stt1\")?;\n    taos.query(\n        \"create stable if not exists st1(ts timestamp, v int) tags(t1 int, t2 bool)\"\n    )?;\n\n    let mut stmt = RawStmt::from_raw_taos(\u0026taos);\n    let sql = \"insert into ? using st1 tags(?, ?) values(?, ?)\";\n    stmt.prepare(sql)?;\n\n    let tags = vec![TaosBind::from(\u00261i32), TaosBind::from(\u0026true)];\n    println!(\"tags: {tags:#?}\");\n    let tbname = \"tb1\";\n    stmt.set_tbname_tags_v3(\u0026tbname, \u0026tags)?;\n    println!(\"bind\");\n\n    // todo: get_param not implemented in taosc 3.0\n    // let p = stmt.get_param(0)?;\n    // dbg!(p);\n\n    let params = vec![TaosBind::from(\u0026ITimestamp(0)), TaosBind::from(\u00260i32)];\n    stmt.bind_param(\u0026params)?;\n    println!(\"add batch\");\n\n    stmt.add_batch()?;\n    stmt.execute()?;\n\n    assert!(stmt.affected_rows() == 1);\n\n    let res = taos.query(\"select count(*) from st1\")?;\n\n    taos.query(\"drop database stt1\")?;\n    Ok(())\n}\n","traces":[{"line":17,"address":[8102448],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":18,"address":[8102460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[8133933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[8133943,8134009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[8134016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[8133963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[8131376],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":36,"address":[8131381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[8131392],"length":1,"stats":{"Line":0},"fn_name":"errstr"},{"line":41,"address":[8131401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[8131633,8131472],"length":1,"stats":{"Line":0},"fn_name":"err_as_str"},{"line":47,"address":[8131504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8131680],"length":1,"stats":{"Line":0},"fn_name":"from_raw_taos"},{"line":55,"address":[8131689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8131744],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":59,"address":[8131900,8131782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[8131952],"length":1,"stats":{"Line":0},"fn_name":"use_result"},{"line":96,"address":[8131984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[8132048],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":101,"address":[8132057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[8132096],"length":1,"stats":{"Line":0},"fn_name":"execute"},{"line":106,"address":[8132252,8132134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[8132304],"length":1,"stats":{"Line":0},"fn_name":"add_batch"},{"line":111,"address":[8132342,8132460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8132512],"length":1,"stats":{"Line":0},"fn_name":"is_insert"},{"line":116,"address":[8132550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[8132691,8132592,8132665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[8132558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[8132657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8132752],"length":1,"stats":{"Line":0},"fn_name":"num_params"},{"line":126,"address":[8132790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8132832,8132902,8132930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[8132798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[8132897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8132992],"length":1,"stats":{"Line":0},"fn_name":"get_param"},{"line":136,"address":[8133041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8133116,8133254,8133217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[8133073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8133179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8133312],"length":1,"stats":{"Line":0},"fn_name":"bind_param"},{"line":145,"address":[8133376,8133520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8133568],"length":1,"stats":{"Line":0},"fn_name":"bind_param_batch"},{"line":150,"address":[8133687,8133776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[8133632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[8133824],"length":1,"stats":{"Line":0},"fn_name":"bind_single_param_batch"},{"line":158,"address":[8134023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[8133877],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":65},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","multi.rs"],"content":"use taos_query::common::{\n    itypes::{IsPrimitive, IsValue},\n    Ty,\n};\n\nuse crate::{BindFrom, TaosBind, TaosBindV2, TaosMultiBind};\n\nfn box_into_raw\u003cT\u003e(v: T) -\u003e *mut T {\n    Box::into_raw(Box::new(v))\n}\n\n// impl\u003cT\u003e From\u003cT\u003e for TaosMultiBind\n// where\n//     T: IsValue,\n// {\n//     #[inline(always)]\n//     fn from(v: T) -\u003e Self {\n//         macro_rules! as_is {\n//             () =\u003e {{\n//                 let mut param = Self::new(T::TY);\n//                 param.buffer_length = T::TY.fixed_length();\n//                 param.buffer = box_into_raw(v) as _;\n//                 param.length = box_into_raw(param.buffer_length) as _;\n//                 param\n//             }};\n//             ($v:expr) =\u003e {{\n//                 let mut param = Self::new(T::TY);\n//                 param.buffer_length = T::TY.fixed_length();\n//                 param.buffer = box_into_raw($v) as _;\n//                 param.length = box_into_raw(param.buffer_length) as _;\n//                 param\n//             }};\n//         }\n\n//         match T::TY {\n//             Ty::Null =\u003e Self::null(),\n//             Ty::Bool =\u003e as_is!(),\n//             Ty::TinyInt =\u003e as_is!(),\n//             Ty::SmallInt =\u003e as_is!(),\n//             Ty::Int =\u003e as_is!(),\n//             Ty::BigInt =\u003e as_is!(),\n//             Ty::UTinyInt =\u003e as_is!(),\n//             Ty::USmallInt =\u003e as_is!(),\n//             Ty::UInt =\u003e as_is!(),\n//             Ty::UBigInt =\u003e as_is!(),\n//             Ty::Float =\u003e as_is!(),\n//             Ty::Double =\u003e as_is!(),\n//             Ty::Timestamp =\u003e {\n//                 as_is!(v.as_timestamp())\n//             }\n//             Ty::VarChar =\u003e Self::from_varchar(v.as_var_char()),\n//             Ty::NChar =\u003e Self::from_nchar(v.as_nchar()),\n//             Ty::Json =\u003e todo!(),\n//             _ =\u003e Self::null(),\n//         }\n//     }\n// }\n\n#[cfg(test)]\nmod tests {\n    use crate::{TaosBind, TaosBindV2};\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false].iter() {\n            let bind = TaosBindV2::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const bool).read() };\n            assert!(v1.eq(v));\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBindV2::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","tmq.rs"],"content":"use std::{borrow::Cow, fmt::Display, os::raw::*};\n\nuse taos_macros::c_cfg;\n\nuse crate::ffi::TAOS_RES;\n\n#[repr(transparent)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\npub struct tmq_resp_err_t(i32);\n\nimpl PartialEq\u003ci32\u003e for tmq_conf_res_t {\n    fn eq(\u0026self, other: \u0026i32) -\u003e bool {\n        self == other\n    }\n}\n\nimpl tmq_resp_err_t {\n    pub fn ok_or(self, s: impl Into\u003cCow\u003c'static, str\u003e\u003e) -\u003e Result\u003c(), taos_error::Error\u003e {\n        match self {\n            Self(0) =\u003e Ok(()),\n            _ =\u003e Err(taos_error::Error::from_string(s.into())),\n        }\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_t {\n    _unused: [u8; 0],\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_conf_t {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_list_t {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_message_t {\n    _unused: [u8; 0],\n}\n\n#[repr(C)]\npub enum tmq_conf_res_t {\n    Unknown = -2,\n    Invalid = -1,\n    Ok = 0,\n}\n\nimpl tmq_conf_res_t {\n    pub fn ok(self, k: \u0026str, v: \u0026str) -\u003e Result\u003c(), taos_error::Error\u003e {\n        match self {\n            Self::Ok =\u003e Ok(()),\n            Self::Invalid =\u003e Err(taos_error::Error::from_string(format!(\n                \"Invalid key value pair ({k}, {v})\"\n            ))),\n            Self::Unknown =\u003e Err(taos_error::Error::from_string(format!(\"Unknown key {k}\"))),\n        }\n    }\n}\n\npub type tmq_commit_cb =\n    unsafe extern \"C\" fn(tmq: *mut tmq_t, resp: tmq_resp_err_t, param: *mut c_void);\n\n// TMQ streaming/consuming API.\n#[c_cfg(taos_tmq)]\nextern \"C\" {\n    pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n    pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32;\n    pub fn tmq_list_destroy(list: *mut tmq_list_t);\n    pub fn tmq_list_get_size(list: *const tmq_list_t) -\u003e i32;\n    pub fn tmq_list_to_c_array(list: *const tmq_list_t) -\u003e *mut *mut c_char;\n\n    pub fn tmq_consumer_new(\n        conf: *mut tmq_conf_t,\n        errstr: *mut c_char,\n        errstr_len: i32,\n    ) -\u003e *mut tmq_t;\n\n    pub fn tmq_err2str(err: tmq_resp_err_t) -\u003e *const c_char;\n\n    pub fn tmq_subscribe(tmq: *mut tmq_t, topic_list: *mut tmq_list_t) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_subscription(tmq: *mut tmq_t, topic_list: *mut *mut tmq_list_t) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_consumer_poll(tmq: *mut tmq_t, blocking_time: i64) -\u003e *mut TAOS_RES;\n\n    pub fn tmq_consumer_close(tmq: *mut tmq_t) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_commit_sync(tmq: *mut tmq_t, msg: *const TAOS_RES) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_commit_async(\n        tmq: *mut tmq_t,\n        msg: *const TAOS_RES,\n        cb: tmq_commit_cb,\n        param: *mut c_void,\n    );\n\n    pub fn tmq_get_topic_name(res: *mut TAOS_RES) -\u003e *const c_char;\n    pub fn tmq_get_table_name(res: *mut TAOS_RES) -\u003e *const c_char;\n    pub fn tmq_get_db_name(res: *mut TAOS_RES) -\u003e *const c_char;\n    pub fn tmq_get_vgroup_id(res: *mut TAOS_RES) -\u003e i32;\n}\n\n// TMQ Conf API\n#[c_cfg(taos_tmq)]\nextern \"C\" {\n    pub fn tmq_conf_new() -\u003e *mut tmq_conf_t;\n\n    pub fn tmq_conf_destroy(conf: *mut tmq_conf_t);\n\n    pub fn tmq_conf_set(\n        conf: *mut tmq_conf_t,\n        key: *const c_char,\n        value: *const c_char,\n    ) -\u003e tmq_conf_res_t;\n\n    pub fn tmq_conf_set_auto_commit_cb(\n        conf: *mut tmq_conf_t,\n        cb: tmq_commit_cb,\n        param: *mut c_void,\n    );\n}\n","traces":[{"line":12,"address":[8046096],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":13,"address":[8046110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3759040],"length":1,"stats":{"Line":0},"fn_name":"ok_or\u003c\u0026str\u003e"},{"line":19,"address":[3759084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3759104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[3759123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8046144],"length":1,"stats":{"Line":0},"fn_name":"ok"},{"line":57,"address":[8046185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8046274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[8046246,8046294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[8046529,8046220],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","types","field.rs"],"content":"use std::ffi::CStr;\n\n// use super::Ty;\nuse taos_query::common::{Field, Ty};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct TAOS_FIELD {\n    pub name: [u8; 65usize],\n    pub type_: u8,\n    #[cfg(taos_v2)]\n    pub bytes: i16,\n    #[cfg(not(taos_v2))]\n    pub bytes: i32,\n}\n\nimpl TAOS_FIELD {\n    pub fn name(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(self.name.as_ptr() as _) }\n    }\n    pub fn type_(\u0026self) -\u003e Ty {\n        self.type_.into()\n    }\n\n    pub fn bytes(\u0026self) -\u003e u32 {\n        self.bytes as _\n    }\n}\n\nimpl Into\u003cField\u003e for \u0026TAOS_FIELD {\n    fn into(self) -\u003e Field {\n        Field::new(\n            self.name()\n                .to_str()\n                .expect(\"invalid utf-8 field name\")\n                .to_string(),\n            self.type_(),\n            self.bytes(),\n        )\n    }\n}\n\npub fn from_raw_fields\u003c'a\u003e(ptr: *const TAOS_FIELD, len: usize) -\u003e Vec\u003cField\u003e {\n    unsafe { std::slice::from_raw_parts(ptr, len) }\n        .into_iter()\n        .map(Into::into)\n        .collect()\n}\n","traces":[{"line":18,"address":[8086592],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":19,"address":[8086601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[8086656],"length":1,"stats":{"Line":0},"fn_name":"type_"},{"line":22,"address":[8086665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[8086688],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":26,"address":[8086693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[8086704,8087006,8086975],"length":1,"stats":{"Line":0},"fn_name":"into"},{"line":33,"address":[8086742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8086854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[8086905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[8087024],"length":1,"stats":{"Line":0},"fn_name":"from_raw_fields"},{"line":44,"address":[8087074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","types","mod.rs"],"content":"use std::{\n    any::{Any, TypeId},\n    borrow::Cow,\n    fmt::Debug,\n    intrinsics::transmute,\n    mem::ManuallyDrop,\n    os::raw::*,\n    ptr,\n};\n\nmod field;\nuse derive_more::Deref;\npub use field::*;\npub use taos_query::common::{Precision, Ty};\n\nuse taos_query::common::{itypes::*, BorrowedColumn, Column, Timestamp};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum TSDB_OPTION {\n    Locale = 0,\n    Charset,\n    Timezone,\n    ConfigDir,\n    ShellActivityTimer,\n    MaxOptions,\n}\npub const TSDB_OPTION_LOCALE: TSDB_OPTION = TSDB_OPTION::Locale;\npub const TSDB_OPTION_CHARSET: TSDB_OPTION = TSDB_OPTION::Charset;\npub const TSDB_OPTION_TIMEZONE: TSDB_OPTION = TSDB_OPTION::Timezone;\npub const TSDB_OPTION_CONFIGDIR: TSDB_OPTION = TSDB_OPTION::ConfigDir;\npub const TSDB_OPTION_SHELL_ACTIVITY_TIMER: TSDB_OPTION = TSDB_OPTION::ShellActivityTimer;\npub const TSDB_MAX_OPTIONS: TSDB_OPTION = TSDB_OPTION::MaxOptions;\n\n#[repr(C)]\n#[derive(Clone)]\npub struct TaosBindV2 {\n    pub buffer_type: c_int,\n    pub buffer: *mut c_void,\n    pub buffer_length: usize,\n    pub length: *mut usize,\n    pub is_null: *mut c_int,\n    pub is_unsigned: c_int,\n    pub error: *mut c_int,\n    pub u: TaosBindUnionV2,\n    pub allocated: c_uint,\n}\n\nimpl Debug for TaosBindV2 {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"TaosBindV2\")\n            .field(\"buffer_type\", \u0026self.buffer_type)\n            .field(\"buffer\", \u0026self.buffer)\n            .field(\"buffer_length\", \u0026self.buffer_length)\n            .field(\"length\", \u0026self.length)\n            .field(\"is_null\", \u0026self.is_null)\n            .field(\"is_unsigned\", \u0026self.is_unsigned)\n            .field(\"error\", \u0026self.error)\n            .field(\"allocated\", \u0026self.allocated)\n            .finish()\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union TaosBindUnionV2 {\n    pub ts: i64,\n    pub b: i8,\n    pub v1: i8,\n    pub v2: i16,\n    pub v4: i32,\n    pub v8: i64,\n    pub f4: f32,\n    pub f8: f64,\n    pub bin: *mut c_uchar,\n    pub nchar: *mut c_char,\n}\n#[repr(C)]\n#[derive(Debug, Clone)]\npub struct TaosMultiBind {\n    pub buffer_type: c_int,\n    pub buffer: *const c_void,\n    pub buffer_length: usize,\n    pub length: *const i32,\n    pub is_null: *const c_char,\n    pub num: c_int,\n}\n\nimpl TaosMultiBind {\n    pub fn new(ty: Ty) -\u003e Self {\n        Self {\n            buffer_type: ty as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: std::ptr::null_mut(),\n            is_null: std::ptr::null_mut(),\n            num: 1,\n        }\n    }\n}\nimpl BindFrom for TaosBindV3 {\n    #[inline]\n    fn null() -\u003e Self {\n        Self(TaosMultiBind {\n            buffer_type: Ty::Null as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: std::ptr::null_mut(),\n            is_null: std::ptr::null_mut(),\n            num: 1 as _,\n        })\n    }\n\n    fn from_primitive\u003cT: IsValue\u003e(v: \u0026T) -\u003e Self {\n        let mut param = TaosMultiBind::new(T::TY);\n        param.buffer_length = T::TY.fixed_length();\n        param.buffer = v as *const T as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0) as _;\n        Self(param)\n    }\n\n    fn from_timestamp(v: i64) -\u003e Self {\n        let mut param = TaosMultiBind::new(Ty::Timestamp);\n        param.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        param.buffer = box_into_raw(v) as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n\n    fn from_varchar(v: \u0026str) -\u003e Self {\n        let mut param = TaosMultiBind::new(Ty::VarChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n\n    fn from_nchar(v: \u0026str) -\u003e Self {\n        let mut param = TaosMultiBind::new(Ty::NChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n}\n\n#[derive(Debug, Deref)]\n#[repr(transparent)]\npub struct TaosBindV3(TaosMultiBind);\n\n#[cfg(taos_v3)]\npub type TaosBind = TaosBindV3;\n#[cfg(not(taos_v3))]\npub type TaosBind = TaosBindV2;\n\nimpl TaosBindV2 {\n    #[inline]\n    pub fn new(buffer_type: Ty) -\u003e Self {\n        let buffer: *mut c_void = ptr::null_mut();\n        let length: *mut usize = ptr::null_mut();\n        let is_null: *mut c_int = ptr::null_mut();\n        let error: *mut c_int = ptr::null_mut();\n        TaosBindV2 {\n            buffer_type: buffer_type as _,\n            buffer,\n            buffer_length: 0,\n            length,\n            is_null,\n            is_unsigned: 0,\n            error,\n            allocated: 1,\n            u: TaosBindUnionV2 { ts: 0 },\n        }\n    }\n\n    pub(crate) fn buffer(\u0026self) -\u003e *const c_void {\n        self.buffer\n    }\n\n    fn ty(\u0026self) -\u003e Ty {\n        Ty::from(self.buffer_type)\n    }\n\n    #[inline]\n    unsafe fn free(\u0026mut self) {\n        if self.ty() == Ty::Json \u0026\u0026 !self.buffer.is_null() {\n            Vec::from_raw_parts(self.buffer as _, *self.length, *self.length);\n        }\n        if !self.length.is_null() {\n            Box::from_raw(self.length);\n        }\n        if !self.is_null.is_null() {\n            Box::from_raw(self.is_null);\n        }\n        if !self.error.is_null() {\n            Box::from_raw(self.error);\n        }\n    }\n}\n\npub trait BindFrom: Sized {\n    fn null() -\u003e Self;\n    fn from_primitive\u003cT: IsValue\u003e(v: \u0026T) -\u003e Self;\n    fn from_timestamp(v: i64) -\u003e Self;\n    fn from_varchar(v: \u0026str) -\u003e Self;\n    fn from_nchar(v: \u0026str) -\u003e Self;\n    fn from_binary(v: \u0026str) -\u003e Self {\n        Self::from_varchar(v)\n    }\n}\n\nfn box_into_raw\u003cT\u003e(v: T) -\u003e *mut T {\n    Box::into_raw(Box::new(v))\n}\n\nimpl BindFrom for TaosBindV2 {\n    #[inline]\n    fn null() -\u003e Self {\n        let mut null = Self::new(Ty::Null);\n        let v = Box::new(1i8);\n        null.is_null = Box::into_raw(v) as _;\n        null\n    }\n    fn from_timestamp(v: i64) -\u003e Self {\n        let mut param = Self::new(Ty::Timestamp);\n        param.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        param.buffer = box_into_raw(v) as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_varchar(v: \u0026str) -\u003e Self {\n        let mut param = Self::new(Ty::VarChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_nchar(v: \u0026str) -\u003e Self {\n        let mut param = Self::new(Ty::NChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_primitive\u003cT: IsValue\u003e(v: \u0026T) -\u003e Self {\n        let mut param = Self::new(T::TY);\n        param.buffer_length = T::TY.fixed_length();\n        param.buffer = v as *const T as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n}\n\nimpl Drop for TaosBindV2 {\n    fn drop(\u0026mut self) {\n        unsafe { self.free() }\n    }\n}\n\npub trait ToMultiBind {\n    fn to_multi_bind(\u0026self) -\u003e TaosMultiBind;\n}\n\n// impl\u003cT\u003e From\u003cT\u003e for TaosBind\n// where\n//     T: IValue + Any,\n// {\n//     fn from(value: T) -\u003e Self {\n//         match T::TY {\n//             Ty::Null =\u003e Self::null(),\n//             Ty::Bool =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026bool = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_bool(*inner)\n//             }\n//             Ty::TinyInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i8 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_tiny_int(*inner)\n//             }\n//             Ty::SmallInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i16 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_small_int(*inner)\n//             }\n//             Ty::Int =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i32 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_int(*inner)\n//             }\n//             Ty::BigInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_big_int(*inner)\n//             }\n\n//             Ty::UTinyInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u8 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_tiny_int_unsigned(*inner)\n//             }\n//             Ty::USmallInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u16 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_small_int_unsigned(*inner)\n//             }\n//             Ty::UInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u32 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_int_unsigned(*inner)\n//             }\n//             Ty::UBigInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_big_int_unsigned(*inner)\n//             }\n//             Ty::Float =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026f32 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_float(*inner)\n//             }\n//             Ty::Double =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026f64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_double(*inner)\n//             }\n//             Ty::Timestamp =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_timestamp(*inner)\n//             }\n//             Ty::VarChar =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026String = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_varchar(inner)\n//             }\n//             Ty::NChar =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026String = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_nchar(inner)\n//             }\n//             Ty::Json =\u003e todo!(),\n//             _ =\u003e Self::null(),\n//         }\n//     }\n// }\n\n// impl\u003cT\u003e From\u003cVec\u003cT\u003e\u003e for TaosMultiBind\n// where\n//     T: IValue,\n// {\n//     fn from(_: Vec\u003cT\u003e) -\u003e Self {\n//         todo!()\n//     }\n// }\n\nimpl TaosMultiBind {\n    pub(crate) fn nulls(n: usize) -\u003e Self {\n        TaosMultiBind {\n            buffer_type: Ty::Null as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: n as _,\n            is_null: std::ptr::null_mut(),\n            num: n as _,\n        }\n    }\n    pub(crate) fn from_primitives\u003cT: IValue\u003e(nulls: Vec\u003cbool\u003e, values: \u0026[T]) -\u003e Self {\n        TaosMultiBind {\n            buffer_type: T::TY as _,\n            buffer: values.as_ptr() as _,\n            buffer_length: std::mem::size_of::\u003cT\u003e(),\n            length: values.len() as _,\n            is_null: ManuallyDrop::new(nulls).as_ptr() as _,\n            num: values.len() as _,\n        }\n    }\n    pub(crate) fn from_raw_timestamps(nulls: Vec\u003cbool\u003e, values: \u0026[i64]) -\u003e Self {\n        TaosMultiBind {\n            buffer_type: Ty::Timestamp as _,\n            buffer: values.as_ptr() as _,\n            buffer_length: std::mem::size_of::\u003ci64\u003e(),\n            length: values.len() as _,\n            is_null: ManuallyDrop::new(nulls).as_ptr() as _,\n            num: values.len() as _,\n        }\n    }\n\n    pub(crate) fn from_binary_vec(values: \u0026[Option\u003cimpl AsRef\u003c[u8]\u003e\u003e]) -\u003e Self {\n        let mut buffer_length = 0;\n        let num = values.len();\n        let mut nulls = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { nulls.set_len(num) };\n        nulls.fill(false);\n        let mut length: ManuallyDrop\u003cVec\u003ci32\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { length.set_len(num) };\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                length[i] = v.len() as _;\n                if v.len() \u003e buffer_length {\n                    buffer_length = v.len();\n                }\n            } else {\n                nulls[i] = true;\n            }\n        }\n        let buffer_size = buffer_length * values.len();\n        let mut buffer: ManuallyDrop\u003cVec\u003cu8\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(buffer_size));\n        unsafe { buffer.set_len(buffer_size) };\n        buffer.fill(0);\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                unsafe {\n                    let dst = buffer.as_mut_ptr().add(buffer_length * i);\n                    std::intrinsics::copy_nonoverlapping(v.as_ptr(), dst, v.len());\n                }\n            }\n        }\n        TaosMultiBind {\n            buffer_type: Ty::VarChar as _,\n            buffer: buffer.as_ptr() as _,\n            buffer_length,\n            length: length.as_ptr() as _,\n            is_null: nulls.as_ptr() as _,\n            num: num as _,\n        }\n    }\n    pub(crate) fn from_string_vec(values: \u0026[Option\u003cimpl AsRef\u003cstr\u003e\u003e]) -\u003e Self {\n        let values: Vec\u003c_\u003e = values\n            .iter()\n            .map(|f| {\n                f.as_ref()\n                    .map(|s| dbg!(s.as_ref().to_string()).into_bytes())\n            })\n            .collect();\n        let mut s = Self::from_binary_vec(\u0026values);\n        s.buffer_type = Ty::NChar as _;\n        s\n    }\n\n    pub(crate) fn buffer(\u0026self) -\u003e *const c_void {\n        self.buffer\n    }\n}\n\nimpl Drop for TaosMultiBind {\n    fn drop(\u0026mut self) {\n        let ty = Ty::from(self.buffer_type as u8);\n        // if ty == Ty::VarChar || ty == Ty::NChar {\n        //     let len = self.buffer_length * self.num as usize;\n        //     unsafe { Vec::from_raw_parts(self.buffer as *mut u8, len, len as _) };\n        //     unsafe { Vec::from_raw_parts(self.length as *mut i32, self.num as _, self.num as _) };\n        // }\n        unsafe { Vec::from_raw_parts(self.is_null as *mut i8, self.num as _, self.num as _) };\n    }\n}\n\nimpl\u003c'c\u003e From\u003c\u0026'c Column\u003e for TaosMultiBind {\n    fn from(col: \u0026'c Column) -\u003e Self {\n        match col {\n            Column::Null(n) =\u003e Self::nulls(*n),\n            Column::Bool(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::TinyInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::SmallInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Int(nulls, values) =\u003e Self::from_primitives(nulls.clone().into_bools(), values),\n            Column::BigInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UTinyInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::USmallInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UBigInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Float(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Double(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Timestamp(nulls, values) =\u003e {\n                Self::from_raw_timestamps(nulls.clone().into_bools(), values)\n            }\n            Column::Binary(values) =\u003e Self::from_binary_vec(values),\n            Column::NChar(values) =\u003e Self::from_string_vec(values),\n            Column::Json(_, _) =\u003e todo!(),\n            Column::VarChar(_, _) =\u003e todo!(),\n            Column::VarBinary(_, _) =\u003e todo!(),\n            Column::Decimal(_, _) =\u003e todo!(),\n            Column::Blob(_, _) =\u003e todo!(),\n            // _ =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl\u003c'b\u003e From\u003cBorrowedColumn\u003c'b\u003e\u003e for TaosMultiBind {\n    fn from(col: BorrowedColumn\u003c'b\u003e) -\u003e Self {\n        use BorrowedColumn::*;\n        match col {\n            Null(n) =\u003e Self::nulls(n),\n            Bool(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            TinyInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            SmallInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Int(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            BigInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UTinyInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            USmallInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UBigInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Float(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Double(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Timestamp(nulls, values) =\u003e {\n                TaosMultiBind::from_raw_timestamps(nulls.into_bools(), values)\n            }\n            Binary(values) =\u003e TaosMultiBind::from_binary_vec(\u0026values),\n            NChar(values) =\u003e TaosMultiBind::from_string_vec(\u0026values),\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\n// impl\u003c'b, 'c\u003e From\u003c\u0026'c BorrowedColumn\u003c'b\u003e\u003e for MultiBind\u003c'c\u003e {\n//     fn from(col: \u0026'c BorrowedColumn\u003c'b\u003e) -\u003e Self {\n//         match col {\n//             BorrowedColumn::Null(n) =\u003e MultiBind::nulls(*n),\n//             BorrowedColumn::Bool(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Int(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Float(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Double(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) =\u003e {\n//                 MultiBind::from_raw_timestamps(nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) =\u003e MultiBind::from_binary_vec(values),\n//             BorrowedColumn::NChar(values) =\u003e MultiBind::from_string_vec(values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\n// impl\u003cT\u003e From\u003cVec\u003cT\u003e\u003e for TaosMultiBind {\n//     fn from(_: Vec\u003cT\u003e) -\u003e Self {\n//         todo!()\n//     }\n// }\n","traces":[{"line":50,"address":[8136144],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":51,"address":[8136504,8136240,8136163,8136416,8136372,8136460,8136328,8136284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[8136236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8136280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[8136324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8136368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[8136412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8136456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[8136500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8136576],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":91,"address":[8136597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[8136784],"length":1,"stats":{"Line":0},"fn_name":"null"},{"line":103,"address":[8136927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8137008,8137254],"length":1,"stats":{"Line":0},"fn_name":"from_timestamp"},{"line":123,"address":[8137038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8137107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8137116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8137142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8137173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[8137201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[8137559,8137280],"length":1,"stats":{"Line":0},"fn_name":"from_varchar"},{"line":132,"address":[8137323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[8137354,8137422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[8137427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8137449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[8137480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8137506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8137600,8137879],"length":1,"stats":{"Line":0},"fn_name":"from_nchar"},{"line":141,"address":[8137643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[8137742,8137674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[8137747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8137769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[8137800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[8137826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8137920],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":162,"address":[8137988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[8138027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[8138075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[8138122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[8138161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[8138165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[8138240],"length":1,"stats":{"Line":0},"fn_name":"buffer"},{"line":180,"address":[8138245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[8138256],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":184,"address":[8138265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[8138288],"length":1,"stats":{"Line":0},"fn_name":"free"},{"line":189,"address":[8138302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[8138413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[8138459,8138392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8138491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[8138470,8138523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[8138555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[8138587,8138534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[8138603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[8103040,8103088],"length":1,"stats":{"Line":0},"fn_name":"from_binary\u003ctaos_sys::types::TaosBindV2\u003e"},{"line":211,"address":[8103109,8103061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8103360,8103136,8103248],"length":1,"stats":{"Line":0},"fn_name":"box_into_raw\u003ci64\u003e"},{"line":216,"address":[8103451,8103329,8103227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[8138841,8138640],"length":1,"stats":{"Line":0},"fn_name":"null"},{"line":222,"address":[8138657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[8138798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[8138803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[8138864,8139030],"length":1,"stats":{"Line":0},"fn_name":"from_timestamp"},{"line":228,"address":[8138891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[8138950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[8138958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[8138988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[8139056,8139256],"length":1,"stats":{"Line":0},"fn_name":"from_varchar"},{"line":236,"address":[8139093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8139118,8139182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[8139186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[8139212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[8139280,8139480],"length":1,"stats":{"Line":0},"fn_name":"from_nchar"},{"line":244,"address":[8139317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[8139342,8139406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8139410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[8139436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[8102048],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":262,"address":[8102053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[8139504],"length":1,"stats":{"Line":0},"fn_name":"nulls"},{"line":371,"address":[8139621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[8105335,8103942,8106848,8106832,8105366,8104432,8104416,8107318,8105831,8105888,8105392,8108310,8104880,8108336,8106358,8107840,8104385,8107814,8108279,8105862,8107783,8106384,8103911,8104849,8103472,8103968,8107287,8108775,8107344,8106327,8108806,8106801,8104896],"length":1,"stats":{"Line":0},"fn_name":"from_primitives\u003cu32\u003e"},{"line":376,"address":[8104496,8105456,8104960,8106912,8107904,8105952,8108400,8103536,8104032,8106448,8107408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[8104976,8107920,8104048,8103552,8105472,8106928,8107424,8108416,8104512,8106464,8105968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[8106045,8104117,8103629,8105053,8104581,8107501,8107997,8105549,8107005,8108493,8106533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[8104138,8106694,8104602,8106554,8107178,8108018,8103802,8105722,8105570,8106066,8104742,8103650,8104278,8107026,8106218,8108170,8105074,8107522,8107674,8105226,8108514,8108666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[8107700,8108196,8106720,8104768,8104304,8105252,8107204,8105748,8108692,8103828,8106244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[8140103,8139664,8140134],"length":1,"stats":{"Line":0},"fn_name":"from_raw_timestamps"},{"line":386,"address":[8139728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[8139744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[8139821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8139842,8139994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[8140020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[8110992,8108832],"length":1,"stats":{"Line":0},"fn_name":"from_binary_vec\u003c\u0026[u8]\u003e"},{"line":396,"address":[8111058,8108898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[8111070,8108910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[8111078,8108918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[8109076,8111236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[8109122,8111282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8111336,8109176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[8109334,8111494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[8111739,8109356,8109579,8111516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8111936,8111787,8109776,8109627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8109664,8111824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[8109844,8112004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8109920,8109890,8112050,8112080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[8109912,8112072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[8109744,8111904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[8112117,8109957,8109544,8111704,8109933,8112093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[8112101,8109941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[8110131,8112291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[8112337,8110177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[8112399,8110239,8112613,8110453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[8112655,8110495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[8110533,8112693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[8112864,8110704,8112759,8110599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[8110754,8112914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[8112956,8110796,8110448,8112608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[8113014,8110854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[8113059,8110899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[8113424,8113152,8113373,8113645],"length":1,"stats":{"Line":0},"fn_name":"from_string_vec\u003c\u0026str\u003e"},{"line":437,"address":[8113205,8113477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[8113696,8113776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c\u0026str\u003e"},{"line":440,"address":[8113733,8113813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[8113906,8114640,8113856,8114690],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003calloc::string::String\u003e"},{"line":444,"address":[8113342,8113540,8113268,8113614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[8113626,8113354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[8140160],"length":1,"stats":{"Line":0},"fn_name":"buffer"},{"line":450,"address":[8140165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[8102064],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":456,"address":[8102078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[8102098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[8141545,8141579,8140176],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":468,"address":[8140223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[8140372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[8140409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[8143583,8140444,8143433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[8140471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[8143261,8140506,8143411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[8140533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[8143089,8140568,8143239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[8140595,8142917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[8140657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[8142895,8140692,8142745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[8140999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[8141034,8141971,8142133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[8141061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[8141096,8141787,8141949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[8141123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[8141158,8141603,8141765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[8141185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[8141220,8141389,8141560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[8140719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[8142573,8140754,8142723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[8140781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[8142551,8140816,8142401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[8140890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[8140925,8142189,8142345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[8142391,8140843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[8142179,8140952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[8143616,8147384,8146679],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":519,"address":[8143661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[8143975,8147139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[8144005,8147127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[8144191,8147083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[8144377,8147039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[8144563,8146995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[8146951,8144749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[8146570,8145649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[8146529,8145835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[8146488,8146021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[8146423,8146177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[8146907,8144935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[8146863,8145121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[8145385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[8146722,8145531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[8145307,8146734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[8146582,8145571],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":199},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","info.rs"],"content":"use taos_sys::ffi::taos_get_client_info;\n\nuse std::ffi::CStr;\n\n#[test]\nfn test_server_info() {\n    let info = unsafe { CStr::from_ptr(taos_get_client_info()) }.to_string_lossy();\n    println!(\"{}\", dbg!(\u0026info));\n    assert!(info.contains(\".\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","query_a.rs"],"content":"use std::{ffi::*, os::raw::c_int};\n\n#[test]\n#[cfg(taos_v2)]\nfn test_query_a() {\n    use taos_sys::*;\n\n    use std::sync::mpsc::channel;\n    use std::sync::mpsc::Sender;\n    pub struct CallbackArg {\n        pub sender: Sender\u003ci32\u003e,\n    }\n    pub unsafe extern \"C\" fn async_query_callback(\n        param: *mut c_void,\n        res: *mut c_void,\n        code: c_int,\n    ) {\n        assert!(code == 0);\n        let _ = RawRes::from_ptr(res);\n        let param = param as *mut CallbackArg;\n        let args = Box::from_raw(param);\n\n        let CallbackArg { sender } = *args;\n\n        sender.send(12).unwrap();\n    }\n\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )\n    .expect(\"connect\");\n    let (sender, receiver) = channel();\n    let args = CallbackArg { sender };\n    let args = Box::new(args);\n    taos.query_a(\n        b\"show databases\\0\" as *const u8 as _,\n        async_query_callback,\n        Box::into_raw(args) as *mut c_void,\n    );\n    let msg = receiver.recv().unwrap();\n    println!(\"received: {msg}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","raw_block.rs"],"content":"// todo: some const functions are not available for stable Rust.\n#![feature(const_slice_from_raw_parts)]\n#![feature(const_slice_index)]\n\nuse once_cell::unsync::OnceCell;\nuse taos_query::{\n    common::{Column, Field, Timestamp, Ty, Value},\n    BlockExt,\n};\nuse taos_sys::Precision;\n\nuse core::slice;\nuse std::{\n    fmt::Debug,\n    mem::transmute,\n    mem::{size_of, transmute_copy},\n    ops::Deref,\n};\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\n#[repr(packed(2))] // use packed(2) because it's int16_t in raw block.\npub struct ColSchema {\n    ty: Ty,\n    len: u32,\n}\n\n#[test]\nfn col_schema() {\n    let col = ColSchema {\n        ty: Ty::BigInt,\n        len: 1,\n    };\n    let bytes: [u8; 6] = unsafe { transmute_copy(\u0026col) };\n    dbg!(\u0026bytes);\n\n    let bytes: [u8; 6] = [4, 0, 1, 0, 0, 0];\n    let col2: ColSchema = unsafe { transmute_copy(\u0026bytes) };\n    dbg!(col2);\n}\n#[test]\nfn test_bin() {\n    let v: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let ptr = v.as_ptr();\n\n    let v_u16 = unsafe { *transmute::\u003c*const u8, *const u16\u003e(ptr) };\n    println!(\"{v_u16:#x?}: {:?}\", v_u16.to_le_bytes());\n    #[derive(Debug, Clone, Copy)]\n    #[repr(packed)]\n    #[allow(dead_code)]\n    struct A {\n        a: u16,\n        b: u32,\n    }\n    println!(\"A size: {}\", std::mem::size_of::\u003cA\u003e());\n    let a: \u0026A = unsafe { transmute::\u003c*const u8, *const A\u003e(ptr).as_ref().unwrap() };\n    println!(\"{a:#x?}\");\n}\n\npub struct RawBlock {\n    data: Vec\u003cu8\u003e,\n    len: usize,\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: Vec\u003c(Ty, isize, isize)\u003e,\n}\n\nimpl RawBlock {\n    pub unsafe fn copy_from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -\u003e Self {\n        let len = *transmute::\u003c*const u8, *const u32\u003e(data) as usize + 4;\n        Self {\n            data: slice::from_raw_parts(data, len).into(),\n            len,\n            rows,\n            cols,\n            precision,\n            offsets: Vec::new(),\n        }\n    }\n}\n\n/// Raw data block format:\n///\n/// ```text,ignore\n/// +--------------+----------+---------------+-----------+-----------------------+-----------------+\n/// | total length | group id | col_schema... | length... | (bitmap or offsets    | col data)   ... |\n/// |  4 bytes     | 8 bytes  | (2 + 4) * cols| 4 * cols  | (row+7)/8 or 4 * rows | length[col] ... |\n/// +--------------+----------+---------------+-----------+-----------------------+-----------------+\n/// ```\n///\n/// The length of bitmap is decided by number of rows of this data block, and the length of each column data is\n/// recorded in the first segment, next to the struct header\n#[derive(Debug)]\npub struct InnerBlock {\n    data: *const u8,\n    len: usize,\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: OnceCell\u003cVec\u003c(Ty, isize, isize)\u003e\u003e,\n}\n\nimpl InnerBlock {\n    /// From raw data block.\n    pub unsafe fn from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -\u003e Self {\n        let len = *transmute::\u003c*const u8, *const u32\u003e(data) as usize + 4;\n        Self {\n            data,\n            len,\n            rows,\n            cols,\n            precision,\n            offsets: OnceCell::new(),\n        }\n    }\n\n    /// The whole block slice length.\n    pub const fn len(\u0026self) -\u003e usize {\n        unsafe { *transmute::\u003c*const u8, *const u32\u003e(self.as_ptr()) as usize + 4 }\n    }\n\n    /// The group id of the raw block.\n    pub const fn group_id(\u0026self) -\u003e u64 {\n        unsafe { *std::mem::transmute::\u003c*const u8, *const u64\u003e(self.as_ptr()) }\n    }\n\n    /// Inner block as bytes slice.\n    pub const fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        unsafe { slice::from_raw_parts(self.data, self.len) }\n    }\n\n    /// Raw data block bytes.\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        self.as_bytes().to_owned()\n    }\n\n    /// Pointer to raw block data slice.\n    const fn as_ptr(\u0026self) -\u003e *const u8 {\n        self.data\n    }\n\n    /// Offset to column schema start position.\n    const fn schema_offset(\u0026self) -\u003e isize {\n        // 4 = block data length.\n        // 8 = group id.\n        4 + 8\n    }\n\n    /// Offset to lengths start position.\n    const fn lengths_offset(\u0026self) -\u003e isize {\n        // 6 == size_of::\u003cColumnSchema\u003e()\n        self.schema_offset() + self.cols as isize * 6\n    }\n\n    /// Offset to column data start position.\n    const fn data_offset(\u0026self) -\u003e isize {\n        self.lengths_offset() + self.cols as isize * 4\n    }\n\n    /// Pointer to specific offset.\n    const unsafe fn offset(\u0026self, count: isize) -\u003e *const u8 {\n        self.as_ptr().offset(count)\n    }\n\n    /// Length of each bitmap block.\n    const fn bitmap_len(\u0026self) -\u003e usize {\n        (self.rows + 7) / 8\n    }\n\n    /// A lazy-init-ed index to each column.\n    ///\n    /// For each column, the index is a 3-element tuple:\n    ///\n    /// 0. Column data type represented as [Ty]\n    /// 1. Offset to column data start position relative to the block front.\n    ///   - For var-type, it's a `rows` length `i32` vector contains the offsets to each row.\n    ///   - For non-var-type, it's the is-null bitmap.\n    /// 2. Offset to the start position of real column data.\n    fn column_offsets(\u0026self) -\u003e \u0026[(Ty, isize, isize)] {\n        self.offsets.get_or_init(|| {\n            let lengths = self.lengths();\n            let mut data_offset = self.data_offset();\n            self.schemas()\n                .iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    assert!(data_offset \u003c self.len() as isize);\n                    if col.ty.is_var_type() {\n                        let o = (col.ty, data_offset, data_offset + 4 * self.rows as isize);\n                        data_offset = o.2 + lengths[i] as isize;\n                        o\n                    } else {\n                        let o = (\n                            col.ty,\n                            data_offset,\n                            data_offset + self.bitmap_len() as isize,\n                        );\n                        data_offset = o.2 + lengths[i] as isize;\n\n                        assert!(data_offset \u003c self.len() as isize);\n                        o\n                    }\n                })\n                .collect()\n        })\n    }\n\n    /// Column schema extractor.\n    #[inline]\n    pub const fn schemas(\u0026self) -\u003e \u0026[ColSchema] {\n        unsafe {\n            let ptr = self.offset(self.schema_offset());\n            slice::from_raw_parts(ptr as *mut ColSchema, self.cols)\n        }\n    }\n    /// Get column data type.\n    #[inline]\n    pub const fn get_type_of(\u0026self, col: usize) -\u003e Ty {\n        self.get_schema_of(col).ty\n    }\n\n    /// Get column schema which includes data type and bytes length.\n    #[inline]\n    pub const fn get_schema_of(\u0026self, col: usize) -\u003e \u0026ColSchema {\n        unsafe { self.schemas().get_unchecked(col) }\n    }\n\n    #[inline]\n    /// Lengths for each column raw data.\n    const fn lengths(\u0026self) -\u003e \u0026[i32] {\n        unsafe {\n            let ptr = self.offset(self.lengths_offset());\n            slice::from_raw_parts(ptr as *mut i32, self.cols)\n        }\n    }\n\n    #[inline]\n    /// Get one value at `(row, col)` of the block.\n    pub unsafe fn get_unchecked(\u0026self, row: usize, col: usize) -\u003e Value {\n        let (ty, o1, o2) = self.column_offsets().get_unchecked(col);\n\n        macro_rules! is_null {\n            ($bm:expr, $row:expr) =\u003e {{\n                (*$bm.offset($row as isize \u003e\u003e 3) \u003e\u003e (7 - ($row \u0026 7)) as u8) \u0026 0x1 == 1\n            }};\n        }\n\n        macro_rules! _primitive_value {\n            ($ty:ident, $native:ty) =\u003e {{\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003c$native\u003e()) as isize)\n                        as *const $native);\n                    Value::$ty(v)\n                }\n            }};\n        }\n\n        match ty {\n            Ty::Null =\u003e Value::Null,\n            Ty::Bool =\u003e _primitive_value!(Bool, bool),\n            Ty::TinyInt =\u003e _primitive_value!(TinyInt, i8),\n            Ty::SmallInt =\u003e _primitive_value!(SmallInt, i16),\n            Ty::Int =\u003e _primitive_value!(Int, i32),\n            Ty::BigInt =\u003e _primitive_value!(BigInt, i64),\n            Ty::Float =\u003e _primitive_value!(Float, f32),\n            Ty::Double =\u003e _primitive_value!(Double, f64),\n            Ty::VarChar =\u003e {\n                //\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    Value::VarChar(\n                        std::str::from_utf8_unchecked(slice::from_raw_parts(\n                            ptr.offset(2),\n                            len as usize,\n                        ))\n                        .to_string(),\n                    )\n                }\n            }\n            Ty::Timestamp =\u003e {\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003ci64\u003e()) as isize) as *const i64);\n                    Value::Timestamp(Timestamp::new(v, self.precision))\n                }\n            }\n            Ty::NChar =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    \n                    Value::NChar(\n                        slice::from_raw_parts(ptr.offset(2) as *mut char, len as usize / 4)\n                            .into_iter()\n                            .collect(),\n                    )\n                }\n            }\n            Ty::UTinyInt =\u003e _primitive_value!(UTinyInt, u8),\n            Ty::USmallInt =\u003e _primitive_value!(USmallInt, u16),\n            Ty::UInt =\u003e _primitive_value!(UInt, u32),\n            Ty::UBigInt =\u003e _primitive_value!(UBigInt, u64),\n            Ty::Json =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    debug_assert!(self.len() as isize \u003e= o1 + row as isize * 4 + len as isize);\n                    let chars_len = len / 4;\n                    let chars_ptr = ptr.offset(2) as *mut char;\n                    let chars = slice::from_raw_parts(chars_ptr, chars_len as usize);\n                    let json: String = chars.into_iter().collect();\n\n                    serde_json::from_str(\u0026json)\n                        .ok()\n                        .map(Value::Json)\n                        .unwrap_or(Value::Null)\n                }\n            }\n            ty =\u003e unreachable!(\"unsupported type: {ty}\"),\n        }\n    }\n}\n\n#[test]\nfn raw_block() -\u003e Result\u003c(), taos_error::Error\u003e {\n    use taos_sys::*;\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )?;\n    let rs = taos.query(\"show databases\")?;\n    let fields = rs.fields();\n    let precision = rs.precision();\n    let field_count = rs.field_count();\n    let (ptr, rows) = rs.fetch_raw_block()?;\n\n    let inner = unsafe { InnerBlock::from_ptr(ptr, rows as _, field_count as _, precision) };\n    let gid = inner.group_id();\n    println!(\"group id: {gid}\");\n\n    for i in 0..field_count {\n        let col = inner.get_schema_of(i as _);\n        let field = \u0026fields[i as usize];\n        println!(\"{field:?}, {col:#x?}\");\n    }\n\n    let schemas = inner.schemas();\n    dbg!(schemas);\n    let lengths = inner.lengths();\n    dbg!(lengths);\n    let offsets = inner.column_offsets();\n    dbg!(offsets);\n\n    dbg!(unsafe { inner.get_unchecked(0, field_count as usize - 1) });\n    for row in 0..dbg!(rows) as usize {\n        for col in 0..field_count as usize {\n            println!(\"({row}, {col}): \");\n            let v = unsafe { inner.get_unchecked(row, col) };\n            dbg!(v);\n        }\n    }\n    Ok(())\n}\n\n// impl BlockExt for InnerBlock {\n//     fn num_of_rows(\u0026self) -\u003e usize {\n//         todo!()\n//     }\n\n//     fn fields(\u0026self) -\u003e \u0026[Field] {\n//         todo!()\n//     }\n\n//     fn precision(\u0026self) -\u003e Precision {\n//         todo!()\n//     }\n\n//     fn is_null(\u0026self, row: usize, col: usize) -\u003e bool {\n//         todo!()\n//     }\n\n//     unsafe fn cell_unchecked(\n//         \u0026self,\n//         row: usize,\n//         col: usize,\n//     ) -\u003e (\u0026Field, taos_query::common::BorrowedValue) {\n//         todo!()\n//     }\n\n//     unsafe fn get_col_unchecked(\u0026self, col: usize) -\u003e taos_query::common::BorrowedColumn {\n//         todo!()\n//     }\n// }\n\n#[test]\nfn inner_block() {\n    use taos_query::common::Timestamp::Milliseconds;\n    use taos_sys::Precision::Millisecond;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let block = unsafe { InnerBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    assert_eq!(block.as_bytes(), bytes);\n    assert_eq!(block.len(), bytes.len());\n\n    use Value::*;\n    let values = vec![\n        vec![\n            Timestamp(Milliseconds(1655538138610)),\n            Bool(true),\n            Value::TinyInt(-1),\n            SmallInt(-1),\n            Int(-1),\n            BigInt(-1),\n            UTinyInt(1),\n            USmallInt(1),\n            UInt(1),\n            UBigInt(1),\n            Float(0.0),\n            Double(0.0),\n            VarChar(\"abc\".to_string()),\n            NChar(\"\".to_string()),\n        ],\n        {\n            Some(Timestamp(Milliseconds(1655538139610)))\n                .into_iter()\n                .chain(std::iter::repeat(Value::Null).take(14))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        },\n    ];\n    assert!(block.cols == 14);\n\n    for row in 0..rows {\n        for col in 0..block.cols {\n            let v = unsafe { block.get_unchecked(row, col) };\n            assert_eq!(v, values[row][col]);\n        }\n    }\n}\n\n#[test]\nfn raw_block_full_test() -\u003e Result\u003c(), taos_error::Error\u003e {\n    use taos_sys::*;\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )?;\n\n    let _ = taos.query(\"drop database if exists _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"create database if not exists _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"use _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"create stable stb1 (ts timestamp,vb bool,vi8 tinyint,vi16 smallint,\\\n        vi32 int,vi64 bigint, vu8 tinyint unsigned,vu16 smallint unsigned,vu32 int unsigned,vu64 bigint unsigned,\\\n        vf float,vd double,vv varchar(100), vn nchar(100)) tags(tj json)\")?;\n\n    let _ = taos.query(\n        \"insert into tb1 using stb1 tags(NULL) values\\\n        (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\",\n    )?;\n    let _ = taos.query(\n        \"insert into tb2 using stb1 tags('{\\\"a\\\":\\\"\\\"}') values\\\n        (now,true,-1,-1,-1,-1, 1,1,1,1,0.0,0.0,'abc', '')\\\n        (now+1s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\",\n    )?;\n    let rs = taos.query(\"select * from tb2 order by tbname\")?;\n    let fields = rs.fields();\n    let precision = rs.precision();\n    let field_count = rs.field_count();\n    let (ptr, rows) = rs.fetch_raw_block()?;\n\n    let inner = unsafe { InnerBlock::from_ptr(ptr, rows as _, field_count as _, precision) };\n    let gid = inner.group_id();\n    println!(\"group id: {gid}\");\n\n    use std::ascii::escape_default;\n\n    pub fn show_buf\u003cB: AsRef\u003c[u8]\u003e\u003e(buf: B) -\u003e String {\n        String::from_utf8(\n            buf.as_ref()\n                .iter()\n                .map(|b| escape_default(*b))\n                .flatten()\n                .collect(),\n        )\n        .unwrap()\n    }\n\n    dbg!(inner.len());\n    dbg!(inner.as_bytes());\n    let bytes = inner.to_vec();\n    println!(\"{}\", show_buf(bytes));\n\n    for i in 0..field_count {\n        let col = inner.get_schema_of(i as _);\n        let field = \u0026fields[i as usize];\n        println!(\"{field:?}, {col:#x?}\");\n    }\n\n    let schemas = inner.schemas();\n    dbg!(schemas);\n    let lengths = inner.lengths();\n    dbg!(lengths);\n    let offsets = inner.column_offsets();\n    dbg!(offsets);\n\n    dbg!(unsafe { inner.get_unchecked(0, field_count as usize - 1) });\n    for row in 0..dbg!(rows) as usize {\n        for col in 0..field_count as usize {\n            println!(\"({row}, {col}): \");\n            let v = unsafe { inner.get_unchecked(row, col) };\n\n            dbg!(v);\n        }\n    }\n    Ok(())\n}\n\n#[test]\nfn char_size() {\n    assert_eq!(size_of::\u003cchar\u003e(), 4);\n}\n","traces":[{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":84},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","time.rs"],"content":"use taos_sys::{ffi::*, *};\n\n#[test]\n#[cfg(taos_parse_time)]\nfn test_parse_time() {\n    use std::ffi::CString;\n    let s = CString::new(\"1970-01-01 00:00:00\").unwrap();\n    let mut time = 0i64;\n    unsafe {\n        taos_options(\n            TSDB_OPTION_TIMEZONE,\n            b\"Europe/Landon\\0\" as *const u8 as *const _,\n        )\n    };\n    let res = unsafe {\n        taos_parse_time(\n            s.as_ptr(),\n            \u0026mut time as _,\n            s.to_bytes().len() as _,\n            Precision::Microsecond,\n            0,\n        )\n    };\n    assert_eq!(res, 0, \"success\");\n    assert_eq!(time, 0, \"parse time\");\n\n    let s = CString::new(\"1970-01-01 08:00:00\").unwrap(); // CST +8\n                                                          // timezone could be set multiple times\n    unsafe {\n        taos_options(\n            TSDB_OPTION_TIMEZONE,\n            b\"Asia/Shanghai\\0\" as *const u8 as *const _,\n        )\n    };\n    let res = unsafe {\n        taos_parse_time(\n            s.as_ptr(),\n            \u0026mut time as _,\n            s.to_bytes().len() as _,\n            Precision::Microsecond,\n            0,\n        )\n    };\n    assert_eq!(res, 0, \"success\");\n    assert_eq!(time, 0, \"parse time\");\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","2.0","src","connector","odbc","examples","rust","main","src","main.rs"],"content":"extern crate odbc;\n// Use this crate and set environmet variable RUST_LOG=odbc to see ODBC warnings\nextern crate env_logger;\nuse odbc::*;\nuse odbc_safe::AutocommitOn;\nuse std::env;\n\nfn main() {\n\n    env_logger::init();\n\n    let conn_str = env::var(\"DSN\").unwrap();\n    match connect(\u0026conn_str) {\n        Ok(()) =\u003e println!(\"Success\"),\n        Err(diag) =\u003e println!(\"Error: {}\", diag),\n    }\n}\n\nfn connect(conn_str: \u0026str) -\u003e std::result::Result\u003c(), DiagnosticRecord\u003e {\n\n    let env = create_environment_v3().map_err(|e| e.unwrap())?;\n\n    let conn = env.connect_with_connection_string(conn_str)?;\n    execute_statement(\u0026conn)\n}\n\nfn execute_statement\u003c'env\u003e(conn: \u0026Connection\u003c'env, AutocommitOn\u003e) -\u003e Result\u003c()\u003e {\n    let stmt = Statement::with_parent(conn)?;\n\n    match stmt.exec_direct(\"select * from m.t\")? {\n        Data(mut stmt) =\u003e {\n            let cols = stmt.num_result_cols()?;\n            println!(\"cols: {}\", cols);\n            while let Some(mut cursor) = stmt.fetch()? {\n                for i in 1..(cols + 1) {\n                    match cursor.get_data::\u003c\u0026str\u003e(i as u16)? {\n                        Some(val) =\u003e print!(\" {}\", val),\n                        None =\u003e print!(\" NULL\"),\n                    }\n                }\n                println!(\"\");\n            }\n        }\n        NoData(_) =\u003e println!(\"Query executed, no data returned\"),\n    }\n\n    Ok(())\n}\n\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","connect.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -\u003e Result\u003cTaos, Error\u003e {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        // .db(\"log\") // remove comment if you want to connect to database log by default.\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\nfn main() {\n    #[allow(unused_variables)]\n    let taos = taos_connect().unwrap();\n    println!(\"Connected\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","stmt_example.rs"],"content":"use bstr::BString;\nuse libtaos::*;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.create_database(\"power\").await?;\n    taos.use_database(\"power\").await?;\n    taos.exec(\"CREATE STABLE meters (ts TIMESTAMP, current FLOAT, voltage INT, phase FLOAT) TAGS (location BINARY(64), groupId INT)\").await?;\n    let mut stmt = taos.stmt(\"INSERT INTO ? USING meters TAGS(?, ?) VALUES(?, ?, ?, ?)\")?;\n    // bind table name and tags\n    stmt.set_tbname_tags(\n        \"d1001\",\n        [\n            Field::Binary(BString::from(\"California.SanFrancisco\")),\n            Field::Int(2),\n        ],\n    )?;\n    // bind values.\n    let values = vec![\n        Field::Timestamp(Timestamp::new(1648432611249, TimestampPrecision::Milli)),\n        Field::Float(10.3),\n        Field::Int(219),\n        Field::Float(0.31),\n    ];\n    stmt.bind(\u0026values)?;\n    // bind one more row\n    let values2 = vec![\n        Field::Timestamp(Timestamp::new(1648432611749, TimestampPrecision::Milli)),\n        Field::Float(12.6),\n        Field::Int(218),\n        Field::Float(0.33),\n    ];\n    stmt.bind(\u0026values2)?;\n    // execute\n    stmt.execute()?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","examples","subscribe_demo.rs"],"content":"fn main() {\n  \n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","nativeexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","connect.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -\u003e Result\u003cTaos, Error\u003e {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        // .db(\"log\") // remove comment if you want to connect to database log by default.\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\n#[tokio::main]\nasync fn main() {\n    #[allow(unused_variables)]\n    let taos = taos_connect().expect(\"connect error\");\n    println!(\"Connected\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","insert_example.rs"],"content":"use libtaos::*;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.create_database(\"power\").await?;\n    taos.exec(\"CREATE STABLE power.meters (ts TIMESTAMP, current FLOAT, voltage INT, phase FLOAT) TAGS (location BINARY(64), groupId INT)\").await?;\n    let sql = \"INSERT INTO power.d1001 USING power.meters TAGS(California.SanFrancisco, 2) VALUES ('2018-10-03 14:38:05.000', 10.30000, 219, 0.31000) ('2018-10-03 14:38:15.000', 12.60000, 218, 0.33000) ('2018-10-03 14:38:16.800', 12.30000, 221, 0.31000)\n    power.d1002 USING power.meters TAGS(California.SanFrancisco, 3) VALUES ('2018-10-03 14:38:16.650', 10.30000, 218, 0.25000)\n    power.d1003 USING power.meters TAGS(California.LosAngeles, 2) VALUES ('2018-10-03 14:38:05.500', 11.80000, 221, 0.28000) ('2018-10-03 14:38:16.600', 13.40000, 223, 0.29000)\n    power.d1004 USING power.meters TAGS(California.LosAngeles, 3) VALUES ('2018-10-03 14:38:05.000', 10.80000, 223, 0.29000) ('2018-10-03 14:38:06.500', 11.50000, 221, 0.35000)\";\n    let result = taos.query(sql).await?;\n    println!(\"{:?}\", result);\n    Ok(())\n}\n\n// output:\n// TaosQueryData { column_meta: [ColumnMeta { name: \"affected_rows\", type_: Int, bytes: 4 }], rows: [[Int(8)]] }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","examples","query_example.rs"],"content":"use libtaos::*;\n\nfn taos_connect() -\u003e Result\u003cTaos, Error\u003e {\n    TaosCfgBuilder::default()\n        .ip(\"localhost\")\n        .user(\"root\")\n        .pass(\"taosdata\")\n        .db(\"power\")\n        .port(6030u16)\n        .build()\n        .expect(\"TaosCfg builder error\")\n        .connect()\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Error\u003e {\n    let taos = taos_connect().expect(\"connect error\");\n    let result = taos.query(\"SELECT ts, current FROM meters LIMIT 2\").await?;\n    // print column names\n    let meta: Vec\u003cColumnMeta\u003e = result.column_meta;\n    for column in meta {\n        print!(\"{}\\t\", column.name)\n    }\n    println!();\n    // print rows\n    let rows: Vec\u003cVec\u003cField\u003e\u003e = result.rows;\n    for row in rows {\n        for field in row {\n            print!(\"{}\\t\", field);\n        }\n        println!();\n    }\n    Ok(())\n}\n\n// output:\n// ts      current\n// 2022-03-28 09:56:51.249 10.3\n// 2022-03-28 09:56:51.749 12.6\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","restexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","influxdb_line_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\"meters,location=California.LosAngeles,groupid=2 current=11.8,voltage=221,phase=0.28 1648432611249\",\n    \"meters,location=California.LosAngeles,groupid=2 current=13.4,voltage=223,phase=0.29 1648432611250\",\n    \"meters,location=California.LosAngeles,groupid=3 current=10.8,voltage=223,phase=0.29 1648432611249\",\n    \"meters,location=California.LosAngeles,groupid=3 current=11.3,voltage=221,phase=0.35 1648432611250\"];\n    let affected_rows = taos\n        .schemaless_insert(\n            \u0026lines,\n            TSDB_SML_LINE_PROTOCOL,\n            TSDB_SML_TIMESTAMP_MILLISECONDS,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows);\n}\n\n// run with:  cargo run --example influxdb_line_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","opentsdb_json_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\n        r#\"[{\"metric\": \"meters.current\", \"timestamp\": 1648432611249, \"value\": 10.3, \"tags\": {\"location\": \"California.SanFrancisco\", \"groupid\": 2}},\n        {\"metric\": \"meters.voltage\", \"timestamp\": 1648432611249, \"value\": 219, \"tags\": {\"location\": \"California.LosAngeles\", \"groupid\": 1}},\n        {\"metric\": \"meters.current\", \"timestamp\": 1648432611250, \"value\": 12.6, \"tags\": {\"location\": \"California.SanFrancisco\", \"groupid\": 2}},\n        {\"metric\": \"meters.voltage\", \"timestamp\": 1648432611250, \"value\": 221, \"tags\": {\"location\": \"California.LosAngeles\", \"groupid\": 1}}]\"#,\n    ];\n\n    let affected_rows = taos\n        .schemaless_insert(\n            \u0026lines,\n            TSDB_SML_JSON_PROTOCOL,\n            TSDB_SML_TIMESTAMP_NOT_CONFIGURED,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows); // affected_rows=4\n}\n\n// run with:  cargo run --example opentsdb_json_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","examples","opentsdb_telnet_example.rs"],"content":"use libtaos::schemaless::*;\nuse libtaos::*;\n\nfn main() {\n    let taos = TaosCfg::default().connect().expect(\"fail to connect\");\n    taos.raw_query(\"CREATE DATABASE test\").unwrap();\n    taos.raw_query(\"USE test\").unwrap();\n    let lines = [\n        \"meters.current 1648432611249 10.3 location=California.SanFrancisco groupid=2\",\n        \"meters.current 1648432611250 12.6 location=California.SanFrancisco groupid=2\",\n        \"meters.current 1648432611249 10.8 location=California.LosAngeles groupid=3\",\n        \"meters.current 1648432611250 11.3 location=California.LosAngeles groupid=3\",\n        \"meters.voltage 1648432611249 219 location=California.SanFrancisco groupid=2\",\n        \"meters.voltage 1648432611250 218 location=California.SanFrancisco groupid=2\",\n        \"meters.voltage 1648432611249 221 location=California.LosAngeles groupid=3\",\n        \"meters.voltage 1648432611250 217 location=California.LosAngeles groupid=3\",\n    ];\n    let affected_rows = taos\n        .schemaless_insert(\n            \u0026lines,\n            TSDB_SML_TELNET_PROTOCOL,\n            TSDB_SML_TIMESTAMP_NOT_CONFIGURED,\n        )\n        .unwrap();\n    println!(\"affected_rows={}\", affected_rows); // affected_rows=8\n}\n\n// run with:  cargo run --example opentsdb_telnet_example\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","docs","examples","rust","schemalessexample","src","main.rs"],"content":"fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","build.rs"],"content":"extern crate bindgen;\n\nuse std::env;\nuse std::path::PathBuf;\n\nfn main() {\n    // Tell cargo to tell rustc to link the system bzip2\n    // shared library.\n    println!(\"cargo:rustc-link-lib=taos\");\n\n    // Tell cargo to invalidate the built crate whenever the wrapper changes\n    println!(\"cargo:rerun-if-changed=wrapper.h\");\n\n    // The bindgen::Builder is the main entry point\n    // to bindgen, and lets you build up options for\n    // the resulting bindings.\n    let bindings = bindgen::Builder::default()\n        // The input header we would like to generate\n        // bindings for.\n        .header(\"wrapper.h\")\n        // Tell cargo to invalidate the built crate whenever any of the\n        // included header files changed.\n        .parse_callbacks(Box::new(bindgen::CargoCallbacks))\n        // Finish the builder and generate the bindings.\n        .generate()\n        // Unwrap the Result and panic on failure.\n        .expect(\"Unable to generate bindings\");\n\n    // Write the bindings to the $OUT_DIR/bindings.rs file.\n    let out_path = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n    bindings\n        .write_to_file(out_path.join(\"bindings.rs\"))\n        .expect(\"Couldn't write bindings!\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","examples","demo.rs"],"content":"use libtdengine::tdengine::{clean_up, Tdengine};\nuse libtdengine::utils;\nuse std::process;\n\nfn main() {\n    let tde = Tdengine::new(\"127.0.0.1:6030\", \"root\", \"taosdata\", \"log\", 0).unwrap_or_else(|err| {\n        eprintln!(\"Can't create Tdengine: {}\", err);\n        process::exit(1)\n    });\n\n    assert_eq!(tde.query(\"drop database demo\").is_ok(), true);\n    assert_eq!(tde.query(\"create database demo\").is_ok(), true);\n    assert_eq!(tde.query(\"use demo\").is_ok(), true);\n    assert_eq!(\n        tde.query(\"create table m1 (ts timestamp, speed int)\")\n            .is_ok(),\n        true\n    );\n\n    for i in 0..10 {\n        assert_eq!(\n            tde.query(format!(\"insert into m1 values (now+{}s, {})\", i, i).as_str())\n                .is_ok(),\n            true\n        );\n    }\n    let rows = tde.query(\"select * from m1\").unwrap_or_else(|err| {\n        eprintln!(\"select error: {}\", err);\n        process::exit(1);\n    });\n    for row in rows {\n        println!(\"{}\", utils::format_row(\u0026row));\n    }\n    // drop manually before clean up\n    drop(tde);\n    // cleanup before program exit\n    clean_up();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","examples","subscribe.rs"],"content":"use libtdengine::subscriber::Subscriber;\nuse libtdengine::tdengine::{clean_up, Tdengine};\nuse std::process;\n\nfn main() {\n    let td = Tdengine::new(\"127.0.0.1\", \"root\", \"taosdata\", \"demo\", 0).unwrap_or_else(|err| {\n        eprintln!(\"Can't create Tdengine: {}\", err);\n        process::exit(1)\n    });\n\n    let mut subscriber =\n        Subscriber::subscribe(td.taos(), 0, \"topic_test\", \"select * from m1;\", 1000)\n            .unwrap_or_else(|err| {\n                eprintln!(\"Can't create Subscriber: {}\", err);\n                process::exit(1)\n            });\n\n    loop {\n        let rows = match subscriber.consume() {\n            Ok(rows) =\u003e rows,\n            Err(err) =\u003e {\n                eprintln!(\"consume exit: {}\", err);\n                break;\n            }\n        };\n\n        // example code\n        for row in rows {\n            println!(\"({}, {})\", row[0].as_i64(), row[1].as_i32());\n        }\n        println!(\"====================\");\n    }\n    drop(td);\n    clean_up();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","bindings.rs"],"content":"/* automatically generated by rust-bindgen 0.55.1 */\n\npub const _STDINT_H: u32 = 1;\npub const _FEATURES_H: u32 = 1;\npub const __USE_ANSI: u32 = 1;\npub const _BSD_SOURCE: u32 = 1;\npub const _SVID_SOURCE: u32 = 1;\npub const __USE_ISOC11: u32 = 1;\npub const __USE_ISOC99: u32 = 1;\npub const __USE_ISOC95: u32 = 1;\npub const _POSIX_SOURCE: u32 = 1;\npub const _POSIX_C_SOURCE: u32 = 200809;\npub const __USE_POSIX_IMPLICITLY: u32 = 1;\npub const __USE_POSIX: u32 = 1;\npub const __USE_POSIX2: u32 = 1;\npub const __USE_POSIX199309: u32 = 1;\npub const __USE_POSIX199506: u32 = 1;\npub const __USE_XOPEN2K: u32 = 1;\npub const __USE_XOPEN2K8: u32 = 1;\npub const _ATFILE_SOURCE: u32 = 1;\npub const __USE_MISC: u32 = 1;\npub const __USE_BSD: u32 = 1;\npub const __USE_SVID: u32 = 1;\npub const __USE_ATFILE: u32 = 1;\npub const __USE_FORTIFY_LEVEL: u32 = 0;\npub const _STDC_PREDEF_H: u32 = 1;\npub const __STDC_IEC_559__: u32 = 1;\npub const __STDC_IEC_559_COMPLEX__: u32 = 1;\npub const __STDC_ISO_10646__: u32 = 201103;\npub const __STDC_NO_THREADS__: u32 = 1;\npub const __GNU_LIBRARY__: u32 = 6;\npub const __GLIBC__: u32 = 2;\npub const __GLIBC_MINOR__: u32 = 17;\npub const __GLIBC_HAVE_LONG_LONG: u32 = 1;\npub const _SYS_CDEFS_H: u32 = 1;\npub const __WORDSIZE: u32 = 64;\npub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;\npub const __SYSCALL_WORDSIZE: u32 = 64;\npub const _BITS_WCHAR_H: u32 = 1;\npub const __WCHAR_MIN: i32 = -2147483648;\npub const __WCHAR_MAX: u32 = 2147483647;\npub const INT8_MIN: i32 = -128;\npub const INT16_MIN: i32 = -32768;\npub const INT32_MIN: i32 = -2147483648;\npub const INT8_MAX: u32 = 127;\npub const INT16_MAX: u32 = 32767;\npub const INT32_MAX: u32 = 2147483647;\npub const UINT8_MAX: u32 = 255;\npub const UINT16_MAX: u32 = 65535;\npub const UINT32_MAX: u32 = 4294967295;\npub const INT_LEAST8_MIN: i32 = -128;\npub const INT_LEAST16_MIN: i32 = -32768;\npub const INT_LEAST32_MIN: i32 = -2147483648;\npub const INT_LEAST8_MAX: u32 = 127;\npub const INT_LEAST16_MAX: u32 = 32767;\npub const INT_LEAST32_MAX: u32 = 2147483647;\npub const UINT_LEAST8_MAX: u32 = 255;\npub const UINT_LEAST16_MAX: u32 = 65535;\npub const UINT_LEAST32_MAX: u32 = 4294967295;\npub const INT_FAST8_MIN: i32 = -128;\npub const INT_FAST16_MIN: i64 = -9223372036854775808;\npub const INT_FAST32_MIN: i64 = -9223372036854775808;\npub const INT_FAST8_MAX: u32 = 127;\npub const INT_FAST16_MAX: u64 = 9223372036854775807;\npub const INT_FAST32_MAX: u64 = 9223372036854775807;\npub const UINT_FAST8_MAX: u32 = 255;\npub const UINT_FAST16_MAX: i32 = -1;\npub const UINT_FAST32_MAX: i32 = -1;\npub const INTPTR_MIN: i64 = -9223372036854775808;\npub const INTPTR_MAX: u64 = 9223372036854775807;\npub const UINTPTR_MAX: i32 = -1;\npub const PTRDIFF_MIN: i64 = -9223372036854775808;\npub const PTRDIFF_MAX: u64 = 9223372036854775807;\npub const SIG_ATOMIC_MIN: i32 = -2147483648;\npub const SIG_ATOMIC_MAX: u32 = 2147483647;\npub const SIZE_MAX: i32 = -1;\npub const WCHAR_MIN: i32 = -2147483648;\npub const WCHAR_MAX: u32 = 2147483647;\npub const WINT_MIN: u32 = 0;\npub const WINT_MAX: u32 = 4294967295;\npub const TSDB_DATA_TYPE_NULL: u32 = 0;\npub const TSDB_DATA_TYPE_BOOL: u32 = 1;\npub const TSDB_DATA_TYPE_TINYINT: u32 = 2;\npub const TSDB_DATA_TYPE_SMALLINT: u32 = 3;\npub const TSDB_DATA_TYPE_INT: u32 = 4;\npub const TSDB_DATA_TYPE_BIGINT: u32 = 5;\npub const TSDB_DATA_TYPE_FLOAT: u32 = 6;\npub const TSDB_DATA_TYPE_DOUBLE: u32 = 7;\npub const TSDB_DATA_TYPE_BINARY: u32 = 8;\npub const TSDB_DATA_TYPE_TIMESTAMP: u32 = 9;\npub const TSDB_DATA_TYPE_NCHAR: u32 = 10;\npub type int_least8_t = ::std::os::raw::c_schar;\npub type int_least16_t = ::std::os::raw::c_short;\npub type int_least32_t = ::std::os::raw::c_int;\npub type int_least64_t = ::std::os::raw::c_long;\npub type uint_least8_t = ::std::os::raw::c_uchar;\npub type uint_least16_t = ::std::os::raw::c_ushort;\npub type uint_least32_t = ::std::os::raw::c_uint;\npub type uint_least64_t = ::std::os::raw::c_ulong;\npub type int_fast8_t = ::std::os::raw::c_schar;\npub type int_fast16_t = ::std::os::raw::c_long;\npub type int_fast32_t = ::std::os::raw::c_long;\npub type int_fast64_t = ::std::os::raw::c_long;\npub type uint_fast8_t = ::std::os::raw::c_uchar;\npub type uint_fast16_t = ::std::os::raw::c_ulong;\npub type uint_fast32_t = ::std::os::raw::c_ulong;\npub type uint_fast64_t = ::std::os::raw::c_ulong;\npub type intmax_t = ::std::os::raw::c_long;\npub type uintmax_t = ::std::os::raw::c_ulong;\npub type TAOS = ::std::os::raw::c_void;\npub type TAOS_ROW = *mut *mut ::std::os::raw::c_void;\npub type TAOS_RES = ::std::os::raw::c_void;\npub type TAOS_SUB = ::std::os::raw::c_void;\npub type TAOS_STREAM = ::std::os::raw::c_void;\npub type TAOS_STMT = ::std::os::raw::c_void;\npub const TSDB_OPTION_TSDB_OPTION_LOCALE: TSDB_OPTION = 0;\npub const TSDB_OPTION_TSDB_OPTION_CHARSET: TSDB_OPTION = 1;\npub const TSDB_OPTION_TSDB_OPTION_TIMEZONE: TSDB_OPTION = 2;\npub const TSDB_OPTION_TSDB_OPTION_CONFIGDIR: TSDB_OPTION = 3;\npub const TSDB_OPTION_TSDB_OPTION_SHELL_ACTIVITY_TIMER: TSDB_OPTION = 4;\npub const TSDB_OPTION_TSDB_MAX_OPTIONS: TSDB_OPTION = 5;\npub type TSDB_OPTION = ::std::os::raw::c_uint;\n#[repr(C)]\n#[derive(Copy, Clone)]\npub struct taosField {\n    pub name: [::std::os::raw::c_char; 65usize],\n    pub type_: u8,\n    pub bytes: i16,\n}\n#[test]\nfn bindgen_test_layout_taosField() {\n    assert_eq!(\n        ::std::mem::size_of::\u003ctaosField\u003e(),\n        68usize,\n        concat!(\"Size of: \", stringify!(taosField))\n    );\n    assert_eq!(\n        ::std::mem::align_of::\u003ctaosField\u003e(),\n        2usize,\n        concat!(\"Alignment of \", stringify!(taosField))\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003ctaosField\u003e())).name as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(name)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003ctaosField\u003e())).type_ as *const _ as usize },\n        65usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(type_)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003ctaosField\u003e())).bytes as *const _ as usize },\n        66usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(taosField),\n            \"::\",\n            stringify!(bytes)\n        )\n    );\n}\npub type TAOS_FIELD = taosField;\nextern \"C\" {\n    pub fn taos_init();\n}\nextern \"C\" {\n    pub fn taos_cleanup();\n}\nextern \"C\" {\n    pub fn taos_options(\n        option: TSDB_OPTION,\n        arg: *const ::std::os::raw::c_void,\n        ...\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_connect(\n        ip: *const ::std::os::raw::c_char,\n        user: *const ::std::os::raw::c_char,\n        pass: *const ::std::os::raw::c_char,\n        db: *const ::std::os::raw::c_char,\n        port: u16,\n    ) -\u003e *mut TAOS;\n}\nextern \"C\" {\n    pub fn taos_close(taos: *mut TAOS);\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct TAOS_BIND {\n    pub buffer_type: ::std::os::raw::c_int,\n    pub buffer: *mut ::std::os::raw::c_void,\n    pub buffer_length: usize,\n    pub length: *mut usize,\n    pub is_null: *mut ::std::os::raw::c_int,\n    pub is_unsigned: ::std::os::raw::c_int,\n    pub error: *mut ::std::os::raw::c_int,\n}\n#[test]\nfn bindgen_test_layout_TAOS_BIND() {\n    assert_eq!(\n        ::std::mem::size_of::\u003cTAOS_BIND\u003e(),\n        56usize,\n        concat!(\"Size of: \", stringify!(TAOS_BIND))\n    );\n    assert_eq!(\n        ::std::mem::align_of::\u003cTAOS_BIND\u003e(),\n        8usize,\n        concat!(\"Alignment of \", stringify!(TAOS_BIND))\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).buffer_type as *const _ as usize },\n        0usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer_type)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).buffer as *const _ as usize },\n        8usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).buffer_length as *const _ as usize },\n        16usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(buffer_length)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).length as *const _ as usize },\n        24usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(length)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).is_null as *const _ as usize },\n        32usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(is_null)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).is_unsigned as *const _ as usize },\n        40usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(is_unsigned)\n        )\n    );\n    assert_eq!(\n        unsafe { \u0026(*(::std::ptr::null::\u003cTAOS_BIND\u003e())).error as *const _ as usize },\n        48usize,\n        concat!(\n            \"Offset of field: \",\n            stringify!(TAOS_BIND),\n            \"::\",\n            stringify!(error)\n        )\n    );\n}\nextern \"C\" {\n    pub fn taos_stmt_init(taos: *mut TAOS) -\u003e *mut TAOS_STMT;\n}\nextern \"C\" {\n    pub fn taos_stmt_prepare(\n        stmt: *mut TAOS_STMT,\n        sql: *const ::std::os::raw::c_char,\n        length: ::std::os::raw::c_ulong,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_bind_param(\n        stmt: *mut TAOS_STMT,\n        bind: *mut TAOS_BIND,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_add_batch(stmt: *mut TAOS_STMT) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_execute(stmt: *mut TAOS_STMT) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stmt_use_result(stmt: *mut TAOS_STMT) -\u003e *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_stmt_close(stmt: *mut TAOS_STMT) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_query(taos: *mut TAOS, sql: *const ::std::os::raw::c_char) -\u003e *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_fetch_row(res: *mut TAOS_RES) -\u003e TAOS_ROW;\n}\nextern \"C\" {\n    pub fn taos_result_precision(res: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_free_result(res: *mut TAOS_RES);\n}\nextern \"C\" {\n    pub fn taos_field_count(tres: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_num_fields(res: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_affected_rows(res: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_fetch_fields(res: *mut TAOS_RES) -\u003e *mut TAOS_FIELD;\n}\nextern \"C\" {\n    pub fn taos_select_db(\n        taos: *mut TAOS,\n        db: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_print_row(\n        str_: *mut ::std::os::raw::c_char,\n        row: TAOS_ROW,\n        fields: *mut TAOS_FIELD,\n        num_fields: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_stop_query(res: *mut TAOS_RES);\n}\nextern \"C\" {\n    pub fn taos_fetch_block(res: *mut TAOS_RES, rows: *mut TAOS_ROW) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_validate_sql(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_fetch_lengths(res: *mut TAOS_RES) -\u003e *mut ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_get_server_info(taos: *mut TAOS) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_get_client_info() -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_errstr(tres: *mut TAOS_RES) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn taos_errno(tres: *mut TAOS_RES) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn taos_query_a(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                code: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn taos_fetch_rows_a(\n        res: *mut TAOS_RES,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                numOfRows: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn taos_fetch_row_a(\n        res: *mut TAOS_RES,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                row: TAOS_ROW,\n            ),\n        \u003e,\n        param: *mut ::std::os::raw::c_void,\n    );\n}\npub type TAOS_SUBSCRIBE_CALLBACK = ::std::option::Option\u003c\n    unsafe extern \"C\" fn(\n        tsub: *mut TAOS_SUB,\n        res: *mut TAOS_RES,\n        param: *mut ::std::os::raw::c_void,\n        code: ::std::os::raw::c_int,\n    ),\n\u003e;\nextern \"C\" {\n    pub fn taos_subscribe(\n        taos: *mut TAOS,\n        restart: ::std::os::raw::c_int,\n        topic: *const ::std::os::raw::c_char,\n        sql: *const ::std::os::raw::c_char,\n        fp: TAOS_SUBSCRIBE_CALLBACK,\n        param: *mut ::std::os::raw::c_void,\n        interval: ::std::os::raw::c_int,\n    ) -\u003e *mut TAOS_SUB;\n}\nextern \"C\" {\n    pub fn taos_consume(tsub: *mut TAOS_SUB) -\u003e *mut TAOS_RES;\n}\nextern \"C\" {\n    pub fn taos_unsubscribe(tsub: *mut TAOS_SUB, keepProgress: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn taos_open_stream(\n        taos: *mut TAOS,\n        sql: *const ::std::os::raw::c_char,\n        fp: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                param: *mut ::std::os::raw::c_void,\n                arg1: *mut TAOS_RES,\n                row: TAOS_ROW,\n            ),\n        \u003e,\n        stime: i64,\n        param: *mut ::std::os::raw::c_void,\n        callback: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e *mut TAOS_STREAM;\n}\nextern \"C\" {\n    pub fn taos_close_stream(tstr: *mut TAOS_STREAM);\n}\nextern \"C\" {\n    pub fn taos_load_table_info(\n        taos: *mut TAOS,\n        tableNameList: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","lib.rs"],"content":"#![allow(unused)]\n#![allow(non_camel_case_types)]\n\n#[path = \"bindings.rs\"]\npub mod bindings;\n#[path = \"subscriber.rs\"]\npub mod subscriber;\n#[path = \"tdengine.rs\"]\npub mod tdengine;\n#[path = \"utils.rs\"]\npub mod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","subscriber.rs"],"content":"use crate::bindings::*;\nuse crate::utils;\n\nuse std::os::raw::{c_int, c_void};\nuse std::ptr;\n\npub struct Subscriber {\n    tsub: *mut c_void,\n    fields: *mut taosField,\n    fcount: c_int,\n}\n\nimpl Subscriber {\n    pub fn subscribe(\n        taos: *mut c_void,\n        restart: i32,\n        topic: \u0026str,\n        sql: \u0026str,\n        interval: i32,\n    ) -\u003e Result\u003cSubscriber, \u0026'static str\u003e {\n        unsafe {\n            let mut tsub = taos_subscribe(\n                taos,\n                restart as c_int,\n                utils::str_into_raw(topic),\n                utils::str_into_raw(sql),\n                None,\n                ptr::null_mut(),\n                interval as c_int,\n            );\n            if tsub.is_null() {\n                return Err(utils::raw_into_str(taos_errstr(tsub)));\n            }\n\n            Ok(Subscriber {\n                tsub: tsub,\n                fields: ptr::null_mut(), // init\n                fcount: 0,               // init\n            })\n        }\n    }\n\n    pub fn consume(self: \u0026mut Subscriber) -\u003e Result\u003cVec\u003cutils::Row\u003e, \u0026'static str\u003e {\n        unsafe {\n            let taos_res = taos_consume(self.tsub);\n            if taos_res.is_null() {\n                return Err(utils::raw_into_str(taos_errstr(self.tsub)));\n            }\n            if self.fields.is_null() {\n                self.fields = taos_fetch_fields(taos_res);\n                // fetch err msg\n                if self.fields.is_null() {\n                    return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                }\n            }\n\n            if self.fcount == 0 {\n                self.fcount = taos_field_count(taos_res);\n                if self.fcount == 0 {\n                    return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                }\n                println!(\"{} fields\", self.fcount);\n            }\n\n            let mut rows: Vec\u003cutils::Row\u003e = Vec::\u003cutils::Row\u003e::new();\n            loop {\n                let taos_row = taos_fetch_row(taos_res);\n                if taos_row.is_null() {\n                    // chek retcode\n                    if taos_errno(taos_res) != 0 {\n                        return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                    }\n                    break;\n                }\n\n                // example code for taos_print_row\n                //let mut buf: Vec\u003cc_char\u003e = vec![0; 4096];\n                //taos_print_row(buf.as_mut_ptr(), taos_row, self.fields, self.fcount);\n                //println!(\n                //    \"internal print {}\",\n                //    CStr::from_ptr(buf.as_ptr()).to_str().unwrap()\n                //);\n\n                let raw_row = std::slice::from_raw_parts(taos_row, self.fcount as usize);\n                let row = utils::raw_into_row(self.fields, self.fcount, raw_row);\n                rows.push(row);\n            }\n            println!(\"{} rows fetched\", rows.len());\n            Ok(rows)\n        }\n    }\n\n    pub fn unsubscribe(self: \u0026Subscriber, keep_progress: i32) {\n        unsafe { taos_unsubscribe(self.tsub, keep_progress as c_int) }\n    }\n\n    pub fn print_row(self: \u0026Subscriber, row: \u0026utils::Row) {\n        println!(\"format row: {}\", utils::format_row(row));\n    }\n}\n\nimpl Drop for Subscriber {\n    fn drop(\u0026mut self) {\n        unsafe {\n            taos_unsubscribe(self.tsub, 1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","tdengine.rs"],"content":"use crate::bindings::*;\nuse crate::utils;\n\nuse std::os::raw::c_void;\n\npub struct Tdengine {\n    conn: *mut c_void, // tdengine conn\n}\n\nimpl Tdengine {\n    pub fn new(\n        ip: \u0026str, // host ip\n        username: \u0026str,\n        passwd: \u0026str,\n        db: \u0026str,\n        port: i32, // tdengine port\n    ) -\u003e Result\u003cTdengine, \u0026'static str\u003e {\n        unsafe {\n            taos_init();\n            let mut conn = taos_connect(\n                utils::str_into_raw(ip),\n                utils::str_into_raw(username),\n                utils::str_into_raw(passwd),\n                utils::str_into_raw(db),\n                port as u16,\n            );\n            if conn.is_null() {\n                Err(utils::raw_into_str(taos_errstr(conn)))\n            } else {\n                println!(\"connected to {}:{} user:{}, db:{}\", ip, port, username, db);\n                Ok(Tdengine { conn })\n            }\n        }\n    }\n\n    pub fn query(self: \u0026Tdengine, s: \u0026str) -\u003e Result\u003cVec\u003cutils::Row\u003e, \u0026'static str\u003e {\n        unsafe {\n            let taos_res = taos_query(self.conn, utils::str_into_raw(s));\n            // check retcode\n            if taos_errno(taos_res) != 0 {\n                let err = utils::raw_into_str(taos_errstr(taos_res));\n                println!(\"query '{}' error: {}\", s, err);\n                return Err(err);\n            }\n            println!(\"query '{}' ok\", s);\n            let mut rows: Vec\u003cutils::Row\u003e = Vec::\u003cutils::Row\u003e::new();\n            let fields = taos_fetch_fields(taos_res);\n            let fcount = taos_field_count(taos_res);\n            loop {\n                let taos_row = taos_fetch_row(taos_res);\n                if taos_row.is_null() {\n                    // check retcode\n                    if taos_errno(taos_res) != 0 {\n                        return Err(utils::raw_into_str(taos_errstr(taos_res)));\n                    }\n                    break;\n                }\n\n                let raw_row = std::slice::from_raw_parts(taos_row, fcount as usize);\n                let row = utils::raw_into_row(fields, fcount, raw_row);\n                rows.push(row);\n            }\n            taos_free_result(taos_res);\n            println!(\"{} rows fetched\", rows.len());\n            Ok(rows)\n        }\n    }\n\n    pub fn taos(self: \u0026Tdengine) -\u003e *mut c_void {\n        self.conn\n    }\n}\n\nimpl Drop for Tdengine {\n    fn drop(\u0026mut self) {\n        unsafe {\n            taos_close(self.conn);\n            // we will not do clean up here\n        }\n    }\n}\n\npub fn clean_up() {\n    unsafe {\n        taos_cleanup();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","examples","rust","src","utils.rs"],"content":"use crate::bindings;\n\nuse std::ffi::{CStr, CString};\nuse std::fmt;\nuse std::os::raw::{c_char, c_int, c_void};\n\n// #[derive(Debug)]\npub enum Field {\n    tinyInt(i8),\n    smallInt(i16),\n    normalInt(i32),\n    bigInt(i64),\n    float(f32),\n    double(f64),\n    string(String),\n    boolType(bool),\n}\n\nimpl fmt::Display for Field {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match \u0026*self {\n            Field::tinyInt(v) =\u003e write!(f, \"{}\", v),\n            Field::smallInt(v) =\u003e write!(f, \"{}\", v),\n            Field::normalInt(v) =\u003e write!(f, \"{}\", v),\n            Field::bigInt(v) =\u003e write!(f, \"{}\", v),\n            Field::float(v) =\u003e write!(f, \"{}\", v),\n            Field::double(v) =\u003e write!(f, \"{}\", v),\n            Field::tinyInt(v) =\u003e write!(f, \"{}\", v),\n            Field::boolType(v) =\u003e write!(f, \"{}\", v),\n            Field::string(v) =\u003e write!(f, \"{}\", v),\n        }\n    }\n}\n\nmacro_rules! impl_as_fields {\n    ($fn:ident, $pattern:pat =\u003e $v:expr, $type:ty) =\u003e {\n        pub fn $fn(\u0026self) -\u003e $type {\n            match *self {\n                $pattern =\u003e $v,\n                _ =\u003e {\n                    println!(\"unexpected $type value {}\", self);\n                    Default::default()\n                }\n            }\n        }\n    };\n}\n\nimpl Field {\n    impl_as_fields!(as_i8, Field::tinyInt(v) =\u003e v, i8);\n    impl_as_fields!(as_i16, Field::smallInt(v) =\u003e v, i16);\n    impl_as_fields!(as_i32, Field::normalInt(v) =\u003e v, i32);\n    impl_as_fields!(as_i64, Field::bigInt(v) =\u003e v, i64);\n    impl_as_fields!(as_f32, Field::float(v) =\u003e v, f32);\n    impl_as_fields!(as_f64, Field::double(v) =\u003e v, f64);\n    impl_as_fields!(as_bool, Field::boolType(v) =\u003e v, bool);\n\n    pub fn as_string(\u0026self) -\u003e String {\n        match \u0026*self {\n            Field::string(v) =\u003e v.to_string(),\n            _ =\u003e {\n                println!(\"unexpected string value {}\", self);\n                \"\".to_string()\n            }\n        }\n    }\n}\n\npub type Row = Vec\u003cField\u003e;\n\npub fn format_row(row: \u0026Row) -\u003e String {\n    let mut s = String::new();\n    for field in row {\n        s.push_str(format!(\"{} \", field).as_str());\n    }\n    s\n}\n\npub fn str_into_raw(s: \u0026str) -\u003e *mut c_char {\n    if s.is_empty() {\n        0 as *mut c_char\n    } else {\n        CString::new(s).unwrap().into_raw()\n    }\n}\n\npub fn raw_into_str\u003c'a\u003e(raw: *mut c_char) -\u003e \u0026'static str {\n    unsafe { CStr::from_ptr(raw).to_str().unwrap() }\n}\n\npub fn raw_into_field(raw: *mut bindings::TAOS_FIELD, fcount: c_int) -\u003e Vec\u003cbindings::taosField\u003e {\n    let mut fields: Vec\u003cbindings::taosField\u003e = Vec::new();\n\n    for i in 0..fcount as isize {\n        fields.push(bindings::taosField {\n            name: unsafe { *raw.offset(i as isize) }.name,\n            bytes: unsafe { *raw.offset(i as isize) }.bytes,\n            type_: unsafe { *raw.offset(i as isize) }.type_,\n        });\n    }\n    fields\n}\n\npub fn raw_into_row(\n    fields: *mut bindings::TAOS_FIELD,\n    fcount: c_int,\n    raw_row: \u0026[*mut c_void],\n) -\u003e Row {\n    let mut row: Row = Vec::new();\n    let fields = raw_into_field(fields, fcount);\n\n    for (i, field) in fields.iter().enumerate() {\n        unsafe {\n            match field.type_ as u32 {\n                bindings::TSDB_DATA_TYPE_TINYINT =\u003e {\n                    row.push(Field::tinyInt(*(raw_row[i] as *mut i8)));\n                }\n                bindings::TSDB_DATA_TYPE_SMALLINT =\u003e {\n                    row.push(Field::smallInt(*(raw_row[i] as *mut i16)));\n                }\n                bindings::TSDB_DATA_TYPE_INT =\u003e {\n                    row.push(Field::normalInt(*(raw_row[i] as *mut i32)));\n                }\n                bindings::TSDB_DATA_TYPE_BIGINT | bindings::TSDB_DATA_TYPE_TIMESTAMP =\u003e {\n                    row.push(Field::bigInt(*(raw_row[i] as *mut i64)));\n                }\n                bindings::TSDB_DATA_TYPE_FLOAT =\u003e {\n                    row.push(Field::float(*(raw_row[i] as *mut f32)));\n                }\n                bindings::TSDB_DATA_TYPE_DOUBLE =\u003e {\n                    row.push(Field::double(*(raw_row[i] as *mut f64)));\n                }\n                bindings::TSDB_DATA_TYPE_NCHAR =\u003e {\n                    let a = CStr::from_ptr(raw_row[i] as *const c_char)\n                        .to_string_lossy()\n                        .into_owned();\n                    row.push(Field::string(a));\n                }\n                bindings::TSDB_DATA_TYPE_BOOL =\u003e {\n                    row.push(Field::boolType(*(raw_row[i] as *mut i8) != 0));\n                }\n                _ =\u003e println!(\"\"),\n            }\n        }\n    }\n    row\n}\n","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","serde.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    types::{Record, Value},\n    Reader, Writer,\n};\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse std::time::Duration;\n\nconst RAW_SMALL_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"test\",\n  \"type\": \"record\",\n  \"name\": \"Test\",\n  \"fields\": [\n    {\n      \"type\": {\n        \"type\": \"string\"\n      },\n      \"name\": \"field\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_BIG_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"my.example\",\n  \"type\": \"record\",\n  \"name\": \"userInfo\",\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"username\"\n    },\n    {\n      \"default\": -1,\n      \"type\": \"int\",\n      \"name\": \"age\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"phone\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"housenum\"\n    },\n    {\n      \"default\": {},\n      \"type\": {\n        \"fields\": [\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"street\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"city\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"state_prov\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"country\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"zip\"\n          }\n        ],\n        \"type\": \"record\",\n        \"name\": \"mailing_address\"\n      },\n      \"name\": \"address\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_ADDRESS_SCHEMA: \u0026str = r#\"\n{\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"street\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"city\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"state_prov\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"country\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"zip\"\n    }\n  ],\n  \"type\": \"record\",\n  \"name\": \"mailing_address\"\n}\n\"#;\n\nfn make_small_record() -\u003e (Schema, Value) {\n    let small_schema = Schema::parse_str(RAW_SMALL_SCHEMA).unwrap();\n    let small_record = {\n        let mut small_record = Record::new(\u0026small_schema).unwrap();\n        small_record.put(\"field\", \"foo\");\n        small_record.into()\n    };\n    (small_schema, small_record)\n}\n\nfn make_big_record() -\u003e (Schema, Value) {\n    let big_schema = Schema::parse_str(RAW_BIG_SCHEMA).unwrap();\n    let address_schema = Schema::parse_str(RAW_ADDRESS_SCHEMA).unwrap();\n    let mut address = Record::new(\u0026address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let big_record = {\n        let mut big_record = Record::new(\u0026big_schema).unwrap();\n        big_record.put(\"username\", \"username\");\n        big_record.put(\"age\", 10i32);\n        big_record.put(\"phone\", \"000000000\");\n        big_record.put(\"housenum\", \"0000\");\n        big_record.put(\"address\", address);\n        big_record.into()\n    };\n\n    (big_schema, big_record)\n}\n\nfn make_records(record: Value, count: usize) -\u003e Vec\u003cValue\u003e {\n    std::iter::repeat(record).take(count).collect()\n}\n\nfn write(schema: \u0026Schema, records: \u0026[Value]) -\u003e Vec\u003cu8\u003e {\n    let mut writer = Writer::new(schema, Vec::new());\n    writer.extend_from_slice(records).unwrap();\n    writer.into_inner().unwrap()\n}\n\nfn read(schema: \u0026Schema, bytes: \u0026[u8]) {\n    let reader = Reader::with_schema(schema, bytes).unwrap();\n\n    for record in reader {\n        let _ = record.unwrap();\n    }\n}\n\nfn read_schemaless(bytes: \u0026[u8]) {\n    let reader = Reader::new(bytes).unwrap();\n\n    for record in reader {\n        let _ = record.unwrap();\n    }\n}\n\nfn bench_write(\n    c: \u0026mut Criterion,\n    make_record: impl Fn() -\u003e (Schema, Value),\n    n_records: usize,\n    name: \u0026str,\n) {\n    let (schema, record) = make_record();\n    let records = make_records(record, n_records);\n    c.bench_function(name, |b| b.iter(|| write(\u0026schema, \u0026records)));\n}\n\nfn bench_read(\n    c: \u0026mut Criterion,\n    make_record: impl Fn() -\u003e (Schema, Value),\n    n_records: usize,\n    name: \u0026str,\n) {\n    let (schema, record) = make_record();\n    let records = make_records(record, n_records);\n    let bytes = write(\u0026schema, \u0026records);\n    c.bench_function(name, |b| b.iter(|| read(\u0026schema, \u0026bytes)));\n}\n\nfn bench_from_file(c: \u0026mut Criterion, file_path: \u0026str, name: \u0026str) {\n    let bytes = std::fs::read(file_path).unwrap();\n    c.bench_function(name, |b| b.iter(|| read_schemaless(\u0026bytes)));\n}\n\nfn bench_small_schema_write_1_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_small_record, 1, \"small schema, write 1 record\");\n}\n\nfn bench_small_schema_write_100_record(c: \u0026mut Criterion) {\n    bench_write(\n        c,\n        \u0026make_small_record,\n        100,\n        \"small schema, write 100 records\",\n    );\n}\n\nfn bench_small_schema_write_10_000_record(c: \u0026mut Criterion) {\n    bench_write(\n        c,\n        \u0026make_small_record,\n        10_000,\n        \"small schema, write 10k records\",\n    );\n}\n\nfn bench_small_schema_read_1_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_small_record, 1, \"small schema, read 1 record\");\n}\n\nfn bench_small_schema_read_100_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_small_record, 100, \"small schema, read 100 records\");\n}\n\nfn bench_small_schema_read_10_000_record(c: \u0026mut Criterion) {\n    bench_read(\n        c,\n        \u0026make_small_record,\n        10_000,\n        \"small schema, read 10k records\",\n    );\n}\n\nfn bench_big_schema_write_1_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_big_record, 1, \"big schema, write 1 record\");\n}\n\nfn bench_big_schema_write_100_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_big_record, 100, \"big schema, write 100 records\");\n}\n\nfn bench_big_schema_write_10_000_record(c: \u0026mut Criterion) {\n    bench_write(c, \u0026make_big_record, 10_000, \"big schema, write 10k records\");\n}\n\nfn bench_big_schema_read_1_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_big_record, 1, \"big schema, read 1 record\");\n}\n\nfn bench_big_schema_read_100_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_big_record, 100, \"big schema, read 100 records\");\n}\n\nfn bench_big_schema_read_10_000_record(c: \u0026mut Criterion) {\n    bench_read(c, \u0026make_big_record, 10_000, \"big schema, read 10k records\");\n}\n\nfn bench_big_schema_read_100_000_record(c: \u0026mut Criterion) {\n    bench_read(\n        c,\n        \u0026make_big_record,\n        100_000,\n        \"big schema, read 100k records\",\n    );\n}\n\n// This benchmark reads from the `benches/quickstop-null.avro` file, which was pulled from\n// the `goavro` project benchmarks:\n// https://github.com/linkedin/goavro/blob/master/fixtures/quickstop-null.avro\n// This was done for the sake of comparing this crate against the `goavro` implementation.\nfn bench_file_quickstop_null(c: \u0026mut Criterion) {\n    bench_from_file(c, \"benches/quickstop-null.avro\", \"quickstop null file\");\n}\n\ncriterion_group!(\n    benches,\n    bench_small_schema_write_1_record,\n    bench_small_schema_write_100_record,\n    bench_small_schema_read_1_record,\n    bench_small_schema_read_100_record,\n    bench_big_schema_write_1_record,\n    bench_big_schema_write_100_record,\n    bench_big_schema_read_1_record,\n    bench_big_schema_read_100_record,\n);\n\ncriterion_group!(\n    name = long_benches;\n    config = Criterion::default().sample_size(20).measurement_time(Duration::from_secs(10));\n    targets =\n        bench_file_quickstop_null,\n        bench_small_schema_write_10_000_record,\n        bench_small_schema_read_10_000_record,\n        bench_big_schema_read_10_000_record,\n        bench_big_schema_write_10_000_record\n);\n\ncriterion_group!(\n    name = very_long_benches;\n    config = Criterion::default().sample_size(10).measurement_time(Duration::from_secs(20));\n    targets =\n        bench_big_schema_read_100_000_record,\n);\n\ncriterion_main!(benches, long_benches, very_long_benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","serde_json.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse criterion::{criterion_group, criterion_main, Criterion};\nuse serde_json::Value;\nuse std::{collections::HashMap, iter::FromIterator};\n\nfn make_big_json_record() -\u003e Value {\n    let address = HashMap::\u003c_, _\u003e::from_iter(vec![\n        (\"street\", \"street\"),\n        (\"city\", \"city\"),\n        (\"state_prov\", \"state_prov\"),\n        (\"country\", \"country\"),\n        (\"zip\", \"zip\"),\n    ]);\n    let address_json = serde_json::to_value(address).unwrap();\n    let big_record = HashMap::\u003c_, _\u003e::from_iter(vec![\n        (\"username\", serde_json::to_value(\"username\").unwrap()),\n        (\"age\", serde_json::to_value(10i32).unwrap()),\n        (\"phone\", serde_json::to_value(\"000000000\").unwrap()),\n        (\"housenum\", serde_json::to_value(\"0000\").unwrap()),\n        (\"address\", address_json),\n    ]);\n    serde_json::to_value(big_record).unwrap()\n}\n\nfn write_json(records: \u0026[Value]) -\u003e Vec\u003cu8\u003e {\n    serde_json::to_vec(records).unwrap()\n}\n\nfn read_json(bytes: \u0026[u8]) {\n    let reader: serde_json::Value = serde_json::from_slice(bytes).unwrap();\n    for record in reader.as_array().unwrap() {\n        let _ = record;\n    }\n}\n\nfn bench_read_json(\n    c: \u0026mut Criterion,\n    make_record: impl Fn() -\u003e Value,\n    n_records: usize,\n    name: \u0026str,\n) {\n    let records = std::iter::repeat(make_record())\n        .take(n_records)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    let bytes = write_json(\u0026records);\n    c.bench_function(name, |b| b.iter(|| read_json(\u0026bytes)));\n}\n\nfn bench_big_schema_json_read_10_000_record(c: \u0026mut Criterion) {\n    bench_read_json(\n        c,\n        \u0026make_big_json_record,\n        10_000,\n        \"big schema, read 10k JSON records\",\n    );\n}\n\ncriterion_group!(\n    name = benches;\n    config = Criterion::default().sample_size(10);\n    targets = bench_big_schema_json_read_10_000_record,\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","benches","single.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    to_avro_datum,\n    types::{Record, Value},\n};\nuse criterion::{criterion_group, criterion_main, Criterion};\n\nconst RAW_SMALL_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"test\",\n  \"type\": \"record\",\n  \"name\": \"Test\",\n  \"fields\": [\n    {\n      \"type\": {\n        \"type\": \"string\"\n      },\n      \"name\": \"field\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_BIG_SCHEMA: \u0026str = r#\"\n{\n  \"namespace\": \"my.example\",\n  \"type\": \"record\",\n  \"name\": \"userInfo\",\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"username\"\n    },\n    {\n      \"default\": -1,\n      \"type\": \"int\",\n      \"name\": \"age\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"phone\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"housenum\"\n    },\n    {\n      \"default\": {},\n      \"type\": {\n        \"fields\": [\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"street\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"city\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"state_prov\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"country\"\n          },\n          {\n            \"default\": \"NONE\",\n            \"type\": \"string\",\n            \"name\": \"zip\"\n          }\n        ],\n        \"type\": \"record\",\n        \"name\": \"mailing_address\"\n      },\n      \"name\": \"address\"\n    }\n  ]\n}\n\"#;\n\nconst RAW_ADDRESS_SCHEMA: \u0026str = r#\"\n{\n  \"fields\": [\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"street\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"city\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"state_prov\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"country\"\n    },\n    {\n      \"default\": \"NONE\",\n      \"type\": \"string\",\n      \"name\": \"zip\"\n    }\n  ],\n  \"type\": \"record\",\n  \"name\": \"mailing_address\"\n}\n\"#;\n\nfn make_small_record() -\u003e (Schema, Value) {\n    let small_schema = Schema::parse_str(RAW_SMALL_SCHEMA).unwrap();\n    let small_record = {\n        let mut small_record = Record::new(\u0026small_schema).unwrap();\n        small_record.put(\"field\", \"foo\");\n        small_record.into()\n    };\n\n    (small_schema, small_record)\n}\n\nfn make_big_record() -\u003e (Schema, Value) {\n    let big_schema = Schema::parse_str(RAW_BIG_SCHEMA).unwrap();\n    let address_schema = Schema::parse_str(RAW_ADDRESS_SCHEMA).unwrap();\n    let mut address = Record::new(\u0026address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let big_record = {\n        let mut big_record = Record::new(\u0026big_schema).unwrap();\n        big_record.put(\"username\", \"username\");\n        big_record.put(\"age\", 10i32);\n        big_record.put(\"phone\", \"000000000\");\n        big_record.put(\"housenum\", \"0000\");\n        big_record.put(\"address\", address);\n        big_record.into()\n    };\n\n    (big_schema, big_record)\n}\n\nfn bench_small_schema_write_record(c: \u0026mut Criterion) {\n    let (schema, record) = make_small_record();\n    c.bench_function(\"small record\", |b| {\n        b.iter(|| to_avro_datum(\u0026schema, record.clone()))\n    });\n}\n\nfn bench_big_schema_write_record(c: \u0026mut Criterion) {\n    let (schema, record) = make_big_record();\n    c.bench_function(\"big record\", |b| {\n        b.iter(|| to_avro_datum(\u0026schema, record.clone()))\n    });\n}\n\ncriterion_group!(\n    benches,\n    bench_small_schema_write_record,\n    bench_big_schema_write_record\n);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","examples","benchmark.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse avro_rs::{\n    schema::Schema,\n    types::{Record, Value},\n    Reader, Writer,\n};\nuse std::time::{Duration, Instant};\n\nfn nanos(duration: Duration) -\u003e u64 {\n    duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64\n}\n\nfn seconds(nanos: u64) -\u003e f64 {\n    (nanos as f64) / 1_000_000_000f64\n}\n\n/*\nfn duration(nanos: u64) -\u003e Duration {\n    Duration::new(nanos / 1_000_000_000, (nanos % 1_000_000_000) as u32)\n}\n*/\n\nfn benchmark(schema: \u0026Schema, record: \u0026Value, s: \u0026str, count: usize, runs: usize) {\n    let mut records = Vec::new();\n    for __ in 0..count {\n        records.push(record.clone());\n    }\n\n    let mut durations = Vec::with_capacity(runs);\n\n    let mut bytes = None;\n    for _ in 0..runs {\n        let records = records.clone();\n\n        let start = Instant::now();\n        let mut writer = Writer::new(schema, Vec::new());\n        writer.extend(records.into_iter()).unwrap();\n\n        let duration = Instant::now().duration_since(start);\n        durations.push(duration);\n\n        bytes = Some(writer.into_inner().unwrap());\n    }\n\n    let total_duration_write = durations.into_iter().fold(0u64, |a, b| a + nanos(b));\n\n    // println!(\"Write: {} {} {:?}\", count, runs, seconds(total_duration));\n\n    let bytes = bytes.unwrap();\n\n    let mut durations = Vec::with_capacity(runs);\n\n    for _ in 0..runs {\n        let start = Instant::now();\n        let reader = Reader::with_schema(schema, \u0026bytes[..]).unwrap();\n\n        let mut read_records = Vec::with_capacity(count);\n        for record in reader {\n            read_records.push(record);\n        }\n\n        let duration = Instant::now().duration_since(start);\n        durations.push(duration);\n\n        assert_eq!(count, read_records.len());\n    }\n\n    let total_duration_read = durations.into_iter().fold(0u64, |a, b| a + nanos(b));\n\n    // println!(\"Read: {} {} {:?}\", count, runs, seconds(total_duration));\n    let (s_w, s_r) = (seconds(total_duration_write), seconds(total_duration_read));\n\n    println!(\"{},{},{},{},{}\", count, runs, s, s_w, s_r);\n}\n\nfn main() {\n    let raw_small_schema = r#\"\n        {\"namespace\": \"test\", \"type\": \"record\", \"name\": \"Test\", \"fields\": [{\"type\": {\"type\": \"string\"}, \"name\": \"field\"}]}\n    \"#;\n\n    let raw_big_schema = r#\"\n        {\"namespace\": \"my.example\", \"type\": \"record\", \"name\": \"userInfo\", \"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"username\"}, {\"default\": -1, \"type\": \"int\", \"name\": \"age\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"phone\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"housenum\"}, {\"default\": {}, \"type\": {\"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"street\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"city\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"state_prov\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"country\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"zip\"}], \"type\": \"record\", \"name\": \"mailing_address\"}, \"name\": \"address\"}]}\n    \"#;\n\n    let small_schema = Schema::parse_str(raw_small_schema).unwrap();\n    let big_schema = Schema::parse_str(raw_big_schema).unwrap();\n\n    println!(\"{:?}\", small_schema);\n    println!(\"{:?}\", big_schema);\n\n    let mut small_record = Record::new(\u0026small_schema).unwrap();\n    small_record.put(\"field\", \"foo\");\n    let small_record = small_record.into();\n\n    let raw_address_schema = r#\"{\"fields\": [{\"default\": \"NONE\", \"type\": \"string\", \"name\": \"street\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"city\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"state_prov\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"country\"}, {\"default\": \"NONE\", \"type\": \"string\", \"name\": \"zip\"}], \"type\": \"record\", \"name\": \"mailing_address\"}\"#;\n    let address_schema = Schema::parse_str(raw_address_schema).unwrap();\n    let mut address = Record::new(\u0026address_schema).unwrap();\n    address.put(\"street\", \"street\");\n    address.put(\"city\", \"city\");\n    address.put(\"state_prov\", \"state_prov\");\n    address.put(\"country\", \"country\");\n    address.put(\"zip\", \"zip\");\n\n    let mut big_record = Record::new(\u0026big_schema).unwrap();\n    big_record.put(\"username\", \"username\");\n    big_record.put(\"age\", 10i32);\n    big_record.put(\"phone\", \"000000000\");\n    big_record.put(\"housenum\", \"0000\");\n    big_record.put(\"address\", address);\n    let big_record = big_record.into();\n\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 10_000, 1);\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 10_000, 1);\n\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 1, 100_000);\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 100, 1000);\n    benchmark(\u0026small_schema, \u0026small_record, \"S\", 10_000, 10);\n\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 1, 100_000);\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 100, 1000);\n    benchmark(\u0026big_schema, \u0026big_record, \"B\", 10_000, 10);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","examples","to_value.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n#[derive(Debug, serde::Serialize)]\nstruct Test {\n    a: i64,\n    b: \u0026'static str,\n}\n\nfn main() -\u003e anyhow::Result\u003c()\u003e {\n    let test = Test { a: 27, b: \"foo\" };\n    let value = avro_rs::to_value(test)?;\n    println!(\"{:?}\", value);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","codec.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for all supported compression codecs in Avro.\nuse crate::{types::Value, AvroResult, Error};\nuse libflate::deflate::{Decoder, Encoder};\nuse std::io::{Read, Write};\nuse strum_macros::{EnumString, IntoStaticStr};\n\n/// The compression codec used to compress blocks.\n#[derive(Clone, Copy, Debug, PartialEq, EnumString, IntoStaticStr)]\n#[strum(serialize_all = \"kebab_case\")]\npub enum Codec {\n    /// The `Null` codec simply passes through data uncompressed.\n    Null,\n    /// The `Deflate` codec writes the data block using the deflate algorithm\n    /// as specified in RFC 1951, and typically implemented using the zlib library.\n    /// Note that this format (unlike the \"zlib format\" in RFC 1950) does not have a checksum.\n    Deflate,\n    #[cfg(feature = \"snappy\")]\n    /// The `Snappy` codec uses Google's [Snappy](http://google.github.io/snappy/)\n    /// compression library. Each compressed block is followed by the 4-byte, big-endian\n    /// CRC32 checksum of the uncompressed data in the block.\n    Snappy,\n}\n\nimpl From\u003cCodec\u003e for Value {\n    fn from(value: Codec) -\u003e Self {\n        Self::Bytes(\u003c\u0026str\u003e::from(value).as_bytes().to_vec())\n    }\n}\n\nimpl Codec {\n    /// Compress a stream of bytes in-place.\n    pub fn compress(self, stream: \u0026mut Vec\u003cu8\u003e) -\u003e AvroResult\u003c()\u003e {\n        match self {\n            Codec::Null =\u003e (),\n            Codec::Deflate =\u003e {\n                let mut encoder = Encoder::new(Vec::new());\n                encoder.write_all(stream).map_err(Error::DeflateCompress)?;\n                // Deflate errors seem to just be io::Error\n                *stream = encoder\n                    .finish()\n                    .into_result()\n                    .map_err(Error::DeflateCompressFinish)?;\n            }\n            #[cfg(feature = \"snappy\")]\n            Codec::Snappy =\u003e {\n                use byteorder::ByteOrder;\n\n                let mut encoded: Vec\u003cu8\u003e = vec![0; snap::raw::max_compress_len(stream.len())];\n                let compressed_size = snap::raw::Encoder::new()\n                    .compress(\u0026stream[..], \u0026mut encoded[..])\n                    .map_err(Error::SnappyCompress)?;\n\n                let crc = crc::crc32::checksum_ieee(\u0026stream[..]);\n                byteorder::BigEndian::write_u32(\u0026mut encoded[compressed_size..], crc);\n                encoded.truncate(compressed_size + 4);\n\n                *stream = encoded;\n            }\n        };\n\n        Ok(())\n    }\n\n    /// Decompress a stream of bytes in-place.\n    pub fn decompress(self, stream: \u0026mut Vec\u003cu8\u003e) -\u003e AvroResult\u003c()\u003e {\n        *stream = match self {\n            Codec::Null =\u003e return Ok(()),\n            Codec::Deflate =\u003e {\n                let mut decoded = Vec::new();\n                let mut decoder = Decoder::new(\u0026stream[..]);\n                decoder\n                    .read_to_end(\u0026mut decoded)\n                    .map_err(Error::DeflateDecompress)?;\n                decoded\n            }\n            #[cfg(feature = \"snappy\")]\n            Codec::Snappy =\u003e {\n                use byteorder::ByteOrder;\n\n                let decompressed_size = snap::raw::decompress_len(\u0026stream[..stream.len() - 4])\n                    .map_err(Error::GetSnappyDecompressLen)?;\n                let mut decoded = vec![0; decompressed_size];\n                snap::raw::Decoder::new()\n                    .decompress(\u0026stream[..stream.len() - 4], \u0026mut decoded[..])\n                    .map_err(Error::SnappyDecompress)?;\n\n                let expected = byteorder::BigEndian::read_u32(\u0026stream[stream.len() - 4..]);\n                let actual = crc::crc32::checksum_ieee(\u0026decoded);\n\n                if expected != actual {\n                    return Err(Error::SnappyCrc32 { expected, actual });\n                }\n                decoded\n            }\n        };\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    const INPUT: \u0026[u8] = b\"theanswertolifetheuniverseandeverythingis42theanswertolifetheuniverseandeverythingis4theanswertolifetheuniverseandeverythingis2\";\n\n    #[test]\n    fn null_compress_and_decompress() {\n        let codec = Codec::Null;\n        let mut stream = INPUT.to_vec();\n        codec.compress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n        codec.decompress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[test]\n    fn deflate_compress_and_decompress() {\n        let codec = Codec::Deflate;\n        let mut stream = INPUT.to_vec();\n        codec.compress(\u0026mut stream).unwrap();\n        assert_ne!(INPUT, stream.as_slice());\n        assert!(INPUT.len() \u003e stream.len());\n        codec.decompress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[cfg(feature = \"snappy\")]\n    #[test]\n    fn snappy_compress_and_decompress() {\n        let codec = Codec::Snappy;\n        let mut stream = INPUT.to_vec();\n        codec.compress(\u0026mut stream).unwrap();\n        assert_ne!(INPUT, stream.as_slice());\n        assert!(INPUT.len() \u003e stream.len());\n        codec.decompress(\u0026mut stream).unwrap();\n        assert_eq!(INPUT, stream.as_slice());\n    }\n\n    #[test]\n    fn codec_to_str() {\n        assert_eq!(\u003c\u0026str\u003e::from(Codec::Null), \"null\");\n        assert_eq!(\u003c\u0026str\u003e::from(Codec::Deflate), \"deflate\");\n\n        #[cfg(feature = \"snappy\")]\n        assert_eq!(\u003c\u0026str\u003e::from(Codec::Snappy), \"snappy\");\n    }\n\n    #[test]\n    fn codec_from_str() {\n        use std::str::FromStr;\n\n        assert_eq!(Codec::from_str(\"null\").unwrap(), Codec::Null);\n        assert_eq!(Codec::from_str(\"deflate\").unwrap(), Codec::Deflate);\n\n        #[cfg(feature = \"snappy\")]\n        assert_eq!(Codec::from_str(\"snappy\").unwrap(), Codec::Snappy);\n\n        assert!(Codec::from_str(\"not a codec\").is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","de.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for serde-compatible deserialization.\nuse crate::{types::Value, Error};\nuse serde::{\n    de::{self, DeserializeSeed, Visitor},\n    forward_to_deserialize_any, Deserialize,\n};\nuse std::{\n    collections::{\n        hash_map::{Keys, Values},\n        HashMap,\n    },\n    slice::Iter,\n};\n\npub struct Deserializer\u003c'de\u003e {\n    input: \u0026'de Value,\n}\n\nstruct SeqDeserializer\u003c'de\u003e {\n    input: Iter\u003c'de, Value\u003e,\n}\n\nstruct MapDeserializer\u003c'de\u003e {\n    input_keys: Keys\u003c'de, String, Value\u003e,\n    input_values: Values\u003c'de, String, Value\u003e,\n}\n\nstruct StructDeserializer\u003c'de\u003e {\n    input: Iter\u003c'de, (String, Value)\u003e,\n    value: Option\u003c\u0026'de Value\u003e,\n}\n\npub struct EnumUnitDeserializer\u003c'a\u003e {\n    input: \u0026'a str,\n}\n\npub struct EnumDeserializer\u003c'de\u003e {\n    input: \u0026'de [(String, Value)],\n}\n\nimpl\u003c'de\u003e Deserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de Value) -\u003e Self {\n        Deserializer { input }\n    }\n}\n\nimpl\u003c'de\u003e SeqDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de [Value]) -\u003e Self {\n        SeqDeserializer {\n            input: input.iter(),\n        }\n    }\n}\n\nimpl\u003c'de\u003e MapDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de HashMap\u003cString, Value\u003e) -\u003e Self {\n        MapDeserializer {\n            input_keys: input.keys(), // input.keys().map(|k| Value::String(k.clone())).collect::\u003cVec\u003c_\u003e\u003e().iter(),\n            input_values: input.values(),\n            // keys: input.keys().map(|s| Value::String(s.to_owned())).collect::\u003cVec\u003cValue\u003e\u003e(),\n            // values: input.values().map(|s| s.to_owned()).collect::\u003cVec\u003cValue\u003e\u003e(),\n        }\n    }\n}\n\nimpl\u003c'de\u003e StructDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de [(String, Value)]) -\u003e Self {\n        StructDeserializer {\n            input: input.iter(),\n            value: None,\n        }\n    }\n}\n\nimpl\u003c'a\u003e EnumUnitDeserializer\u003c'a\u003e {\n    pub fn new(input: \u0026'a str) -\u003e Self {\n        EnumUnitDeserializer { input }\n    }\n}\n\nimpl\u003c'de\u003e EnumDeserializer\u003c'de\u003e {\n    pub fn new(input: \u0026'de [(String, Value)]) -\u003e Self {\n        EnumDeserializer { input }\n    }\n}\n\nimpl\u003c'de\u003e de::EnumAccess\u003c'de\u003e for EnumUnitDeserializer\u003c'de\u003e {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: self.input.to_owned(),\n            })?,\n            self,\n        ))\n    }\n}\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for EnumUnitDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"Unexpected Newtype variant\"))\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"Unexpected tuple variant\"))\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"Unexpected struct variant\"))\n    }\n}\n\nimpl\u003c'de\u003e de::EnumAccess\u003c'de\u003e for EnumDeserializer\u003c'de\u003e {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        self.input.first().map_or(\n            Err(de::Error::custom(\"A record must have a least one field\")),\n            |item| match (item.0.as_ref(), \u0026item.1) {\n                (\"type\", Value::String(x)) =\u003e Ok((\n                    seed.deserialize(StringDeserializer {\n                        input: x.to_owned(),\n                    })?,\n                    self,\n                )),\n                (field, Value::String(_)) =\u003e Err(de::Error::custom(format!(\n                    \"Expected first field named 'type': got '{}' instead\",\n                    field\n                ))),\n                (_, _) =\u003e Err(de::Error::custom(\n                    \"Expected first field of type String for the type name\".to_string(),\n                )),\n            },\n        )\n    }\n}\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for EnumDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\n                \"Expected a newtype variant, got nothing instead.\",\n            )),\n            |item| seed.deserialize(\u0026Deserializer::new(\u0026item.1)),\n        )\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\n                \"Expected a tuple variant, got nothing instead.\",\n            )),\n            |item| de::Deserializer::deserialize_seq(\u0026Deserializer::new(\u0026item.1), visitor),\n        )\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.input.get(1).map_or(\n            Err(de::Error::custom(\"Expected a struct variant, got nothing\")),\n            |item| {\n                de::Deserializer::deserialize_struct(\n                    \u0026Deserializer::new(\u0026item.1),\n                    \"\",\n                    fields,\n                    visitor,\n                )\n            },\n        )\n    }\n}\n\nimpl\u003c'a, 'de\u003e de::Deserializer\u003c'de\u003e for \u0026'a Deserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.input {\n            Value::Null =\u003e visitor.visit_unit(),\n            \u0026Value::Boolean(b) =\u003e visitor.visit_bool(b),\n            Value::Int(i) | Value::Date(i) | Value::TimeMillis(i) =\u003e visitor.visit_i32(*i),\n            Value::Long(i)\n            | Value::TimeMicros(i)\n            | Value::TimestampMillis(i)\n            | Value::TimestampMicros(i) =\u003e visitor.visit_i64(*i),\n            \u0026Value::Float(f) =\u003e visitor.visit_f32(f),\n            \u0026Value::Double(d) =\u003e visitor.visit_f64(d),\n            Value::Union(u) =\u003e match **u {\n                Value::Null =\u003e visitor.visit_unit(),\n                Value::Boolean(b) =\u003e visitor.visit_bool(b),\n                Value::Int(i) =\u003e visitor.visit_i32(i),\n                Value::Long(i) =\u003e visitor.visit_i64(i),\n                Value::Float(f) =\u003e visitor.visit_f32(f),\n                Value::Double(d) =\u003e visitor.visit_f64(d),\n                _ =\u003e Err(de::Error::custom(\"Unsupported union\")),\n            },\n            Value::Record(ref fields) =\u003e visitor.visit_map(StructDeserializer::new(fields)),\n            Value::Array(ref fields) =\u003e visitor.visit_seq(SeqDeserializer::new(fields)),\n            value =\u003e Err(de::Error::custom(format!(\n                \"incorrect value of type: {:?}\",\n                crate::schema::SchemaKind::from(value)\n            ))),\n        }\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64\n    }\n\n    fn deserialize_char\u003cV\u003e(self, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::custom(\"avro does not support char\"))\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_str(s),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e ::std::str::from_utf8(bytes)\n                .map_err(|e| de::Error::custom(e.to_string()))\n                .and_then(|s| visitor.visit_str(s)),\n            Value::Uuid(ref u) =\u003e visitor.visit_str(\u0026u.to_string()),\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_string(s.to_owned()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e {\n                String::from_utf8(bytes.to_owned())\n                    .map_err(|e| de::Error::custom(e.to_string()))\n                    .and_then(|s| visitor.visit_string(s))\n            }\n            Value::Union(ref x) =\u003e match **x {\n                Value::String(ref s) =\u003e visitor.visit_string(s.to_owned()),\n                _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n            },\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_bytes(s.as_bytes()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e visitor.visit_bytes(bytes),\n            Value::Uuid(ref u) =\u003e visitor.visit_bytes(u.as_bytes()),\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::String(ref s) =\u003e visitor.visit_byte_buf(s.clone().into_bytes()),\n            Value::Bytes(ref bytes) | Value::Fixed(_, ref bytes) =\u003e {\n                visitor.visit_byte_buf(bytes.to_owned())\n            }\n            _ =\u003e Err(de::Error::custom(\"not a string|bytes|fixed\")),\n        }\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Union(ref inner) if inner.as_ref() == \u0026Value::Null =\u003e visitor.visit_none(),\n            Value::Union(ref inner) =\u003e visitor.visit_some(\u0026Deserializer::new(inner)),\n            _ =\u003e Err(de::Error::custom(\"not a union\")),\n        }\n    }\n\n    fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Null =\u003e visitor.visit_unit(),\n            _ =\u003e Err(de::Error::custom(\"not a null\")),\n        }\n    }\n\n    fn deserialize_unit_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Array(ref items) =\u003e visitor.visit_seq(SeqDeserializer::new(items)),\n            Value::Union(ref inner) =\u003e match **inner {\n                Value::Array(ref items) =\u003e visitor.visit_seq(SeqDeserializer::new(items)),\n                _ =\u003e Err(de::Error::custom(\"not an array\")),\n            },\n            _ =\u003e Err(de::Error::custom(\"not an array\")),\n        }\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, _: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        _: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Map(ref items) =\u003e visitor.visit_map(MapDeserializer::new(items)),\n            _ =\u003e Err(de::Error::custom(\"not a map\")),\n        }\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        _: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            Value::Record(ref fields) =\u003e visitor.visit_map(StructDeserializer::new(fields)),\n            Value::Union(ref inner) =\u003e match **inner {\n                Value::Record(ref fields) =\u003e visitor.visit_map(StructDeserializer::new(fields)),\n                _ =\u003e Err(de::Error::custom(\"not a record\")),\n            },\n            _ =\u003e Err(de::Error::custom(\"not a record\")),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        _variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match *self.input {\n            // This branch can be anything...\n            Value::Record(ref fields) =\u003e visitor.visit_enum(EnumDeserializer::new(fields)),\n            // This has to be a unit Enum\n            Value::Enum(_index, ref field) =\u003e visitor.visit_enum(EnumUnitDeserializer::new(field)),\n            _ =\u003e Err(de::Error::custom(\"not an enum\")),\n        }\n    }\n\n    fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_any(visitor)\n    }\n}\n\nimpl\u003c'de\u003e de::SeqAccess\u003c'de\u003e for SeqDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input.next() {\n            Some(item) =\u003e seed.deserialize(\u0026Deserializer::new(item)).map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n}\n\nimpl\u003c'de\u003e de::MapAccess\u003c'de\u003e for MapDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input_keys.next() {\n            Some(key) =\u003e seed\n                .deserialize(StringDeserializer {\n                    input: (*key).clone(),\n                })\n                .map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input_values.next() {\n            Some(value) =\u003e seed.deserialize(\u0026Deserializer::new(value)),\n            None =\u003e Err(de::Error::custom(\"should not happen - too many values\")),\n        }\n    }\n}\n\nimpl\u003c'de\u003e de::MapAccess\u003c'de\u003e for StructDeserializer\u003c'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.input.next() {\n            Some(item) =\u003e {\n                let (ref field, ref value) = *item;\n                self.value = Some(value);\n                seed.deserialize(StringDeserializer {\n                    input: field.clone(),\n                })\n                .map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.value.take() {\n            Some(value) =\u003e seed.deserialize(\u0026Deserializer::new(value)),\n            None =\u003e Err(de::Error::custom(\"should not happen - too many values\")),\n        }\n    }\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\n\n/// Interpret a `Value` as an instance of type `D`.\n///\n/// This conversion can fail if the structure of the `Value` does not match the\n/// structure expected by `D`.\npub fn from_value\u003c'de, D: Deserialize\u003c'de\u003e\u003e(value: \u0026'de Value) -\u003e Result\u003cD, Error\u003e {\n    let de = Deserializer::new(value);\n    D::deserialize(\u0026de)\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::Serialize;\n    use uuid::Uuid;\n\n    use super::*;\n\n    #[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]\n    struct Test {\n        a: i64,\n        b: String,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestInner {\n        a: Test,\n        b: i32,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitExternalEnum {\n        a: UnitExternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    enum UnitExternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitInternalEnum {\n        a: UnitInternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(tag = \"t\")]\n    enum UnitInternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitAdjacentEnum {\n        a: UnitAdjacentEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum UnitAdjacentEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    struct TestUnitUntaggedEnum {\n        a: UnitUntaggedEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize, PartialEq)]\n    #[serde(untagged)]\n    enum UnitUntaggedEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestSingleValueExternalEnum {\n        a: SingleValueExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum SingleValueExternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestStructExternalEnum {\n        a: StructExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum StructExternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    struct TestTupleExternalEnum {\n        a: TupleExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize, PartialEq)]\n    enum TupleExternalEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[test]\n    fn test_from_value() {\n        let test = Value::Record(vec![\n            (\"a\".to_owned(), Value::Long(27)),\n            (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n        ]);\n        let expected = Test {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let final_value: Test = from_value(\u0026test).unwrap();\n        assert_eq!(final_value, expected);\n\n        let test_inner = Value::Record(vec![\n            (\n                \"a\".to_owned(),\n                Value::Record(vec![\n                    (\"a\".to_owned(), Value::Long(27)),\n                    (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n                ]),\n            ),\n            (\"b\".to_owned(), Value::Int(35)),\n        ]);\n\n        let expected_inner = TestInner { a: expected, b: 35 };\n        let final_value: TestInner = from_value(\u0026test_inner).unwrap();\n        assert_eq!(final_value, expected_inner)\n    }\n    #[test]\n    fn test_from_value_unit_enum() {\n        let expected = TestUnitExternalEnum {\n            a: UnitExternalEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\"a\".to_owned(), Value::Enum(0, \"Val1\".to_owned()))]);\n        let final_value: TestUnitExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit external enum\"\n        );\n\n        let expected = TestUnitInternalEnum {\n            a: UnitInternalEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n        let final_value: TestUnitInternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit internal enum\"\n        );\n        let expected = TestUnitAdjacentEnum {\n            a: UnitAdjacentEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n        let final_value: TestUnitAdjacentEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit adjacent enum\"\n        );\n        let expected = TestUnitUntaggedEnum {\n            a: UnitUntaggedEnum::Val1,\n        };\n\n        let test = Value::Record(vec![(\"a\".to_owned(), Value::Null)]);\n        let final_value: TestUnitUntaggedEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing unit untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_single_value_enum() {\n        let expected = TestSingleValueExternalEnum {\n            a: SingleValueExternalEnum::Double(64.0),\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Double\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Double(64.0))),\n                ),\n            ]),\n        )]);\n        let final_value: TestSingleValueExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"Error deserializing single value external enum(union)\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_struct_enum() {\n        let expected = TestStructExternalEnum {\n            a: StructExternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]))),\n                ),\n            ]),\n        )]);\n        let final_value: TestStructExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"error deserializing struct external enum(union)\"\n        );\n    }\n\n    #[test]\n    fn test_from_value_tuple_enum() {\n        let expected = TestTupleExternalEnum {\n            a: TupleExternalEnum::Val1(1.0, 2.0),\n        };\n\n        let test = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Array(vec![\n                        Value::Float(1.0),\n                        Value::Float(2.0),\n                    ]))),\n                ),\n            ]),\n        )]);\n        let final_value: TestTupleExternalEnum = from_value(\u0026test).unwrap();\n        assert_eq!(\n            final_value, expected,\n            \"error serializing tuple external enum(union)\"\n        );\n    }\n\n    type TestResult\u003cT\u003e = Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n    #[test]\n    fn test_date() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::Date(raw_value);\n        let result = crate::from_value::\u003ci32\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_time_millis() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimeMillis(raw_value);\n        let result = crate::from_value::\u003ci32\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_time_micros() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimeMicros(raw_value);\n        let result = crate::from_value::\u003ci64\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_timestamp_millis() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimestampMillis(raw_value);\n        let result = crate::from_value::\u003ci64\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_timestamp_micros() -\u003e TestResult\u003c()\u003e {\n        let raw_value = 1;\n        let value = Value::TimestampMicros(raw_value);\n        let result = crate::from_value::\u003ci64\u003e(\u0026value)?;\n        assert_eq!(result, raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_from_value_uuid_str() -\u003e TestResult\u003c()\u003e {\n        let raw_value = \"9ec535ff-3e2a-45bd-91d3-0a01321b5a49\";\n        let value = Value::Uuid(Uuid::parse_str(raw_value).unwrap());\n        let result = crate::from_value::\u003cUuid\u003e(\u0026value)?;\n        assert_eq!(result.to_string(), raw_value);\n        Ok(())\n    }\n\n    #[test]\n    fn test_from_value_uuid_slice() -\u003e TestResult\u003c()\u003e {\n        let raw_value = \u0026[4, 54, 67, 12, 43, 2, 2, 76, 32, 50, 87, 5, 1, 33, 43, 87];\n        let value = Value::Uuid(Uuid::from_slice(raw_value)?);\n        let result = crate::from_value::\u003cUuid\u003e(\u0026value)?;\n        assert_eq!(result.as_bytes(), raw_value);\n        Ok(())\n    }\n}\n","traces":[{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":158},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","decimal.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{AvroResult, Error};\nuse num_bigint::{BigInt, Sign};\n\n#[derive(Debug, Clone)]\npub struct Decimal {\n    value: BigInt,\n    len: usize,\n}\n\n// We only care about value equality, not byte length. Can two equal `BigInt`s have two different\n// byte lengths?\nimpl PartialEq for Decimal {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.value == other.value\n    }\n}\n\nimpl Decimal {\n    pub(crate) fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    fn to_vec(\u0026self) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        self.to_sign_extended_bytes_with_len(self.len)\n    }\n\n    pub(crate) fn to_sign_extended_bytes_with_len(\u0026self, len: usize) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n        let sign_byte = 0xFF * u8::from(self.value.sign() == Sign::Minus);\n        let mut decimal_bytes = vec![sign_byte; len];\n        let raw_bytes = self.value.to_signed_bytes_be();\n        let num_raw_bytes = raw_bytes.len();\n        let start_byte_index = len.checked_sub(num_raw_bytes).ok_or(Error::SignExtend {\n            requested: len,\n            needed: num_raw_bytes,\n        })?;\n        decimal_bytes[start_byte_index..].copy_from_slice(\u0026raw_bytes);\n        Ok(decimal_bytes)\n    }\n}\n\nimpl std::convert::TryFrom\u003c\u0026Decimal\u003e for Vec\u003cu8\u003e {\n    type Error = Error;\n\n    fn try_from(decimal: \u0026Decimal) -\u003e Result\u003cSelf, Self::Error\u003e {\n        decimal.to_vec()\n    }\n}\n\nimpl\u003cT: AsRef\u003c[u8]\u003e\u003e From\u003cT\u003e for Decimal {\n    fn from(bytes: T) -\u003e Self {\n        let bytes_ref = bytes.as_ref();\n        Self {\n            value: BigInt::from_signed_bytes_be(bytes_ref),\n            len: bytes_ref.len(),\n        }\n    }\n}\n","traces":[{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","decode.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{\n    decimal::Decimal,\n    duration::Duration,\n    schema::Schema,\n    types::Value,\n    util::{safe_len, zag_i32, zag_i64},\n    AvroResult, Error,\n};\nuse std::{collections::HashMap, convert::TryFrom, io::Read, str::FromStr};\nuse uuid::Uuid;\n\n#[inline]\nfn decode_long\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cValue\u003e {\n    zag_i64(reader).map(Value::Long)\n}\n\n#[inline]\nfn decode_int\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cValue\u003e {\n    zag_i32(reader).map(Value::Int)\n}\n\n#[inline]\nfn decode_len\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cusize\u003e {\n    let len = zag_i64(reader)?;\n    safe_len(usize::try_from(len).map_err(|e| Error::ConvertI64ToUsize(e, len))?)\n}\n\n/// Decode the length of a sequence.\n///\n/// Maps and arrays are 0-terminated, 0i64 is also encoded as 0 in Avro reading a length of 0 means\n/// the end of the map or array.\nfn decode_seq_len\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cusize\u003e {\n    let raw_len = zag_i64(reader)?;\n    safe_len(\n        usize::try_from(match raw_len.cmp(\u00260) {\n            std::cmp::Ordering::Equal =\u003e return Ok(0),\n            std::cmp::Ordering::Less =\u003e {\n                let _size = zag_i64(reader)?;\n                -raw_len\n            }\n            std::cmp::Ordering::Greater =\u003e raw_len,\n        })\n        .map_err(|e| Error::ConvertI64ToUsize(e, raw_len))?,\n    )\n}\n\n/// Decode a `Value` from avro format given its `Schema`.\npub fn decode\u003cR: Read\u003e(schema: \u0026Schema, reader: \u0026mut R) -\u003e AvroResult\u003cValue\u003e {\n    match *schema {\n        Schema::Null =\u003e Ok(Value::Null),\n        Schema::Boolean =\u003e {\n            let mut buf = [0u8; 1];\n            reader\n                .read_exact(\u0026mut buf[..])\n                .map_err(Error::ReadBoolean)?;\n\n            match buf[0] {\n                0u8 =\u003e Ok(Value::Boolean(false)),\n                1u8 =\u003e Ok(Value::Boolean(true)),\n                _ =\u003e Err(Error::BoolValue(buf[0])),\n            }\n        }\n        Schema::Decimal { ref inner, .. } =\u003e match \u0026**inner {\n            Schema::Fixed { .. } =\u003e match decode(inner, reader)? {\n                Value::Fixed(_, bytes) =\u003e Ok(Value::Decimal(Decimal::from(bytes))),\n                value =\u003e Err(Error::FixedValue(value.into())),\n            },\n            Schema::Bytes =\u003e match decode(inner, reader)? {\n                Value::Bytes(bytes) =\u003e Ok(Value::Decimal(Decimal::from(bytes))),\n                value =\u003e Err(Error::BytesValue(value.into())),\n            },\n            schema =\u003e Err(Error::ResolveDecimalSchema(schema.into())),\n        },\n        Schema::Uuid =\u003e Ok(Value::Uuid(\n            Uuid::from_str(match decode(\u0026Schema::String, reader)? {\n                Value::String(ref s) =\u003e s,\n                value =\u003e return Err(Error::GetUuidFromStringValue(value.into())),\n            })\n            .map_err(Error::ConvertStrToUuid)?,\n        )),\n        Schema::Int =\u003e decode_int(reader),\n        Schema::Date =\u003e zag_i32(reader).map(Value::Date),\n        Schema::TimeMillis =\u003e zag_i32(reader).map(Value::TimeMillis),\n        Schema::Long =\u003e decode_long(reader),\n        Schema::TimeMicros =\u003e zag_i64(reader).map(Value::TimeMicros),\n        Schema::TimestampMillis =\u003e zag_i64(reader).map(Value::TimestampMillis),\n        Schema::TimestampMicros =\u003e zag_i64(reader).map(Value::TimestampMicros),\n        Schema::Duration =\u003e {\n            let mut buf = [0u8; 12];\n            reader.read_exact(\u0026mut buf).map_err(Error::ReadDuration)?;\n            Ok(Value::Duration(Duration::from(buf)))\n        }\n        Schema::Float =\u003e {\n            let mut buf = [0u8; std::mem::size_of::\u003cf32\u003e()];\n            reader.read_exact(\u0026mut buf[..]).map_err(Error::ReadFloat)?;\n            Ok(Value::Float(f32::from_le_bytes(buf)))\n        }\n        Schema::Double =\u003e {\n            let mut buf = [0u8; std::mem::size_of::\u003cf64\u003e()];\n            reader.read_exact(\u0026mut buf[..]).map_err(Error::ReadDouble)?;\n            Ok(Value::Double(f64::from_le_bytes(buf)))\n        }\n        Schema::Bytes =\u003e {\n            let len = decode_len(reader)?;\n            let mut buf = vec![0u8; len];\n            reader.read_exact(\u0026mut buf).map_err(Error::ReadBytes)?;\n            Ok(Value::Bytes(buf))\n        }\n        Schema::String =\u003e {\n            let len = decode_len(reader)?;\n            let mut buf = vec![0u8; len];\n            reader.read_exact(\u0026mut buf).map_err(Error::ReadString)?;\n\n            Ok(Value::String(\n                String::from_utf8(buf).map_err(Error::ConvertToUtf8)?,\n            ))\n        }\n        Schema::Fixed { size, .. } =\u003e {\n            let mut buf = vec![0u8; size];\n            reader\n                .read_exact(\u0026mut buf)\n                .map_err(|e| Error::ReadFixed(e, size))?;\n            Ok(Value::Fixed(size, buf))\n        }\n        Schema::Array(ref inner) =\u003e {\n            let mut items = Vec::new();\n\n            loop {\n                let len = decode_seq_len(reader)?;\n                if len == 0 {\n                    break;\n                }\n\n                items.reserve(len);\n                for _ in 0..len {\n                    items.push(decode(inner, reader)?);\n                }\n            }\n\n            Ok(Value::Array(items))\n        }\n        Schema::Map(ref inner) =\u003e {\n            let mut items = HashMap::new();\n\n            loop {\n                let len = decode_seq_len(reader)?;\n                if len == 0 {\n                    break;\n                }\n\n                items.reserve(len);\n                for _ in 0..len {\n                    match decode(\u0026Schema::String, reader)? {\n                        Value::String(key) =\u003e {\n                            let value = decode(inner, reader)?;\n                            items.insert(key, value);\n                        }\n                        value =\u003e return Err(Error::MapKeyType(value.into())),\n                    }\n                }\n            }\n\n            Ok(Value::Map(items))\n        }\n        Schema::Union(ref inner) =\u003e {\n            let index = zag_i64(reader)?;\n            let variants = inner.variants();\n            let variant = variants\n                .get(usize::try_from(index).map_err(|e| Error::ConvertI64ToUsize(e, index))?)\n                .ok_or_else(|| Error::GetUnionVariant {\n                    index,\n                    num_variants: variants.len(),\n                })?;\n            let value = decode(variant, reader)?;\n            Ok(Value::Union(Box::new(value)))\n        }\n        Schema::Record { ref fields, .. } =\u003e {\n            // Benchmarks indicate ~10% improvement using this method.\n            let mut items = Vec::with_capacity(fields.len());\n            for field in fields {\n                // TODO: This clone is also expensive. See if we can do away with it...\n                items.push((field.name.clone(), decode(\u0026field.schema, reader)?));\n            }\n            Ok(Value::Record(items))\n        }\n        Schema::Enum { ref symbols, .. } =\u003e {\n            Ok(if let Value::Int(raw_index) = decode_int(reader)? {\n                let index = usize::try_from(raw_index)\n                    .map_err(|e| Error::ConvertI32ToUsize(e, raw_index))?;\n                if (0..=symbols.len()).contains(\u0026index) {\n                    let symbol = symbols[index].clone();\n                    Value::Enum(raw_index, symbol)\n                } else {\n                    return Err(Error::GetEnumValue {\n                        index,\n                        nsymbols: symbols.len(),\n                    });\n                }\n            } else {\n                return Err(Error::GetEnumSymbol);\n            })\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        decode::decode,\n        schema::Schema,\n        types::{\n            Value,\n            Value::{Array, Int, Map},\n        },\n        Decimal,\n    };\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_decode_array_without_size() {\n        let mut input: \u0026[u8] = \u0026[6, 2, 4, 6, 0];\n        let result = decode(\u0026Schema::Array(Box::new(Schema::Int)), \u0026mut input);\n        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_array_with_size() {\n        let mut input: \u0026[u8] = \u0026[5, 6, 2, 4, 6, 0];\n        let result = decode(\u0026Schema::Array(Box::new(Schema::Int)), \u0026mut input);\n        assert_eq!(Array(vec!(Int(1), Int(2), Int(3))), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_map_without_size() {\n        let mut input: \u0026[u8] = \u0026[0x02, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];\n        let result = decode(\u0026Schema::Map(Box::new(Schema::Int)), \u0026mut input);\n        let mut expected = HashMap::new();\n        expected.insert(String::from(\"test\"), Int(1));\n        assert_eq!(Map(expected), result.unwrap());\n    }\n\n    #[test]\n    fn test_decode_map_with_size() {\n        let mut input: \u0026[u8] = \u0026[0x01, 0x0C, 0x08, 0x74, 0x65, 0x73, 0x74, 0x02, 0x00];\n        let result = decode(\u0026Schema::Map(Box::new(Schema::Int)), \u0026mut input);\n        let mut expected = HashMap::new();\n        expected.insert(String::from(\"test\"), Int(1));\n        assert_eq!(Map(expected), result.unwrap());\n    }\n\n    #[test]\n    fn test_negative_decimal_value() {\n        use crate::{encode::encode, schema::Name};\n        use num_bigint::ToBigInt;\n        let inner = Box::new(Schema::Fixed {\n            size: 2,\n            name: Name::new(\"decimal\"),\n        });\n        let schema = Schema::Decimal {\n            inner,\n            precision: 4,\n            scale: 2,\n        };\n        let bigint = (-423).to_bigint().unwrap();\n        let value = Value::Decimal(Decimal::from(bigint.to_signed_bytes_be()));\n\n        let mut buffer = Vec::new();\n        encode(\u0026value, \u0026schema, \u0026mut buffer);\n\n        let mut bytes = \u0026buffer[..];\n        let result = decode(\u0026schema, \u0026mut bytes).unwrap();\n        assert_eq!(result, value);\n    }\n\n    #[test]\n    fn test_decode_decimal_with_bigger_than_necessary_size() {\n        use crate::{encode::encode, schema::Name};\n        use num_bigint::ToBigInt;\n        let inner = Box::new(Schema::Fixed {\n            size: 13,\n            name: Name::new(\"decimal\"),\n        });\n        let schema = Schema::Decimal {\n            inner,\n            precision: 4,\n            scale: 2,\n        };\n        let value = Value::Decimal(Decimal::from(\n            ((-423).to_bigint().unwrap()).to_signed_bytes_be(),\n        ));\n        let mut buffer = Vec::\u003cu8\u003e::new();\n\n        encode(\u0026value, \u0026schema, \u0026mut buffer);\n        let mut bytes: \u0026[u8] = \u0026buffer[..];\n        let result = decode(\u0026schema, \u0026mut bytes).unwrap();\n        assert_eq!(result, value);\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":127},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","duration.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse byteorder::LittleEndian;\nuse zerocopy::U32;\n\n/// A struct representing duration that hides the details of endianness and conversion between\n/// platform-native u32 and byte arrays.\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Duration {\n    months: Months,\n    days: Days,\n    millis: Millis,\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Months(U32\u003cLittleEndian\u003e);\n\nimpl Months {\n    pub fn new(months: u32) -\u003e Self {\n        Self(U32::new(months))\n    }\n}\n\nimpl From\u003cMonths\u003e for u32 {\n    fn from(days: Months) -\u003e Self {\n        days.0.get()\n    }\n}\n\nimpl From\u003c[u8; 4]\u003e for Months {\n    fn from(bytes: [u8; 4]) -\u003e Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef\u003c[u8; 4]\u003e for Months {\n    fn as_ref(\u0026self) -\u003e \u0026[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Days(U32\u003cLittleEndian\u003e);\n\nimpl Days {\n    pub fn new(days: u32) -\u003e Self {\n        Self(U32::new(days))\n    }\n}\n\nimpl From\u003cDays\u003e for u32 {\n    fn from(days: Days) -\u003e Self {\n        days.0.get()\n    }\n}\n\nimpl From\u003c[u8; 4]\u003e for Days {\n    fn from(bytes: [u8; 4]) -\u003e Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef\u003c[u8; 4]\u003e for Days {\n    fn as_ref(\u0026self) -\u003e \u0026[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\n#[derive(Debug, Copy, Clone, PartialEq)]\npub struct Millis(U32\u003cLittleEndian\u003e);\n\nimpl Millis {\n    pub fn new(millis: u32) -\u003e Self {\n        Self(U32::new(millis))\n    }\n}\n\nimpl From\u003cMillis\u003e for u32 {\n    fn from(days: Millis) -\u003e Self {\n        days.0.get()\n    }\n}\n\nimpl From\u003c[u8; 4]\u003e for Millis {\n    fn from(bytes: [u8; 4]) -\u003e Self {\n        Self(U32::from(bytes))\n    }\n}\n\nimpl AsRef\u003c[u8; 4]\u003e for Millis {\n    fn as_ref(\u0026self) -\u003e \u0026[u8; 4] {\n        self.0.as_ref()\n    }\n}\n\nimpl Duration {\n    /// Construct a new `Duration`.\n    pub fn new(months: Months, days: Days, millis: Millis) -\u003e Self {\n        Self {\n            months,\n            days,\n            millis,\n        }\n    }\n\n    /// Return the number of months in this duration.\n    pub fn months(\u0026self) -\u003e Months {\n        self.months\n    }\n\n    /// Return the number of days in this duration.\n    pub fn days(\u0026self) -\u003e Days {\n        self.days\n    }\n\n    /// Return the number of milliseconds in this duration.\n    pub fn millis(\u0026self) -\u003e Millis {\n        self.millis\n    }\n}\n\nimpl From\u003cDuration\u003e for [u8; 12] {\n    fn from(duration: Duration) -\u003e Self {\n        let mut bytes = [0u8; 12];\n        bytes[0..4].copy_from_slice(duration.months.as_ref());\n        bytes[4..8].copy_from_slice(duration.days.as_ref());\n        bytes[8..12].copy_from_slice(duration.millis.as_ref());\n        bytes\n    }\n}\n\nimpl From\u003c[u8; 12]\u003e for Duration {\n    fn from(bytes: [u8; 12]) -\u003e Self {\n        Self {\n            months: Months::from([bytes[0], bytes[1], bytes[2], bytes[3]]),\n            days: Days::from([bytes[4], bytes[5], bytes[6], bytes[7]]),\n            millis: Millis::from([bytes[8], bytes[9], bytes[10], bytes[11]]),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","encode.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{\n    schema::Schema,\n    types::Value,\n    util::{zig_i32, zig_i64},\n};\nuse std::convert::TryInto;\n\n/// Encode a `Value` into avro format.\n///\n/// **NOTE** This will not perform schema validation. The value is assumed to\n/// be valid with regards to the schema. Schema are needed only to guide the\n/// encoding for complex type values.\npub fn encode(value: \u0026Value, schema: \u0026Schema, buffer: \u0026mut Vec\u003cu8\u003e) {\n    encode_ref(value, schema, buffer)\n}\n\nfn encode_bytes\u003cB: AsRef\u003c[u8]\u003e + ?Sized\u003e(s: \u0026B, buffer: \u0026mut Vec\u003cu8\u003e) {\n    let bytes = s.as_ref();\n    encode(\u0026Value::Long(bytes.len() as i64), \u0026Schema::Long, buffer);\n    buffer.extend_from_slice(bytes);\n}\n\nfn encode_long(i: i64, buffer: \u0026mut Vec\u003cu8\u003e) {\n    zig_i64(i, buffer)\n}\n\nfn encode_int(i: i32, buffer: \u0026mut Vec\u003cu8\u003e) {\n    zig_i32(i, buffer)\n}\n\n/// Encode a `Value` into avro format.\n///\n/// **NOTE** This will not perform schema validation. The value is assumed to\n/// be valid with regards to the schema. Schema are needed only to guide the\n/// encoding for complex type values.\npub fn encode_ref(value: \u0026Value, schema: \u0026Schema, buffer: \u0026mut Vec\u003cu8\u003e) {\n    match value {\n        Value::Null =\u003e (),\n        Value::Boolean(b) =\u003e buffer.push(if *b { 1u8 } else { 0u8 }),\n        // Pattern | Pattern here to signify that these _must_ have the same encoding.\n        Value::Int(i) | Value::Date(i) | Value::TimeMillis(i) =\u003e encode_int(*i, buffer),\n        Value::Long(i)\n        | Value::TimestampMillis(i)\n        | Value::TimestampMicros(i)\n        | Value::TimeMicros(i) =\u003e encode_long(*i, buffer),\n        Value::Float(x) =\u003e buffer.extend_from_slice(\u0026x.to_le_bytes()),\n        Value::Double(x) =\u003e buffer.extend_from_slice(\u0026x.to_le_bytes()),\n        Value::Decimal(decimal) =\u003e match schema {\n            Schema::Decimal { inner, .. } =\u003e match *inner.clone() {\n                Schema::Fixed { size, .. } =\u003e {\n                    let bytes = decimal.to_sign_extended_bytes_with_len(size).unwrap();\n                    let num_bytes = bytes.len();\n                    if num_bytes != size {\n                        panic!(\n                            \"signed decimal bytes length {} not equal to fixed schema size {}\",\n                            num_bytes, size\n                        );\n                    }\n                    encode(\u0026Value::Fixed(size, bytes), inner, buffer)\n                }\n                Schema::Bytes =\u003e encode(\u0026Value::Bytes(decimal.try_into().unwrap()), inner, buffer),\n                _ =\u003e panic!(\"invalid inner type for decimal: {:?}\", inner),\n            },\n            _ =\u003e panic!(\"invalid type for decimal: {:?}\", schema),\n        },\n        \u0026Value::Duration(duration) =\u003e {\n            let slice: [u8; 12] = duration.into();\n            buffer.extend_from_slice(\u0026slice);\n        }\n        Value::Uuid(uuid) =\u003e encode_bytes(\u0026uuid.to_string(), buffer),\n        Value::Bytes(bytes) =\u003e match *schema {\n            Schema::Bytes =\u003e encode_bytes(bytes, buffer),\n            Schema::Fixed { .. } =\u003e buffer.extend(bytes),\n            _ =\u003e (),\n        },\n        Value::String(s) =\u003e match *schema {\n            Schema::String =\u003e {\n                encode_bytes(s, buffer);\n            }\n            Schema::Enum { ref symbols, .. } =\u003e {\n                if let Some(index) = symbols.iter().position(|item| item == s) {\n                    encode_int(index as i32, buffer);\n                }\n            }\n            _ =\u003e (),\n        },\n        Value::Fixed(_, bytes) =\u003e buffer.extend(bytes),\n        Value::Enum(i, _) =\u003e encode_int(*i, buffer),\n        Value::Union(item) =\u003e {\n            if let Schema::Union(ref inner) = *schema {\n                // Find the schema that is matched here. Due to validation, this should always\n                // return a value.\n                let (idx, inner_schema) = inner\n                    .find_schema(item)\n                    .expect(\"Invalid Union validation occurred\");\n                encode_long(idx as i64, buffer);\n                encode_ref(\u0026*item, inner_schema, buffer);\n            }\n        }\n        Value::Array(items) =\u003e {\n            if let Schema::Array(ref inner) = *schema {\n                if !items.is_empty() {\n                    encode_long(items.len() as i64, buffer);\n                    for item in items.iter() {\n                        encode_ref(item, inner, buffer);\n                    }\n                }\n                buffer.push(0u8);\n            }\n        }\n        Value::Map(items) =\u003e {\n            if let Schema::Map(ref inner) = *schema {\n                if !items.is_empty() {\n                    encode_long(items.len() as i64, buffer);\n                    for (key, value) in items {\n                        encode_bytes(key, buffer);\n                        encode_ref(value, inner, buffer);\n                    }\n                }\n                buffer.push(0u8);\n            }\n        }\n        Value::Record(fields) =\u003e {\n            if let Schema::Record {\n                fields: ref schema_fields,\n                ..\n            } = *schema\n            {\n                for (i, \u0026(_, ref value)) in fields.iter().enumerate() {\n                    encode_ref(value, \u0026schema_fields[i].schema, buffer);\n                }\n            }\n        }\n    }\n}\n\npub fn encode_to_vec(value: \u0026Value, schema: \u0026Schema) -\u003e Vec\u003cu8\u003e {\n    let mut buffer = Vec::new();\n    encode(value, schema, \u0026mut buffer);\n    buffer\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_encode_empty_array() {\n        let mut buf = Vec::new();\n        let empty: Vec\u003cValue\u003e = Vec::new();\n        encode(\n            \u0026Value::Array(empty),\n            \u0026Schema::Array(Box::new(Schema::Int)),\n            \u0026mut buf,\n        );\n        assert_eq!(vec![0u8], buf);\n    }\n\n    #[test]\n    fn test_encode_empty_map() {\n        let mut buf = Vec::new();\n        let empty: HashMap\u003cString, Value\u003e = HashMap::new();\n        encode(\n            \u0026Value::Map(empty),\n            \u0026Schema::Map(Box::new(Schema::Int)),\n            \u0026mut buf,\n        );\n        assert_eq!(vec![0u8], buf);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","error.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{schema::SchemaKind, types::ValueKind};\nuse std::fmt;\n\n#[derive(thiserror::Error, Debug)]\npub enum Error {\n    #[error(\"Bad Snappy CRC32; expected {expected:x} but got {actual:x}\")]\n    SnappyCrc32 { expected: u32, actual: u32 },\n\n    #[error(\"Invalid u8 for bool: {0}\")]\n    BoolValue(u8),\n\n    #[error(\"Not a fixed value, required for decimal with fixed schema: {0:?}\")]\n    FixedValue(ValueKind),\n\n    #[error(\"Not a bytes value, required for decimal with bytes schema: {0:?}\")]\n    BytesValue(ValueKind),\n\n    #[error(\"Not a string value, required for uuid: {0:?}\")]\n    GetUuidFromStringValue(ValueKind),\n\n    #[error(\"Two schemas with the same fullname were given: {0:?}\")]\n    NameCollision(String),\n\n    #[error(\"Not a fixed or bytes type, required for decimal schema, got: {0:?}\")]\n    ResolveDecimalSchema(SchemaKind),\n\n    #[error(\"Invalid utf-8 string\")]\n    ConvertToUtf8(#[source] std::string::FromUtf8Error),\n\n    /// Describes errors happened while validating Avro data.\n    #[error(\"Value does not match schema\")]\n    Validation,\n\n    #[error(\"Unable to allocate {desired} bytes (maximum allowed: {maximum})\")]\n    MemoryAllocation { desired: usize, maximum: usize },\n\n    /// Describe a specific error happening with decimal representation\n    #[error(\"Number of bytes requested for decimal sign extension {requested} is less than the number of bytes needed to decode {needed}\")]\n    SignExtend { requested: usize, needed: usize },\n\n    #[error(\"Failed to read boolean bytes\")]\n    ReadBoolean(#[source] std::io::Error),\n\n    #[error(\"Failed to read bytes\")]\n    ReadBytes(#[source] std::io::Error),\n\n    #[error(\"Failed to read string\")]\n    ReadString(#[source] std::io::Error),\n\n    #[error(\"Failed to read double\")]\n    ReadDouble(#[source] std::io::Error),\n\n    #[error(\"Failed to read float\")]\n    ReadFloat(#[source] std::io::Error),\n\n    #[error(\"Failed to read duration\")]\n    ReadDuration(#[source] std::io::Error),\n\n    #[error(\"Failed to read fixed number of bytes: {1}\")]\n    ReadFixed(#[source] std::io::Error, usize),\n\n    #[error(\"Failed to convert \u0026str to UUID\")]\n    ConvertStrToUuid(#[source] uuid::Error),\n\n    #[error(\"Map key is not a string; key type is {0:?}\")]\n    MapKeyType(ValueKind),\n\n    #[error(\"Union index {index} out of bounds: {num_variants}\")]\n    GetUnionVariant { index: i64, num_variants: usize },\n\n    #[error(\"Enum symbol index out of bounds: {num_variants}\")]\n    EnumSymbolIndex { index: usize, num_variants: usize },\n\n    #[error(\"Enum symbol not found\")]\n    GetEnumSymbol,\n\n    #[error(\"Scale {scale} is greater than precision {precision}\")]\n    GetScaleAndPrecision { scale: usize, precision: usize },\n\n    #[error(\n        \"Fixed type number of bytes {size} is not large enough to hold decimal values of precision {precision}\"\n    )]\n    GetScaleWithFixedSize { size: usize, precision: usize },\n\n    #[error(\"expected UUID, got: {0:?}\")]\n    GetUuid(ValueKind),\n\n    #[error(\"Fixed bytes of size 12 expected, got Fixed of size {0}\")]\n    GetDecimalFixedBytes(usize),\n\n    #[error(\"Duration expected, got {0:?}\")]\n    ResolveDuration(ValueKind),\n\n    #[error(\"Decimal expected, got {0:?}\")]\n    ResolveDecimal(ValueKind),\n\n    #[error(\"Missing field in record: {0:?}\")]\n    GetField(String),\n\n    #[error(\"Unable to convert to u8, got {0:?}\")]\n    GetU8(ValueKind),\n\n    #[error(\"Precision {precision} too small to hold decimal values with {num_bytes} bytes\")]\n    ComparePrecisionAndSize { precision: usize, num_bytes: usize },\n\n    #[error(\"Cannot convert length to i32: {1}\")]\n    ConvertLengthToI32(#[source] std::num::TryFromIntError, usize),\n\n    #[error(\"Date expected, got {0:?}\")]\n    GetDate(ValueKind),\n\n    #[error(\"TimeMillis expected, got {0:?}\")]\n    GetTimeMillis(ValueKind),\n\n    #[error(\"TimeMicros expected, got {0:?}\")]\n    GetTimeMicros(ValueKind),\n\n    #[error(\"TimestampMillis expected, got {0:?}\")]\n    GetTimestampMillis(ValueKind),\n\n    #[error(\"TimestampMicros expected, got {0:?}\")]\n    GetTimestampMicros(ValueKind),\n\n    #[error(\"Null expected, got {0:?}\")]\n    GetNull(ValueKind),\n\n    #[error(\"Boolean expected, got {0:?}\")]\n    GetBoolean(ValueKind),\n\n    #[error(\"Int expected, got {0:?}\")]\n    GetInt(ValueKind),\n\n    #[error(\"Long expected, got {0:?}\")]\n    GetLong(ValueKind),\n\n    #[error(\"Double expected, got {0:?}\")]\n    GetDouble(ValueKind),\n\n    #[error(\"Float expected, got {0:?}\")]\n    GetFloat(ValueKind),\n\n    #[error(\"Bytes expected, got {0:?}\")]\n    GetBytes(ValueKind),\n\n    #[error(\"String expected, got {0:?}\")]\n    GetString(ValueKind),\n\n    #[error(\"Enum expected, got {0:?}\")]\n    GetEnum(ValueKind),\n\n    #[error(\"Fixed size mismatch, {size} expected, got {n}\")]\n    CompareFixedSizes { size: usize, n: usize },\n\n    #[error(\"String expected for fixed, got {0:?}\")]\n    GetStringForFixed(ValueKind),\n\n    #[error(\"Enum default {symbol:?} is not among allowed symbols {symbols:?}\")]\n    GetEnumDefault {\n        symbol: String,\n        symbols: Vec\u003cString\u003e,\n    },\n\n    #[error(\"Enum value index {index} is out of bounds {nsymbols}\")]\n    GetEnumValue { index: usize, nsymbols: usize },\n\n    #[error(\"Key {0} not found in decimal metadata JSON\")]\n    GetDecimalMetadataFromJson(\u0026'static str),\n\n    #[error(\"Could not find matching type in union\")]\n    FindUnionVariant,\n\n    #[error(\"Array({expected:?}) expected, got {other:?}\")]\n    GetArray {\n        expected: SchemaKind,\n        other: ValueKind,\n    },\n\n    #[error(\"Map({expected:?}) expected, got {other:?}\")]\n    GetMap {\n        expected: SchemaKind,\n        other: ValueKind,\n    },\n\n    #[error(\"Record with fields {expected:?} expected, got {other:?}\")]\n    GetRecord {\n        expected: Vec\u003c(String, SchemaKind)\u003e,\n        other: ValueKind,\n    },\n\n    #[error(\"No `name` field\")]\n    GetNameField,\n\n    #[error(\"No `name` in record field\")]\n    GetNameFieldFromRecord,\n\n    #[error(\"Unions may not directly contain a union\")]\n    GetNestedUnion,\n\n    #[error(\"Unions cannot contain duplicate types\")]\n    GetUnionDuplicate,\n\n    #[error(\"JSON value {0} claims to be u64 but cannot be converted\")]\n    GetU64FromJson(serde_json::Number),\n\n    #[error(\"JSON value {0} claims to be i64 but cannot be converted\")]\n    GetI64FromJson(serde_json::Number),\n\n    #[error(\"Cannot convert u64 to usize: {1}\")]\n    ConvertU64ToUsize(#[source] std::num::TryFromIntError, u64),\n\n    #[error(\"Cannot convert i64 to usize: {1}\")]\n    ConvertI64ToUsize(#[source] std::num::TryFromIntError, i64),\n\n    #[error(\"Cannot convert i32 to usize: {1}\")]\n    ConvertI32ToUsize(#[source] std::num::TryFromIntError, i32),\n\n    #[error(\"Invalid JSON value for decimal precision/scale integer: {0}\")]\n    GetPrecisionOrScaleFromJson(serde_json::Number),\n\n    #[error(\"Failed to parse schema from JSON\")]\n    ParseSchemaJson(#[source] serde_json::Error),\n\n    #[error(\"Must be a JSON string, object or array\")]\n    ParseSchemaFromValidJson,\n\n    #[error(\"Unknown primitiive type: {0}\")]\n    ParsePrimitive(String),\n\n    #[error(\"invalid JSON for {key:?}: {precision:?}\")]\n    GetDecimalPrecisionFromJson {\n        key: String,\n        precision: serde_json::Value,\n    },\n\n    #[error(\"Unexpected `type` {0} variant for `logicalType`\")]\n    GetLogicalTypeVariant(serde_json::Value),\n\n    #[error(\"No `type` field found for `logicalType`\")]\n    GetLogicalTypeField,\n\n    #[error(\"logicalType must be a string\")]\n    GetLogicalTypeFieldType,\n\n    #[error(\"Unknown complex type: {0}\")]\n    GetComplexType(serde_json::Value),\n\n    #[error(\"No `type` in complex type\")]\n    GetComplexTypeField,\n\n    #[error(\"No `fields` in record\")]\n    GetRecordFieldsJson,\n\n    #[error(\"No `symbols` field in enum\")]\n    GetEnumSymbolsField,\n\n    #[error(\"Unable to parse `symbols` in enum\")]\n    GetEnumSymbols,\n\n    #[error(\"Invalid enum symbol name {0}\")]\n    EnumSymbolName(String),\n\n    #[error(\"Duplicate enum symbol {0}\")]\n    EnumSymbolDuplicate(String),\n\n    #[error(\"No `items` in array\")]\n    GetArrayItemsField,\n\n    #[error(\"No `values` in map\")]\n    GetMapValuesField,\n\n    #[error(\"No `size` in fixed\")]\n    GetFixedSizeField,\n\n    #[error(\"Failed to compress with flate\")]\n    DeflateCompress(#[source] std::io::Error),\n\n    #[error(\"Failed to finish flate compressor\")]\n    DeflateCompressFinish(std::io::Error),\n\n    #[error(\"Failed to decompress with flate\")]\n    DeflateDecompress(#[source] std::io::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to compress with snappy\")]\n    SnappyCompress(#[source] snap::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to get snappy decompression length\")]\n    GetSnappyDecompressLen(#[source] snap::Error),\n\n    #[cfg(feature = \"snappy\")]\n    #[error(\"Failed to decompress with snappy\")]\n    SnappyDecompress(#[source] snap::Error),\n\n    #[error(\"Failed to read header\")]\n    ReadHeader(#[source] std::io::Error),\n\n    #[error(\"wrong magic in header\")]\n    HeaderMagic,\n\n    #[error(\"Failed to get JSON from avro.schema key in map\")]\n    GetAvroSchemaFromMap,\n\n    #[error(\"no metadata in header\")]\n    GetHeaderMetadata,\n\n    #[error(\"Failed to read marker bytes\")]\n    ReadMarker(#[source] std::io::Error),\n\n    #[error(\"Failed to read block marker bytes\")]\n    ReadBlockMarker(#[source] std::io::Error),\n\n    #[error(\"Read into buffer failed\")]\n    ReadIntoBuf(#[source] std::io::Error),\n\n    #[error(\"block marker does not match header marker\")]\n    GetBlockMarker,\n\n    #[error(\"Overflow when decoding integer value\")]\n    IntegerOverflow,\n\n    #[error(\"Failed to read bytes for decoding variable length integer\")]\n    ReadVariableIntegerBytes(#[source] std::io::Error),\n\n    #[error(\"Decoded integer out of range for i32: {1}\")]\n    ZagI32(#[source] std::num::TryFromIntError, i64),\n\n    #[error(\"unable to read block\")]\n    ReadBlock,\n\n    #[error(\"Failed to serialize value into Avro value: {0}\")]\n    SerializeValue(String),\n\n    #[error(\"Failed to deserialize Avro value into value: {0}\")]\n    DeserializeValue(String),\n\n    #[error(\"Failed to write buffer bytes during flush\")]\n    WriteBytes(#[source] std::io::Error),\n\n    #[error(\"Failed to write marker\")]\n    WriteMarker(#[source] std::io::Error),\n\n    #[error(\"Failed to convert JSON to string\")]\n    ConvertJsonToString(#[source] serde_json::Error),\n\n    /// Error while converting float to json value\n    #[error(\"failed to convert avro float to json: {0}\")]\n    ConvertF64ToJson(f64),\n}\n\nimpl serde::ser::Error for Error {\n    fn custom\u003cT: fmt::Display\u003e(msg: T) -\u003e Self {\n        Error::SerializeValue(msg.to_string())\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom\u003cT: fmt::Display\u003e(msg: T) -\u003e Self {\n        Error::DeserializeValue(msg.to_string())\n    }\n}\n","traces":[{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","lib.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! A library for working with [Apache Avro](https://avro.apache.org/) in Rust.\n//!\n//! Please check our [documentation](https://docs.rs/avro-rs) for examples, tutorials and API reference.\n//!\n//! **[Apache Avro](https://avro.apache.org/)** is a data serialization system which provides rich\n//! data structures and a compact, fast, binary data format.\n//!\n//! All data in Avro is schematized, as in the following example:\n//!\n//! ```text\n//! {\n//!     \"type\": \"record\",\n//!     \"name\": \"test\",\n//!     \"fields\": [\n//!         {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!         {\"name\": \"b\", \"type\": \"string\"}\n//!     ]\n//! }\n//! ```\n//!\n//! There are basically two ways of handling Avro data in Rust:\n//!\n//! * **as Avro-specialized data types** based on an Avro schema;\n//! * **as generic Rust serde-compatible types** implementing/deriving `Serialize` and\n//! `Deserialize`;\n//!\n//! **avro-rs** provides a way to read and write both these data representations easily and\n//! efficiently.\n//!\n//! # Installing the library\n//!\n//!\n//! Add to your `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! avro-rs = \"x.y\"\n//! ```\n//!\n//! Or in case you want to leverage the **Snappy** codec:\n//!\n//! ```toml\n//! [dependencies.avro-rs]\n//! version = \"x.y\"\n//! features = [\"snappy\"]\n//! ```\n//!\n//! # Upgrading to a newer minor version\n//!\n//! The library is still in beta, so there might be backward-incompatible changes between minor\n//! versions. If you have troubles upgrading, check the [version upgrade guide](migration_guide.md).\n//!\n//! # Defining a schema\n//!\n//! An Avro data cannot exist without an Avro schema. Schemas **must** be used while writing and\n//! **can** be used while reading and they carry the information regarding the type of data we are\n//! handling. Avro schemas are used for both schema validation and resolution of Avro data.\n//!\n//! Avro schemas are defined in **JSON** format and can just be parsed out of a raw string:\n//!\n//! ```\n//! use avro_rs::Schema;\n//!\n//! let raw_schema = r#\"\n//!     {\n//!         \"type\": \"record\",\n//!         \"name\": \"test\",\n//!         \"fields\": [\n//!             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!             {\"name\": \"b\", \"type\": \"string\"}\n//!         ]\n//!     }\n//! \"#;\n//!\n//! // if the schema is not valid, this function will return an error\n//! let schema = Schema::parse_str(raw_schema).unwrap();\n//!\n//! // schemas can be printed for debugging\n//! println!(\"{:?}\", schema);\n//! ```\n//!\n//! Additionally, a list of of definitions (which may depend on each other) can be given and all of\n//! them will be parsed into the corresponding schemas.\n//!\n//! ```\n//! use avro_rs::Schema;\n//!\n//! let raw_schema_1 = r#\"{\n//!         \"name\": \"A\",\n//!         \"type\": \"record\",\n//!         \"fields\": [\n//!             {\"name\": \"field_one\", \"type\": \"float\"}\n//!         ]\n//!     }\"#;\n//!\n//! // This definition depends on the definition of A above\n//! let raw_schema_2 = r#\"{\n//!         \"name\": \"B\",\n//!         \"type\": \"record\",\n//!         \"fields\": [\n//!             {\"name\": \"field_one\", \"type\": \"A\"}\n//!         ]\n//!     }\"#;\n//!\n//! // if the schemas are not valid, this function will return an error\n//! let schemas = Schema::parse_list(\u0026[raw_schema_1, raw_schema_2]).unwrap();\n//!\n//! // schemas can be printed for debugging\n//! println!(\"{:?}\", schemas);\n//! ```\n//! *N.B.* It is important to note that the composition of schema definitions requires schemas with names.\n//! For this reason, only schemas of type Record, Enum, and Fixed should be input into this function.\n//!\n//! The library provides also a programmatic interface to define schemas without encoding them in\n//! JSON (for advanced use), but we highly recommend the JSON interface. Please read the API\n//! reference in case you are interested.\n//!\n//! For more information about schemas and what kind of information you can encapsulate in them,\n//! please refer to the appropriate section of the\n//! [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas).\n//!\n//! # Writing data\n//!\n//! Once we have defined a schema, we are ready to serialize data in Avro, validating them against\n//! the provided schema in the process. As mentioned before, there are two ways of handling Avro\n//! data in Rust.\n//!\n//! **NOTE:** The library also provides a low-level interface for encoding a single datum in Avro\n//! bytecode without generating markers and headers (for advanced use), but we highly recommend the\n//! `Writer` interface to be totally Avro-compatible. Please read the API reference in case you are\n//! interested.\n//!\n//! ## The avro way\n//!\n//! Given that the schema we defined above is that of an Avro *Record*, we are going to use the\n//! associated type provided by the library to specify the data we want to serialize:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! use avro_rs::types::Record;\n//! use avro_rs::Writer;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! // a writer needs a schema and something to write to\n//! let mut writer = Writer::new(\u0026schema, Vec::new());\n//!\n//! // the Record type models our Record schema\n//! let mut record = Record::new(writer.schema()).unwrap();\n//! record.put(\"a\", 27i64);\n//! record.put(\"b\", \"foo\");\n//!\n//! // schema validation happens here\n//! writer.append(record).unwrap();\n//!\n//! // this is how to get back the resulting avro bytecode\n//! // this performs a flush operation to make sure data has been written, so it can fail\n//! // you can also call `writer.flush()` yourself without consuming the writer\n//! let encoded = writer.into_inner().unwrap();\n//! ```\n//!\n//! The vast majority of the times, schemas tend to define a record as a top-level container\n//! encapsulating all the values to convert as fields and providing documentation for them, but in\n//! case we want to directly define an Avro value, the library offers that capability via the\n//! `Value` interface.\n//!\n//! ```\n//! use avro_rs::types::Value;\n//!\n//! let mut value = Value::String(\"foo\".to_string());\n//! ```\n//!\n//! ## The serde way\n//!\n//! Given that the schema we defined above is an Avro *Record*, we can directly use a Rust struct\n//! deriving `Serialize` to model our data:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use serde::Serialize;\n//! use avro_rs::Writer;\n//!\n//! #[derive(Debug, Serialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! // a writer needs a schema and something to write to\n//! let mut writer = Writer::new(\u0026schema, Vec::new());\n//!\n//! // the structure models our Record schema\n//! let test = Test {\n//!     a: 27,\n//!     b: \"foo\".to_owned(),\n//! };\n//!\n//! // schema validation happens here\n//! writer.append_ser(test).unwrap();\n//!\n//! // this is how to get back the resulting avro bytecode\n//! // this performs a flush operation to make sure data is written, so it can fail\n//! // you can also call `writer.flush()` yourself without consuming the writer\n//! let encoded = writer.into_inner();\n//! ```\n//!\n//! The vast majority of the times, schemas tend to define a record as a top-level container\n//! encapsulating all the values to convert as fields and providing documentation for them, but in\n//! case we want to directly define an Avro value, any type implementing `Serialize` should work.\n//!\n//! ```\n//! let mut value = \"foo\".to_string();\n//! ```\n//!\n//! ## Using codecs to compress data\n//!\n//! Avro supports three different compression codecs when encoding data:\n//!\n//! * **Null**: leaves data uncompressed;\n//! * **Deflate**: writes the data block using the deflate algorithm as specified in RFC 1951, and\n//! typically implemented using the zlib library. Note that this format (unlike the \"zlib format\" in\n//! RFC 1950) does not have a checksum.\n//! * **Snappy**: uses Google's [Snappy](http://google.github.io/snappy/) compression library. Each\n//! compressed block is followed by the 4-byte, big-endianCRC32 checksum of the uncompressed data in\n//! the block. You must enable the `snappy` feature to use this codec.\n//!\n//! To specify a codec to use to compress data, just specify it while creating a `Writer`:\n//! ```\n//! # use avro_rs::Schema;\n//! use avro_rs::Writer;\n//! use avro_rs::Codec;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Deflate);\n//! ```\n//!\n//! # Reading data\n//!\n//! As far as reading Avro encoded data goes, we can just use the schema encoded with the data to\n//! read them. The library will do it automatically for us, as it already does for the compression\n//! codec:\n//!\n//! ```\n//! use avro_rs::Reader;\n//! # use avro_rs::Schema;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! // reader creation can fail in case the input to read from is not Avro-compatible or malformed\n//! let reader = Reader::new(\u0026input[..]).unwrap();\n//! ```\n//!\n//! In case, instead, we want to specify a different (but compatible) reader schema from the schema\n//! the data has been written with, we can just do as the following:\n//! ```\n//! use avro_rs::Schema;\n//! use avro_rs::Reader;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! #\n//! # let writer_raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026writer_schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//!\n//! let reader_raw_schema = r#\"\n//!     {\n//!         \"type\": \"record\",\n//!         \"name\": \"test\",\n//!         \"fields\": [\n//!             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!             {\"name\": \"b\", \"type\": \"string\"},\n//!             {\"name\": \"c\", \"type\": \"long\", \"default\": 43}\n//!         ]\n//!     }\n//! \"#;\n//!\n//! let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n//!\n//! // reader creation can fail in case the input to read from is not Avro-compatible or malformed\n//! let reader = Reader::with_schema(\u0026reader_schema, \u0026input[..]).unwrap();\n//! ```\n//!\n//! The library will also automatically perform schema resolution while reading the data.\n//!\n//! For more information about schema compatibility and resolution, please refer to the\n//! [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas).\n//!\n//! As usual, there are two ways to handle Avro data in Rust, as you can see below.\n//!\n//! **NOTE:** The library also provides a low-level interface for decoding a single datum in Avro\n//! bytecode without markers and header (for advanced use), but we highly recommend the `Reader`\n//! interface to leverage all Avro features. Please read the API reference in case you are\n//! interested.\n//!\n//!\n//! ## The avro way\n//!\n//! We can just read directly instances of `Value` out of the `Reader` iterator:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use avro_rs::types::Record;\n//! # use avro_rs::Writer;\n//! use avro_rs::Reader;\n//! #\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026schema, Vec::new());\n//! # let mut record = Record::new(writer.schema()).unwrap();\n//! # record.put(\"a\", 27i64);\n//! # record.put(\"b\", \"foo\");\n//! # writer.append(record).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! let reader = Reader::new(\u0026input[..]).unwrap();\n//!\n//! // value is a Result  of an Avro Value in case the read operation fails\n//! for value in reader {\n//!     println!(\"{:?}\", value.unwrap());\n//! }\n//!\n//! ```\n//!\n//! ## The serde way\n//!\n//! Alternatively, we can use a Rust type implementing `Deserialize` and representing our schema to\n//! read the data into:\n//!\n//! ```\n//! # use avro_rs::Schema;\n//! # use avro_rs::Writer;\n//! # use serde::{Deserialize, Serialize};\n//! use avro_rs::Reader;\n//! use avro_rs::from_value;\n//!\n//! # #[derive(Serialize)]\n//! #[derive(Debug, Deserialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! # let raw_schema = r#\"\n//! #     {\n//! #         \"type\": \"record\",\n//! #         \"name\": \"test\",\n//! #         \"fields\": [\n//! #             {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//! #             {\"name\": \"b\", \"type\": \"string\"}\n//! #         ]\n//! #     }\n//! # \"#;\n//! # let schema = Schema::parse_str(raw_schema).unwrap();\n//! # let mut writer = Writer::new(\u0026schema, Vec::new());\n//! # let test = Test {\n//! #     a: 27,\n//! #     b: \"foo\".to_owned(),\n//! # };\n//! # writer.append_ser(test).unwrap();\n//! # let input = writer.into_inner().unwrap();\n//! let reader = Reader::new(\u0026input[..]).unwrap();\n//!\n//! // value is a Result in case the read operation fails\n//! for value in reader {\n//!     println!(\"{:?}\", from_value::\u003cTest\u003e(\u0026value.unwrap()));\n//! }\n//! ```\n//!\n//! # Putting everything together\n//!\n//! The following is an example of how to combine everything showed so far and it is meant to be a\n//! quick reference of the library interface:\n//!\n//! ```\n//! use avro_rs::{Codec, Reader, Schema, Writer, from_value, types::Record, Error};\n//! use serde::{Deserialize, Serialize};\n//!\n//! #[derive(Debug, Deserialize, Serialize)]\n//! struct Test {\n//!     a: i64,\n//!     b: String,\n//! }\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     let raw_schema = r#\"\n//!         {\n//!             \"type\": \"record\",\n//!             \"name\": \"test\",\n//!             \"fields\": [\n//!                 {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!                 {\"name\": \"b\", \"type\": \"string\"}\n//!             ]\n//!         }\n//!     \"#;\n//!\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!\n//!     println!(\"{:?}\", schema);\n//!\n//!     let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Deflate);\n//!\n//!     let mut record = Record::new(writer.schema()).unwrap();\n//!     record.put(\"a\", 27i64);\n//!     record.put(\"b\", \"foo\");\n//!\n//!     writer.append(record)?;\n//!\n//!     let test = Test {\n//!         a: 27,\n//!         b: \"foo\".to_owned(),\n//!     };\n//!\n//!     writer.append_ser(test)?;\n//!\n//!     let input = writer.into_inner()?;\n//!     let reader = Reader::with_schema(\u0026schema, \u0026input[..])?;\n//!\n//!     for record in reader {\n//!         println!(\"{:?}\", from_value::\u003cTest\u003e(\u0026record?));\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! `avro-rs` also supports the logical types listed in the [Avro specification](https://avro.apache.org/docs/current/spec.html#Logical+Types):\n//!\n//! 1. `Decimal` using the [`num_bigint`](https://docs.rs/num-bigint/0.2.6/num_bigint) crate\n//! 1. UUID using the [`uuid`](https://docs.rs/uuid/0.8.1/uuid) crate\n//! 1. Date, Time (milli) as `i32` and Time (micro) as `i64`\n//! 1. Timestamp (milli and micro) as `i64`\n//! 1. Duration as a custom type with `months`, `days` and `millis` accessor methods each of which returns an `i32`\n//!\n//! Note that the on-disk representation is identical to the underlying primitive/complex type.\n//!\n//! ### Read and write logical types\n//!\n//! ```rust\n//! use avro_rs::{\n//!     types::Record, types::Value, Codec, Days, Decimal, Duration, Millis, Months, Reader, Schema,\n//!     Writer, Error,\n//! };\n//! use num_bigint::ToBigInt;\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     let raw_schema = r#\"\n//!     {\n//!       \"type\": \"record\",\n//!       \"name\": \"test\",\n//!       \"fields\": [\n//!         {\n//!           \"name\": \"decimal_fixed\",\n//!           \"type\": {\n//!             \"type\": \"fixed\",\n//!             \"size\": 2,\n//!             \"name\": \"decimal\"\n//!           },\n//!           \"logicalType\": \"decimal\",\n//!           \"precision\": 4,\n//!           \"scale\": 2\n//!         },\n//!         {\n//!           \"name\": \"decimal_var\",\n//!           \"type\": \"bytes\",\n//!           \"logicalType\": \"decimal\",\n//!           \"precision\": 10,\n//!           \"scale\": 3\n//!         },\n//!         {\n//!           \"name\": \"uuid\",\n//!           \"type\": \"string\",\n//!           \"logicalType\": \"uuid\"\n//!         },\n//!         {\n//!           \"name\": \"date\",\n//!           \"type\": \"int\",\n//!           \"logicalType\": \"date\"\n//!         },\n//!         {\n//!           \"name\": \"time_millis\",\n//!           \"type\": \"int\",\n//!           \"logicalType\": \"time-millis\"\n//!         },\n//!         {\n//!           \"name\": \"time_micros\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"time-micros\"\n//!         },\n//!         {\n//!           \"name\": \"timestamp_millis\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"timestamp-millis\"\n//!         },\n//!         {\n//!           \"name\": \"timestamp_micros\",\n//!           \"type\": \"long\",\n//!           \"logicalType\": \"timestamp-micros\"\n//!         },\n//!         {\n//!           \"name\": \"duration\",\n//!           \"type\": {\n//!             \"type\": \"fixed\",\n//!             \"size\": 12,\n//!             \"name\": \"duration\"\n//!           },\n//!           \"logicalType\": \"duration\"\n//!         }\n//!       ]\n//!     }\n//!     \"#;\n//!\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!\n//!     println!(\"{:?}\", schema);\n//!\n//!     let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Deflate);\n//!\n//!     let mut record = Record::new(writer.schema()).unwrap();\n//!     record.put(\"decimal_fixed\", Decimal::from(9936.to_bigint().unwrap().to_signed_bytes_be()));\n//!     record.put(\"decimal_var\", Decimal::from((-32442.to_bigint().unwrap()).to_signed_bytes_be()));\n//!     record.put(\"uuid\", uuid::Uuid::new_v4());\n//!     record.put(\"date\", Value::Date(1));\n//!     record.put(\"time_millis\", Value::TimeMillis(2));\n//!     record.put(\"time_micros\", Value::TimeMicros(3));\n//!     record.put(\"timestamp_millis\", Value::TimestampMillis(4));\n//!     record.put(\"timestamp_micros\", Value::TimestampMicros(5));\n//!     record.put(\"duration\", Duration::new(Months::new(6), Days::new(7), Millis::new(8)));\n//!\n//!     writer.append(record)?;\n//!\n//!     let input = writer.into_inner()?;\n//!     let reader = Reader::with_schema(\u0026schema, \u0026input[..])?;\n//!\n//!     for record in reader {\n//!         println!(\"{:?}\", record?);\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Calculate Avro schema fingerprint\n//!\n//! This library supports calculating the following fingerprints:\n//!\n//!  - SHA-256\n//!  - MD5\n//!  - Rabin\n//!\n//! An example of fingerprinting for the supported fingerprints:\n//!\n//! ```rust\n//! use avro_rs::rabin::Rabin;\n//! use avro_rs::{Schema, Error};\n//! use md5::Md5;\n//! use sha2::Sha256;\n//!\n//! fn main() -\u003e Result\u003c(), Error\u003e {\n//!     let raw_schema = r#\"\n//!         {\n//!             \"type\": \"record\",\n//!             \"name\": \"test\",\n//!             \"fields\": [\n//!                 {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n//!                 {\"name\": \"b\", \"type\": \"string\"}\n//!             ]\n//!         }\n//!     \"#;\n//!     let schema = Schema::parse_str(raw_schema)?;\n//!     println!(\"{}\", schema.fingerprint::\u003cSha256\u003e());\n//!     println!(\"{}\", schema.fingerprint::\u003cMd5\u003e());\n//!     println!(\"{}\", schema.fingerprint::\u003cRabin\u003e());\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Ill-formed data\n//!\n//! In order to ease decoding, the Binary Encoding specification of Avro data\n//! requires some fields to have their length encoded alongside the data.\n//!\n//! If encoded data passed to a `Reader` has been ill-formed, it can happen that\n//! the bytes meant to contain the length of data are bogus and could result\n//! in extravagant memory allocation.\n//!\n//! To shield users from ill-formed data, `avro-rs` sets a limit (default: 512MB)\n//! to any allocation it will perform when decoding data.\n//!\n//! If you expect some of your data fields to be larger than this limit, be sure\n//! to make use of the `max_allocation_bytes` function before reading **any** data\n//! (we leverage Rust's [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html)\n//! mechanism to initialize this value, if\n//! any call to decode is made before a call to `max_allocation_bytes`, the limit\n//! will be 512MB throughout the lifetime of the program).\n//!\n//!\n//! ```rust\n//! use avro_rs::max_allocation_bytes;\n//!\n//! max_allocation_bytes(2 * 1024 * 1024 * 1024);  // 2GB\n//!\n//! // ... happily decode large data\n//!\n//! ```\n//!\n//! ## Check schemas compatibility\n//!\n//! This library supports checking for schemas compatibility.\n//!\n//! Note: It does not yet support named schemas (more on\n//! https://github.com/flavray/avro-rs/pull/76).\n//!\n//! Examples of checking for compatibility:\n//!\n//! 1. Compatible schemas\n//!\n//! Explanation: an int array schema can be read by a long array schema- an int\n//! (32bit signed integer) fits into a long (64bit signed integer)\n//!\n//! ```rust\n//! use avro_rs::{Schema, schema_compatibility::SchemaCompatibility};\n//!\n//! let writers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"int\"}\"#).unwrap();\n//! let readers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"long\"}\"#).unwrap();\n//! assert_eq!(true, SchemaCompatibility::can_read(\u0026writers_schema, \u0026readers_schema));\n//! ```\n//!\n//! 2. Incompatible schemas (a long array schema cannot be read by an int array schema)\n//!\n//! Explanation: a long array schema cannot be read by an int array schema- a\n//! long (64bit signed integer) does not fit into an int (32bit signed integer)\n//!\n//! ```rust\n//! use avro_rs::{Schema, schema_compatibility::SchemaCompatibility};\n//!\n//! let writers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"long\"}\"#).unwrap();\n//! let readers_schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\":\"int\"}\"#).unwrap();\n//! assert_eq!(false, SchemaCompatibility::can_read(\u0026writers_schema, \u0026readers_schema));\n//! ```\n\nmod codec;\nmod de;\nmod decimal;\nmod decode;\nmod duration;\nmod encode;\nmod error;\nmod reader;\nmod ser;\nmod util;\nmod writer;\n\npub mod rabin;\npub mod schema;\npub mod schema_compatibility;\npub mod types;\n\npub use codec::Codec;\npub use de::from_value;\npub use decimal::Decimal;\npub use duration::{Days, Duration, Millis, Months};\npub use error::{Error, Error as DeError, Error as SerError};\npub use reader::{from_avro_datum, Reader};\npub use schema::Schema;\npub use ser::to_value;\npub use util::max_allocation_bytes;\npub use writer::{to_avro_datum, Writer};\n\n/// A convenience type alias for `Result`s with `Error`s.\npub type AvroResult\u003cT\u003e = Result\u003cT, Error\u003e;\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        from_avro_datum,\n        types::{Record, Value},\n        Codec, Reader, Schema, Writer,\n    };\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_default() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#;\n        let reader_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(\u0026reader_schema, \u0026input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(1, \"spades\".to_string())),\n            ])\n        );\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_string_value() {\n        let raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(\u0026schema, \u0026input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(2, \"clubs\".to_string())),\n            ])\n        );\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_resolution() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let reader_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"ninja\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::with_schema(\u0026reader_schema, \u0026input[..]).unwrap();\n        assert!(reader.next().unwrap().is_err());\n        assert!(reader.next().is_none());\n    }\n\n    //TODO: move where it fits better\n    #[test]\n    fn test_enum_no_reader_schema() {\n        let writer_raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"},\n                    {\n                        \"name\": \"c\",\n                        \"type\": {\n                            \"type\": \"enum\",\n                            \"name\": \"suit\",\n                            \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]\n                        },\n                        \"default\": \"spades\"\n                    }\n                ]\n            }\n        \"#;\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let mut writer = Writer::with_codec(\u0026writer_schema, Vec::new(), Codec::Null);\n        let mut record = Record::new(writer.schema()).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        record.put(\"c\", \"clubs\");\n        writer.append(record).unwrap();\n        let input = writer.into_inner().unwrap();\n        let mut reader = Reader::new(\u0026input[..]).unwrap();\n        assert_eq!(\n            reader.next().unwrap().unwrap(),\n            Value::Record(vec![\n                (\"a\".to_string(), Value::Long(27)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n                (\"c\".to_string(), Value::Enum(2, \"clubs\".to_string())),\n            ])\n        );\n    }\n\n    #[test]\n    fn test_illformed_length() {\n        let raw_schema = r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#;\n\n        let schema = Schema::parse_str(raw_schema).unwrap();\n\n        // Would allocated 18446744073709551605 bytes\n        let illformed: \u0026[u8] = \u0026[0x3e, 0x15, 0xff, 0x1f, 0x15, 0xff];\n\n        let value = from_avro_datum(\u0026schema, \u0026mut \u0026*illformed, None);\n        assert!(value.is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","rabin.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Implementation of the Rabin fingerprint algorithm\nuse byteorder::{ByteOrder, LittleEndian};\nuse digest::{consts::U8, generic_array::GenericArray, FixedOutput, Reset, Update};\nuse lazy_static::lazy_static;\n\nconst EMPTY: i64 = -4513414715797952619;\n\nlazy_static! {\n    static ref FPTABLE: [i64; 256] = {\n        let mut fp_table: [i64; 256] = [0; 256];\n        for i in 0..256 {\n            let mut fp = i;\n            for _ in 0..8 {\n                fp = (fp as u64 \u003e\u003e 1) as i64 ^ (EMPTY \u0026 -(fp \u0026 1));\n            }\n            fp_table[i as usize] = fp\n        }\n        fp_table\n    };\n}\n\n/// Implementation of the Rabin fingerprint algorithm using the Digest trait as described in [schema_fingerprints](https://avro.apache.org/docs/current/spec.html#schema_fingerprints).\n///\n/// The digest is returned as the 8-byte little-endian encoding of the Rabin hash.\n/// This is what is used for avro [single object encoding](https://avro.apache.org/docs/current/spec.html#single_object_encoding)\n///\n/// ```rust\n/// use avro_rs::rabin::Rabin;\n/// use digest::Digest;\n/// use hex_literal::hex;\n///\n/// // create the Rabin hasher\n/// let mut hasher = Rabin::new();\n///\n/// // add the data\n/// hasher.update(b\"hello world\");\n///\n/// // read hash digest and consume hasher\n/// let result = hasher.finalize();\n///\n/// assert_eq!(result[..], hex!(\"60335ba6d0415528\"));\n/// ```\n///\n/// To convert the digest to the commonly used 64-bit integer value, you can use the byteorder crate:\n///\n/// ```rust\n/// # use avro_rs::rabin::Rabin;\n/// # use digest::Digest;\n/// # use hex_literal::hex;\n///\n/// # let mut hasher = Rabin::new();\n///\n/// # hasher.update(b\"hello world\");\n///\n/// # let result = hasher.finalize();\n///\n/// # assert_eq!(result[..], hex!(\"60335ba6d0415528\"));\n/// use byteorder::{ByteOrder, LittleEndian};\n///\n/// let i = LittleEndian::read_i64(\u0026result.to_vec());\n///\n/// assert_eq!(i, 2906301498937520992)\n/// ```\n#[derive(Clone)]\npub struct Rabin {\n    result: i64,\n}\n\nimpl Default for Rabin {\n    fn default() -\u003e Self {\n        Rabin { result: EMPTY }\n    }\n}\n\nimpl Update for Rabin {\n    fn update(\u0026mut self, input: impl AsRef\u003c[u8]\u003e) {\n        for b in input.as_ref() {\n            self.result = (self.result as u64 \u003e\u003e 8) as i64\n                ^ FPTABLE[((self.result ^ *b as i64) \u0026 0xff) as usize];\n        }\n    }\n}\n\nimpl FixedOutput for Rabin {\n    // 8-byte little-endian form of the i64\n    // See: https://avro.apache.org/docs/current/spec.html#single_object_encoding\n    type OutputSize = U8;\n\n    fn finalize_into(self, out: \u0026mut GenericArray\u003cu8, Self::OutputSize\u003e) {\n        LittleEndian::write_i64(out, self.result);\n    }\n\n    fn finalize_into_reset(\u0026mut self, out: \u0026mut GenericArray\u003cu8, Self::OutputSize\u003e) {\n        LittleEndian::write_i64(out, self.result);\n        self.result = EMPTY;\n    }\n}\n\nimpl Reset for Rabin {\n    fn reset(\u0026mut self) {\n        self.result = EMPTY;\n    }\n}\n\ndigest::impl_write!(Rabin);\n\n#[cfg(test)]\nmod tests {\n    use super::Rabin;\n    use byteorder::{ByteOrder, LittleEndian};\n    use digest::Digest;\n\n    // See: https://github.com/apache/avro/blob/master/share/test/data/schema-tests.txt\n    #[test]\n    fn test1() {\n        let data: \u0026[(\u0026str, i64)] = \u0026[\n            (r#\"\"null\"\"#, 7195948357588979594),\n            (r#\"\"boolean\"\"#, -6970731678124411036),\n            (\n                r#\"{\"name\":\"foo\",\"type\":\"fixed\",\"size\":15}\"#,\n                1756455273707447556,\n            ),\n            (\n                r#\"{\"name\":\"PigValue\",\"type\":\"record\",\"fields\":[{\"name\":\"value\",\"type\":[\"null\",\"int\",\"long\",\"PigValue\"]}]}\"#,\n                -1759257747318642341,\n            ),\n        ];\n\n        let mut hasher = Rabin::new();\n\n        for (s, fp) in data {\n            hasher.update(s.as_bytes());\n            let result = LittleEndian::read_i64(\u0026hasher.finalize_reset().to_vec());\n            assert_eq!(*fp, result);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","reader.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling reading from Avro format at user level.\nuse crate::{decode::decode, schema::Schema, types::Value, util, AvroResult, Codec, Error};\nuse serde_json::from_slice;\nuse std::{\n    io::{ErrorKind, Read},\n    str::FromStr,\n};\n\n// Internal Block reader.\n#[derive(Debug, Clone)]\nstruct Block\u003cR\u003e {\n    reader: R,\n    // Internal buffering to reduce allocation.\n    buf: Vec\u003cu8\u003e,\n    buf_idx: usize,\n    // Number of elements expected to exist within this block.\n    message_count: usize,\n    marker: [u8; 16],\n    codec: Codec,\n    writer_schema: Schema,\n}\n\nimpl\u003cR: Read\u003e Block\u003cR\u003e {\n    fn new(reader: R) -\u003e AvroResult\u003cBlock\u003cR\u003e\u003e {\n        let mut block = Block {\n            reader,\n            codec: Codec::Null,\n            writer_schema: Schema::Null,\n            buf: vec![],\n            buf_idx: 0,\n            message_count: 0,\n            marker: [0; 16],\n        };\n\n        block.read_header()?;\n        Ok(block)\n    }\n\n    /// Try to read the header and to set the writer `Schema`, the `Codec` and the marker based on\n    /// its content.\n    fn read_header(\u0026mut self) -\u003e AvroResult\u003c()\u003e {\n        let meta_schema = Schema::Map(Box::new(Schema::Bytes));\n\n        let mut buf = [0u8; 4];\n        self.reader\n            .read_exact(\u0026mut buf)\n            .map_err(Error::ReadHeader)?;\n\n        if buf != [b'O', b'b', b'j', 1u8] {\n            return Err(Error::HeaderMagic);\n        }\n\n        if let Value::Map(meta) = decode(\u0026meta_schema, \u0026mut self.reader)? {\n            // TODO: surface original parse schema errors instead of coalescing them here\n            let json = meta\n                .get(\"avro.schema\")\n                .and_then(|bytes| {\n                    if let Value::Bytes(ref bytes) = *bytes {\n                        from_slice(bytes.as_ref()).ok()\n                    } else {\n                        None\n                    }\n                })\n                .ok_or(Error::GetAvroSchemaFromMap)?;\n            self.writer_schema = Schema::parse(\u0026json)?;\n\n            if let Some(codec) = meta\n                .get(\"avro.codec\")\n                .and_then(|codec| {\n                    if let Value::Bytes(ref bytes) = *codec {\n                        std::str::from_utf8(bytes.as_ref()).ok()\n                    } else {\n                        None\n                    }\n                })\n                .and_then(|codec| Codec::from_str(codec).ok())\n            {\n                self.codec = codec;\n            }\n        } else {\n            return Err(Error::GetHeaderMetadata);\n        }\n\n        self.reader\n            .read_exact(\u0026mut self.marker)\n            .map_err(Error::ReadMarker)\n    }\n\n    fn fill_buf(\u0026mut self, n: usize) -\u003e AvroResult\u003c()\u003e {\n        // The buffer needs to contain exactly `n` elements, otherwise codecs will potentially read\n        // invalid bytes.\n        //\n        // The are two cases to handle here:\n        //\n        // 1. `n \u003e self.buf.len()`:\n        //    In this case we call `Vec::resize`, which guarantees that `self.buf.len() == n`.\n        // 2. `n \u003c self.buf.len()`:\n        //    We need to resize to ensure that the buffer len is safe to read `n` elements.\n        //\n        // TODO: Figure out a way to avoid having to truncate for the second case.\n        self.buf.resize(n, 0);\n        self.reader\n            .read_exact(\u0026mut self.buf)\n            .map_err(Error::ReadIntoBuf)?;\n        self.buf_idx = 0;\n        Ok(())\n    }\n\n    /// Try to read a data block, also performing schema resolution for the objects contained in\n    /// the block. The objects are stored in an internal buffer to the `Reader`.\n    fn read_block_next(\u0026mut self) -\u003e AvroResult\u003c()\u003e {\n        assert!(self.is_empty(), \"Expected self to be empty!\");\n        match util::read_long(\u0026mut self.reader) {\n            Ok(block_len) =\u003e {\n                self.message_count = block_len as usize;\n                let block_bytes = util::read_long(\u0026mut self.reader)?;\n                self.fill_buf(block_bytes as usize)?;\n                let mut marker = [0u8; 16];\n                self.reader\n                    .read_exact(\u0026mut marker)\n                    .map_err(Error::ReadBlockMarker)?;\n\n                if marker != self.marker {\n                    return Err(Error::GetBlockMarker);\n                }\n\n                // NOTE (JAB): This doesn't fit this Reader pattern very well.\n                // `self.buf` is a growable buffer that is reused as the reader is iterated.\n                // For non `Codec::Null` variants, `decompress` will allocate a new `Vec`\n                // and replace `buf` with the new one, instead of reusing the same buffer.\n                // We can address this by using some \"limited read\" type to decode directly\n                // into the buffer. But this is fine, for now.\n                self.codec.decompress(\u0026mut self.buf)\n            }\n            Err(Error::ReadVariableIntegerBytes(io_err)) =\u003e {\n                if let ErrorKind::UnexpectedEof = io_err.kind() {\n                    // to not return any error in case we only finished to read cleanly from the stream\n                    Ok(())\n                } else {\n                    Err(Error::ReadVariableIntegerBytes(io_err))\n                }\n            }\n            Err(e) =\u003e Err(e),\n        }\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.message_count\n    }\n\n    fn is_empty(\u0026self) -\u003e bool {\n        self.len() == 0\n    }\n\n    fn read_next(\u0026mut self, read_schema: Option\u003c\u0026Schema\u003e) -\u003e AvroResult\u003cOption\u003cValue\u003e\u003e {\n        if self.is_empty() {\n            self.read_block_next()?;\n            if self.is_empty() {\n                return Ok(None);\n            }\n        }\n\n        let mut block_bytes = \u0026self.buf[self.buf_idx..];\n        let b_original = block_bytes.len();\n        let item = from_avro_datum(\u0026self.writer_schema, \u0026mut block_bytes, read_schema)?;\n        self.buf_idx += b_original - block_bytes.len();\n        self.message_count -= 1;\n        Ok(Some(item))\n    }\n}\n\n/// Main interface for reading Avro formatted values.\n///\n/// To be used as an iterator:\n///\n/// ```no_run\n/// # use avro_rs::Reader;\n/// # use std::io::Cursor;\n/// # let input = Cursor::new(Vec::\u003cu8\u003e::new());\n/// for value in Reader::new(input).unwrap() {\n///     match value {\n///         Ok(v) =\u003e println!(\"{:?}\", v),\n///         Err(e) =\u003e println!(\"Error: {}\", e),\n///     };\n/// }\n/// ```\npub struct Reader\u003c'a, R\u003e {\n    block: Block\u003cR\u003e,\n    reader_schema: Option\u003c\u0026'a Schema\u003e,\n    errored: bool,\n    should_resolve_schema: bool,\n}\n\nimpl\u003c'a, R: Read\u003e Reader\u003c'a, R\u003e {\n    /// Creates a `Reader` given something implementing the `io::Read` trait to read from.\n    /// No reader `Schema` will be set.\n    ///\n    /// **NOTE** The avro header is going to be read automatically upon creation of the `Reader`.\n    pub fn new(reader: R) -\u003e AvroResult\u003cReader\u003c'a, R\u003e\u003e {\n        let block = Block::new(reader)?;\n        let reader = Reader {\n            block,\n            reader_schema: None,\n            errored: false,\n            should_resolve_schema: false,\n        };\n        Ok(reader)\n    }\n\n    /// Creates a `Reader` given a reader `Schema` and something implementing the `io::Read` trait\n    /// to read from.\n    ///\n    /// **NOTE** The avro header is going to be read automatically upon creation of the `Reader`.\n    pub fn with_schema(schema: \u0026'a Schema, reader: R) -\u003e AvroResult\u003cReader\u003c'a, R\u003e\u003e {\n        let block = Block::new(reader)?;\n        let mut reader = Reader {\n            block,\n            reader_schema: Some(schema),\n            errored: false,\n            should_resolve_schema: false,\n        };\n        // Check if the reader and writer schemas disagree.\n        reader.should_resolve_schema = reader.writer_schema() != schema;\n        Ok(reader)\n    }\n\n    /// Get a reference to the writer `Schema`.\n    pub fn writer_schema(\u0026self) -\u003e \u0026Schema {\n        \u0026self.block.writer_schema\n    }\n\n    /// Get a reference to the optional reader `Schema`.\n    pub fn reader_schema(\u0026self) -\u003e Option\u003c\u0026Schema\u003e {\n        self.reader_schema\n    }\n\n    #[inline]\n    fn read_next(\u0026mut self) -\u003e AvroResult\u003cOption\u003cValue\u003e\u003e {\n        let read_schema = if self.should_resolve_schema {\n            self.reader_schema\n        } else {\n            None\n        };\n\n        self.block.read_next(read_schema)\n    }\n}\n\nimpl\u003c'a, R: Read\u003e Iterator for Reader\u003c'a, R\u003e {\n    type Item = AvroResult\u003cValue\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        // to prevent keep on reading after the first error occurs\n        if self.errored {\n            return None;\n        };\n        match self.read_next() {\n            Ok(opt) =\u003e opt.map(Ok),\n            Err(e) =\u003e {\n                self.errored = true;\n                Some(Err(e))\n            }\n        }\n    }\n}\n\n/// Decode a `Value` encoded in Avro format given its `Schema` and anything implementing `io::Read`\n/// to read from.\n///\n/// In case a reader `Schema` is provided, schema resolution will also be performed.\n///\n/// **NOTE** This function has a quite small niche of usage and does NOT take care of reading the\n/// header and consecutive data blocks; use [`Reader`](struct.Reader.html) if you don't know what\n/// you are doing, instead.\npub fn from_avro_datum\u003cR: Read\u003e(\n    writer_schema: \u0026Schema,\n    reader: \u0026mut R,\n    reader_schema: Option\u003c\u0026Schema\u003e,\n) -\u003e AvroResult\u003cValue\u003e {\n    let value = decode(writer_schema, reader)?;\n    match reader_schema {\n        Some(schema) =\u003e value.resolve(schema),\n        None =\u003e Ok(value),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{types::Record, Reader};\n    use std::io::Cursor;\n\n    const SCHEMA: \u0026str = r#\"\n    {\n      \"type\": \"record\",\n      \"name\": \"test\",\n      \"fields\": [\n        {\n          \"name\": \"a\",\n          \"type\": \"long\",\n          \"default\": 42\n        },\n        {\n          \"name\": \"b\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n    \"#;\n    const UNION_SCHEMA: \u0026str = r#\"[\"null\", \"long\"]\"#;\n    const ENCODED: \u0026[u8] = \u0026[\n        79u8, 98u8, 106u8, 1u8, 4u8, 22u8, 97u8, 118u8, 114u8, 111u8, 46u8, 115u8, 99u8, 104u8,\n        101u8, 109u8, 97u8, 222u8, 1u8, 123u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8,\n        114u8, 101u8, 99u8, 111u8, 114u8, 100u8, 34u8, 44u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8,\n        58u8, 34u8, 116u8, 101u8, 115u8, 116u8, 34u8, 44u8, 34u8, 102u8, 105u8, 101u8, 108u8,\n        100u8, 115u8, 34u8, 58u8, 91u8, 123u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8, 58u8, 34u8,\n        97u8, 34u8, 44u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8, 108u8, 111u8, 110u8,\n        103u8, 34u8, 44u8, 34u8, 100u8, 101u8, 102u8, 97u8, 117u8, 108u8, 116u8, 34u8, 58u8, 52u8,\n        50u8, 125u8, 44u8, 123u8, 34u8, 110u8, 97u8, 109u8, 101u8, 34u8, 58u8, 34u8, 98u8, 34u8,\n        44u8, 34u8, 116u8, 121u8, 112u8, 101u8, 34u8, 58u8, 34u8, 115u8, 116u8, 114u8, 105u8,\n        110u8, 103u8, 34u8, 125u8, 93u8, 125u8, 20u8, 97u8, 118u8, 114u8, 111u8, 46u8, 99u8, 111u8,\n        100u8, 101u8, 99u8, 8u8, 110u8, 117u8, 108u8, 108u8, 0u8, 94u8, 61u8, 54u8, 221u8, 190u8,\n        207u8, 108u8, 180u8, 158u8, 57u8, 114u8, 40u8, 173u8, 199u8, 228u8, 239u8, 4u8, 20u8, 54u8,\n        6u8, 102u8, 111u8, 111u8, 84u8, 6u8, 98u8, 97u8, 114u8, 94u8, 61u8, 54u8, 221u8, 190u8,\n        207u8, 108u8, 180u8, 158u8, 57u8, 114u8, 40u8, 173u8, 199u8, 228u8, 239u8,\n    ];\n\n    #[test]\n    fn test_from_avro_datum() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut encoded: \u0026'static [u8] = \u0026[54, 6, 102, 111, 111];\n\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        let expected = record.into();\n\n        assert_eq!(\n            from_avro_datum(\u0026schema, \u0026mut encoded, None).unwrap(),\n            expected\n        );\n    }\n\n    #[test]\n    fn test_null_union() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let mut encoded: \u0026'static [u8] = \u0026[2, 0];\n\n        assert_eq!(\n            from_avro_datum(\u0026schema, \u0026mut encoded, None).unwrap(),\n            Value::Union(Box::new(Value::Long(0)))\n        );\n    }\n\n    #[test]\n    fn test_reader_iterator() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let reader = Reader::with_schema(\u0026schema, ENCODED).unwrap();\n\n        let mut record1 = Record::new(\u0026schema).unwrap();\n        record1.put(\"a\", 27i64);\n        record1.put(\"b\", \"foo\");\n\n        let mut record2 = Record::new(\u0026schema).unwrap();\n        record2.put(\"a\", 42i64);\n        record2.put(\"b\", \"bar\");\n\n        let expected = vec![record1.into(), record2.into()];\n\n        for (i, value) in reader.enumerate() {\n            assert_eq!(value.unwrap(), expected[i]);\n        }\n    }\n\n    #[test]\n    fn test_reader_invalid_header() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let invalid = ENCODED.to_owned().into_iter().skip(1).collect::\u003cVec\u003cu8\u003e\u003e();\n        assert!(Reader::with_schema(\u0026schema, \u0026invalid[..]).is_err());\n    }\n\n    #[test]\n    fn test_reader_invalid_block() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let invalid = ENCODED\n            .to_owned()\n            .into_iter()\n            .rev()\n            .skip(19)\n            .collect::\u003cVec\u003cu8\u003e\u003e()\n            .into_iter()\n            .rev()\n            .collect::\u003cVec\u003cu8\u003e\u003e();\n        let reader = Reader::with_schema(\u0026schema, \u0026invalid[..]).unwrap();\n        for value in reader {\n            assert!(value.is_err());\n        }\n    }\n\n    #[test]\n    fn test_reader_empty_buffer() {\n        let empty = Cursor::new(Vec::new());\n        assert!(Reader::new(empty).is_err());\n    }\n\n    #[test]\n    fn test_reader_only_header() {\n        let invalid = ENCODED\n            .to_owned()\n            .into_iter()\n            .take(165)\n            .collect::\u003cVec\u003cu8\u003e\u003e();\n        let reader = Reader::new(\u0026invalid[..]).unwrap();\n        for value in reader {\n            assert!(value.is_err());\n        }\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":102},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","schema.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for parsing and interacting with schemas in Avro format.\nuse crate::{error::Error, types, util::MapHelper, AvroResult};\nuse digest::Digest;\nuse lazy_static::lazy_static;\nuse regex::Regex;\nuse serde::{\n    ser::{SerializeMap, SerializeSeq},\n    Deserialize, Serialize, Serializer,\n};\nuse serde_json::{Map, Value};\nuse std::{\n    borrow::Cow,\n    collections::{HashMap, HashSet},\n    convert::TryInto,\n    fmt,\n    str::FromStr,\n};\nuse strum_macros::{EnumDiscriminants, EnumString};\n\nlazy_static! {\n    static ref ENUM_SYMBOL_NAME: Regex = Regex::new(r\"[A-Za-z_][A-Za-z0-9_]*\").unwrap();\n}\n\n/// Represents an Avro schema fingerprint\n/// More information about Avro schema fingerprints can be found in the\n/// [Avro Schema Fingerprint documentation](https://avro.apache.org/docs/current/spec.html#schema_fingerprints)\npub struct SchemaFingerprint {\n    pub bytes: Vec\u003cu8\u003e,\n}\n\nimpl fmt::Display for SchemaFingerprint {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(\n            f,\n            \"{}\",\n            self.bytes\n                .iter()\n                .map(|byte| format!(\"{:02x}\", byte))\n                .collect::\u003cVec\u003cString\u003e\u003e()\n                .join(\"\")\n        )\n    }\n}\n\n/// Represents any valid Avro schema\n/// More information about Avro schemas can be found in the\n/// [Avro Specification](https://avro.apache.org/docs/current/spec.html#schemas)\n#[derive(Clone, Debug, EnumDiscriminants)]\n#[strum_discriminants(name(SchemaKind), derive(Hash))]\npub enum Schema {\n    /// A `null` Avro schema.\n    Null,\n    /// A `boolean` Avro schema.\n    Boolean,\n    /// An `int` Avro schema.\n    Int,\n    /// A `long` Avro schema.\n    Long,\n    /// A `float` Avro schema.\n    Float,\n    /// A `double` Avro schema.\n    Double,\n    /// A `bytes` Avro schema.\n    /// `Bytes` represents a sequence of 8-bit unsigned bytes.\n    Bytes,\n    /// A `string` Avro schema.\n    /// `String` represents a unicode character sequence.\n    String,\n    /// A `array` Avro schema. Avro arrays are required to have the same type for each element.\n    /// This variant holds the `Schema` for the array element type.\n    Array(Box\u003cSchema\u003e),\n    /// A `map` Avro schema.\n    /// `Map` holds a pointer to the `Schema` of its values, which must all be the same schema.\n    /// `Map` keys are assumed to be `string`.\n    Map(Box\u003cSchema\u003e),\n    /// A `union` Avro schema.\n    Union(UnionSchema),\n    /// A `record` Avro schema.\n    ///\n    /// The `lookup` table maps field names to their position in the `Vec`\n    /// of `fields`.\n    Record {\n        name: Name,\n        doc: Documentation,\n        fields: Vec\u003cRecordField\u003e,\n        lookup: HashMap\u003cString, usize\u003e,\n    },\n    /// An `enum` Avro schema.\n    Enum {\n        name: Name,\n        doc: Documentation,\n        symbols: Vec\u003cString\u003e,\n    },\n    /// A `fixed` Avro schema.\n    Fixed { name: Name, size: usize },\n    /// Logical type which represents `Decimal` values. The underlying type is serialized and\n    /// deserialized as `Schema::Bytes` or `Schema::Fixed`.\n    ///\n    /// `scale` defaults to 0 and is an integer greater than or equal to 0 and `precision` is an\n    /// integer greater than 0.\n    Decimal {\n        precision: DecimalMetadata,\n        scale: DecimalMetadata,\n        inner: Box\u003cSchema\u003e,\n    },\n    /// A universally unique identifier, annotating a string.\n    Uuid,\n    /// Logical type which represents the number of days since the unix epoch.\n    /// Serialization format is `Schema::Int`.\n    Date,\n    /// The time of day in number of milliseconds after midnight with no reference any calendar,\n    /// time zone or date in particular.\n    TimeMillis,\n    /// The time of day in number of microseconds after midnight with no reference any calendar,\n    /// time zone or date in particular.\n    TimeMicros,\n    /// An instant in time represented as the number of milliseconds after the UNIX epoch.\n    TimestampMillis,\n    /// An instant in time represented as the number of microseconds after the UNIX epoch.\n    TimestampMicros,\n    /// An amount of time defined by a number of months, days and milliseconds.\n    Duration,\n}\n\nimpl PartialEq for Schema {\n    /// Assess equality of two `Schema` based on [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.canonical_form() == other.canonical_form()\n    }\n}\n\nimpl SchemaKind {\n    pub fn is_primitive(self) -\u003e bool {\n        matches!(\n            self,\n            SchemaKind::Null\n                | SchemaKind::Boolean\n                | SchemaKind::Int\n                | SchemaKind::Long\n                | SchemaKind::Double\n                | SchemaKind::Float\n                | SchemaKind::Bytes\n                | SchemaKind::String,\n        )\n    }\n}\n\nimpl\u003c'a\u003e From\u003c\u0026'a types::Value\u003e for SchemaKind {\n    fn from(value: \u0026'a types::Value) -\u003e Self {\n        use crate::types::Value;\n        match value {\n            Value::Null =\u003e Self::Null,\n            Value::Boolean(_) =\u003e Self::Boolean,\n            Value::Int(_) =\u003e Self::Int,\n            Value::Long(_) =\u003e Self::Long,\n            Value::Float(_) =\u003e Self::Float,\n            Value::Double(_) =\u003e Self::Double,\n            Value::Bytes(_) =\u003e Self::Bytes,\n            Value::String(_) =\u003e Self::String,\n            Value::Array(_) =\u003e Self::Array,\n            Value::Map(_) =\u003e Self::Map,\n            Value::Union(_) =\u003e Self::Union,\n            Value::Record(_) =\u003e Self::Record,\n            Value::Enum(_, _) =\u003e Self::Enum,\n            Value::Fixed(_, _) =\u003e Self::Fixed,\n            Value::Decimal { .. } =\u003e Self::Decimal,\n            Value::Uuid(_) =\u003e Self::Uuid,\n            Value::Date(_) =\u003e Self::Date,\n            Value::TimeMillis(_) =\u003e Self::TimeMillis,\n            Value::TimeMicros(_) =\u003e Self::TimeMicros,\n            Value::TimestampMillis(_) =\u003e Self::TimestampMillis,\n            Value::TimestampMicros(_) =\u003e Self::TimestampMicros,\n            Value::Duration { .. } =\u003e Self::Duration,\n        }\n    }\n}\n\n/// Represents names for `record`, `enum` and `fixed` Avro schemas.\n///\n/// Each of these `Schema`s have a `fullname` composed of two parts:\n///   * a name\n///   * a namespace\n///\n/// `aliases` can also be defined, to facilitate schema evolution.\n///\n/// More information about schema names can be found in the\n/// [Avro specification](https://avro.apache.org/docs/current/spec.html#names)\n#[derive(Clone, Debug, PartialEq, Deserialize)]\npub struct Name {\n    pub name: String,\n    pub namespace: Option\u003cString\u003e,\n    pub aliases: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Represents documentation for complex Avro schemas.\npub type Documentation = Option\u003cString\u003e;\n\nimpl Name {\n    /// Create a new `Name`.\n    /// No `namespace` nor `aliases` will be defined.\n    pub fn new(name: \u0026str) -\u003e Name {\n        Name {\n            name: name.to_owned(),\n            namespace: None,\n            aliases: None,\n        }\n    }\n\n    /// Parse a `serde_json::Value` into a `Name`.\n    fn parse(complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSelf\u003e {\n        let name = complex.name().ok_or(Error::GetNameField)?;\n\n        let namespace = complex.string(\"namespace\");\n\n        let aliases: Option\u003cVec\u003cString\u003e\u003e = complex\n            .get(\"aliases\")\n            .and_then(|aliases| aliases.as_array())\n            .and_then(|aliases| {\n                aliases\n                    .iter()\n                    .map(|alias| alias.as_str())\n                    .map(|alias| alias.map(|a| a.to_string()))\n                    .collect::\u003cOption\u003c_\u003e\u003e()\n            });\n\n        Ok(Name {\n            name,\n            namespace,\n            aliases,\n        })\n    }\n\n    /// Return the `fullname` of this `Name`\n    ///\n    /// More information about fullnames can be found in the\n    /// [Avro specification](https://avro.apache.org/docs/current/spec.html#names)\n    pub fn fullname(\u0026self, default_namespace: Option\u003c\u0026str\u003e) -\u003e String {\n        if self.name.contains('.') {\n            self.name.clone()\n        } else {\n            let namespace = self\n                .namespace\n                .as_ref()\n                .map(|s| s.as_ref())\n                .or(default_namespace);\n\n            match namespace {\n                Some(ref namespace) =\u003e format!(\"{}.{}\", namespace, self.name),\n                None =\u003e self.name.clone(),\n            }\n        }\n    }\n}\n\n/// Represents a `field` in a `record` Avro schema.\n#[derive(Clone, Debug, PartialEq)]\npub struct RecordField {\n    /// Name of the field.\n    pub name: String,\n    /// Documentation of the field.\n    pub doc: Documentation,\n    /// Default value of the field.\n    /// This value will be used when reading Avro datum if schema resolution\n    /// is enabled.\n    pub default: Option\u003cValue\u003e,\n    /// Schema of the field.\n    pub schema: Schema,\n    /// Order of the field.\n    ///\n    /// **NOTE** This currently has no effect.\n    pub order: RecordFieldOrder,\n    /// Position of the field in the list of `field` of its parent `Schema`\n    pub position: usize,\n}\n\n/// Represents any valid order for a `field` in a `record` Avro schema.\n#[derive(Clone, Debug, PartialEq, EnumString)]\n#[strum(serialize_all = \"kebab_case\")]\npub enum RecordFieldOrder {\n    Ascending,\n    Descending,\n    Ignore,\n}\n\nimpl RecordField {\n    /// Parse a `serde_json::Value` into a `RecordField`.\n    fn parse(field: \u0026Map\u003cString, Value\u003e, position: usize, parser: \u0026mut Parser) -\u003e AvroResult\u003cSelf\u003e {\n        let name = field.name().ok_or(Error::GetNameFieldFromRecord)?;\n\n        // TODO: \"type\" = \"\u003crecord name\u003e\"\n        let schema = parser.parse_complex(field)?;\n\n        let default = field.get(\"default\").cloned();\n\n        let order = field\n            .get(\"order\")\n            .and_then(|order| order.as_str())\n            .and_then(|order| RecordFieldOrder::from_str(order).ok())\n            .unwrap_or(RecordFieldOrder::Ascending);\n\n        Ok(RecordField {\n            name,\n            doc: field.doc(),\n            default,\n            schema,\n            order,\n            position,\n        })\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct UnionSchema {\n    pub(crate) schemas: Vec\u003cSchema\u003e,\n    // Used to ensure uniqueness of schema inputs, and provide constant time finding of the\n    // schema index given a value.\n    // **NOTE** that this approach does not work for named types, and will have to be modified\n    // to support that. A simple solution is to also keep a mapping of the names used.\n    variant_index: HashMap\u003cSchemaKind, usize\u003e,\n}\n\nimpl UnionSchema {\n    pub(crate) fn new(schemas: Vec\u003cSchema\u003e) -\u003e AvroResult\u003cSelf\u003e {\n        let mut vindex = HashMap::new();\n        for (i, schema) in schemas.iter().enumerate() {\n            if let Schema::Union(_) = schema {\n                return Err(Error::GetNestedUnion);\n            }\n            let kind = SchemaKind::from(schema);\n            if vindex.insert(kind, i).is_some() {\n                return Err(Error::GetUnionDuplicate);\n            }\n        }\n        Ok(UnionSchema {\n            schemas,\n            variant_index: vindex,\n        })\n    }\n\n    /// Returns a slice to all variants of this schema.\n    pub fn variants(\u0026self) -\u003e \u0026[Schema] {\n        \u0026self.schemas\n    }\n\n    /// Returns true if the first variant of this `UnionSchema` is `Null`.\n    pub fn is_nullable(\u0026self) -\u003e bool {\n        !self.schemas.is_empty() \u0026\u0026 self.schemas[0] == Schema::Null\n    }\n\n    /// Optionally returns a reference to the schema matched by this value, as well as its position\n    /// within this union.\n    pub fn find_schema(\u0026self, value: \u0026types::Value) -\u003e Option\u003c(usize, \u0026Schema)\u003e {\n        let type_index = \u0026SchemaKind::from(value);\n        if let Some(\u0026i) = self.variant_index.get(type_index) {\n            // fast path\n            Some((i, \u0026self.schemas[i]))\n        } else {\n            // slow path (required for matching logical types)\n            self.schemas\n                .iter()\n                .enumerate()\n                .find(|(_, schema)| value.validate(schema))\n        }\n    }\n}\n\n// No need to compare variant_index, it is derivative of schemas.\nimpl PartialEq for UnionSchema {\n    fn eq(\u0026self, other: \u0026UnionSchema) -\u003e bool {\n        self.schemas.eq(\u0026other.schemas)\n    }\n}\n\ntype DecimalMetadata = usize;\npub(crate) type Precision = DecimalMetadata;\npub(crate) type Scale = DecimalMetadata;\n\nfn parse_json_integer_for_decimal(value: \u0026serde_json::Number) -\u003e Result\u003cDecimalMetadata, Error\u003e {\n    Ok(if value.is_u64() {\n        let num = value\n            .as_u64()\n            .ok_or_else(|| Error::GetU64FromJson(value.clone()))?;\n        num.try_into()\n            .map_err(|e| Error::ConvertU64ToUsize(e, num))?\n    } else if value.is_i64() {\n        let num = value\n            .as_i64()\n            .ok_or_else(|| Error::GetI64FromJson(value.clone()))?;\n        num.try_into()\n            .map_err(|e| Error::ConvertI64ToUsize(e, num))?\n    } else {\n        return Err(Error::GetPrecisionOrScaleFromJson(value.clone()));\n    })\n}\n\n#[derive(Default)]\nstruct Parser {\n    input_schemas: HashMap\u003cString, Value\u003e,\n    input_order: Vec\u003cString\u003e,\n    parsed_schemas: HashMap\u003cString, Schema\u003e,\n}\n\nimpl Schema {\n    /// Converts `self` into its [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    pub fn canonical_form(\u0026self) -\u003e String {\n        let json = serde_json::to_value(self)\n            .unwrap_or_else(|e| panic!(\"cannot parse Schema from JSON: {0}\", e));\n        parsing_canonical_form(\u0026json)\n    }\n\n    /// Generate [fingerprint] of Schema's [Parsing Canonical Form].\n    ///\n    /// [Parsing Canonical Form]:\n    /// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\n    /// [fingerprint]:\n    /// https://avro.apache.org/docs/current/spec.html#schema_fingerprints\n    pub fn fingerprint\u003cD: Digest\u003e(\u0026self) -\u003e SchemaFingerprint {\n        let mut d = D::new();\n        d.update(self.canonical_form());\n        SchemaFingerprint {\n            bytes: d.finalize().to_vec(),\n        }\n    }\n\n    /// Create a `Schema` from a string representing a JSON Avro schema.\n    pub fn parse_str(input: \u0026str) -\u003e Result\u003cSchema, Error\u003e {\n        let mut parser = Parser::default();\n        parser.parse_str(input)\n    }\n\n    /// Create a array of `Schema`'s from a list of named JSON Avro schemas (Record, Enum, and\n    /// Fixed).\n    ///\n    /// It is allowed that the schemas have cross-dependencies; these will be resolved\n    /// during parsing.\n    ///\n    /// If two of the input schemas have the same fullname, an Error will be returned.\n    pub fn parse_list(input: \u0026[\u0026str]) -\u003e Result\u003cVec\u003cSchema\u003e, Error\u003e {\n        let mut input_schemas: HashMap\u003cString, Value\u003e = HashMap::with_capacity(input.len());\n        let mut input_order: Vec\u003cString\u003e = Vec::with_capacity(input.len());\n        for js in input {\n            let schema: Value = serde_json::from_str(js).map_err(Error::ParseSchemaJson)?;\n            if let Value::Object(inner) = \u0026schema {\n                let fullname = Name::parse(inner)?.fullname(None);\n                let previous_value = input_schemas.insert(fullname.clone(), schema);\n                if previous_value.is_some() {\n                    return Err(Error::NameCollision(fullname));\n                }\n                input_order.push(fullname);\n            } else {\n                return Err(Error::GetNameField);\n            }\n        }\n        let mut parser = Parser {\n            input_schemas,\n            input_order,\n            parsed_schemas: HashMap::with_capacity(input.len()),\n        };\n        parser.parse_list()\n    }\n\n    pub fn parse(value: \u0026Value) -\u003e AvroResult\u003cSchema\u003e {\n        let mut parser = Parser::default();\n        parser.parse(value)\n    }\n}\n\nimpl Parser {\n    /// Create a `Schema` from a string representing a JSON Avro schema.\n    fn parse_str(\u0026mut self, input: \u0026str) -\u003e Result\u003cSchema, Error\u003e {\n        // TODO: (#82) this should be a ParseSchemaError wrapping the JSON error\n        let value = serde_json::from_str(input).map_err(Error::ParseSchemaJson)?;\n        self.parse(\u0026value)\n    }\n\n    /// Create an array of `Schema`'s from an iterator of JSON Avro schemas. It is allowed that\n    /// the schemas have cross-dependencies; these will be resolved during parsing.\n    fn parse_list(\u0026mut self) -\u003e Result\u003cVec\u003cSchema\u003e, Error\u003e {\n        while !self.input_schemas.is_empty() {\n            let next_name = self\n                .input_schemas\n                .keys()\n                .next()\n                .expect(\"Input schemas unexpectedly empty\")\n                .to_owned();\n            let (name, value) = self\n                .input_schemas\n                .remove_entry(\u0026next_name)\n                .expect(\"Key unexpectedly missing\");\n            let parsed = self.parse(\u0026value)?;\n            self.parsed_schemas.insert(name, parsed);\n        }\n\n        let mut parsed_schemas = Vec::with_capacity(self.parsed_schemas.len());\n        for name in self.input_order.drain(0..) {\n            let parsed = self\n                .parsed_schemas\n                .remove(\u0026name)\n                .expect(\"One of the input schemas was unexpectedly not parsed\");\n            parsed_schemas.push(parsed);\n        }\n        Ok(parsed_schemas)\n    }\n\n    /// Create a `Schema` from a `serde_json::Value` representing a JSON Avro\n    /// schema.\n    fn parse(\u0026mut self, value: \u0026Value) -\u003e AvroResult\u003cSchema\u003e {\n        match *value {\n            Value::String(ref t) =\u003e self.parse_known_schema(t.as_str()),\n            Value::Object(ref data) =\u003e self.parse_complex(data),\n            Value::Array(ref data) =\u003e self.parse_union(data),\n            _ =\u003e Err(Error::ParseSchemaFromValidJson),\n        }\n    }\n\n    /// Parse a `serde_json::Value` representing an Avro type whose Schema is known into a\n    /// `Schema`. A Schema for a `serde_json::Value` is known if it is primitive or has\n    /// been parsed previously by the parsed and stored in its map of parsed_schemas.\n    fn parse_known_schema(\u0026mut self, name: \u0026str) -\u003e AvroResult\u003cSchema\u003e {\n        match name {\n            \"null\" =\u003e Ok(Schema::Null),\n            \"boolean\" =\u003e Ok(Schema::Boolean),\n            \"int\" =\u003e Ok(Schema::Int),\n            \"long\" =\u003e Ok(Schema::Long),\n            \"double\" =\u003e Ok(Schema::Double),\n            \"float\" =\u003e Ok(Schema::Float),\n            \"bytes\" =\u003e Ok(Schema::Bytes),\n            \"string\" =\u003e Ok(Schema::String),\n            _ =\u003e self.fetch_schema(name),\n        }\n    }\n\n    /// Given a name, tries to retrieve the parsed schema from `parsed_schemas`.\n    /// If a parsed schema is not found, it checks if a json  with that name exists\n    /// in `input_schemas` and then parses it  (removing it from `input_schemas`)\n    /// and adds the parsed schema to `parsed_schemas`\n    ///\n    /// This method allows schemas definitions that depend on other types to\n    /// parse their dependencies (or look them up if already parsed).\n    fn fetch_schema(\u0026mut self, name: \u0026str) -\u003e AvroResult\u003cSchema\u003e {\n        if let Some(parsed) = self.parsed_schemas.get(name) {\n            return Ok(parsed.clone());\n        }\n        let value = self\n            .input_schemas\n            .remove(name)\n            .ok_or_else(|| Error::ParsePrimitive(name.into()))?;\n        let parsed = self.parse(\u0026value)?;\n        self.parsed_schemas.insert(name.to_string(), parsed.clone());\n        Ok(parsed)\n    }\n\n    fn parse_precision_and_scale(\n        complex: \u0026Map\u003cString, Value\u003e,\n    ) -\u003e Result\u003c(Precision, Scale), Error\u003e {\n        fn get_decimal_integer(\n            complex: \u0026Map\u003cString, Value\u003e,\n            key: \u0026'static str,\n        ) -\u003e Result\u003cDecimalMetadata, Error\u003e {\n            match complex.get(key) {\n                Some(\u0026Value::Number(ref value)) =\u003e parse_json_integer_for_decimal(value),\n                None =\u003e Err(Error::GetDecimalMetadataFromJson(key)),\n                Some(precision) =\u003e Err(Error::GetDecimalPrecisionFromJson {\n                    key: key.into(),\n                    precision: precision.clone(),\n                }),\n            }\n        }\n        let precision = get_decimal_integer(complex, \"precision\")?;\n        let scale = get_decimal_integer(complex, \"scale\")?;\n        Ok((precision, scale))\n    }\n\n    /// Parse a `serde_json::Value` representing a complex Avro type into a\n    /// `Schema`.\n    ///\n    /// Avro supports \"recursive\" definition of types.\n    /// e.g: {\"type\": {\"type\": \"string\"}}\n    fn parse_complex(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        fn logical_verify_type(\n            complex: \u0026Map\u003cString, Value\u003e,\n            kinds: \u0026[SchemaKind],\n            parser: \u0026mut Parser,\n        ) -\u003e AvroResult\u003cSchema\u003e {\n            match complex.get(\"type\") {\n                Some(value) =\u003e {\n                    let ty = parser.parse(value)?;\n                    if kinds\n                        .iter()\n                        .any(|\u0026kind| SchemaKind::from(ty.clone()) == kind)\n                    {\n                        Ok(ty)\n                    } else {\n                        Err(Error::GetLogicalTypeVariant(value.clone()))\n                    }\n                }\n                None =\u003e Err(Error::GetLogicalTypeField),\n            }\n        }\n        match complex.get(\"logicalType\") {\n            Some(\u0026Value::String(ref t)) =\u003e match t.as_str() {\n                \"decimal\" =\u003e {\n                    let inner = Box::new(logical_verify_type(\n                        complex,\n                        \u0026[SchemaKind::Fixed, SchemaKind::Bytes],\n                        self,\n                    )?);\n\n                    let (precision, scale) = Self::parse_precision_and_scale(complex)?;\n\n                    return Ok(Schema::Decimal {\n                        precision,\n                        scale,\n                        inner,\n                    });\n                }\n                \"uuid\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::String], self)?;\n                    return Ok(Schema::Uuid);\n                }\n                \"date\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Int], self)?;\n                    return Ok(Schema::Date);\n                }\n                \"time-millis\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Int], self)?;\n                    return Ok(Schema::TimeMillis);\n                }\n                \"time-micros\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimeMicros);\n                }\n                \"timestamp-millis\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimestampMillis);\n                }\n                \"timestamp-micros\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Long], self)?;\n                    return Ok(Schema::TimestampMicros);\n                }\n                \"duration\" =\u003e {\n                    logical_verify_type(complex, \u0026[SchemaKind::Fixed], self)?;\n                    return Ok(Schema::Duration);\n                }\n                // In this case, of an unknown logical type, we just pass through to the underlying\n                // type.\n                _ =\u003e {}\n            },\n            // The spec says to ignore invalid logical types and just continue through to the\n            // underlying type - It is unclear whether that applies to this case or not, where the\n            // `logicalType` is not a string.\n            Some(_) =\u003e return Err(Error::GetLogicalTypeFieldType),\n            _ =\u003e {}\n        }\n        match complex.get(\"type\") {\n            Some(\u0026Value::String(ref t)) =\u003e match t.as_str() {\n                \"record\" =\u003e self.parse_record(complex),\n                \"enum\" =\u003e Self::parse_enum(complex),\n                \"array\" =\u003e self.parse_array(complex),\n                \"map\" =\u003e self.parse_map(complex),\n                \"fixed\" =\u003e Self::parse_fixed(complex),\n                other =\u003e self.parse_known_schema(other),\n            },\n            Some(\u0026Value::Object(ref data)) =\u003e self.parse_complex(data),\n            Some(\u0026Value::Array(ref variants)) =\u003e self.parse_union(variants),\n            Some(unknown) =\u003e Err(Error::GetComplexType(unknown.clone())),\n            None =\u003e Err(Error::GetComplexTypeField),\n        }\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro record type into a\n    /// `Schema`.\n    fn parse_record(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        let name = Name::parse(complex)?;\n\n        let mut lookup = HashMap::new();\n\n        let fields: Vec\u003cRecordField\u003e = complex\n            .get(\"fields\")\n            .and_then(|fields| fields.as_array())\n            .ok_or(Error::GetRecordFieldsJson)\n            .and_then(|fields| {\n                fields\n                    .iter()\n                    .filter_map(|field| field.as_object())\n                    .enumerate()\n                    .map(|(position, field)| RecordField::parse(field, position, self))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()\n            })?;\n\n        for field in \u0026fields {\n            lookup.insert(field.name.clone(), field.position);\n        }\n\n        Ok(Schema::Record {\n            name,\n            doc: complex.doc(),\n            fields,\n            lookup,\n        })\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro enum type into a\n    /// `Schema`.\n    fn parse_enum(complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        let name = Name::parse(complex)?;\n\n        let symbols: Vec\u003cString\u003e = complex\n            .get(\"symbols\")\n            .and_then(|v| v.as_array())\n            .ok_or(Error::GetEnumSymbolsField)\n            .and_then(|symbols| {\n                symbols\n                    .iter()\n                    .map(|symbol| symbol.as_str().map(|s| s.to_string()))\n                    .collect::\u003cOption\u003c_\u003e\u003e()\n                    .ok_or(Error::GetEnumSymbols)\n            })?;\n\n        let mut existing_symbols: HashSet\u003c\u0026String\u003e = HashSet::with_capacity(symbols.len());\n        for symbol in symbols.iter() {\n            // Ensure enum symbol names match [A-Za-z_][A-Za-z0-9_]*\n            if !ENUM_SYMBOL_NAME.is_match(symbol) {\n                return Err(Error::EnumSymbolName(symbol.to_string()));\n            }\n\n            // Ensure there are no duplicate symbols\n            if existing_symbols.contains(\u0026symbol) {\n                return Err(Error::EnumSymbolDuplicate(symbol.to_string()));\n            }\n\n            existing_symbols.insert(symbol);\n        }\n\n        Ok(Schema::Enum {\n            name,\n            doc: complex.doc(),\n            symbols,\n        })\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro array type into a\n    /// `Schema`.\n    fn parse_array(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        complex\n            .get(\"items\")\n            .ok_or(Error::GetArrayItemsField)\n            .and_then(|items| self.parse(items))\n            .map(|schema| Schema::Array(Box::new(schema)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro map type into a\n    /// `Schema`.\n    fn parse_map(\u0026mut self, complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        complex\n            .get(\"values\")\n            .ok_or(Error::GetMapValuesField)\n            .and_then(|items| self.parse(items))\n            .map(|schema| Schema::Map(Box::new(schema)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro union type into a\n    /// `Schema`.\n    fn parse_union(\u0026mut self, items: \u0026[Value]) -\u003e AvroResult\u003cSchema\u003e {\n        items\n            .iter()\n            .map(|v| self.parse(v))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .and_then(|schemas| Ok(Schema::Union(UnionSchema::new(schemas)?)))\n    }\n\n    /// Parse a `serde_json::Value` representing a Avro fixed type into a\n    /// `Schema`.\n    fn parse_fixed(complex: \u0026Map\u003cString, Value\u003e) -\u003e AvroResult\u003cSchema\u003e {\n        let name = Name::parse(complex)?;\n\n        let size = complex\n            .get(\"size\")\n            .and_then(|v| v.as_i64())\n            .ok_or(Error::GetFixedSizeField)?;\n\n        Ok(Schema::Fixed {\n            name,\n            size: size as usize,\n        })\n    }\n}\n\nimpl Serialize for Schema {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Schema::Null =\u003e serializer.serialize_str(\"null\"),\n            Schema::Boolean =\u003e serializer.serialize_str(\"boolean\"),\n            Schema::Int =\u003e serializer.serialize_str(\"int\"),\n            Schema::Long =\u003e serializer.serialize_str(\"long\"),\n            Schema::Float =\u003e serializer.serialize_str(\"float\"),\n            Schema::Double =\u003e serializer.serialize_str(\"double\"),\n            Schema::Bytes =\u003e serializer.serialize_str(\"bytes\"),\n            Schema::String =\u003e serializer.serialize_str(\"string\"),\n            Schema::Array(ref inner) =\u003e {\n                let mut map = serializer.serialize_map(Some(2))?;\n                map.serialize_entry(\"type\", \"array\")?;\n                map.serialize_entry(\"items\", \u0026*inner.clone())?;\n                map.end()\n            }\n            Schema::Map(ref inner) =\u003e {\n                let mut map = serializer.serialize_map(Some(2))?;\n                map.serialize_entry(\"type\", \"map\")?;\n                map.serialize_entry(\"values\", \u0026*inner.clone())?;\n                map.end()\n            }\n            Schema::Union(ref inner) =\u003e {\n                let variants = inner.variants();\n                let mut seq = serializer.serialize_seq(Some(variants.len()))?;\n                for v in variants {\n                    seq.serialize_element(v)?;\n                }\n                seq.end()\n            }\n            Schema::Record {\n                ref name,\n                ref doc,\n                ref fields,\n                ..\n            } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"record\")?;\n                if let Some(ref n) = name.namespace {\n                    map.serialize_entry(\"namespace\", n)?;\n                }\n                map.serialize_entry(\"name\", \u0026name.name)?;\n                if let Some(ref docstr) = doc {\n                    map.serialize_entry(\"doc\", docstr)?;\n                }\n                if let Some(ref aliases) = name.aliases {\n                    map.serialize_entry(\"aliases\", aliases)?;\n                }\n                map.serialize_entry(\"fields\", fields)?;\n                map.end()\n            }\n            Schema::Enum {\n                ref name,\n                ref symbols,\n                ..\n            } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"enum\")?;\n                map.serialize_entry(\"name\", \u0026name.name)?;\n                map.serialize_entry(\"symbols\", symbols)?;\n                map.end()\n            }\n            Schema::Fixed { ref name, ref size } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"fixed\")?;\n                map.serialize_entry(\"name\", \u0026name.name)?;\n                map.serialize_entry(\"size\", size)?;\n                map.end()\n            }\n            Schema::Decimal {\n                ref scale,\n                ref precision,\n                ref inner,\n            } =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \u0026*inner.clone())?;\n                map.serialize_entry(\"logicalType\", \"decimal\")?;\n                map.serialize_entry(\"scale\", scale)?;\n                map.serialize_entry(\"precision\", precision)?;\n                map.end()\n            }\n            Schema::Uuid =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"string\")?;\n                map.serialize_entry(\"logicalType\", \"uuid\")?;\n                map.end()\n            }\n            Schema::Date =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"int\")?;\n                map.serialize_entry(\"logicalType\", \"date\")?;\n                map.end()\n            }\n            Schema::TimeMillis =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"int\")?;\n                map.serialize_entry(\"logicalType\", \"time-millis\")?;\n                map.end()\n            }\n            Schema::TimeMicros =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"time-micros\")?;\n                map.end()\n            }\n            Schema::TimestampMillis =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"timestamp-millis\")?;\n                map.end()\n            }\n            Schema::TimestampMicros =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n                map.serialize_entry(\"type\", \"long\")?;\n                map.serialize_entry(\"logicalType\", \"timestamp-micros\")?;\n                map.end()\n            }\n            Schema::Duration =\u003e {\n                let mut map = serializer.serialize_map(None)?;\n\n                // the Avro doesn't indicate what the name of the underlying fixed type of a\n                // duration should be or typically is.\n                let inner = Schema::Fixed {\n                    name: Name::new(\"duration\"),\n                    size: 12,\n                };\n                map.serialize_entry(\"type\", \u0026inner)?;\n                map.serialize_entry(\"logicalType\", \"duration\")?;\n                map.end()\n            }\n        }\n    }\n}\n\nimpl Serialize for RecordField {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let mut map = serializer.serialize_map(None)?;\n        map.serialize_entry(\"name\", \u0026self.name)?;\n        map.serialize_entry(\"type\", \u0026self.schema)?;\n\n        if let Some(ref default) = self.default {\n            map.serialize_entry(\"default\", default)?;\n        }\n\n        map.end()\n    }\n}\n\n/// Parses a **valid** avro schema into the Parsing Canonical Form.\n/// https://avro.apache.org/docs/1.8.2/spec.html#Parsing+Canonical+Form+for+Schemas\nfn parsing_canonical_form(schema: \u0026serde_json::Value) -\u003e String {\n    match schema {\n        serde_json::Value::Object(map) =\u003e pcf_map(map),\n        serde_json::Value::String(s) =\u003e pcf_string(s),\n        serde_json::Value::Array(v) =\u003e pcf_array(v),\n        json =\u003e panic!(\n            \"got invalid JSON value for canonical form of schema: {0}\",\n            json\n        ),\n    }\n}\n\nfn pcf_map(schema: \u0026Map\u003cString, serde_json::Value\u003e) -\u003e String {\n    // Look for the namespace variant up front.\n    let ns = schema.get(\"namespace\").and_then(|v| v.as_str());\n    let mut fields = Vec::new();\n    for (k, v) in schema {\n        // Reduce primitive types to their simple form. ([PRIMITIVE] rule)\n        if schema.len() == 1 \u0026\u0026 k == \"type\" {\n            // Invariant: function is only callable from a valid schema, so this is acceptable.\n            if let serde_json::Value::String(s) = v {\n                return pcf_string(s);\n            }\n        }\n\n        // Strip out unused fields ([STRIP] rule)\n        if field_ordering_position(k).is_none() || k == \"default\" || k == \"doc\" || k == \"aliases\" {\n            continue;\n        }\n\n        // Fully qualify the name, if it isn't already ([FULLNAMES] rule).\n        if k == \"name\" {\n            // Invariant: Only valid schemas. Must be a string.\n            let name = v.as_str().unwrap();\n            let n = match ns {\n                Some(namespace) if !name.contains('.') =\u003e {\n                    Cow::Owned(format!(\"{}.{}\", namespace, name))\n                }\n                _ =\u003e Cow::Borrowed(name),\n            };\n\n            fields.push((k, format!(\"{}:{}\", pcf_string(k), pcf_string(\u0026*n))));\n            continue;\n        }\n\n        // Strip off quotes surrounding \"size\" type, if they exist ([INTEGERS] rule).\n        if k == \"size\" {\n            let i = match v.as_str() {\n                Some(s) =\u003e s.parse::\u003ci64\u003e().expect(\"Only valid schemas are accepted!\"),\n                None =\u003e v.as_i64().unwrap(),\n            };\n            fields.push((k, format!(\"{}:{}\", pcf_string(k), i)));\n            continue;\n        }\n\n        // For anything else, recursively process the result.\n        fields.push((\n            k,\n            format!(\"{}:{}\", pcf_string(k), parsing_canonical_form(v)),\n        ));\n    }\n\n    // Sort the fields by their canonical ordering ([ORDER] rule).\n    fields.sort_unstable_by_key(|(k, _)| field_ordering_position(k).unwrap());\n    let inter = fields\n        .into_iter()\n        .map(|(_, v)| v)\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\",\");\n    format!(\"{{{}}}\", inter)\n}\n\nfn pcf_array(arr: \u0026[serde_json::Value]) -\u003e String {\n    let inter = arr\n        .iter()\n        .map(parsing_canonical_form)\n        .collect::\u003cVec\u003cString\u003e\u003e()\n        .join(\",\");\n    format!(\"[{}]\", inter)\n}\n\nfn pcf_string(s: \u0026str) -\u003e String {\n    format!(\"\\\"{}\\\"\", s)\n}\n\nconst RESERVED_FIELDS: \u0026[\u0026str] = \u0026[\n    \"name\",\n    \"type\",\n    \"fields\",\n    \"symbols\",\n    \"items\",\n    \"values\",\n    \"logicalType\",\n    \"size\",\n    \"order\",\n    \"doc\",\n    \"aliases\",\n    \"default\",\n];\n\n// Used to define the ordering and inclusion of fields.\nfn field_ordering_position(field: \u0026str) -\u003e Option\u003cusize\u003e {\n    RESERVED_FIELDS\n        .iter()\n        .position(|\u0026f| f == field)\n        .map(|pos| pos + 1)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_invalid_schema() {\n        assert!(Schema::parse_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_primitive_schema() {\n        assert_eq!(Schema::Null, Schema::parse_str(\"\\\"null\\\"\").unwrap());\n        assert_eq!(Schema::Int, Schema::parse_str(\"\\\"int\\\"\").unwrap());\n        assert_eq!(Schema::Double, Schema::parse_str(\"\\\"double\\\"\").unwrap());\n    }\n\n    #[test]\n    fn test_array_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"array\", \"items\": \"string\"}\"#).unwrap();\n        assert_eq!(Schema::Array(Box::new(Schema::String)), schema);\n    }\n\n    #[test]\n    fn test_map_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"map\", \"values\": \"double\"}\"#).unwrap();\n        assert_eq!(Schema::Map(Box::new(Schema::Double)), schema);\n    }\n\n    #[test]\n    fn test_union_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", \"int\"]\"#).unwrap();\n        assert_eq!(\n            Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n            schema\n        );\n    }\n\n    #[test]\n    fn test_union_unsupported_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", [\"null\", \"int\"], \"string\"]\"#);\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_multi_union_schema() {\n        let schema = Schema::parse_str(r#\"[\"null\", \"int\", \"float\", \"string\", \"bytes\"]\"#);\n        assert!(schema.is_ok());\n        let schema = schema.unwrap();\n        assert_eq!(SchemaKind::from(\u0026schema), SchemaKind::Union);\n        let union_schema = match schema {\n            Schema::Union(u) =\u003e u,\n            _ =\u003e unreachable!(),\n        };\n        assert_eq!(union_schema.variants().len(), 5);\n        let mut variants = union_schema.variants().iter();\n        assert_eq!(SchemaKind::from(variants.next().unwrap()), SchemaKind::Null);\n        assert_eq!(SchemaKind::from(variants.next().unwrap()), SchemaKind::Int);\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::Float\n        );\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::String\n        );\n        assert_eq!(\n            SchemaKind::from(variants.next().unwrap()),\n            SchemaKind::Bytes\n        );\n        assert_eq!(variants.next(), None);\n    }\n\n    #[test]\n    fn test_record_schema() {\n        let schema = Schema::parse_str(\n            r#\"\n            {\n                \"type\": \"record\",\n                \"name\": \"test\",\n                \"fields\": [\n                    {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n                    {\"name\": \"b\", \"type\": \"string\"}\n                ]\n            }\n        \"#,\n        )\n        .unwrap();\n\n        let mut lookup = HashMap::new();\n        lookup.insert(\"a\".to_owned(), 0);\n        lookup.insert(\"b\".to_owned(), 1);\n\n        let expected = Schema::Record {\n            name: Name::new(\"test\"),\n            doc: None,\n            fields: vec![\n                RecordField {\n                    name: \"a\".to_string(),\n                    doc: None,\n                    default: Some(Value::Number(42i64.into())),\n                    schema: Schema::Long,\n                    order: RecordFieldOrder::Ascending,\n                    position: 0,\n                },\n                RecordField {\n                    name: \"b\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::String,\n                    order: RecordFieldOrder::Ascending,\n                    position: 1,\n                },\n            ],\n            lookup,\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_enum_schema() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Suit\", \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"hearts\"]}\"#,\n        ).unwrap();\n\n        let expected = Schema::Enum {\n            name: Name::new(\"Suit\"),\n            doc: None,\n            symbols: vec![\n                \"diamonds\".to_owned(),\n                \"spades\".to_owned(),\n                \"clubs\".to_owned(),\n                \"hearts\".to_owned(),\n            ],\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_enum_schema_duplicate() {\n        // Duplicate \"diamonds\"\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Suit\", \"symbols\": [\"diamonds\", \"spades\", \"clubs\", \"diamonds\"]}\"#,\n        );\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_enum_schema_name() {\n        // Invalid name \"0000\" does not match [A-Za-z_][A-Za-z0-9_]*\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Enum\", \"symbols\": [\"0000\", \"variant\"]}\"#,\n        );\n        assert!(schema.is_err());\n    }\n\n    #[test]\n    fn test_fixed_schema() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"fixed\", \"name\": \"test\", \"size\": 16}\"#).unwrap();\n\n        let expected = Schema::Fixed {\n            name: Name::new(\"test\"),\n            size: 16usize,\n        };\n\n        assert_eq!(expected, schema);\n    }\n\n    #[test]\n    fn test_no_documentation() {\n        let schema =\n            Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Coin\", \"symbols\": [\"heads\", \"tails\"]}\"#)\n                .unwrap();\n\n        let doc = match schema {\n            Schema::Enum { doc, .. } =\u003e doc,\n            _ =\u003e return,\n        };\n\n        assert!(doc.is_none());\n    }\n\n    #[test]\n    fn test_documentation() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": \"enum\", \"name\": \"Coin\", \"doc\": \"Some documentation\", \"symbols\": [\"heads\", \"tails\"]}\"#\n        ).unwrap();\n\n        let doc = match schema {\n            Schema::Enum { doc, .. } =\u003e doc,\n            _ =\u003e None,\n        };\n\n        assert_eq!(\"Some documentation\".to_owned(), doc.unwrap());\n    }\n\n    // Tests to ensure Schema is Send + Sync. These tests don't need to _do_ anything, if they can\n    // compile, they pass.\n    #[test]\n    fn test_schema_is_send() {\n        fn send\u003cS: Send\u003e(_s: S) {}\n\n        let schema = Schema::Null;\n        send(schema);\n    }\n\n    #[test]\n    fn test_schema_is_sync() {\n        fn sync\u003cS: Sync\u003e(_s: S) {}\n\n        let schema = Schema::Null;\n        sync(\u0026schema);\n        sync(schema);\n    }\n\n    #[test]\n    fn test_schema_fingerprint() {\n        use crate::rabin::Rabin;\n        use md5::Md5;\n        use sha2::Sha256;\n\n        let raw_schema = r#\"\n    {\n        \"type\": \"record\",\n        \"name\": \"test\",\n        \"fields\": [\n            {\"name\": \"a\", \"type\": \"long\", \"default\": 42},\n            {\"name\": \"b\", \"type\": \"string\"},\n            {\"name\": \"c\", \"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\n        ]\n    }\n\"#;\n\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        assert_eq!(\n            \"abf662f831715ff78f88545a05a9262af75d6406b54e1a8a174ff1d2b75affc4\",\n            format!(\"{}\", schema.fingerprint::\u003cSha256\u003e())\n        );\n\n        assert_eq!(\n            \"6e21c350f71b1a34e9efe90970f1bc69\",\n            format!(\"{}\", schema.fingerprint::\u003cMd5\u003e())\n        );\n        assert_eq!(\n            \"28cf0a67d9937bb3\",\n            format!(\"{}\", schema.fingerprint::\u003cRabin\u003e())\n        )\n    }\n\n    #[test]\n    fn test_logical_types() {\n        let schema = Schema::parse_str(r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#).unwrap();\n        assert_eq!(schema, Schema::Date);\n\n        let schema =\n            Schema::parse_str(r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#).unwrap();\n        assert_eq!(schema, Schema::TimestampMicros);\n    }\n\n    #[test]\n    fn test_nullable_logical_type() {\n        let schema = Schema::parse_str(\n            r#\"{\"type\": [\"null\", {\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}]}\"#,\n        )\n        .unwrap();\n        assert_eq!(\n            schema,\n            Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::TimestampMicros]).unwrap())\n        );\n    }\n\n    #[test]\n    fn record_field_order_from_str() {\n        use std::str::FromStr;\n\n        assert_eq!(\n            RecordFieldOrder::from_str(\"ascending\").unwrap(),\n            RecordFieldOrder::Ascending\n        );\n        assert_eq!(\n            RecordFieldOrder::from_str(\"descending\").unwrap(),\n            RecordFieldOrder::Descending\n        );\n        assert_eq!(\n            RecordFieldOrder::from_str(\"ignore\").unwrap(),\n            RecordFieldOrder::Ignore\n        );\n        assert!(RecordFieldOrder::from_str(\"not an ordering\").is_err());\n    }\n}\n","traces":[{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":873,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":923,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":957,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":139},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","schema_compatibility.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for checking schema compatibility\nuse crate::schema::{Schema, SchemaKind};\nuse std::{\n    collections::{hash_map::DefaultHasher, HashSet},\n    hash::Hasher,\n    ptr,\n};\n\npub struct SchemaCompatibility;\n\nstruct Checker {\n    recursion: HashSet\u003c(u64, u64)\u003e,\n}\n\nimpl Checker {\n    /// Create a new checker, with recursion set to an empty set.\n    pub(crate) fn new() -\u003e Self {\n        Self {\n            recursion: HashSet::new(),\n        }\n    }\n\n    pub(crate) fn can_read(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        self.full_match_schemas(writers_schema, readers_schema)\n    }\n\n    pub(crate) fn full_match_schemas(\n        \u0026mut self,\n        writers_schema: \u0026Schema,\n        readers_schema: \u0026Schema,\n    ) -\u003e bool {\n        if self.recursion_in_progress(writers_schema, readers_schema) {\n            return true;\n        }\n\n        if !SchemaCompatibility::match_schemas(writers_schema, readers_schema) {\n            return false;\n        }\n\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        if w_type != SchemaKind::Union \u0026\u0026 (r_type.is_primitive() || r_type == SchemaKind::Fixed) {\n            return true;\n        }\n\n        match r_type {\n            SchemaKind::Record =\u003e self.match_record_schemas(writers_schema, readers_schema),\n            SchemaKind::Map =\u003e {\n                if let Schema::Map(w_m) = writers_schema {\n                    if let Schema::Map(r_m) = readers_schema {\n                        self.full_match_schemas(w_m, r_m)\n                    } else {\n                        unreachable!(\"readers_schema should have been Schema::Map\")\n                    }\n                } else {\n                    unreachable!(\"writers_schema should have been Schema::Map\")\n                }\n            }\n            SchemaKind::Array =\u003e {\n                if let Schema::Array(w_a) = writers_schema {\n                    if let Schema::Array(r_a) = readers_schema {\n                        self.full_match_schemas(w_a, r_a)\n                    } else {\n                        unreachable!(\"readers_schema should have been Schema::Array\")\n                    }\n                } else {\n                    unreachable!(\"writers_schema should have been Schema::Array\")\n                }\n            }\n            SchemaKind::Union =\u003e self.match_union_schemas(writers_schema, readers_schema),\n            SchemaKind::Enum =\u003e {\n                // reader's symbols must contain all writer's symbols\n                if let Schema::Enum {\n                    symbols: w_symbols, ..\n                } = writers_schema\n                {\n                    if let Schema::Enum {\n                        symbols: r_symbols, ..\n                    } = readers_schema\n                    {\n                        return !w_symbols.iter().any(|e| !r_symbols.contains(e));\n                    }\n                }\n                false\n            }\n            _ =\u003e {\n                if w_type == SchemaKind::Union {\n                    if let Schema::Union(r) = writers_schema {\n                        if r.schemas.len() == 1 {\n                            return self.full_match_schemas(\u0026r.schemas[0], readers_schema);\n                        }\n                    }\n                }\n                false\n            }\n        }\n    }\n\n    fn match_record_schemas(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let w_type = SchemaKind::from(writers_schema);\n\n        if w_type == SchemaKind::Union {\n            return false;\n        }\n\n        if let Schema::Record {\n            fields: w_fields,\n            lookup: w_lookup,\n            ..\n        } = writers_schema\n        {\n            if let Schema::Record {\n                fields: r_fields, ..\n            } = readers_schema\n            {\n                for field in r_fields.iter() {\n                    if let Some(pos) = w_lookup.get(\u0026field.name) {\n                        if !self.full_match_schemas(\u0026w_fields[*pos].schema, \u0026field.schema) {\n                            return false;\n                        }\n                    } else if field.default.is_none() {\n                        return false;\n                    }\n                }\n            }\n        }\n        true\n    }\n\n    fn match_union_schemas(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        assert_eq!(r_type, SchemaKind::Union);\n\n        if w_type == SchemaKind::Union {\n            if let Schema::Union(u) = writers_schema {\n                u.schemas\n                    .iter()\n                    .all(|schema| self.full_match_schemas(schema, readers_schema))\n            } else {\n                unreachable!(\"writers_schema should have been Schema::Union\")\n            }\n        } else if let Schema::Union(u) = readers_schema {\n            u.schemas\n                .iter()\n                .any(|schema| self.full_match_schemas(writers_schema, schema))\n        } else {\n            unreachable!(\"readers_schema should have been Schema::Union\")\n        }\n    }\n\n    fn recursion_in_progress(\u0026mut self, writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let mut hasher = DefaultHasher::new();\n        ptr::hash(writers_schema, \u0026mut hasher);\n        let w_hash = hasher.finish();\n\n        hasher = DefaultHasher::new();\n        ptr::hash(readers_schema, \u0026mut hasher);\n        let r_hash = hasher.finish();\n\n        let key = (w_hash, r_hash);\n        // This is a shortcut to add if not exists *and* return false. It will return true\n        // if it was able to insert.\n        !self.recursion.insert(key)\n    }\n}\n\nimpl SchemaCompatibility {\n    /// `can_read` performs a full, recursive check that a datum written using the\n    /// writers_schema can be read using the readers_schema.\n    pub fn can_read(writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let mut c = Checker::new();\n        c.can_read(writers_schema, readers_schema)\n    }\n\n    /// `mutual_read` performs a full, recursive check that a datum written using either\n    /// the writers_schema or the readers_schema can be read using the other schema.\n    pub fn mutual_read(writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        SchemaCompatibility::can_read(writers_schema, readers_schema)\n            \u0026\u0026 SchemaCompatibility::can_read(readers_schema, writers_schema)\n    }\n\n    ///  `match_schemas` performs a basic check that a datum written with the\n    ///  writers_schema could be read using the readers_schema. This check only includes\n    ///  matching the types, including schema promotion, and matching the full name for\n    ///  named types. Aliases for named types are not supported here, and the rust\n    ///  implementation of Avro in general does not include support for aliases (I think).\n    pub(crate) fn match_schemas(writers_schema: \u0026Schema, readers_schema: \u0026Schema) -\u003e bool {\n        let w_type = SchemaKind::from(writers_schema);\n        let r_type = SchemaKind::from(readers_schema);\n\n        if w_type == SchemaKind::Union || r_type == SchemaKind::Union {\n            return true;\n        }\n\n        if w_type == r_type {\n            if r_type.is_primitive() {\n                return true;\n            }\n\n            match r_type {\n                SchemaKind::Record =\u003e {\n                    if let Schema::Record { name: w_name, .. } = writers_schema {\n                        if let Schema::Record { name: r_name, .. } = readers_schema {\n                            return w_name.fullname(None) == r_name.fullname(None);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Record\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Record\")\n                    }\n                }\n                SchemaKind::Fixed =\u003e {\n                    if let Schema::Fixed {\n                        name: w_name,\n                        size: w_size,\n                    } = writers_schema\n                    {\n                        if let Schema::Fixed {\n                            name: r_name,\n                            size: r_size,\n                        } = readers_schema\n                        {\n                            return w_name.fullname(None) == r_name.fullname(None)\n                                \u0026\u0026 w_size == r_size;\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Fixed\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Fixed\")\n                    }\n                }\n                SchemaKind::Enum =\u003e {\n                    if let Schema::Enum { name: w_name, .. } = writers_schema {\n                        if let Schema::Enum { name: r_name, .. } = readers_schema {\n                            return w_name.fullname(None) == r_name.fullname(None);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Enum\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Enum\")\n                    }\n                }\n                SchemaKind::Map =\u003e {\n                    if let Schema::Map(w_m) = writers_schema {\n                        if let Schema::Map(r_m) = readers_schema {\n                            return SchemaCompatibility::match_schemas(w_m, r_m);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Map\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Map\")\n                    }\n                }\n                SchemaKind::Array =\u003e {\n                    if let Schema::Array(w_a) = writers_schema {\n                        if let Schema::Array(r_a) = readers_schema {\n                            return SchemaCompatibility::match_schemas(w_a, r_a);\n                        } else {\n                            unreachable!(\"readers_schema should have been Schema::Array\")\n                        }\n                    } else {\n                        unreachable!(\"writers_schema should have been Schema::Array\")\n                    }\n                }\n                _ =\u003e (),\n            };\n        }\n\n        if w_type == SchemaKind::Int\n            \u0026\u0026 vec![SchemaKind::Long, SchemaKind::Float, SchemaKind::Double]\n                .iter()\n                .any(|\u0026t| t == r_type)\n        {\n            return true;\n        }\n\n        if w_type == SchemaKind::Long\n            \u0026\u0026 vec![SchemaKind::Float, SchemaKind::Double]\n                .iter()\n                .any(|\u0026t| t == r_type)\n        {\n            return true;\n        }\n\n        if w_type == SchemaKind::Float \u0026\u0026 r_type == SchemaKind::Double {\n            return true;\n        }\n\n        if w_type == SchemaKind::String \u0026\u0026 r_type == SchemaKind::Bytes {\n            return true;\n        }\n\n        if w_type == SchemaKind::Bytes \u0026\u0026 r_type == SchemaKind::String {\n            return true;\n        }\n\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn int_array_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"int\"}\"#).unwrap()\n    }\n\n    fn long_array_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"long\"}\"#).unwrap()\n    }\n\n    fn string_array_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"array\", \"items\":\"string\"}\"#).unwrap()\n    }\n\n    fn int_map_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"int\"}\"#).unwrap()\n    }\n\n    fn long_map_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"long\"}\"#).unwrap()\n    }\n\n    fn string_map_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"map\", \"values\":\"string\"}\"#).unwrap()\n    }\n\n    fn enum1_ab_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"A\",\"B\"]}\"#).unwrap()\n    }\n\n    fn enum1_abc_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"A\",\"B\",\"C\"]}\"#).unwrap()\n    }\n\n    fn enum1_bc_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum1\", \"symbols\":[\"B\",\"C\"]}\"#).unwrap()\n    }\n\n    fn enum2_ab_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"Enum2\", \"symbols\":[\"A\",\"B\"]}\"#).unwrap()\n    }\n\n    fn empty_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[]}\"#).unwrap()\n    }\n\n    fn empty_record2_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record2\", \"fields\": []}\"#).unwrap()\n    }\n\n    fn a_int_record1_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}]}\"#,\n        )\n        .unwrap()\n    }\n\n    fn a_long_record1_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"long\"}]}\"#,\n        )\n        .unwrap()\n    }\n\n    fn a_int_b_int_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}, {\"name\":\"b\", \"type\":\"int\"}]}\"#).unwrap()\n    }\n\n    fn a_dint_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn a_int_b_dint_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\"}, {\"name\":\"b\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn a_dint_b_dint_record1_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"Record1\", \"fields\":[{\"name\":\"a\", \"type\":\"int\", \"default\":0}, {\"name\":\"b\", \"type\":\"int\", \"default\":0}]}\"#).unwrap()\n    }\n\n    fn nested_record() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\",\"name\":\"parent\",\"fields\":[{\"name\":\"attribute\",\"type\":{\"type\":\"record\",\"name\":\"child\",\"fields\":[{\"name\":\"id\",\"type\":\"string\"}]}}]}\"#).unwrap()\n    }\n\n    fn nested_optional_record() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\",\"name\":\"parent\",\"fields\":[{\"name\":\"attribute\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"child\",\"fields\":[{\"name\":\"id\",\"type\":\"string\"}]}],\"default\":null}]}\"#).unwrap()\n    }\n\n    fn int_list_record_schema() -\u003e Schema {\n        Schema::parse_str(r#\"{\"type\":\"record\", \"name\":\"List\", \"fields\": [{\"name\": \"head\", \"type\": \"int\"},{\"name\": \"tail\", \"type\": \"array\", \"items\": \"int\"}]}\"#).unwrap()\n    }\n\n    fn long_list_record_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\n        \"type\":\"record\", \"name\":\"List\", \"fields\": [\n          {\"name\": \"head\", \"type\": \"long\"},\n          {\"name\": \"tail\", \"type\": \"array\", \"items\": \"long\"}\n      ]}\n\"#,\n        )\n        .unwrap()\n    }\n\n    fn union_schema(schemas: Vec\u003cSchema\u003e) -\u003e Schema {\n        let schema_string = schemas\n            .iter()\n            .map(|s| s.canonical_form())\n            .collect::\u003cVec\u003cString\u003e\u003e()\n            .join(\",\");\n        dbg!(\u0026schema_string);\n        Schema::parse_str(\u0026format!(\"[{}]\", schema_string)).unwrap()\n    }\n\n    fn empty_union_schema() -\u003e Schema {\n        union_schema(vec![])\n    }\n\n    // unused\n    // fn null_union_schema() -\u003e Schema { union_schema(vec![Schema::Null]) }\n\n    fn int_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::Int])\n    }\n\n    fn long_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::Long])\n    }\n\n    fn string_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::String])\n    }\n\n    fn int_string_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::Int, Schema::String])\n    }\n\n    fn string_int_union_schema() -\u003e Schema {\n        union_schema(vec![Schema::String, Schema::Int])\n    }\n\n    #[test]\n    fn test_broken() {\n        assert!(!SchemaCompatibility::can_read(\n            \u0026int_string_union_schema(),\n            \u0026int_union_schema()\n        ))\n    }\n\n    #[test]\n    fn test_incompatible_reader_writer_pairs() {\n        let incompatible_schemas = vec![\n            // null\n            (Schema::Null, Schema::Int),\n            (Schema::Null, Schema::Long),\n            // boolean\n            (Schema::Boolean, Schema::Int),\n            // int\n            (Schema::Int, Schema::Null),\n            (Schema::Int, Schema::Boolean),\n            (Schema::Int, Schema::Long),\n            (Schema::Int, Schema::Float),\n            (Schema::Int, Schema::Double),\n            // long\n            (Schema::Long, Schema::Float),\n            (Schema::Long, Schema::Double),\n            // float\n            (Schema::Float, Schema::Double),\n            // string\n            (Schema::String, Schema::Boolean),\n            (Schema::String, Schema::Int),\n            // bytes\n            (Schema::Bytes, Schema::Null),\n            (Schema::Bytes, Schema::Int),\n            // array and maps\n            (int_array_schema(), long_array_schema()),\n            (int_map_schema(), int_array_schema()),\n            (int_array_schema(), int_map_schema()),\n            (int_map_schema(), long_map_schema()),\n            // enum\n            (enum1_ab_schema(), enum1_abc_schema()),\n            (enum1_bc_schema(), enum1_abc_schema()),\n            (enum1_ab_schema(), enum2_ab_schema()),\n            (Schema::Int, enum2_ab_schema()),\n            (enum2_ab_schema(), Schema::Int),\n            //union\n            (int_union_schema(), int_string_union_schema()),\n            (string_union_schema(), int_string_union_schema()),\n            //record\n            (empty_record2_schema(), empty_record1_schema()),\n            (a_int_record1_schema(), empty_record1_schema()),\n            (a_int_b_dint_record1_schema(), empty_record1_schema()),\n            (int_list_record_schema(), long_list_record_schema()),\n            (nested_record(), nested_optional_record()),\n        ];\n\n        assert!(!incompatible_schemas\n            .iter()\n            .any(|(reader, writer)| SchemaCompatibility::can_read(writer, reader)));\n    }\n\n    #[test]\n    fn test_compatible_reader_writer_pairs() {\n        let compatible_schemas = vec![\n            (Schema::Null, Schema::Null),\n            (Schema::Long, Schema::Int),\n            (Schema::Float, Schema::Int),\n            (Schema::Float, Schema::Long),\n            (Schema::Double, Schema::Long),\n            (Schema::Double, Schema::Int),\n            (Schema::Double, Schema::Float),\n            (Schema::String, Schema::Bytes),\n            (Schema::Bytes, Schema::String),\n            (int_array_schema(), int_array_schema()),\n            (long_array_schema(), int_array_schema()),\n            (int_map_schema(), int_map_schema()),\n            (long_map_schema(), int_map_schema()),\n            (enum1_ab_schema(), enum1_ab_schema()),\n            (enum1_abc_schema(), enum1_ab_schema()),\n            (empty_union_schema(), empty_union_schema()),\n            (int_union_schema(), int_union_schema()),\n            (int_string_union_schema(), string_int_union_schema()),\n            (int_union_schema(), empty_union_schema()),\n            (long_union_schema(), int_union_schema()),\n            (int_union_schema(), Schema::Int),\n            (Schema::Int, int_union_schema()),\n            (empty_record1_schema(), empty_record1_schema()),\n            (empty_record1_schema(), a_int_record1_schema()),\n            (a_int_record1_schema(), a_int_record1_schema()),\n            (a_dint_record1_schema(), a_int_record1_schema()),\n            (a_dint_record1_schema(), a_dint_record1_schema()),\n            (a_int_record1_schema(), a_dint_record1_schema()),\n            (a_long_record1_schema(), a_int_record1_schema()),\n            (a_int_record1_schema(), a_int_b_int_record1_schema()),\n            (a_dint_record1_schema(), a_int_b_int_record1_schema()),\n            (a_int_b_dint_record1_schema(), a_int_record1_schema()),\n            (a_dint_b_dint_record1_schema(), empty_record1_schema()),\n            (a_dint_b_dint_record1_schema(), a_int_record1_schema()),\n            (a_int_b_int_record1_schema(), a_dint_b_dint_record1_schema()),\n            (int_list_record_schema(), int_list_record_schema()),\n            (long_list_record_schema(), long_list_record_schema()),\n            (long_list_record_schema(), int_list_record_schema()),\n            (nested_optional_record(), nested_record()),\n        ];\n\n        assert!(compatible_schemas\n            .iter()\n            .all(|(reader, writer)| SchemaCompatibility::can_read(writer, reader)));\n    }\n\n    fn writer_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n        {\"name\":\"oldfield1\", \"type\":\"int\"},\n        {\"name\":\"oldfield2\", \"type\":\"string\"}\n      ]}\n\"#,\n        )\n        .unwrap()\n    }\n\n    #[test]\n    fn test_missing_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n        {\"name\":\"oldfield1\", \"type\":\"int\"}\n      ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema,\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_missing_second_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield2\", \"type\":\"string\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_all_fields() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"oldfield2\", \"type\":\"string\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_new_field_with_default() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"newfield1\", \"type\":\"int\", \"default\":42}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_new_field() {\n        let reader_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"Record\", \"fields\":[\n          {\"name\":\"oldfield1\", \"type\":\"int\"},\n          {\"name\":\"newfield1\", \"type\":\"int\"}\n        ]}\n\"#,\n        )\n        .unwrap();\n        assert!(!SchemaCompatibility::can_read(\n            \u0026writer_schema(),\n            \u0026reader_schema\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026reader_schema,\n            \u0026writer_schema()\n        ));\n    }\n\n    #[test]\n    fn test_array_writer_schema() {\n        let valid_reader = string_array_schema();\n        let invalid_reader = string_map_schema();\n\n        assert!(SchemaCompatibility::can_read(\n            \u0026string_array_schema(),\n            \u0026valid_reader\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026string_array_schema(),\n            \u0026invalid_reader\n        ));\n    }\n\n    #[test]\n    fn test_primitive_writer_schema() {\n        let valid_reader = Schema::String;\n        assert!(SchemaCompatibility::can_read(\n            \u0026Schema::String,\n            \u0026valid_reader\n        ));\n        assert!(!SchemaCompatibility::can_read(\n            \u0026Schema::Int,\n            \u0026Schema::String\n        ));\n    }\n\n    #[test]\n    fn test_union_reader_writer_subset_incompatiblity() {\n        // reader union schema must contain all writer union branches\n        let union_writer = union_schema(vec![Schema::Int, Schema::String]);\n        let union_reader = union_schema(vec![Schema::String]);\n\n        assert!(!SchemaCompatibility::can_read(\u0026union_writer, \u0026union_reader));\n        assert!(SchemaCompatibility::can_read(\u0026union_reader, \u0026union_writer));\n    }\n\n    #[test]\n    fn test_incompatible_record_field() {\n        let string_schema = Schema::parse_str(\n            r#\"\n        {\"type\":\"record\", \"name\":\"MyRecord\", \"namespace\":\"ns\", \"fields\": [\n            {\"name\":\"field1\", \"type\":\"string\"}\n        ]}\n        \"#,\n        )\n        .unwrap();\n\n        let int_schema = Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"MyRecord\", \"namespace\":\"ns\", \"fields\": [\n        {\"name\":\"field1\", \"type\":\"int\"}\n      ]}\n\"#,\n        )\n        .unwrap();\n\n        assert!(!SchemaCompatibility::can_read(\u0026string_schema, \u0026int_schema));\n    }\n\n    #[test]\n    fn test_enum_symbols() {\n        let enum_schema1 = Schema::parse_str(\n            r#\"\n      {\"type\":\"enum\", \"name\":\"MyEnum\", \"symbols\":[\"A\",\"B\"]}\n\"#,\n        )\n        .unwrap();\n        let enum_schema2 =\n            Schema::parse_str(r#\"{\"type\":\"enum\", \"name\":\"MyEnum\", \"symbols\":[\"A\",\"B\",\"C\"]}\"#)\n                .unwrap();\n        assert!(!SchemaCompatibility::can_read(\u0026enum_schema2, \u0026enum_schema1));\n        assert!(SchemaCompatibility::can_read(\u0026enum_schema1, \u0026enum_schema2));\n    }\n\n    // unused\n    /*\n        fn point_2d_schema() -\u003e Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point2D\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n    */\n\n    fn point_2d_fullname_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Point\", \"namespace\":\"written\", \"fields\":[\n        {\"name\":\"x\", \"type\":\"double\"},\n        {\"name\":\"y\", \"type\":\"double\"}\n      ]}\n    \"#,\n        )\n        .unwrap()\n    }\n\n    fn point_3d_no_default_schema() -\u003e Schema {\n        Schema::parse_str(\n            r#\"\n      {\"type\":\"record\", \"name\":\"Point\", \"fields\":[\n        {\"name\":\"x\", \"type\":\"double\"},\n        {\"name\":\"y\", \"type\":\"double\"},\n        {\"name\":\"z\", \"type\":\"double\"}\n      ]}\n    \"#,\n        )\n        .unwrap()\n    }\n\n    // unused\n    /*\n        fn point_3d_schema() -\u003e Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point3D\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"},\n            {\"name\":\"z\", \"type\":\"double\", \"default\": 0.0}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n\n        fn point_3d_match_name_schema() -\u003e Schema {\n            Schema::parse_str(\n                r#\"\n          {\"type\":\"record\", \"name\":\"Point\", \"fields\":[\n            {\"name\":\"x\", \"type\":\"double\"},\n            {\"name\":\"y\", \"type\":\"double\"},\n            {\"name\":\"z\", \"type\":\"double\", \"default\": 0.0}\n          ]}\n        \"#,\n            )\n            .unwrap()\n        }\n    */\n\n    #[test]\n    fn test_union_resolution_no_structure_match() {\n        // short name match, but no structure match\n        let read_schema = union_schema(vec![Schema::Null, point_3d_no_default_schema()]);\n        assert!(!SchemaCompatibility::can_read(\n            \u0026point_2d_fullname_schema(),\n            \u0026read_schema\n        ));\n    }\n\n    // TODO(nlopes): the below require named schemas to be fully supported. See:\n    // https://github.com/flavray/avro-rs/pull/76\n    //\n    // #[test]\n    // fn test_union_resolution_first_structure_match_2d() {\n    //     // multiple structure matches with no name matches\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_3d_no_default_schema(),\n    //         point_2d_schema(),\n    //         point_3d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(\u0026point_2d_fullname_schema(), \u0026read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_first_structure_match_3d() {\n    //     // multiple structure matches with no name matches\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_3d_no_default_schema(),\n    //         point_3d_schema(),\n    //         point_2d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(\u0026point_2d_fullname_schema(), \u0026read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_named_structure_match() {\n    //     // multiple structure matches with a short name match\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_2d_schema(),\n    //         point_3d_match_name_schema(),\n    //         point_3d_schema(),\n    //     ]);\n    //     assert!(\n    //         !SchemaCompatibility::can_read(\u0026point_2d_fullname_schema(), \u0026read_schema)\n    //     );\n    // }\n\n    // #[test]\n    // fn test_union_resolution_full_name_match() {\n    //     // there is a full name match that should be chosen\n    //     let read_schema = union_schema(vec![\n    //         Schema::Null,\n    //         point_2d_schema(),\n    //         point_3d_match_name_schema(),\n    //         point_3d_schema(),\n    //         point_2d_fullname_schema(),\n    //     ]);\n    //     assert!(SchemaCompatibility::can_read(\n    //         \u0026point_2d_fullname_schema(),\n    //         \u0026read_schema\n    //     ));\n    // }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","ser.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic for serde-compatible serialization.\nuse crate::{types::Value, Error};\nuse serde::{ser, Serialize};\nuse std::{collections::HashMap, iter::once};\n\n#[derive(Clone, Default)]\npub struct Serializer {}\n\npub struct SeqSerializer {\n    items: Vec\u003cValue\u003e,\n}\n\npub struct SeqVariantSerializer\u003c'a\u003e {\n    index: u32,\n    variant: \u0026'a str,\n    items: Vec\u003cValue\u003e,\n}\n\npub struct MapSerializer {\n    indices: HashMap\u003cString, usize\u003e,\n    values: Vec\u003cValue\u003e,\n}\n\npub struct StructSerializer {\n    fields: Vec\u003c(String, Value)\u003e,\n}\n\npub struct StructVariantSerializer\u003c'a\u003e {\n    index: u32,\n    variant: \u0026'a str,\n    fields: Vec\u003c(String, Value)\u003e,\n}\n\nimpl SeqSerializer {\n    pub fn new(len: Option\u003cusize\u003e) -\u003e SeqSerializer {\n        let items = match len {\n            Some(len) =\u003e Vec::with_capacity(len),\n            None =\u003e Vec::new(),\n        };\n\n        SeqSerializer { items }\n    }\n}\n\nimpl\u003c'a\u003e SeqVariantSerializer\u003c'a\u003e {\n    pub fn new(index: u32, variant: \u0026'a str, len: Option\u003cusize\u003e) -\u003e SeqVariantSerializer {\n        let items = match len {\n            Some(len) =\u003e Vec::with_capacity(len),\n            None =\u003e Vec::new(),\n        };\n        SeqVariantSerializer {\n            index,\n            variant,\n            items,\n        }\n    }\n}\n\nimpl MapSerializer {\n    pub fn new(len: Option\u003cusize\u003e) -\u003e MapSerializer {\n        let (indices, values) = match len {\n            Some(len) =\u003e (HashMap::with_capacity(len), Vec::with_capacity(len)),\n            None =\u003e (HashMap::new(), Vec::new()),\n        };\n\n        MapSerializer { indices, values }\n    }\n}\n\nimpl StructSerializer {\n    pub fn new(len: usize) -\u003e StructSerializer {\n        StructSerializer {\n            fields: Vec::with_capacity(len),\n        }\n    }\n}\n\nimpl\u003c'a\u003e StructVariantSerializer\u003c'a\u003e {\n    pub fn new(index: u32, variant: \u0026'a str, len: usize) -\u003e StructVariantSerializer {\n        StructVariantSerializer {\n            index,\n            variant,\n            fields: Vec::with_capacity(len),\n        }\n    }\n}\n\nimpl\u003c'b\u003e ser::Serializer for \u0026'b mut Serializer {\n    type Ok = Value;\n    type Error = Error;\n    type SerializeSeq = SeqSerializer;\n    type SerializeTuple = SeqSerializer;\n    type SerializeTupleStruct = SeqSerializer;\n    type SerializeTupleVariant = SeqVariantSerializer\u003c'b\u003e;\n    type SerializeMap = MapSerializer;\n    type SerializeStruct = StructSerializer;\n    type SerializeStructVariant = StructVariantSerializer\u003c'b\u003e;\n\n    fn serialize_bool(self, v: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Boolean(v))\n    }\n\n    fn serialize_i8(self, v: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_i16(self, v: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_i32(self, v: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Int(v))\n    }\n\n    fn serialize_i64(self, v: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Long(v))\n    }\n\n    fn serialize_u8(self, v: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_u16(self, v: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_i32(i32::from(v))\n    }\n\n    fn serialize_u32(self, v: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        if v \u003c= i32::max_value() as u32 {\n            self.serialize_i32(v as i32)\n        } else {\n            self.serialize_i64(i64::from(v))\n        }\n    }\n\n    fn serialize_u64(self, v: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        if v \u003c= i64::max_value() as u64 {\n            self.serialize_i64(v as i64)\n        } else {\n            Err(ser::Error::custom(\"u64 is too large\"))\n        }\n    }\n\n    fn serialize_f32(self, v: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Float(v))\n    }\n\n    fn serialize_f64(self, v: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Double(v))\n    }\n\n    fn serialize_char(self, v: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_str(\u0026once(v).collect::\u003cString\u003e())\n    }\n\n    fn serialize_str(self, v: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::String(v.to_owned()))\n    }\n\n    fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Bytes(v.to_owned()))\n    }\n\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::from(None::\u003cSelf::Ok\u003e))\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let v = value.serialize(\u0026mut Serializer::default())?;\n        Ok(Value::from(Some(v)))\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Null)\n    }\n\n    fn serialize_unit_struct(self, _: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        self.serialize_unit()\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Enum(index as i32, variant.to_string()))\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(index as i32, variant.to_owned()),\n            ),\n            (\n                \"value\".to_owned(),\n                Value::Union(Box::new(value.serialize(self)?)),\n            ),\n        ]))\n    }\n\n    fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n        Ok(SeqSerializer::new(len))\n    }\n\n    fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n        self.serialize_seq(Some(len))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        Ok(SeqVariantSerializer::new(index, variant, Some(len)))\n    }\n\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n        Ok(MapSerializer::new(len))\n    }\n\n    fn serialize_struct(\n        self,\n        _: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n        Ok(StructSerializer::new(len))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        Ok(StructVariantSerializer::new(index, variant, len))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeSeq for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.items\n            .push(value.serialize(\u0026mut Serializer::default())?);\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Array(self.items))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeTuple for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeTupleStruct for SeqSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeSeq for SeqVariantSerializer\u003c'a\u003e {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.items.push(Value::Union(Box::new(\n            value.serialize(\u0026mut Serializer::default())?,\n        )));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(self.index as i32, self.variant.to_owned()),\n            ),\n            (\"value\".to_owned(), Value::Array(self.items)),\n        ]))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeTupleVariant for SeqVariantSerializer\u003c'a\u003e {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        ser::SerializeSeq::serialize_element(self, value)\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        ser::SerializeSeq::end(self)\n    }\n}\n\nimpl ser::SerializeMap for MapSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let key = key.serialize(\u0026mut Serializer::default())?;\n\n        if let Value::String(key) = key {\n            self.indices.insert(key, self.values.len());\n            Ok(())\n        } else {\n            Err(ser::Error::custom(\"map key is not a string\"))\n        }\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.values\n            .push(value.serialize(\u0026mut Serializer::default())?);\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        let mut items = HashMap::new();\n        for (key, index) in self.indices {\n            if let Some(value) = self.values.get(index) {\n                items.insert(key, value.clone());\n            }\n        }\n\n        Ok(Value::Map(items))\n    }\n}\n\nimpl ser::SerializeStruct for StructSerializer {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        name: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.fields.push((\n            name.to_owned(),\n            value.serialize(\u0026mut Serializer::default())?,\n        ));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Record(self.fields))\n    }\n}\n\nimpl\u003c'a\u003e ser::SerializeStructVariant for StructVariantSerializer\u003c'a\u003e {\n    type Ok = Value;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        name: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.fields.push((\n            name.to_owned(),\n            value.serialize(\u0026mut Serializer::default())?,\n        ));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(Value::Record(vec![\n            (\n                \"type\".to_owned(),\n                Value::Enum(self.index as i32, self.variant.to_owned()),\n            ),\n            (\n                \"value\".to_owned(),\n                Value::Union(Box::new(Value::Record(self.fields))),\n            ),\n        ]))\n    }\n}\n\n/// Interpret a serializeable instance as a `Value`.\n///\n/// This conversion can fail if the value is not valid as per the Avro specification.\n/// e.g: HashMap with non-string keys\npub fn to_value\u003cS: Serialize\u003e(value: S) -\u003e Result\u003cValue, Error\u003e {\n    let mut serializer = Serializer::default();\n    value.serialize(\u0026mut serializer)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde::{Deserialize, Serialize};\n\n    #[derive(Debug, Deserialize, Serialize, Clone)]\n    struct Test {\n        a: i64,\n        b: String,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestInner {\n        a: Test,\n        b: i32,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitExternalEnum {\n        a: UnitExternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    enum UnitExternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitInternalEnum {\n        a: UnitInternalEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(tag = \"t\")]\n    enum UnitInternalEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitAdjacentEnum {\n        a: UnitAdjacentEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum UnitAdjacentEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    struct TestUnitUntaggedEnum {\n        a: UnitUntaggedEnum,\n    }\n\n    #[derive(Debug, Deserialize, Serialize)]\n    #[serde(untagged)]\n    enum UnitUntaggedEnum {\n        Val1,\n        Val2,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueExternalEnum {\n        a: SingleValueExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum SingleValueExternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueInternalEnum {\n        a: SingleValueInternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\")]\n    enum SingleValueInternalEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueAdjacentEnum {\n        a: SingleValueAdjacentEnum,\n    }\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum SingleValueAdjacentEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestSingleValueUntaggedEnum {\n        a: SingleValueUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum SingleValueUntaggedEnum {\n        Double(f64),\n        String(String),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructExternalEnum {\n        a: StructExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum StructExternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructInternalEnum {\n        a: StructInternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum StructInternalEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructAdjacentEnum {\n        a: StructAdjacentEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum StructAdjacentEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestStructUntaggedEnum {\n        a: StructUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum StructUntaggedEnum {\n        Val1 { x: f32, y: f32 },\n        Val2 { x: f32, y: f32, z: f32 },\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleExternalEnum {\n        a: TupleExternalEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    enum TupleExternalEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    // Tuple Internal Enum cannot be instantiated\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleAdjacentEnum {\n        a: TupleAdjacentEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"v\")]\n    enum TupleAdjacentEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    struct TestTupleUntaggedEnum {\n        a: TupleUntaggedEnum,\n    }\n\n    #[derive(Debug, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum TupleUntaggedEnum {\n        Val1(f32, f32),\n        Val2(f32, f32, f32),\n    }\n\n    #[test]\n    fn test_to_value() {\n        let test = Test {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let expected = Value::Record(vec![\n            (\"a\".to_owned(), Value::Long(27)),\n            (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n        ]);\n\n        assert_eq!(to_value(test.clone()).unwrap(), expected);\n\n        let test_inner = TestInner { a: test, b: 35 };\n\n        let expected_inner = Value::Record(vec![\n            (\n                \"a\".to_owned(),\n                Value::Record(vec![\n                    (\"a\".to_owned(), Value::Long(27)),\n                    (\"b\".to_owned(), Value::String(\"foo\".to_owned())),\n                ]),\n            ),\n            (\"b\".to_owned(), Value::Int(35)),\n        ]);\n\n        assert_eq!(to_value(test_inner).unwrap(), expected_inner);\n    }\n\n    #[test]\n    fn test_to_value_unit_enum() {\n        let test = TestUnitExternalEnum {\n            a: UnitExternalEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Enum(0, \"Val1\".to_owned()))]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit external enum\"\n        );\n\n        let test = TestUnitInternalEnum {\n            a: UnitInternalEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit internal enum\"\n        );\n\n        let test = TestUnitAdjacentEnum {\n            a: UnitAdjacentEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![(\"t\".to_owned(), Value::String(\"Val1\".to_owned()))]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit adjacent enum\"\n        );\n\n        let test = TestUnitUntaggedEnum {\n            a: UnitUntaggedEnum::Val1,\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Null)]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing unit untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_single_value_enum() {\n        let test = TestSingleValueExternalEnum {\n            a: SingleValueExternalEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(0, \"Double\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Double(64.0))),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value external enum\"\n        );\n\n        // It is not possible to serialize an internal Single Value enum...\n        let test = TestSingleValueInternalEnum {\n            a: SingleValueInternalEnum::Double(64.0),\n        };\n\n        assert!(to_value(test).is_err(), \"{}\", true);\n\n        let test = TestSingleValueAdjacentEnum {\n            a: SingleValueAdjacentEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Double\".to_owned())),\n                (\"v\".to_owned(), Value::Double(64.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value adjacent enum\"\n        );\n\n        let test = TestSingleValueUntaggedEnum {\n            a: SingleValueUntaggedEnum::Double(64.0),\n        };\n\n        let expected = Value::Record(vec![(\"a\".to_owned(), Value::Double(64.0))]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"Error serializing single value untagged enum\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_struct_enum() {\n        let test = TestStructExternalEnum {\n            a: StructExternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(0, \"Val1\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Union(Box::new(Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]))),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct external enum\"\n        );\n\n        // I don't think that this is feasible in avro\n\n        let test = TestStructInternalEnum {\n            a: StructInternalEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct internal enum\"\n        );\n\n        let test = TestStructAdjacentEnum {\n            a: StructAdjacentEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"v\".to_owned(),\n                    Value::Record(vec![\n                        (\"x\".to_owned(), Value::Float(1.0)),\n                        (\"y\".to_owned(), Value::Float(2.0)),\n                    ]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct adjacent enum\"\n        );\n\n        let test = TestStructUntaggedEnum {\n            a: StructUntaggedEnum::Val1 { x: 1.0, y: 2.0 },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct untagged enum\"\n        );\n\n        let test = TestStructUntaggedEnum {\n            a: StructUntaggedEnum::Val2 {\n                x: 1.0,\n                y: 2.0,\n                z: 3.0,\n            },\n        };\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"x\".to_owned(), Value::Float(1.0)),\n                (\"y\".to_owned(), Value::Float(2.0)),\n                (\"z\".to_owned(), Value::Float(3.0)),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing struct untagged enum variant\"\n        );\n    }\n\n    #[test]\n    fn test_to_value_tuple_enum() {\n        let test = TestTupleExternalEnum {\n            a: TupleExternalEnum::Val2(1.0, 2.0, 3.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"type\".to_owned(), Value::Enum(1, \"Val2\".to_owned())),\n                (\n                    \"value\".to_owned(),\n                    Value::Array(vec![\n                        Value::Union(Box::new(Value::Float(1.0))),\n                        Value::Union(Box::new(Value::Float(2.0))),\n                        Value::Union(Box::new(Value::Float(3.0))),\n                    ]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple external enum\"\n        );\n\n        let test = TestTupleAdjacentEnum {\n            a: TupleAdjacentEnum::Val1(1.0, 2.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Record(vec![\n                (\"t\".to_owned(), Value::String(\"Val1\".to_owned())),\n                (\n                    \"v\".to_owned(),\n                    Value::Array(vec![Value::Float(1.0), Value::Float(2.0)]),\n                ),\n            ]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple adjacent enum\"\n        );\n\n        let test = TestTupleUntaggedEnum {\n            a: TupleUntaggedEnum::Val1(1.0, 2.0),\n        };\n\n        let expected = Value::Record(vec![(\n            \"a\".to_owned(),\n            Value::Array(vec![Value::Float(1.0), Value::Float(2.0)]),\n        )]);\n\n        assert_eq!(\n            to_value(test).unwrap(),\n            expected,\n            \"error serializing tuple untagged enum\"\n        );\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":108},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","types.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling the intermediate representation of Avro values.\nuse crate::{\n    decimal::Decimal,\n    duration::Duration,\n    schema::{Precision, RecordField, Scale, Schema, SchemaKind, UnionSchema},\n    AvroResult, Error,\n};\nuse serde_json::{Number, Value as JsonValue};\nuse std::{collections::HashMap, convert::TryFrom, hash::BuildHasher, str::FromStr, u8};\nuse uuid::Uuid;\n\n/// Compute the maximum decimal value precision of a byte array of length `len` could hold.\nfn max_prec_for_len(len: usize) -\u003e Result\u003cusize, Error\u003e {\n    let len = i32::try_from(len).map_err(|e| Error::ConvertLengthToI32(e, len))?;\n    Ok((2.0_f64.powi(8 * len - 1) - 1.0).log10().floor() as usize)\n}\n\n/// A valid Avro value.\n///\n/// More information about Avro values can be found in the [Avro\n/// Specification](https://avro.apache.org/docs/current/spec.html#schemas)\n#[derive(Clone, Debug, PartialEq, strum_macros::EnumDiscriminants)]\n#[strum_discriminants(name(ValueKind))]\npub enum Value {\n    /// A `null` Avro value.\n    Null,\n    /// A `boolean` Avro value.\n    Boolean(bool),\n    /// A `int` Avro value.\n    Int(i32),\n    /// A `long` Avro value.\n    Long(i64),\n    /// A `float` Avro value.\n    Float(f32),\n    /// A `double` Avro value.\n    Double(f64),\n    /// A `bytes` Avro value.\n    Bytes(Vec\u003cu8\u003e),\n    /// A `string` Avro value.\n    String(String),\n    /// A `fixed` Avro value.\n    /// The size of the fixed value is represented as a `usize`.\n    Fixed(usize, Vec\u003cu8\u003e),\n    /// An `enum` Avro value.\n    ///\n    /// An Enum is represented by a symbol and its position in the symbols list\n    /// of its corresponding schema.\n    /// This allows schema-less encoding, as well as schema resolution while\n    /// reading values.\n    Enum(i32, String),\n    /// An `union` Avro value.\n    Union(Box\u003cValue\u003e),\n    /// An `array` Avro value.\n    Array(Vec\u003cValue\u003e),\n    /// A `map` Avro value.\n    Map(HashMap\u003cString, Value\u003e),\n    /// A `record` Avro value.\n    ///\n    /// A Record is represented by a vector of (`\u003crecord name\u003e`, `value`).\n    /// This allows schema-less encoding.\n    ///\n    /// See [Record](types.Record) for a more user-friendly support.\n    Record(Vec\u003c(String, Value)\u003e),\n    /// A date value.\n    ///\n    /// Serialized and deserialized as `i32` directly. Can only be deserialized properly with a\n    /// schema.\n    Date(i32),\n    /// An Avro Decimal value. Bytes are in big-endian order, per the Avro spec.\n    Decimal(Decimal),\n    /// Time in milliseconds.\n    TimeMillis(i32),\n    /// Time in microseconds.\n    TimeMicros(i64),\n    /// Timestamp in milliseconds.\n    TimestampMillis(i64),\n    /// Timestamp in microseconds.\n    TimestampMicros(i64),\n    /// Avro Duration. An amount of time defined by months, days and milliseconds.\n    Duration(Duration),\n    /// Universally unique identifier.\n    /// Universally unique identifier.\n    Uuid(Uuid),\n}\n/// Any structure implementing the [ToAvro](trait.ToAvro.html) trait will be usable\n/// from a [Writer](../writer/struct.Writer.html).\n#[deprecated(\n    since = \"0.11.0\",\n    note = \"Please use Value::from, Into::into or value.into() instead\"\n)]\npub trait ToAvro {\n    /// Transforms this value into an Avro-compatible [Value](enum.Value.html).\n    fn avro(self) -\u003e Value;\n}\n\n#[allow(deprecated)]\nimpl\u003cT: Into\u003cValue\u003e\u003e ToAvro for T {\n    fn avro(self) -\u003e Value {\n        self.into()\n    }\n}\n\nmacro_rules! to_value(\n    ($type:ty, $variant_constructor:expr) =\u003e (\n        impl From\u003c$type\u003e for Value {\n            fn from(value: $type) -\u003e Self {\n                $variant_constructor(value)\n            }\n        }\n    );\n);\n\nto_value!(bool, Value::Boolean);\nto_value!(i32, Value::Int);\nto_value!(i64, Value::Long);\nto_value!(f32, Value::Float);\nto_value!(f64, Value::Double);\nto_value!(String, Value::String);\nto_value!(Vec\u003cu8\u003e, Value::Bytes);\nto_value!(uuid::Uuid, Value::Uuid);\nto_value!(Decimal, Value::Decimal);\nto_value!(Duration, Value::Duration);\n\nimpl From\u003c()\u003e for Value {\n    fn from(_: ()) -\u003e Self {\n        Self::Null\n    }\n}\n\nimpl From\u003cusize\u003e for Value {\n    fn from(value: usize) -\u003e Self {\n        i64::try_from(value)\n            .expect(\"cannot convert usize to i64\")\n            .into()\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Value {\n    fn from(value: \u0026str) -\u003e Self {\n        Self::String(value.to_owned())\n    }\n}\n\nimpl From\u003c\u0026[u8]\u003e for Value {\n    fn from(value: \u0026[u8]) -\u003e Self {\n        Self::Bytes(value.to_owned())\n    }\n}\n\nimpl\u003cT\u003e From\u003cOption\u003cT\u003e\u003e for Value\nwhere\n    T: Into\u003cSelf\u003e,\n{\n    fn from(value: Option\u003cT\u003e) -\u003e Self {\n        Self::Union(Box::new(value.map_or_else(|| Self::Null, Into::into)))\n    }\n}\n\nimpl\u003cK, V, S\u003e From\u003cHashMap\u003cK, V, S\u003e\u003e for Value\nwhere\n    K: Into\u003cString\u003e,\n    V: Into\u003cSelf\u003e,\n    S: BuildHasher,\n{\n    fn from(value: HashMap\u003cK, V, S\u003e) -\u003e Self {\n        Self::Map(\n            value\n                .into_iter()\n                .map(|(key, value)| (key.into(), value.into()))\n                .collect(),\n        )\n    }\n}\n\n/// Utility interface to build `Value::Record` objects.\n#[derive(Debug, Clone)]\npub struct Record\u003c'a\u003e {\n    /// List of fields contained in the record.\n    /// Ordered according to the fields in the schema given to create this\n    /// `Record` object. Any unset field defaults to `Value::Null`.\n    pub fields: Vec\u003c(String, Value)\u003e,\n    schema_lookup: \u0026'a HashMap\u003cString, usize\u003e,\n}\n\nimpl\u003c'a\u003e Record\u003c'a\u003e {\n    /// Create a `Record` given a `Schema`.\n    ///\n    /// If the `Schema` is not a `Schema::Record` variant, `None` will be returned.\n    pub fn new(schema: \u0026Schema) -\u003e Option\u003cRecord\u003e {\n        match *schema {\n            Schema::Record {\n                fields: ref schema_fields,\n                lookup: ref schema_lookup,\n                ..\n            } =\u003e {\n                let mut fields = Vec::with_capacity(schema_fields.len());\n                for schema_field in schema_fields.iter() {\n                    fields.push((schema_field.name.clone(), Value::Null));\n                }\n\n                Some(Record {\n                    fields,\n                    schema_lookup,\n                })\n            }\n            _ =\u003e None,\n        }\n    }\n\n    /// Put a compatible value (implementing the `ToAvro` trait) in the\n    /// `Record` for a given `field` name.\n    ///\n    /// **NOTE** Only ensure that the field name is present in the `Schema` given when creating\n    /// this `Record`. Does not perform any schema validation.\n    pub fn put\u003cV\u003e(\u0026mut self, field: \u0026str, value: V)\n    where\n        V: Into\u003cValue\u003e,\n    {\n        if let Some(\u0026position) = self.schema_lookup.get(field) {\n            self.fields[position].1 = value.into()\n        }\n    }\n}\n\nimpl\u003c'a\u003e From\u003cRecord\u003c'a\u003e\u003e for Value {\n    fn from(value: Record\u003c'a\u003e) -\u003e Self {\n        Self::Record(value.fields)\n    }\n}\n\nimpl From\u003cJsonValue\u003e for Value {\n    fn from(value: JsonValue) -\u003e Self {\n        match value {\n            JsonValue::Null =\u003e Self::Null,\n            JsonValue::Bool(b) =\u003e b.into(),\n            JsonValue::Number(ref n) if n.is_i64() =\u003e Value::Long(n.as_i64().unwrap()),\n            JsonValue::Number(ref n) if n.is_f64() =\u003e Value::Double(n.as_f64().unwrap()),\n            JsonValue::Number(n) =\u003e Value::Long(n.as_u64().unwrap() as i64), // TODO: Not so great\n            JsonValue::String(s) =\u003e s.into(),\n            JsonValue::Array(items) =\u003e Value::Array(items.into_iter().map(Value::from).collect()),\n            JsonValue::Object(items) =\u003e Value::Map(\n                items\n                    .into_iter()\n                    .map(|(key, value)| (key, value.into()))\n                    .collect(),\n            ),\n        }\n    }\n}\n\n/// Convert Avro values to Json values\nimpl std::convert::TryFrom\u003cValue\u003e for JsonValue {\n    type Error = crate::error::Error;\n    fn try_from(value: Value) -\u003e AvroResult\u003cSelf\u003e {\n        match value {\n            Value::Null =\u003e Ok(Self::Null),\n            Value::Boolean(b) =\u003e Ok(Self::Bool(b)),\n            Value::Int(i) =\u003e Ok(Self::Number(i.into())),\n            Value::Long(l) =\u003e Ok(Self::Number(l.into())),\n            Value::Float(f) =\u003e Number::from_f64(f.into())\n                .map(Self::Number)\n                .ok_or_else(|| Error::ConvertF64ToJson(f.into())),\n            Value::Double(d) =\u003e Number::from_f64(d)\n                .map(Self::Number)\n                .ok_or(Error::ConvertF64ToJson(d)),\n            Value::Bytes(bytes) =\u003e Ok(Self::Array(bytes.into_iter().map(|b| b.into()).collect())),\n            Value::String(s) =\u003e Ok(Self::String(s)),\n            Value::Fixed(_size, items) =\u003e {\n                Ok(Self::Array(items.into_iter().map(|v| v.into()).collect()))\n            }\n            Value::Enum(_i, s) =\u003e Ok(Self::String(s)),\n            Value::Union(b) =\u003e Self::try_from(*b),\n            Value::Array(items) =\u003e items\n                .into_iter()\n                .map(Self::try_from)\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n                .map(Self::Array),\n            Value::Map(items) =\u003e items\n                .into_iter()\n                .map(|(key, value)| Self::try_from(value).map(|v| (key, v)))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n                .map(|v| Self::Object(v.into_iter().collect())),\n            Value::Record(items) =\u003e items\n                .into_iter()\n                .map(|(key, value)| Self::try_from(value).map(|v| (key, v)))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n                .map(|v| Self::Object(v.into_iter().collect())),\n            Value::Date(d) =\u003e Ok(Self::Number(d.into())),\n            Value::Decimal(ref d) =\u003e \u003cVec\u003cu8\u003e\u003e::try_from(d)\n                .map(|vec| Self::Array(vec.into_iter().map(|v| v.into()).collect())),\n            Value::TimeMillis(t) =\u003e Ok(Self::Number(t.into())),\n            Value::TimeMicros(t) =\u003e Ok(Self::Number(t.into())),\n            Value::TimestampMillis(t) =\u003e Ok(Self::Number(t.into())),\n            Value::TimestampMicros(t) =\u003e Ok(Self::Number(t.into())),\n            Value::Duration(d) =\u003e Ok(Self::Array(\n                \u003c[u8; 12]\u003e::from(d).iter().map(|\u0026v| v.into()).collect(),\n            )),\n            Value::Uuid(uuid) =\u003e Ok(Self::String(uuid.to_hyphenated().to_string())),\n        }\n    }\n}\n\nimpl Value {\n    /// Validate the value against the given [Schema](../schema/enum.Schema.html).\n    ///\n    /// See the [Avro specification](https://avro.apache.org/docs/current/spec.html)\n    /// for the full set of rules of schema validation.\n    pub fn validate(\u0026self, schema: \u0026Schema) -\u003e bool {\n        match (self, schema) {\n            (\u0026Value::Null, \u0026Schema::Null) =\u003e true,\n            (\u0026Value::Boolean(_), \u0026Schema::Boolean) =\u003e true,\n            (\u0026Value::Int(_), \u0026Schema::Int) =\u003e true,\n            (\u0026Value::Int(_), \u0026Schema::Date) =\u003e true,\n            (\u0026Value::Int(_), \u0026Schema::TimeMillis) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::Long) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::TimeMicros) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::TimestampMillis) =\u003e true,\n            (\u0026Value::Long(_), \u0026Schema::TimestampMicros) =\u003e true,\n            (\u0026Value::TimestampMicros(_), \u0026Schema::TimestampMicros) =\u003e true,\n            (\u0026Value::TimestampMillis(_), \u0026Schema::TimestampMillis) =\u003e true,\n            (\u0026Value::TimeMicros(_), \u0026Schema::TimeMicros) =\u003e true,\n            (\u0026Value::TimeMillis(_), \u0026Schema::TimeMillis) =\u003e true,\n            (\u0026Value::Date(_), \u0026Schema::Date) =\u003e true,\n            (\u0026Value::Decimal(_), \u0026Schema::Decimal { .. }) =\u003e true,\n            (\u0026Value::Duration(_), \u0026Schema::Duration) =\u003e true,\n            (\u0026Value::Uuid(_), \u0026Schema::Uuid) =\u003e true,\n            (\u0026Value::Float(_), \u0026Schema::Float) =\u003e true,\n            (\u0026Value::Double(_), \u0026Schema::Double) =\u003e true,\n            (\u0026Value::Bytes(_), \u0026Schema::Bytes) =\u003e true,\n            (\u0026Value::Bytes(_), \u0026Schema::Decimal { .. }) =\u003e true,\n            (\u0026Value::String(_), \u0026Schema::String) =\u003e true,\n            (\u0026Value::String(_), \u0026Schema::Uuid) =\u003e true,\n            (\u0026Value::Fixed(n, _), \u0026Schema::Fixed { size, .. }) =\u003e n == size,\n            (\u0026Value::Bytes(ref b), \u0026Schema::Fixed { size, .. }) =\u003e b.len() == size,\n            (\u0026Value::Fixed(n, _), \u0026Schema::Duration) =\u003e n == 12,\n            // TODO: check precision against n\n            (\u0026Value::Fixed(_n, _), \u0026Schema::Decimal { .. }) =\u003e true,\n            (\u0026Value::String(ref s), \u0026Schema::Enum { ref symbols, .. }) =\u003e symbols.contains(s),\n            (\u0026Value::Enum(i, ref s), \u0026Schema::Enum { ref symbols, .. }) =\u003e symbols\n                .get(i as usize)\n                .map(|ref symbol| symbol == \u0026s)\n                .unwrap_or(false),\n            // (\u0026Value::Union(None), \u0026Schema::Union(_)) =\u003e true,\n            (\u0026Value::Union(ref value), \u0026Schema::Union(ref inner)) =\u003e {\n                inner.find_schema(value).is_some()\n            }\n            (\u0026Value::Array(ref items), \u0026Schema::Array(ref inner)) =\u003e {\n                items.iter().all(|item| item.validate(inner))\n            }\n            (\u0026Value::Map(ref items), \u0026Schema::Map(ref inner)) =\u003e {\n                items.iter().all(|(_, value)| value.validate(inner))\n            }\n            (\u0026Value::Record(ref record_fields), \u0026Schema::Record { ref fields, .. }) =\u003e {\n                fields.len() == record_fields.len()\n                    \u0026\u0026 fields.iter().zip(record_fields.iter()).all(\n                        |(field, \u0026(ref name, ref value))| {\n                            field.name == *name \u0026\u0026 value.validate(\u0026field.schema)\n                        },\n                    )\n            }\n            (\u0026Value::Map(ref items), \u0026Schema::Record { ref fields, .. }) =\u003e {\n                fields.iter().all(|field| {\n                    if let Some(item) = items.get(\u0026field.name) {\n                        item.validate(\u0026field.schema)\n                    } else {\n                        false\n                    }\n                })\n            }\n            _ =\u003e false,\n        }\n    }\n\n    /// Attempt to perform schema resolution on the value, with the given\n    /// [Schema](../schema/enum.Schema.html).\n    ///\n    /// See [Schema Resolution](https://avro.apache.org/docs/current/spec.html#Schema+Resolution)\n    /// in the Avro specification for the full set of rules of schema\n    /// resolution.\n    pub fn resolve(mut self, schema: \u0026Schema) -\u003e AvroResult\u003cSelf\u003e {\n        // Check if this schema is a union, and if the reader schema is not.\n        if SchemaKind::from(\u0026self) == SchemaKind::Union\n            \u0026\u0026 SchemaKind::from(schema) != SchemaKind::Union\n        {\n            // Pull out the Union, and attempt to resolve against it.\n            let v = match self {\n                Value::Union(b) =\u003e *b,\n                _ =\u003e unreachable!(),\n            };\n            self = v;\n        }\n        match *schema {\n            Schema::Null =\u003e self.resolve_null(),\n            Schema::Boolean =\u003e self.resolve_boolean(),\n            Schema::Int =\u003e self.resolve_int(),\n            Schema::Long =\u003e self.resolve_long(),\n            Schema::Float =\u003e self.resolve_float(),\n            Schema::Double =\u003e self.resolve_double(),\n            Schema::Bytes =\u003e self.resolve_bytes(),\n            Schema::String =\u003e self.resolve_string(),\n            Schema::Fixed { size, .. } =\u003e self.resolve_fixed(size),\n            Schema::Union(ref inner) =\u003e self.resolve_union(inner),\n            Schema::Enum { ref symbols, .. } =\u003e self.resolve_enum(symbols),\n            Schema::Array(ref inner) =\u003e self.resolve_array(inner),\n            Schema::Map(ref inner) =\u003e self.resolve_map(inner),\n            Schema::Record { ref fields, .. } =\u003e self.resolve_record(fields),\n            Schema::Decimal {\n                scale,\n                precision,\n                ref inner,\n            } =\u003e self.resolve_decimal(precision, scale, inner),\n            Schema::Date =\u003e self.resolve_date(),\n            Schema::TimeMillis =\u003e self.resolve_time_millis(),\n            Schema::TimeMicros =\u003e self.resolve_time_micros(),\n            Schema::TimestampMillis =\u003e self.resolve_timestamp_millis(),\n            Schema::TimestampMicros =\u003e self.resolve_timestamp_micros(),\n            Schema::Duration =\u003e self.resolve_duration(),\n            Schema::Uuid =\u003e self.resolve_uuid(),\n        }\n    }\n\n    fn resolve_uuid(self) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(match self {\n            uuid @ Value::Uuid(_) =\u003e uuid,\n            Value::String(ref string) =\u003e {\n                Value::Uuid(Uuid::from_str(string).map_err(Error::ConvertStrToUuid)?)\n            }\n            other =\u003e return Err(Error::GetUuid(other.into())),\n        })\n    }\n\n    fn resolve_duration(self) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(match self {\n            duration @ Value::Duration { .. } =\u003e duration,\n            Value::Fixed(size, bytes) =\u003e {\n                if size != 12 {\n                    return Err(Error::GetDecimalFixedBytes(size));\n                }\n                Value::Duration(Duration::from([\n                    bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],\n                    bytes[8], bytes[9], bytes[10], bytes[11],\n                ]))\n            }\n            other =\u003e return Err(Error::ResolveDuration(other.into())),\n        })\n    }\n\n    fn resolve_decimal(\n        self,\n        precision: Precision,\n        scale: Scale,\n        inner: \u0026Schema,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        if scale \u003e precision {\n            return Err(Error::GetScaleAndPrecision { scale, precision });\n        }\n        match inner {\n            \u0026Schema::Fixed { size, .. } =\u003e {\n                if max_prec_for_len(size)? \u003c precision {\n                    return Err(Error::GetScaleWithFixedSize { size, precision });\n                }\n            }\n            Schema::Bytes =\u003e (),\n            _ =\u003e return Err(Error::ResolveDecimalSchema(inner.into())),\n        };\n        match self {\n            Value::Decimal(num) =\u003e {\n                let num_bytes = num.len();\n                if max_prec_for_len(num_bytes)? \u003e precision {\n                    Err(Error::ComparePrecisionAndSize {\n                        precision,\n                        num_bytes,\n                    })\n                } else {\n                    Ok(Value::Decimal(num))\n                }\n                // check num.bits() here\n            }\n            Value::Fixed(_, bytes) | Value::Bytes(bytes) =\u003e {\n                if max_prec_for_len(bytes.len())? \u003e precision {\n                    Err(Error::ComparePrecisionAndSize {\n                        precision,\n                        num_bytes: bytes.len(),\n                    })\n                } else {\n                    // precision and scale match, can we assume the underlying type can hold the data?\n                    Ok(Value::Decimal(Decimal::from(bytes)))\n                }\n            }\n            other =\u003e Err(Error::ResolveDecimal(other.into())),\n        }\n    }\n\n    fn resolve_date(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Date(d) | Value::Int(d) =\u003e Ok(Value::Date(d)),\n            other =\u003e Err(Error::GetDate(other.into())),\n        }\n    }\n\n    fn resolve_time_millis(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimeMillis(t) | Value::Int(t) =\u003e Ok(Value::TimeMillis(t)),\n            other =\u003e Err(Error::GetTimeMillis(other.into())),\n        }\n    }\n\n    fn resolve_time_micros(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimeMicros(t) | Value::Long(t) =\u003e Ok(Value::TimeMicros(t)),\n            Value::Int(t) =\u003e Ok(Value::TimeMicros(i64::from(t))),\n            other =\u003e Err(Error::GetTimeMicros(other.into())),\n        }\n    }\n\n    fn resolve_timestamp_millis(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimestampMillis(ts) | Value::Long(ts) =\u003e Ok(Value::TimestampMillis(ts)),\n            Value::Int(ts) =\u003e Ok(Value::TimestampMillis(i64::from(ts))),\n            other =\u003e Err(Error::GetTimestampMillis(other.into())),\n        }\n    }\n\n    fn resolve_timestamp_micros(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::TimestampMicros(ts) | Value::Long(ts) =\u003e Ok(Value::TimestampMicros(ts)),\n            Value::Int(ts) =\u003e Ok(Value::TimestampMicros(i64::from(ts))),\n            other =\u003e Err(Error::GetTimestampMicros(other.into())),\n        }\n    }\n\n    fn resolve_null(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Null =\u003e Ok(Value::Null),\n            other =\u003e Err(Error::GetNull(other.into())),\n        }\n    }\n\n    fn resolve_boolean(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Boolean(b) =\u003e Ok(Value::Boolean(b)),\n            other =\u003e Err(Error::GetBoolean(other.into())),\n        }\n    }\n\n    fn resolve_int(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Int(n)),\n            Value::Long(n) =\u003e Ok(Value::Int(n as i32)),\n            other =\u003e Err(Error::GetInt(other.into())),\n        }\n    }\n\n    fn resolve_long(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Long(i64::from(n))),\n            Value::Long(n) =\u003e Ok(Value::Long(n)),\n            other =\u003e Err(Error::GetLong(other.into())),\n        }\n    }\n\n    fn resolve_float(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Float(n as f32)),\n            Value::Long(n) =\u003e Ok(Value::Float(n as f32)),\n            Value::Float(x) =\u003e Ok(Value::Float(x)),\n            Value::Double(x) =\u003e Ok(Value::Float(x as f32)),\n            other =\u003e Err(Error::GetFloat(other.into())),\n        }\n    }\n\n    fn resolve_double(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Int(n) =\u003e Ok(Value::Double(f64::from(n))),\n            Value::Long(n) =\u003e Ok(Value::Double(n as f64)),\n            Value::Float(x) =\u003e Ok(Value::Double(f64::from(x))),\n            Value::Double(x) =\u003e Ok(Value::Double(x)),\n            other =\u003e Err(Error::GetDouble(other.into())),\n        }\n    }\n\n    fn resolve_bytes(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Bytes(bytes) =\u003e Ok(Value::Bytes(bytes)),\n            Value::String(s) =\u003e Ok(Value::Bytes(s.into_bytes())),\n            Value::Array(items) =\u003e Ok(Value::Bytes(\n                items\n                    .into_iter()\n                    .map(Value::try_u8)\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?,\n            )),\n            other =\u003e Err(Error::GetBytes(other.into())),\n        }\n    }\n\n    fn resolve_string(self) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::String(s) =\u003e Ok(Value::String(s)),\n            Value::Bytes(bytes) =\u003e Ok(Value::String(\n                String::from_utf8(bytes).map_err(Error::ConvertToUtf8)?,\n            )),\n            other =\u003e Err(Error::GetString(other.into())),\n        }\n    }\n\n    fn resolve_fixed(self, size: usize) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Fixed(n, bytes) =\u003e {\n                if n == size {\n                    Ok(Value::Fixed(n, bytes))\n                } else {\n                    Err(Error::CompareFixedSizes { size, n })\n                }\n            }\n            other =\u003e Err(Error::GetStringForFixed(other.into())),\n        }\n    }\n\n    fn resolve_enum(self, symbols: \u0026[String]) -\u003e Result\u003cSelf, Error\u003e {\n        let validate_symbol = |symbol: String, symbols: \u0026[String]| {\n            if let Some(index) = symbols.iter().position(|item| item == \u0026symbol) {\n                Ok(Value::Enum(index as i32, symbol))\n            } else {\n                Err(Error::GetEnumDefault {\n                    symbol,\n                    symbols: symbols.into(),\n                })\n            }\n        };\n\n        match self {\n            Value::Enum(raw_index, s) =\u003e {\n                let index = usize::try_from(raw_index)\n                    .map_err(|e| Error::ConvertI32ToUsize(e, raw_index))?;\n                if (0..=symbols.len()).contains(\u0026index) {\n                    validate_symbol(s, symbols)\n                } else {\n                    Err(Error::GetEnumValue {\n                        index,\n                        nsymbols: symbols.len(),\n                    })\n                }\n            }\n            Value::String(s) =\u003e validate_symbol(s, symbols),\n            other =\u003e Err(Error::GetEnum(other.into())),\n        }\n    }\n\n    fn resolve_union(self, schema: \u0026UnionSchema) -\u003e Result\u003cSelf, Error\u003e {\n        let v = match self {\n            // Both are unions case.\n            Value::Union(v) =\u003e *v,\n            // Reader is a union, but writer is not.\n            v =\u003e v,\n        };\n        // Find the first match in the reader schema.\n        let (_, inner) = schema.find_schema(\u0026v).ok_or(Error::FindUnionVariant)?;\n        Ok(Value::Union(Box::new(v.resolve(inner)?)))\n    }\n\n    fn resolve_array(self, schema: \u0026Schema) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Array(items) =\u003e Ok(Value::Array(\n                items\n                    .into_iter()\n                    .map(|item| item.resolve(schema))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()?,\n            )),\n            other =\u003e Err(Error::GetArray {\n                expected: schema.into(),\n                other: other.into(),\n            }),\n        }\n    }\n\n    fn resolve_map(self, schema: \u0026Schema) -\u003e Result\u003cSelf, Error\u003e {\n        match self {\n            Value::Map(items) =\u003e Ok(Value::Map(\n                items\n                    .into_iter()\n                    .map(|(key, value)| value.resolve(schema).map(|value| (key, value)))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()?,\n            )),\n            other =\u003e Err(Error::GetMap {\n                expected: schema.into(),\n                other: other.into(),\n            }),\n        }\n    }\n\n    fn resolve_record(self, fields: \u0026[RecordField]) -\u003e Result\u003cSelf, Error\u003e {\n        let mut items = match self {\n            Value::Map(items) =\u003e Ok(items),\n            Value::Record(fields) =\u003e Ok(fields.into_iter().collect::\u003cHashMap\u003c_, _\u003e\u003e()),\n            other =\u003e Err(Error::GetRecord {\n                expected: fields\n                    .iter()\n                    .map(|field| (field.name.clone(), field.schema.clone().into()))\n                    .collect(),\n                other: other.into(),\n            }),\n        }?;\n\n        let new_fields = fields\n            .iter()\n            .map(|field| {\n                let value = match items.remove(\u0026field.name) {\n                    Some(value) =\u003e value,\n                    None =\u003e match field.default {\n                        Some(ref value) =\u003e match field.schema {\n                            Schema::Enum { ref symbols, .. } =\u003e {\n                                Value::from(value.clone()).resolve_enum(symbols)?\n                            }\n                            Schema::Union(ref union_schema) =\u003e {\n                                let first = \u0026union_schema.variants()[0];\n                                // NOTE: this match exists only to optimize null defaults for large\n                                // backward-compatible schemas with many nullable fields\n                                match first {\n                                    Schema::Null =\u003e Value::Union(Box::new(Value::Null)),\n                                    _ =\u003e Value::Union(Box::new(\n                                        Value::from(value.clone()).resolve(first)?,\n                                    )),\n                                }\n                            }\n                            _ =\u003e Value::from(value.clone()),\n                        },\n                        None =\u003e {\n                            return Err(Error::GetField(field.name.clone()));\n                        }\n                    },\n                };\n                value\n                    .resolve(\u0026field.schema)\n                    .map(|value| (field.name.clone(), value))\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        Ok(Value::Record(new_fields))\n    }\n\n    fn try_u8(self) -\u003e AvroResult\u003cu8\u003e {\n        let int = self.resolve(\u0026Schema::Int)?;\n        if let Value::Int(n) = int {\n            if n \u003e= 0 \u0026\u0026 n \u003c= i32::from(u8::MAX) {\n                return Ok(n as u8);\n            }\n        }\n\n        Err(Error::GetU8(int.into()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        decimal::Decimal,\n        duration::{Days, Duration, Millis, Months},\n        schema::{Name, RecordField, RecordFieldOrder, Schema, UnionSchema},\n        types::Value,\n    };\n    use uuid::Uuid;\n\n    #[test]\n    fn validate() {\n        let value_schema_valid = vec![\n            (Value::Int(42), Schema::Int, true),\n            (Value::Int(42), Schema::Boolean, false),\n            (\n                Value::Union(Box::new(Value::Null)),\n                Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Int(42))),\n                Schema::Union(UnionSchema::new(vec![Schema::Null, Schema::Int]).unwrap()),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Null)),\n                Schema::Union(UnionSchema::new(vec![Schema::Double, Schema::Int]).unwrap()),\n                false,\n            ),\n            (\n                Value::Union(Box::new(Value::Int(42))),\n                Schema::Union(\n                    UnionSchema::new(vec![\n                        Schema::Null,\n                        Schema::Double,\n                        Schema::String,\n                        Schema::Int,\n                    ])\n                    .unwrap(),\n                ),\n                true,\n            ),\n            (\n                Value::Union(Box::new(Value::Long(42i64))),\n                Schema::Union(\n                    UnionSchema::new(vec![Schema::Null, Schema::TimestampMillis]).unwrap(),\n                ),\n                true,\n            ),\n            (\n                Value::Array(vec![Value::Long(42i64)]),\n                Schema::Array(Box::new(Schema::Long)),\n                true,\n            ),\n            (\n                Value::Array(vec![Value::Boolean(true)]),\n                Schema::Array(Box::new(Schema::Long)),\n                false,\n            ),\n            (Value::Record(vec![]), Schema::Null, false),\n        ];\n\n        for (value, schema, valid) in value_schema_valid.into_iter() {\n            assert_eq!(valid, value.validate(\u0026schema));\n        }\n    }\n\n    #[test]\n    fn validate_fixed() {\n        let schema = Schema::Fixed {\n            size: 4,\n            name: Name::new(\"some_fixed\"),\n        };\n\n        assert!(Value::Fixed(4, vec![0, 0, 0, 0]).validate(\u0026schema));\n        assert!(!Value::Fixed(5, vec![0, 0, 0, 0, 0]).validate(\u0026schema));\n        assert!(Value::Bytes(vec![0, 0, 0, 0]).validate(\u0026schema));\n        assert!(!Value::Bytes(vec![0, 0, 0, 0, 0]).validate(\u0026schema));\n    }\n\n    #[test]\n    fn validate_enum() {\n        let schema = Schema::Enum {\n            name: Name::new(\"some_enum\"),\n            doc: None,\n            symbols: vec![\n                \"spades\".to_string(),\n                \"hearts\".to_string(),\n                \"diamonds\".to_string(),\n                \"clubs\".to_string(),\n            ],\n        };\n\n        assert!(Value::Enum(0, \"spades\".to_string()).validate(\u0026schema));\n        assert!(Value::String(\"spades\".to_string()).validate(\u0026schema));\n\n        assert!(!Value::Enum(1, \"spades\".to_string()).validate(\u0026schema));\n        assert!(!Value::String(\"lorem\".to_string()).validate(\u0026schema));\n\n        let other_schema = Schema::Enum {\n            name: Name::new(\"some_other_enum\"),\n            doc: None,\n            symbols: vec![\n                \"hearts\".to_string(),\n                \"diamonds\".to_string(),\n                \"clubs\".to_string(),\n                \"spades\".to_string(),\n            ],\n        };\n\n        assert!(!Value::Enum(0, \"spades\".to_string()).validate(\u0026other_schema));\n    }\n\n    #[test]\n    fn validate_record() {\n        use std::collections::HashMap;\n        // {\n        //    \"type\": \"record\",\n        //    \"fields\": [\n        //      {\"type\": \"long\", \"name\": \"a\"},\n        //      {\"type\": \"string\", \"name\": \"b\"}\n        //    ]\n        // }\n        let schema = Schema::Record {\n            name: Name::new(\"some_record\"),\n            doc: None,\n            fields: vec![\n                RecordField {\n                    name: \"a\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::Long,\n                    order: RecordFieldOrder::Ascending,\n                    position: 0,\n                },\n                RecordField {\n                    name: \"b\".to_string(),\n                    doc: None,\n                    default: None,\n                    schema: Schema::String,\n                    order: RecordFieldOrder::Ascending,\n                    position: 1,\n                },\n            ],\n            lookup: HashMap::new(),\n        };\n\n        assert!(Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            (\"a\".to_string(), Value::Long(42i64)),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Boolean(false)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"c\".to_string(), Value::String(\"foo\".to_string())),\n        ])\n        .validate(\u0026schema));\n\n        assert!(!Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            (\"c\".to_string(), Value::Null),\n        ])\n        .validate(\u0026schema));\n\n        assert!(Value::Map(\n            vec![\n                (\"a\".to_string(), Value::Long(42i64)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            ]\n            .into_iter()\n            .collect()\n        )\n        .validate(\u0026schema));\n\n        let union_schema = Schema::Union(UnionSchema::new(vec![Schema::Null, schema]).unwrap());\n\n        assert!(Value::Union(Box::new(Value::Record(vec![\n            (\"a\".to_string(), Value::Long(42i64)),\n            (\"b\".to_string(), Value::String(\"foo\".to_string())),\n        ])))\n        .validate(\u0026union_schema));\n\n        assert!(Value::Union(Box::new(Value::Map(\n            vec![\n                (\"a\".to_string(), Value::Long(42i64)),\n                (\"b\".to_string(), Value::String(\"foo\".to_string())),\n            ]\n            .into_iter()\n            .collect()\n        )))\n        .validate(\u0026union_schema));\n    }\n\n    #[test]\n    fn resolve_bytes_ok() {\n        let value = Value::Array(vec![Value::Int(0), Value::Int(42)]);\n        assert_eq!(\n            value.resolve(\u0026Schema::Bytes).unwrap(),\n            Value::Bytes(vec![0u8, 42u8])\n        );\n    }\n\n    #[test]\n    fn resolve_bytes_failure() {\n        let value = Value::Array(vec![Value::Int(2000), Value::Int(-42)]);\n        assert!(value.resolve(\u0026Schema::Bytes).is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_bytes() {\n        let value = Value::Decimal(Decimal::from(vec![1, 2]));\n        value\n            .clone()\n            .resolve(\u0026Schema::Decimal {\n                precision: 10,\n                scale: 4,\n                inner: Box::new(Schema::Bytes),\n            })\n            .unwrap();\n        assert!(value.resolve(\u0026Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_invalid_scale() {\n        let value = Value::Decimal(Decimal::from(vec![1]));\n        assert!(value\n            .resolve(\u0026Schema::Decimal {\n                precision: 2,\n                scale: 3,\n                inner: Box::new(Schema::Bytes),\n            })\n            .is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_invalid_precision_for_length() {\n        let value = Value::Decimal(Decimal::from((1u8..=8u8).rev().collect::\u003cVec\u003c_\u003e\u003e()));\n        assert!(value\n            .resolve(\u0026Schema::Decimal {\n                precision: 1,\n                scale: 0,\n                inner: Box::new(Schema::Bytes),\n            })\n            .is_err());\n    }\n\n    #[test]\n    fn resolve_decimal_fixed() {\n        let value = Value::Decimal(Decimal::from(vec![1, 2]));\n        assert!(value\n            .clone()\n            .resolve(\u0026Schema::Decimal {\n                precision: 10,\n                scale: 1,\n                inner: Box::new(Schema::Fixed {\n                    name: Name::new(\"decimal\"),\n                    size: 20\n                })\n            })\n            .is_ok());\n        assert!(value.resolve(\u0026Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_date() {\n        let value = Value::Date(2345);\n        assert!(value.clone().resolve(\u0026Schema::Date).is_ok());\n        assert!(value.resolve(\u0026Schema::String).is_err());\n    }\n\n    #[test]\n    fn resolve_time_millis() {\n        let value = Value::TimeMillis(10);\n        assert!(value.clone().resolve(\u0026Schema::TimeMillis).is_ok());\n        assert!(value.resolve(\u0026Schema::TimeMicros).is_err());\n    }\n\n    #[test]\n    fn resolve_time_micros() {\n        let value = Value::TimeMicros(10);\n        assert!(value.clone().resolve(\u0026Schema::TimeMicros).is_ok());\n        assert!(value.resolve(\u0026Schema::TimeMillis).is_err());\n    }\n\n    #[test]\n    fn resolve_timestamp_millis() {\n        let value = Value::TimestampMillis(10);\n        assert!(value.clone().resolve(\u0026Schema::TimestampMillis).is_ok());\n        assert!(value.resolve(\u0026Schema::Float).is_err());\n\n        let value = Value::Float(10.0f32);\n        assert!(value.resolve(\u0026Schema::TimestampMillis).is_err());\n    }\n\n    #[test]\n    fn resolve_timestamp_micros() {\n        let value = Value::TimestampMicros(10);\n        assert!(value.clone().resolve(\u0026Schema::TimestampMicros).is_ok());\n        assert!(value.resolve(\u0026Schema::Int).is_err());\n\n        let value = Value::Double(10.0);\n        assert!(value.resolve(\u0026Schema::TimestampMicros).is_err());\n    }\n\n    #[test]\n    fn resolve_duration() {\n        let value = Value::Duration(Duration::new(\n            Months::new(10),\n            Days::new(5),\n            Millis::new(3000),\n        ));\n        assert!(value.clone().resolve(\u0026Schema::Duration).is_ok());\n        assert!(value.resolve(\u0026Schema::TimestampMicros).is_err());\n        assert!(Value::Long(1i64).resolve(\u0026Schema::Duration).is_err());\n    }\n\n    #[test]\n    fn resolve_uuid() {\n        let value = Value::Uuid(Uuid::parse_str(\"1481531d-ccc9-46d9-a56f-5b67459c0537\").unwrap());\n        assert!(value.clone().resolve(\u0026Schema::Uuid).is_ok());\n        assert!(value.resolve(\u0026Schema::TimestampMicros).is_err());\n    }\n\n    #[test]\n    fn json_from_avro() {\n        assert_eq!(JsonValue::try_from(Value::Null).unwrap(), JsonValue::Null);\n        assert_eq!(\n            JsonValue::try_from(Value::Boolean(true)).unwrap(),\n            JsonValue::Bool(true)\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Int(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Long(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Float(1.0)).unwrap(),\n            JsonValue::Number(Number::from_f64(1.0).unwrap())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Double(1.0)).unwrap(),\n            JsonValue::Number(Number::from_f64(1.0).unwrap())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Bytes(vec![1, 2, 3])).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::String(\"test\".into())).unwrap(),\n            JsonValue::String(\"test\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Fixed(3, vec![1, 2, 3])).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Enum(1, \"test_enum\".into())).unwrap(),\n            JsonValue::String(\"test_enum\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Union(Box::new(Value::String(\"test_enum\".into())))).unwrap(),\n            JsonValue::String(\"test_enum\".into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Array(vec![\n                Value::Int(1),\n                Value::Int(2),\n                Value::Int(3)\n            ]))\n            .unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Map(\n                vec![\n                    (\"v1\".to_string(), Value::Int(1)),\n                    (\"v2\".to_string(), Value::Int(2)),\n                    (\"v3\".to_string(), Value::Int(3))\n                ]\n                .into_iter()\n                .collect()\n            ))\n            .unwrap(),\n            JsonValue::Object(\n                vec![\n                    (\"v1\".to_string(), JsonValue::Number(1.into())),\n                    (\"v2\".to_string(), JsonValue::Number(2.into())),\n                    (\"v3\".to_string(), JsonValue::Number(3.into()))\n                ]\n                .into_iter()\n                .collect()\n            )\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Record(vec![\n                (\"v1\".to_string(), Value::Int(1)),\n                (\"v2\".to_string(), Value::Int(2)),\n                (\"v3\".to_string(), Value::Int(3))\n            ]))\n            .unwrap(),\n            JsonValue::Object(\n                vec![\n                    (\"v1\".to_string(), JsonValue::Number(1.into())),\n                    (\"v2\".to_string(), JsonValue::Number(2.into())),\n                    (\"v3\".to_string(), JsonValue::Number(3.into()))\n                ]\n                .into_iter()\n                .collect()\n            )\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Date(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Decimal(vec![1, 2, 3].into())).unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into())\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimeMillis(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimeMicros(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimestampMillis(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::TimestampMicros(1)).unwrap(),\n            JsonValue::Number(1.into())\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Duration(\n                [1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8].into()\n            ))\n            .unwrap(),\n            JsonValue::Array(vec![\n                JsonValue::Number(1.into()),\n                JsonValue::Number(2.into()),\n                JsonValue::Number(3.into()),\n                JsonValue::Number(4.into()),\n                JsonValue::Number(5.into()),\n                JsonValue::Number(6.into()),\n                JsonValue::Number(7.into()),\n                JsonValue::Number(8.into()),\n                JsonValue::Number(9.into()),\n                JsonValue::Number(10.into()),\n                JsonValue::Number(11.into()),\n                JsonValue::Number(12.into()),\n            ])\n        );\n        assert_eq!(\n            JsonValue::try_from(Value::Uuid(\n                Uuid::parse_str(\"936DA01F-9ABD-4D9D-80C7-02AF85C822A8\").unwrap()\n            ))\n            .unwrap(),\n            JsonValue::String(\"936da01f-9abd-4d9d-80c7-02af85c822a8\".into())\n        );\n    }\n}\n","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","util.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nuse crate::{AvroResult, Error};\nuse serde_json::{Map, Value};\nuse std::{convert::TryFrom, i64, io::Read, sync::Once};\n\n/// Maximum number of bytes that can be allocated when decoding\n/// Avro-encoded values. This is a protection against ill-formed\n/// data, whose length field might be interpreted as enourmous.\n/// See max_allocation_bytes to change this limit.\npub static mut MAX_ALLOCATION_BYTES: usize = 512 * 1024 * 1024;\nstatic MAX_ALLOCATION_BYTES_ONCE: Once = Once::new();\n\npub trait MapHelper {\n    fn string(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e;\n\n    fn name(\u0026self) -\u003e Option\u003cString\u003e {\n        self.string(\"name\")\n    }\n\n    fn doc(\u0026self) -\u003e Option\u003cString\u003e {\n        self.string(\"doc\")\n    }\n}\n\nimpl MapHelper for Map\u003cString, Value\u003e {\n    fn string(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.get(key)\n            .and_then(|v| v.as_str())\n            .map(|v| v.to_string())\n    }\n}\n\npub fn read_long\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003ci64\u003e {\n    zag_i64(reader)\n}\n\npub fn zig_i32(n: i32, buffer: \u0026mut Vec\u003cu8\u003e) {\n    zig_i64(n as i64, buffer)\n}\n\npub fn zig_i64(n: i64, buffer: \u0026mut Vec\u003cu8\u003e) {\n    encode_variable(((n \u003c\u003c 1) ^ (n \u003e\u003e 63)) as u64, buffer)\n}\n\npub fn zag_i32\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003ci32\u003e {\n    let i = zag_i64(reader)?;\n    i32::try_from(i).map_err(|e| Error::ZagI32(e, i))\n}\n\npub fn zag_i64\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003ci64\u003e {\n    let z = decode_variable(reader)?;\n    Ok(if z \u0026 0x1 == 0 {\n        (z \u003e\u003e 1) as i64\n    } else {\n        !(z \u003e\u003e 1) as i64\n    })\n}\n\nfn encode_variable(mut z: u64, buffer: \u0026mut Vec\u003cu8\u003e) {\n    loop {\n        if z \u003c= 0x7F {\n            buffer.push((z \u0026 0x7F) as u8);\n            break;\n        } else {\n            buffer.push((0x80 | (z \u0026 0x7F)) as u8);\n            z \u003e\u003e= 7;\n        }\n    }\n}\n\nfn decode_variable\u003cR: Read\u003e(reader: \u0026mut R) -\u003e AvroResult\u003cu64\u003e {\n    let mut i = 0u64;\n    let mut buf = [0u8; 1];\n\n    let mut j = 0;\n    loop {\n        if j \u003e 9 {\n            // if j * 7 \u003e 64\n            return Err(Error::IntegerOverflow);\n        }\n        reader\n            .read_exact(\u0026mut buf[..])\n            .map_err(Error::ReadVariableIntegerBytes)?;\n        i |= (u64::from(buf[0] \u0026 0x7F)) \u003c\u003c (j * 7);\n        if (buf[0] \u003e\u003e 7) == 0 {\n            break;\n        } else {\n            j += 1;\n        }\n    }\n\n    Ok(i)\n}\n\n/// Set a new maximum number of bytes that can be allocated when decoding data.\n/// Once called, the limit cannot be changed.\n///\n/// **NOTE** This function must be called before decoding **any** data. The\n/// library leverages [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html)\n/// to set the limit either when calling this method, or when decoding for\n/// the first time.\npub fn max_allocation_bytes(num_bytes: usize) -\u003e usize {\n    unsafe {\n        MAX_ALLOCATION_BYTES_ONCE.call_once(|| {\n            MAX_ALLOCATION_BYTES = num_bytes;\n        });\n        MAX_ALLOCATION_BYTES\n    }\n}\n\npub fn safe_len(len: usize) -\u003e AvroResult\u003cusize\u003e {\n    let max_bytes = max_allocation_bytes(512 * 1024 * 1024);\n\n    if len \u003c= max_bytes {\n        Ok(len)\n    } else {\n        Err(Error::MemoryAllocation {\n            desired: len,\n            maximum: max_bytes,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_zigzag() {\n        let mut a = Vec::new();\n        let mut b = Vec::new();\n        zig_i32(42i32, \u0026mut a);\n        zig_i64(42i64, \u0026mut b);\n        assert_eq!(a, b);\n    }\n\n    #[test]\n    fn test_zig_i64() {\n        let mut s = Vec::new();\n        zig_i64(std::i32::MAX as i64, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i64(std::i32::MAX as i64 + 1, \u0026mut s);\n        assert_eq!(s, [128, 128, 128, 128, 16]);\n\n        s.clear();\n        zig_i64(std::i32::MIN as i64, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i64(std::i32::MIN as i64 - 1, \u0026mut s);\n        assert_eq!(s, [129, 128, 128, 128, 16]);\n\n        s.clear();\n        zig_i64(i64::MAX, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 255, 255, 255, 255, 255, 1]);\n\n        s.clear();\n        zig_i64(i64::MIN, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 255, 255, 255, 255, 255, 1]);\n    }\n\n    #[test]\n    fn test_zig_i32() {\n        let mut s = Vec::new();\n        zig_i32(std::i32::MAX / 2, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 7]);\n\n        s.clear();\n        zig_i32(std::i32::MIN / 2, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 7]);\n\n        s.clear();\n        zig_i32(-(std::i32::MIN / 2), \u0026mut s);\n        assert_eq!(s, [128, 128, 128, 128, 8]);\n\n        s.clear();\n        zig_i32(std::i32::MIN / 2 - 1, \u0026mut s);\n        assert_eq!(s, [129, 128, 128, 128, 8]);\n\n        s.clear();\n        zig_i32(std::i32::MAX, \u0026mut s);\n        assert_eq!(s, [254, 255, 255, 255, 15]);\n\n        s.clear();\n        zig_i32(std::i32::MIN, \u0026mut s);\n        assert_eq!(s, [255, 255, 255, 255, 15]);\n    }\n\n    #[test]\n    fn test_overflow() {\n        let causes_left_shift_overflow: \u0026[u8] = \u0026[0xe1, 0xe1, 0xe1, 0xe1, 0xe1];\n        assert!(decode_variable(\u0026mut \u0026*causes_left_shift_overflow).is_err());\n    }\n\n    #[test]\n    fn test_safe_len() {\n        assert_eq!(42usize, safe_len(42usize).unwrap());\n        assert!(safe_len(1024 * 1024 * 1024).is_err());\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","src","writer.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Logic handling writing in Avro format at user level.\nuse crate::{\n    encode::{encode, encode_ref, encode_to_vec},\n    schema::Schema,\n    ser::Serializer,\n    types::Value,\n    AvroResult, Codec, Error,\n};\nuse rand::random;\nuse serde::Serialize;\nuse std::{collections::HashMap, io::Write};\n\nconst DEFAULT_BLOCK_SIZE: usize = 16000;\nconst AVRO_OBJECT_HEADER: \u0026[u8] = b\"Obj\\x01\";\n\n/// Main interface for writing Avro formatted values.\n#[derive(typed_builder::TypedBuilder)]\npub struct Writer\u003c'a, W\u003e {\n    schema: \u0026'a Schema,\n    writer: W,\n    #[builder(default = Codec::Null)]\n    codec: Codec,\n    #[builder(default = DEFAULT_BLOCK_SIZE)]\n    block_size: usize,\n    #[builder(default = Vec::with_capacity(block_size), setter(skip))]\n    buffer: Vec\u003cu8\u003e,\n    #[builder(default, setter(skip))]\n    serializer: Serializer,\n    #[builder(default = 0, setter(skip))]\n    num_values: usize,\n    #[builder(default = std::iter::repeat_with(random).take(16).collect(), setter(skip))]\n    marker: Vec\u003cu8\u003e,\n    #[builder(default = false, setter(skip))]\n    has_header: bool,\n}\n\nimpl\u003c'a, W: Write\u003e Writer\u003c'a, W\u003e {\n    /// Creates a `Writer` given a `Schema` and something implementing the `io::Write` trait to write\n    /// to.\n    /// No compression `Codec` will be used.\n    pub fn new(schema: \u0026'a Schema, writer: W) -\u003e Self {\n        Self::builder().schema(schema).writer(writer).build()\n    }\n\n    /// Creates a `Writer` with a specific `Codec` given a `Schema` and something implementing the\n    /// `io::Write` trait to write to.\n    pub fn with_codec(schema: \u0026'a Schema, writer: W, codec: Codec) -\u003e Self {\n        Self::builder()\n            .schema(schema)\n            .writer(writer)\n            .codec(codec)\n            .build()\n    }\n\n    /// Get a reference to the `Schema` associated to a `Writer`.\n    pub fn schema(\u0026self) -\u003e \u0026'a Schema {\n        self.schema\n    }\n\n    /// Append a compatible value (implementing the `ToAvro` trait) to a `Writer`, also performing\n    /// schema validation.\n    ///\n    /// Return the number of bytes written (it might be 0, see below).\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append\u003cT: Into\u003cValue\u003e\u003e(\u0026mut self, value: T) -\u003e AvroResult\u003cusize\u003e {\n        let n = if !self.has_header {\n            let header = self.header()?;\n            let n = self.append_bytes(header.as_ref())?;\n            self.has_header = true;\n            n\n        } else {\n            0\n        };\n\n        let avro = value.into();\n        write_value_ref(self.schema, \u0026avro, \u0026mut self.buffer)?;\n\n        self.num_values += 1;\n\n        if self.buffer.len() \u003e= self.block_size {\n            return self.flush().map(|b| b + n);\n        }\n\n        Ok(n)\n    }\n\n    /// Append a compatible value to a `Writer`, also performing schema validation.\n    ///\n    /// Return the number of bytes written (it might be 0, see below).\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append_value_ref(\u0026mut self, value: \u0026Value) -\u003e AvroResult\u003cusize\u003e {\n        let n = if !self.has_header {\n            let header = self.header()?;\n            let n = self.append_bytes(header.as_ref())?;\n            self.has_header = true;\n            n\n        } else {\n            0\n        };\n\n        write_value_ref(self.schema, value, \u0026mut self.buffer)?;\n\n        self.num_values += 1;\n\n        if self.buffer.len() \u003e= self.block_size {\n            return self.flush().map(|b| b + n);\n        }\n\n        Ok(n)\n    }\n\n    /// Append anything implementing the `Serialize` trait to a `Writer` for\n    /// [`serde`](https://docs.serde.rs/serde/index.html) compatibility, also performing schema\n    /// validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function is not guaranteed to perform any actual write, since it relies on\n    /// internal buffering for performance reasons. If you want to be sure the value has been\n    /// written, then call [`flush`](struct.Writer.html#method.flush).\n    pub fn append_ser\u003cS: Serialize\u003e(\u0026mut self, value: S) -\u003e AvroResult\u003cusize\u003e {\n        let avro_value = value.serialize(\u0026mut self.serializer)?;\n        self.append(avro_value)\n    }\n\n    /// Extend a `Writer` with an `Iterator` of compatible values (implementing the `ToAvro`\n    /// trait), also performing schema validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend\u003cI, T: Into\u003cValue\u003e\u003e(\u0026mut self, values: I) -\u003e AvroResult\u003cusize\u003e\n    where\n        I: IntoIterator\u003cItem = T\u003e,\n    {\n        /*\n        https://github.com/rust-lang/rfcs/issues/811 :(\n        let mut stream = values\n            .filter_map(|value| value.serialize(\u0026mut self.serializer).ok())\n            .map(|value| value.encode(self.schema))\n            .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n            .ok_or_else(|| err_msg(\"value does not match given schema\"))?\n            .into_iter()\n            .fold(Vec::new(), |mut acc, stream| {\n                num_values += 1;\n                acc.extend(stream); acc\n            });\n        */\n\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Extend a `Writer` with an `Iterator` of anything implementing the `Serialize` trait for\n    /// [`serde`](https://docs.serde.rs/serde/index.html) compatibility, also performing schema\n    /// validation.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend_ser\u003cI, T: Serialize\u003e(\u0026mut self, values: I) -\u003e AvroResult\u003cusize\u003e\n    where\n        I: IntoIterator\u003cItem = T\u003e,\n    {\n        /*\n        https://github.com/rust-lang/rfcs/issues/811 :(\n        let mut stream = values\n            .filter_map(|value| value.serialize(\u0026mut self.serializer).ok())\n            .map(|value| value.encode(self.schema))\n            .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n            .ok_or_else(|| err_msg(\"value does not match given schema\"))?\n            .into_iter()\n            .fold(Vec::new(), |mut acc, stream| {\n                num_values += 1;\n                acc.extend(stream); acc\n            });\n        */\n\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append_ser(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Extend a `Writer` by appending each `Value` from a slice, while also performing schema\n    /// validation on each value appended.\n    ///\n    /// Return the number of bytes written.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn extend_from_slice(\u0026mut self, values: \u0026[Value]) -\u003e AvroResult\u003cusize\u003e {\n        let mut num_bytes = 0;\n        for value in values {\n            num_bytes += self.append_value_ref(value)?;\n        }\n        num_bytes += self.flush()?;\n\n        Ok(num_bytes)\n    }\n\n    /// Flush the content appended to a `Writer`. Call this function to make sure all the content\n    /// has been written before releasing the `Writer`.\n    ///\n    /// Return the number of bytes written.\n    pub fn flush(\u0026mut self) -\u003e AvroResult\u003cusize\u003e {\n        if self.num_values == 0 {\n            return Ok(0);\n        }\n\n        self.codec.compress(\u0026mut self.buffer)?;\n\n        let num_values = self.num_values;\n        let stream_len = self.buffer.len();\n\n        let num_bytes = self.append_raw(\u0026num_values.into(), \u0026Schema::Long)?\n            + self.append_raw(\u0026stream_len.into(), \u0026Schema::Long)?\n            + self\n                .writer\n                .write(self.buffer.as_ref())\n                .map_err(Error::WriteBytes)?\n            + self.append_marker()?;\n\n        self.buffer.clear();\n        self.num_values = 0;\n\n        Ok(num_bytes)\n    }\n\n    /// Return what the `Writer` is writing to, consuming the `Writer` itself.\n    ///\n    /// **NOTE** This function forces the written data to be flushed (an implicit\n    /// call to [`flush`](struct.Writer.html#method.flush) is performed).\n    pub fn into_inner(mut self) -\u003e AvroResult\u003cW\u003e {\n        self.flush()?;\n        Ok(self.writer)\n    }\n\n    /// Generate and append synchronization marker to the payload.\n    fn append_marker(\u0026mut self) -\u003e AvroResult\u003cusize\u003e {\n        // using .writer.write directly to avoid mutable borrow of self\n        // with ref borrowing of self.marker\n        self.writer.write(\u0026self.marker).map_err(Error::WriteMarker)\n    }\n\n    /// Append a raw Avro Value to the payload avoiding to encode it again.\n    fn append_raw(\u0026mut self, value: \u0026Value, schema: \u0026Schema) -\u003e AvroResult\u003cusize\u003e {\n        self.append_bytes(encode_to_vec(value, schema).as_ref())\n    }\n\n    /// Append pure bytes to the payload.\n    fn append_bytes(\u0026mut self, bytes: \u0026[u8]) -\u003e AvroResult\u003cusize\u003e {\n        self.writer.write(bytes).map_err(Error::WriteBytes)\n    }\n\n    /// Create an Avro header based on schema, codec and sync marker.\n    fn header(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n        let schema_bytes = serde_json::to_string(self.schema)\n            .map_err(Error::ConvertJsonToString)?\n            .into_bytes();\n\n        let mut metadata = HashMap::with_capacity(2);\n        metadata.insert(\"avro.schema\", Value::Bytes(schema_bytes));\n        metadata.insert(\"avro.codec\", self.codec.into());\n\n        let mut header = Vec::new();\n        header.extend_from_slice(AVRO_OBJECT_HEADER);\n        encode(\n            \u0026metadata.into(),\n            \u0026Schema::Map(Box::new(Schema::Bytes)),\n            \u0026mut header,\n        );\n        header.extend_from_slice(\u0026self.marker);\n\n        Ok(header)\n    }\n}\n\n/// Encode a compatible value (implementing the `ToAvro` trait) into Avro format, also performing\n/// schema validation.\n///\n/// This is an internal function which gets the bytes buffer where to write as parameter instead of\n/// creating a new one like `to_avro_datum`.\nfn write_avro_datum\u003cT: Into\u003cValue\u003e\u003e(\n    schema: \u0026Schema,\n    value: T,\n    buffer: \u0026mut Vec\u003cu8\u003e,\n) -\u003e Result\u003c(), Error\u003e {\n    let avro = value.into();\n    if !avro.validate(schema) {\n        return Err(Error::Validation);\n    }\n    encode(\u0026avro, schema, buffer);\n    Ok(())\n}\n\nfn write_value_ref(schema: \u0026Schema, value: \u0026Value, buffer: \u0026mut Vec\u003cu8\u003e) -\u003e AvroResult\u003c()\u003e {\n    if !value.validate(schema) {\n        return Err(Error::Validation);\n    }\n    encode_ref(value, schema, buffer);\n    Ok(())\n}\n\n/// Encode a compatible value (implementing the `ToAvro` trait) into Avro format, also\n/// performing schema validation.\n///\n/// **NOTE** This function has a quite small niche of usage and does NOT generate headers and sync\n/// markers; use [`Writer`](struct.Writer.html) to be fully Avro-compatible if you don't know what\n/// you are doing, instead.\npub fn to_avro_datum\u003cT: Into\u003cValue\u003e\u003e(schema: \u0026Schema, value: T) -\u003e AvroResult\u003cVec\u003cu8\u003e\u003e {\n    let mut buffer = Vec::new();\n    write_avro_datum(schema, value, \u0026mut buffer)?;\n    Ok(buffer)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        decimal::Decimal,\n        duration::{Days, Duration, Millis, Months},\n        schema::Name,\n        types::Record,\n        util::zig_i64,\n    };\n    use serde::{Deserialize, Serialize};\n\n    const AVRO_OBJECT_HEADER_LEN: usize = AVRO_OBJECT_HEADER.len();\n\n    const SCHEMA: \u0026str = r#\"\n    {\n      \"type\": \"record\",\n      \"name\": \"test\",\n      \"fields\": [\n        {\n          \"name\": \"a\",\n          \"type\": \"long\",\n          \"default\": 42\n        },\n        {\n          \"name\": \"b\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n    \"#;\n    const UNION_SCHEMA: \u0026str = r#\"[\"null\", \"long\"]\"#;\n\n    #[test]\n    fn test_to_avro_datum() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let mut expected = Vec::new();\n        zig_i64(27, \u0026mut expected);\n        zig_i64(3, \u0026mut expected);\n        expected.extend(vec![b'f', b'o', b'o'].into_iter());\n\n        assert_eq!(to_avro_datum(\u0026schema, record).unwrap(), expected);\n    }\n\n    #[test]\n    fn test_union_not_null() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let union = Value::Union(Box::new(Value::Long(3)));\n\n        let mut expected = Vec::new();\n        zig_i64(1, \u0026mut expected);\n        zig_i64(3, \u0026mut expected);\n\n        assert_eq!(to_avro_datum(\u0026schema, union).unwrap(), expected);\n    }\n\n    #[test]\n    fn test_union_null() {\n        let schema = Schema::parse_str(UNION_SCHEMA).unwrap();\n        let union = Value::Union(Box::new(Value::Null));\n\n        let mut expected = Vec::new();\n        zig_i64(0, \u0026mut expected);\n\n        assert_eq!(to_avro_datum(\u0026schema, union).unwrap(), expected);\n    }\n\n    type TestResult\u003cT\u003e = Result\u003cT, Box\u003cdyn std::error::Error\u003e\u003e;\n\n    fn logical_type_test\u003cT: Into\u003cValue\u003e + Clone\u003e(\n        schema_str: \u0026'static str,\n\n        expected_schema: \u0026Schema,\n        value: Value,\n\n        raw_schema: \u0026Schema,\n        raw_value: T,\n    ) -\u003e TestResult\u003c()\u003e {\n        let schema = Schema::parse_str(schema_str)?;\n        assert_eq!(\u0026schema, expected_schema);\n        // The serialized format should be the same as the schema.\n        let ser = to_avro_datum(\u0026schema, value.clone())?;\n        let raw_ser = to_avro_datum(raw_schema, raw_value)?;\n        assert_eq!(ser, raw_ser);\n\n        // Should deserialize from the schema into the logical type.\n        let mut r = ser.as_slice();\n        let de = crate::from_avro_datum(\u0026schema, \u0026mut r, None).unwrap();\n        assert_eq!(de, value);\n        Ok(())\n    }\n\n    #[test]\n    fn date() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#,\n            \u0026Schema::Date,\n            Value::Date(1_i32),\n            \u0026Schema::Int,\n            1_i32,\n        )\n    }\n\n    #[test]\n    fn time_millis() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"int\", \"logicalType\": \"time-millis\"}\"#,\n            \u0026Schema::TimeMillis,\n            Value::TimeMillis(1_i32),\n            \u0026Schema::Int,\n            1_i32,\n        )\n    }\n\n    #[test]\n    fn time_micros() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"time-micros\"}\"#,\n            \u0026Schema::TimeMicros,\n            Value::TimeMicros(1_i64),\n            \u0026Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn timestamp_millis() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\"#,\n            \u0026Schema::TimestampMillis,\n            Value::TimestampMillis(1_i64),\n            \u0026Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn timestamp_micros() -\u003e TestResult\u003c()\u003e {\n        logical_type_test(\n            r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#,\n            \u0026Schema::TimestampMicros,\n            Value::TimestampMicros(1_i64),\n            \u0026Schema::Long,\n            1_i64,\n        )\n    }\n\n    #[test]\n    fn decimal_fixed() -\u003e TestResult\u003c()\u003e {\n        let size = 30;\n        let inner = Schema::Fixed {\n            name: Name::new(\"decimal\"),\n            size,\n        };\n        let value = vec![0u8; size];\n        logical_type_test(\n            r#\"{\"type\": {\"type\": \"fixed\", \"size\": 30, \"name\": \"decimal\"}, \"logicalType\": \"decimal\", \"precision\": 20, \"scale\": 5}\"#,\n            \u0026Schema::Decimal {\n                precision: 20,\n                scale: 5,\n                inner: Box::new(inner.clone()),\n            },\n            Value::Decimal(Decimal::from(value.clone())),\n            \u0026inner,\n            Value::Fixed(size, value),\n        )\n    }\n\n    #[test]\n    fn decimal_bytes() -\u003e TestResult\u003c()\u003e {\n        let inner = Schema::Bytes;\n        let value = vec![0u8; 10];\n        logical_type_test(\n            r#\"{\"type\": \"bytes\", \"logicalType\": \"decimal\", \"precision\": 4, \"scale\": 3}\"#,\n            \u0026Schema::Decimal {\n                precision: 4,\n                scale: 3,\n                inner: Box::new(inner.clone()),\n            },\n            Value::Decimal(Decimal::from(value.clone())),\n            \u0026inner,\n            value,\n        )\n    }\n\n    #[test]\n    fn duration() -\u003e TestResult\u003c()\u003e {\n        let inner = Schema::Fixed {\n            name: Name::new(\"duration\"),\n            size: 12,\n        };\n        let value = Value::Duration(Duration::new(\n            Months::new(256),\n            Days::new(512),\n            Millis::new(1024),\n        ));\n        logical_type_test(\n            r#\"{\"type\": {\"type\": \"fixed\", \"name\": \"duration\", \"size\": 12}, \"logicalType\": \"duration\"}\"#,\n            \u0026Schema::Duration,\n            value,\n            \u0026inner,\n            Value::Fixed(12, vec![0, 1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0]),\n        )\n    }\n\n    #[test]\n    fn test_writer_append() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let n1 = writer.append(record.clone()).unwrap();\n        let n2 = writer.append(record.clone()).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_extend() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let mut record = Record::new(\u0026schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n        let record_copy = record.clone();\n        let records = vec![record, record_copy];\n\n        let n1 = writer.extend(records.into_iter()).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[derive(Debug, Clone, Deserialize, Serialize)]\n    struct TestSerdeSerialize {\n        a: i64,\n        b: String,\n    }\n\n    #[test]\n    fn test_writer_append_ser() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let record = TestSerdeSerialize {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n\n        let n1 = writer.append_ser(record).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_extend_ser() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let mut writer = Writer::new(\u0026schema, Vec::new());\n\n        let record = TestSerdeSerialize {\n            a: 27,\n            b: \"foo\".to_owned(),\n        };\n        let record_copy = record.clone();\n        let records = vec![record, record_copy];\n\n        let n1 = writer.extend_ser(records.into_iter()).unwrap();\n        let n2 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    fn make_writer_with_codec(schema: \u0026Schema) -\u003e Writer\u003c'_, Vec\u003cu8\u003e\u003e {\n        Writer::with_codec(schema, Vec::new(), Codec::Deflate)\n    }\n\n    fn make_writer_with_builder(schema: \u0026Schema) -\u003e Writer\u003c'_, Vec\u003cu8\u003e\u003e {\n        Writer::builder()\n            .writer(Vec::new())\n            .schema(schema)\n            .codec(Codec::Deflate)\n            .block_size(100)\n            .build()\n    }\n\n    fn check_writer(mut writer: Writer\u003c'_, Vec\u003cu8\u003e\u003e, schema: \u0026Schema) {\n        let mut record = Record::new(schema).unwrap();\n        record.put(\"a\", 27i64);\n        record.put(\"b\", \"foo\");\n\n        let n1 = writer.append(record.clone()).unwrap();\n        let n2 = writer.append(record.clone()).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        zig_i64(27, \u0026mut data);\n        zig_i64(3, \u0026mut data);\n        data.extend(b\"foo\");\n        data.extend(data.clone());\n        Codec::Deflate.compress(\u0026mut data).unwrap();\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n\n    #[test]\n    fn test_writer_with_codec() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let writer = make_writer_with_codec(\u0026schema);\n        check_writer(writer, \u0026schema);\n    }\n\n    #[test]\n    fn test_writer_with_builder() {\n        let schema = Schema::parse_str(SCHEMA).unwrap();\n        let writer = make_writer_with_builder(\u0026schema);\n        check_writer(writer, \u0026schema);\n    }\n\n    #[test]\n    fn test_logical_writer() {\n        const LOGICAL_TYPE_SCHEMA: \u0026str = r#\"\n        {\n          \"type\": \"record\",\n          \"name\": \"logical_type_test\",\n          \"fields\": [\n            {\n              \"name\": \"a\",\n              \"type\": [\n                \"null\",\n                {\n                  \"type\": \"long\",\n                  \"logicalType\": \"timestamp-micros\"\n                }\n              ]\n            }\n          ]\n        }\n        \"#;\n        let codec = Codec::Deflate;\n        let schema = Schema::parse_str(LOGICAL_TYPE_SCHEMA).unwrap();\n        let mut writer = Writer::builder()\n            .schema(\u0026schema)\n            .codec(codec)\n            .writer(Vec::new())\n            .build();\n\n        let mut record1 = Record::new(\u0026schema).unwrap();\n        record1.put(\n            \"a\",\n            Value::Union(Box::new(Value::TimestampMicros(1234_i64))),\n        );\n\n        let mut record2 = Record::new(\u0026schema).unwrap();\n        record2.put(\"a\", Value::Union(Box::new(Value::Null)));\n\n        let n1 = writer.append(record1).unwrap();\n        let n2 = writer.append(record2).unwrap();\n        let n3 = writer.flush().unwrap();\n        let result = writer.into_inner().unwrap();\n\n        assert_eq!(n1 + n2 + n3, result.len());\n\n        let mut data = Vec::new();\n        // byte indicating not null\n        zig_i64(1, \u0026mut data);\n        zig_i64(1234, \u0026mut data);\n\n        // byte indicating null\n        zig_i64(0, \u0026mut data);\n        codec.compress(\u0026mut data).unwrap();\n\n        // starts with magic\n        assert_eq!(\u0026result[..AVRO_OBJECT_HEADER_LEN], AVRO_OBJECT_HEADER);\n        // ends with data and sync marker\n        let last_data_byte = result.len() - 16;\n        assert_eq!(\n            \u0026result[last_data_byte - data.len()..last_data_byte],\n            data.as_slice()\n        );\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":109},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","tests","io.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Port of https://github.com/apache/avro/blob/release-1.9.1/lang/py/test/test_io.py\nuse avro_rs::{from_avro_datum, to_avro_datum, types::Value, Error, Schema};\nuse lazy_static::lazy_static;\nuse std::io::Cursor;\n\nlazy_static! {\n    static ref SCHEMAS_TO_VALIDATE: Vec\u003c(\u0026'static str, Value)\u003e = vec![\n        (r#\"\"null\"\"#, Value::Null),\n        (r#\"\"boolean\"\"#, Value::Boolean(true)),\n        (r#\"\"string\"\"#, Value::String(\"adsfasdf09809dsf-=adsf\".to_string())),\n        (r#\"\"bytes\"\"#, Value::Bytes(\"12345abcd\".to_string().into_bytes())),\n        (r#\"\"int\"\"#, Value::Int(1234)),\n        (r#\"\"long\"\"#, Value::Long(1234)),\n        (r#\"\"float\"\"#, Value::Float(1234.0)),\n        (r#\"\"double\"\"#, Value::Double(1234.0)),\n        (r#\"{\"type\": \"fixed\", \"name\": \"Test\", \"size\": 1}\"#, Value::Fixed(1, vec![b'B'])),\n        (r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\"#, Value::Enum(1, \"B\".to_string())),\n        (r#\"{\"type\": \"array\", \"items\": \"long\"}\"#, Value::Array(vec![Value::Long(1), Value::Long(3), Value::Long(2)])),\n        (r#\"{\"type\": \"map\", \"values\": \"long\"}\"#, Value::Map([(\"a\".to_string(), Value::Long(1i64)), (\"b\".to_string(), Value::Long(3i64)), (\"c\".to_string(), Value::Long(2i64))].iter().cloned().collect())),\n        (r#\"[\"string\", \"null\", \"long\"]\"#, Value::Union(Box::new(Value::Null))),\n        (r#\"{\"type\": \"record\", \"name\": \"Test\", \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]}\"#, Value::Record(vec![(\"f\".to_string(), Value::Long(1))]))\n    ];\n\n    static ref BINARY_ENCODINGS: Vec\u003c(i64, Vec\u003cu8\u003e)\u003e = vec![\n        (0, vec![0x00]),\n        (-1, vec![0x01]),\n        (1, vec![0x02]),\n        (-2, vec![0x03]),\n        (2, vec![0x04]),\n        (-64, vec![0x7f]),\n        (64, vec![0x80, 0x01]),\n        (8192, vec![0x80, 0x80, 0x01]),\n        (-8193, vec![0x81, 0x80, 0x01]),\n    ];\n\n    static ref DEFAULT_VALUE_EXAMPLES: Vec\u003c(\u0026'static str, \u0026'static str, Value)\u003e = vec![\n        (r#\"\"null\"\"#, \"null\", Value::Null),\n        (r#\"\"boolean\"\"#, \"true\", Value::Boolean(true)),\n        (r#\"\"string\"\"#, r#\"\"foo\"\"#, Value::String(\"foo\".to_string())),\n        // TODO: (#96) investigate why this is failing\n        //(r#\"\"bytes\"\"#, r#\"\"\\u00FF\\u00FF\"\"#, Value::Bytes(vec![0xff, 0xff])),\n        (r#\"\"int\"\"#, \"5\", Value::Int(5)),\n        (r#\"\"long\"\"#, \"5\", Value::Long(5)),\n        (r#\"\"float\"\"#, \"1.1\", Value::Float(1.1)),\n        (r#\"\"double\"\"#, \"1.1\", Value::Double(1.1)),\n        // TODO: (#96) investigate why this is failing\n        //(r#\"{\"type\": \"fixed\", \"name\": \"F\", \"size\": 2}\"#, r#\"\"\\u00FF\\u00FF\"\"#, Value::Bytes(vec![0xff, 0xff])),\n        (r#\"{\"type\": \"enum\", \"name\": \"F\", \"symbols\": [\"FOO\", \"BAR\"]}\"#, r#\"\"FOO\"\"#, Value::Enum(0, \"FOO\".to_string())),\n        (r#\"{\"type\": \"array\", \"items\": \"int\"}\"#, \"[1, 2, 3]\", Value::Array(vec![Value::Int(1), Value::Int(2), Value::Int(3)])),\n        (r#\"{\"type\": \"map\", \"values\": \"int\"}\"#, r#\"{\"a\": 1, \"b\": 2}\"#, Value::Map([(\"a\".to_string(), Value::Int(1)), (\"b\".to_string(), Value::Int(2))].iter().cloned().collect())),\n        (r#\"[\"int\", \"null\"]\"#, \"5\", Value::Union(Box::new(Value::Int(5)))),\n        (r#\"{\"type\": \"record\", \"name\": \"F\", \"fields\": [{\"name\": \"A\", \"type\": \"int\"}]}\"#, r#\"{\"A\": 5}\"#,Value::Record(vec![(\"A\".to_string(), Value::Int(5))])),\n    ];\n\n    static ref LONG_RECORD_SCHEMA: Schema = Schema::parse_str(r#\"\n    {\n        \"type\": \"record\",\n        \"name\": \"Test\",\n        \"fields\": [\n            {\"name\": \"A\", \"type\": \"int\"},\n            {\"name\": \"B\", \"type\": \"int\"},\n            {\"name\": \"C\", \"type\": \"int\"},\n            {\"name\": \"D\", \"type\": \"int\"},\n            {\"name\": \"E\", \"type\": \"int\"},\n            {\"name\": \"F\", \"type\": \"int\"},\n            {\"name\": \"G\", \"type\": \"int\"}\n        ]\n    }\n    \"#).unwrap();\n\n    static ref LONG_RECORD_DATUM: Value = Value::Record(vec![\n        (\"A\".to_string(), Value::Int(1)),\n        (\"B\".to_string(), Value::Int(2)),\n        (\"C\".to_string(), Value::Int(3)),\n        (\"D\".to_string(), Value::Int(4)),\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::Int(6)),\n        (\"G\".to_string(), Value::Int(7)),\n    ]);\n}\n\n#[test]\nfn test_validate() {\n    for (raw_schema, value) in SCHEMAS_TO_VALIDATE.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        assert!(\n            value.validate(\u0026schema),\n            \"value {:?} does not validate schema: {}\",\n            value,\n            raw_schema\n        );\n    }\n}\n\n#[test]\nfn test_round_trip() {\n    for (raw_schema, value) in SCHEMAS_TO_VALIDATE.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        let encoded = to_avro_datum(\u0026schema, value.clone()).unwrap();\n        let decoded = from_avro_datum(\u0026schema, \u0026mut Cursor::new(encoded), None).unwrap();\n        assert_eq!(value, \u0026decoded);\n    }\n}\n\n#[test]\nfn test_binary_int_encoding() {\n    for (number, hex_encoding) in BINARY_ENCODINGS.iter() {\n        let encoded = to_avro_datum(\u0026Schema::Int, Value::Int(*number as i32)).unwrap();\n        assert_eq!(\u0026encoded, hex_encoding);\n    }\n}\n\n#[test]\nfn test_binary_long_encoding() {\n    for (number, hex_encoding) in BINARY_ENCODINGS.iter() {\n        let encoded = to_avro_datum(\u0026Schema::Long, Value::Long(*number as i64)).unwrap();\n        assert_eq!(\u0026encoded, hex_encoding);\n    }\n}\n\n#[test]\nfn test_schema_promotion() {\n    // Each schema is present in order of promotion (int -\u003e long, long -\u003e float, float -\u003e double)\n    // Each value represents the expected decoded value when promoting a value previously encoded with a promotable schema\n    let promotable_schemas = vec![r#\"\"int\"\"#, r#\"\"long\"\"#, r#\"\"float\"\"#, r#\"\"double\"\"#];\n    let promotable_values = vec![\n        Value::Int(219),\n        Value::Long(219),\n        Value::Float(219.0),\n        Value::Double(219.0),\n    ];\n    for (i, writer_raw_schema) in promotable_schemas.iter().enumerate() {\n        let writer_schema = Schema::parse_str(writer_raw_schema).unwrap();\n        let original_value = \u0026promotable_values[i];\n        for (j, reader_raw_schema) in promotable_schemas.iter().enumerate().skip(i + 1) {\n            let reader_schema = Schema::parse_str(reader_raw_schema).unwrap();\n            let encoded = to_avro_datum(\u0026writer_schema, original_value.clone()).unwrap();\n            let decoded = from_avro_datum(\n                \u0026writer_schema,\n                \u0026mut Cursor::new(encoded),\n                Some(\u0026reader_schema),\n            )\n            .unwrap_or_else(|_| {\n                panic!(\n                    \"failed to decode {:?} with schema: {:?}\",\n                    original_value, reader_raw_schema,\n                )\n            });\n            assert_eq!(decoded, promotable_values[j]);\n        }\n    }\n}\n\n#[test]\nfn test_unknown_symbol() {\n    let writer_schema =\n        Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"FOO\", \"BAR\"]}\"#)\n            .unwrap();\n    let reader_schema =\n        Schema::parse_str(r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"BAR\", \"BAZ\"]}\"#)\n            .unwrap();\n    let original_value = Value::Enum(0, \"FOO\".to_string());\n    let encoded = to_avro_datum(\u0026writer_schema, original_value).unwrap();\n    let decoded = from_avro_datum(\n        \u0026writer_schema,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    );\n    assert!(decoded.is_err());\n}\n\n#[test]\nfn test_default_value() {\n    for (field_type, default_json, default_datum) in DEFAULT_VALUE_EXAMPLES.iter() {\n        let reader_schema = Schema::parse_str(\u0026format!(\n            r#\"{{\n                \"type\": \"record\",\n                \"name\": \"Test\",\n                \"fields\": [\n                    {{\"name\": \"H\", \"type\": {}, \"default\": {}}}\n                ]\n            }}\"#,\n            field_type, default_json\n        ))\n        .unwrap();\n        let datum_to_read = Value::Record(vec![(\"H\".to_string(), default_datum.clone())]);\n        let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n        let datum_read = from_avro_datum(\n            \u0026LONG_RECORD_SCHEMA,\n            \u0026mut Cursor::new(encoded),\n            Some(\u0026reader_schema),\n        )\n        .unwrap();\n        assert_eq!(\n            datum_read, datum_to_read,\n            \"{} -\u003e {}\",\n            *field_type, *default_json\n        );\n    }\n}\n\n#[test]\nfn test_no_default_value() -\u003e Result\u003c(), Error\u003e {\n    let reader_schema = Schema::parse_str(\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"H\", \"type\": \"int\"}\n            ]\n        }\"#,\n    )\n    .unwrap();\n    let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let result = from_avro_datum(\n        \u0026LONG_RECORD_SCHEMA,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    );\n    assert!(result.is_err());\n    Ok(())\n}\n\n#[test]\nfn test_projection() {\n    let reader_schema = Schema::parse_str(\n        r#\"\n        {\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"E\", \"type\": \"int\"},\n                {\"name\": \"F\", \"type\": \"int\"}\n            ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_read = Value::Record(vec![\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::Int(6)),\n    ]);\n    let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let datum_read = from_avro_datum(\n        \u0026LONG_RECORD_SCHEMA,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    )\n    .unwrap();\n    assert_eq!(datum_to_read, datum_read);\n}\n\n#[test]\nfn test_field_order() {\n    let reader_schema = Schema::parse_str(\n        r#\"\n        {\n            \"type\": \"record\",\n            \"name\": \"Test\",\n            \"fields\": [\n                {\"name\": \"F\", \"type\": \"int\"},\n                {\"name\": \"E\", \"type\": \"int\"}\n            ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_read = Value::Record(vec![\n        (\"F\".to_string(), Value::Int(6)),\n        (\"E\".to_string(), Value::Int(5)),\n    ]);\n    let encoded = to_avro_datum(\u0026LONG_RECORD_SCHEMA, LONG_RECORD_DATUM.clone()).unwrap();\n    let datum_read = from_avro_datum(\n        \u0026LONG_RECORD_SCHEMA,\n        \u0026mut Cursor::new(encoded),\n        Some(\u0026reader_schema),\n    )\n    .unwrap();\n    assert_eq!(datum_to_read, datum_read);\n}\n\n#[test]\nfn test_type_exception() -\u003e Result\u003c(), String\u003e {\n    let writer_schema = Schema::parse_str(\n        r#\"\n        {\n             \"type\": \"record\",\n             \"name\": \"Test\",\n             \"fields\": [\n                {\"name\": \"F\", \"type\": \"int\"},\n                {\"name\": \"E\", \"type\": \"int\"}\n             ]\n        }\n    \"#,\n    )\n    .unwrap();\n    let datum_to_write = Value::Record(vec![\n        (\"E\".to_string(), Value::Int(5)),\n        (\"F\".to_string(), Value::String(String::from(\"Bad\"))),\n    ]);\n    let encoded = to_avro_datum(\u0026writer_schema, datum_to_write);\n    match encoded {\n        Ok(_) =\u003e Err(String::from(\"Expected ValidationError, got Ok\")),\n        Err(Error::Validation) =\u003e Ok(()),\n        Err(ref e) =\u003e Err(format!(\"Expected ValidationError, got {}\", e)),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","TDengine","tools","taos-tools","deps","avro","lang","rust","tests","schema.rs"],"content":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n//! Port of https://github.com/apache/avro/blob/release-1.9.1/lang/py/test/test_schema.py\nuse avro_rs::{schema::Name, Error, Schema};\nuse lazy_static::lazy_static;\n\nconst PRIMITIVE_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"\"null\"\"#, true),\n    (r#\"{\"type\": \"null\"}\"#, true),\n    (r#\"\"boolean\"\"#, true),\n    (r#\"{\"type\": \"boolean\"}\"#, true),\n    (r#\"\"string\"\"#, true),\n    (r#\"{\"type\": \"string\"}\"#, true),\n    (r#\"\"bytes\"\"#, true),\n    (r#\"{\"type\": \"bytes\"}\"#, true),\n    (r#\"\"int\"\"#, true),\n    (r#\"{\"type\": \"int\"}\"#, true),\n    (r#\"\"long\"\"#, true),\n    (r#\"{\"type\": \"long\"}\"#, true),\n    (r#\"\"float\"\"#, true),\n    (r#\"{\"type\": \"float\"}\"#, true),\n    (r#\"\"double\"\"#, true),\n    (r#\"{\"type\": \"double\"}\"#, true),\n    (r#\"\"true\"\"#, false),\n    (r#\"true\"#, false),\n    (r#\"{\"no_type\": \"test\"}\"#, false),\n    (r#\"{\"type\": \"panther\"}\"#, false),\n];\n\nconst FIXED_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"fixed\", \"name\": \"Test\", \"size\": 1}\"#, true),\n    (\n        r#\"{\n                \"type\": \"fixed\",\n                \"name\": \"MyFixed\",\n                \"namespace\": \"org.apache.hadoop.avro\",\n                \"size\": 1\n            }\"#,\n        true,\n    ),\n    (r#\"{\"type\": \"fixed\", \"name\": \"Missing size\"}\"#, false),\n    (r#\"{\"type\": \"fixed\", \"size\": 314}\"#, false),\n];\n\nconst ENUM_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"name\": \"Status\",\n                \"symbols\": \"Normal Caution Critical\"\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"name\": [ 0, 1, 1, 2, 3, 5, 8 ],\n                \"symbols\": [\"Golden\", \"Mean\"]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                \"symbols\" : [\"I\", \"will\", \"fail\", \"no\", \"name\"]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                 \"name\": \"Test\"\n                 \"symbols\" : [\"AA\", \"AA\"]\n            }\"#,\n        false,\n    ),\n];\n\nconst ARRAY_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"array\", \"items\": \"long\"}\"#, true),\n    (\n        r#\"{\n                \"type\": \"array\",\n                 \"items\": {\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\n            }\"#,\n        true,\n    ),\n];\n\nconst MAP_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"map\", \"values\": \"long\"}\"#, true),\n    (\n        r#\"{\n                \"type\": \"map\",\n                \"values\": {\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"]}\n            }\"#,\n        true,\n    ),\n];\n\nconst UNION_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"[\"string\", \"null\", \"long\"]\"#, true),\n    (r#\"[\"null\", \"null\"]\"#, false),\n    (r#\"[\"long\", \"long\"]\"#, false),\n    (\n        r#\"[\n                {\"type\": \"array\", \"items\": \"long\"}\n                {\"type\": \"array\", \"items\": \"string\"}\n            ]\"#,\n        false,\n    ),\n];\n\nconst RECORD_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Test\",\n                \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]\n            }\"#,\n        true,\n    ),\n    /*\n    // TODO: (#91) figure out why \"type\": \"error\" seems to be valid (search in spec) and uncomment\n    (\n        r#\"{\n            \"type\": \"error\",\n            \"name\": \"Test\",\n            \"fields\": [{\"name\": \"f\", \"type\": \"long\"}]\n        }\"#,\n        true\n    ),\n    */\n    /*\n    // TODO: (#92) properly support recursive types and uncomment\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Node\",\n            \"fields\": [\n                {\"name\": \"label\", \"type\": \"string\"},\n                {\"name\": \"children\", \"type\": {\"type\": \"array\", \"items\": \"Node\"}}\n            ]\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"Lisp\",\n            \"fields\": [\n                {\n                    \"name\": \"value\",\n                    \"type\": [\n                        \"null\", \"string\",\n                        {\n                            \"type\": \"record\",\n                            \"name\": \"Cons\",\n                            \"fields\": [\n                                {\"name\": \"car\", \"type\": \"Lisp\"},\n                                {\"name\": \"cdr\", \"type\": \"Lisp\"}\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"HandshakeRequest\",\n            \"namespace\": \"org.apache.avro.ipc\",\n            \"fields\": [\n                {\"name\": \"clientHash\", \"type\": {\"type\": \"fixed\", \"name\": \"MD5\", \"size\": 16}},\n                {\"name\": \"clientProtocol\", \"type\": [\"null\", \"string\"]},\n                {\"name\": \"serverHash\", \"type\": \"MD5\"},\n                {\"name\": \"meta\", \"type\": [\"null\", {\"type\": \"map\", \"values\": \"bytes\"}]}\n            ]\n        }\"#, true\n    ),\n    */\n    (\n        r#\"{\n                \"type\":\"record\",\n                \"name\":\"HandshakeResponse\",\n                \"namespace\":\"org.apache.avro.ipc\",\n                \"fields\":[\n                    {\n                        \"name\":\"match\",\n                        \"type\":{\n                           \"type\":\"enum\",\n                           \"name\":\"HandshakeMatch\",\n                           \"symbols\":[\"BOTH\", \"CLIENT\", \"NONE\"]\n                        }\n                    },\n                    {\"name\":\"serverProtocol\", \"type\":[\"null\", \"string\"]},\n                    {\n                        \"name\":\"serverHash\",\n                        \"type\":[\"null\", {\"name\":\"MD5\", \"size\":16, \"type\":\"fixed\"}]\n                    },\n                    {\n                        \"name\":\"meta\",\n                        \"type\":[\"null\", {\"type\":\"map\", \"values\":\"bytes\"}]\n                    }\n                ]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\":\"record\",\n                \"name\":\"HandshakeResponse\",\n                \"namespace\":\"org.apache.avro.ipc\",\n                \"fields\":[\n                    {\n                        \"name\":\"match\",\n                        \"type\":{\n                            \"type\":\"enum\",\n                            \"name\":\"HandshakeMatch\",\n                            \"symbols\":[\"BOTH\", \"CLIENT\", \"NONE\"]\n                        }\n                    },\n                    {\"name\":\"serverProtocol\", \"type\":[\"null\", \"string\"]},\n                    {\n                        \"name\":\"serverHash\",\n                        \"type\":[\"null\", { \"name\":\"MD5\", \"size\":16, \"type\":\"fixed\"}]\n                    },\n                    {\"name\":\"meta\", \"type\":[\"null\", { \"type\":\"map\", \"values\":\"bytes\"}]}\n                ]\n            }\"#,\n        true,\n    ),\n    /*\n    // TODO: (#95) support same types but with different names in unions and uncomment (below the explanation)\n\n    // Unions may not contain more than one schema with the same type, except for the named\n    // types record, fixed and enum. For example, unions containing two array types or two map\n    // types are not permitted, but two types with different names are permitted.\n    // (Names permit efficient resolution when reading and writing unions.)\n    (\n        r#\"{\n            \"type\": \"record\",\n            \"name\": \"ipAddr\",\n            \"fields\": [\n                {\n                    \"name\": \"addr\",\n                    \"type\": [\n                        {\"name\": \"IPv6\", \"type\": \"fixed\", \"size\": 16},\n                        {\"name\": \"IPv4\", \"type\": \"fixed\", \"size\": 4}\n                    ]\n                }\n            ]\n        }\"#,\n        true\n    ),\n    */\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Address\",\n                \"fields\": [\n                    {\"type\": \"string\"},\n                    {\"type\": \"string\", \"name\": \"City\"}\n                ]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"Event\",\n                \"fields\": [{\"name\": \"Sponsor\"}, {\"name\": \"City\", \"type\": \"string\"}]\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"fields\": \"His vision, from the constantly passing bars,\"\n                \"name\",\n                \"Rainer\"\n            }\"#,\n        false,\n    ),\n    (\n        r#\"{\n                \"name\": [\"Tom\", \"Jerry\"],\n                \"type\": \"record\",\n                \"fields\": [{\"name\": \"name\", \"type\": \"string\"}]\n            }\"#,\n        false,\n    ),\n];\n\nconst DOC_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"TestDoc\",\n                \"doc\":  \"Doc string\",\n                \"fields\": [{\"name\": \"name\", \"type\": \"string\", \"doc\" : \"Doc String\"}]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"enum\", \"name\": \"Test\", \"symbols\": [\"A\", \"B\"], \"doc\": \"Doc String\"}\"#,\n        true,\n    ),\n];\n\nconst OTHER_ATTRIBUTES_EXAMPLES: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\n                \"type\": \"record\",\n                \"name\": \"TestRecord\",\n                \"cp_string\": \"string\",\n                \"cp_int\": 1,\n                \"cp_array\": [ 1, 2, 3, 4],\n                \"fields\": [\n                    {\"name\": \"f1\", \"type\": \"string\", \"cp_object\": {\"a\":1,\"b\":2}},\n                    {\"name\": \"f2\", \"type\": \"long\", \"cp_null\": null}\n                ]\n            }\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"map\", \"values\": \"long\", \"cp_boolean\": true}\"#,\n        true,\n    ),\n    (\n        r#\"{\n                \"type\": \"enum\",\n                 \"name\": \"TestEnum\",\n                 \"symbols\": [ \"one\", \"two\", \"three\" ],\n                 \"cp_float\" : 1.0\n            }\"#,\n        true,\n    ),\n    (r#\"{\"type\": \"long\", \"date\": \"true\"}\"#, true),\n];\n\nconst DECIMAL_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    /*\n    // TODO: (#93) support logical types and uncomment\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 4,\n            \"size\": 10,\n            \"scale\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 4,\n            \"scale\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 2,\n            \"scale\": -2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": -2,\n            \"scale\": 2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 2,\n            \"scale\": 3\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": -10,\n            \"scale\": 2,\n            \"size\": 5\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 2,\n            \"scale\": 3,\n            \"size\": 2\n        }\"#,\n        false\n    ),\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 2,\n            \"scale\": 2,\n            \"size\": -2\n        }\"#,\n        false\n    ),\n    */\n];\n\nconst DECIMAL_LOGICAL_TYPE_ATTRIBUTES: \u0026[(\u0026str, bool)] = \u0026[\n    /*\n    // TODO: (#93) support logical types and attributes and uncomment\n    (\n        r#\"{\n            \"type\": \"fixed\",\n            \"logicalType\": \"decimal\",\n            \"name\": \"TestDecimal\",\n            \"precision\": 4,\n            \"scale\": 2,\n            \"size\": 2\n        }\"#,\n        true\n    ),\n    (\n        r#\"{\n            \"type\": \"bytes\",\n            \"logicalType\": \"decimal\",\n            \"precision\": 4\n        }\"#,\n        true\n    ),\n    */\n];\n\nconst DATE_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"int\", \"logicalType\": \"date\"}\"#, true),\n    // this is valid even though its logical type is \"date1\", because unknown logical types are\n    // ignored\n    (r#\"{\"type\": \"int\", \"logicalType\": \"date1\"}\"#, true),\n    (r#\"{\"type\": \"long\", \"logicalType\": \"date\"}\"#, false),\n];\n\nconst TIMEMILLIS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-millis\"}\"#, true),\n    // this is valid even though its logical type is \"time-milis\" (missing the second \"l\"),\n    // because unknown logical types are ignored\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-milis\"}\"#, true),\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-millis\"}\"#, false),\n];\n\nconst TIMEMICROS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-micros\"}\"#, true),\n    // this is valid even though its logical type is \"time-micro\" (missing the last \"s\"), because\n    // unknown logical types are ignored\n    (r#\"{\"type\": \"long\", \"logicalType\": \"time-micro\"}\"#, true),\n    (r#\"{\"type\": \"int\", \"logicalType\": \"time-micros\"}\"#, false),\n];\n\nconst TIMESTAMPMILLIS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\"#,\n        true,\n    ),\n    // this is valid even though its logical type is \"timestamp-milis\" (missing the second \"l\"), because\n    // unknown logical types are ignored\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-milis\"}\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"int\", \"logicalType\": \"timestamp-millis\"}\"#,\n        false,\n    ),\n];\n\nconst TIMESTAMPMICROS_LOGICAL_TYPE: \u0026[(\u0026str, bool)] = \u0026[\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micros\"}\"#,\n        true,\n    ),\n    // this is valid even though its logical type is \"timestamp-micro\" (missing the last \"s\"), because\n    // unknown logical types are ignored\n    (\n        r#\"{\"type\": \"long\", \"logicalType\": \"timestamp-micro\"}\"#,\n        true,\n    ),\n    (\n        r#\"{\"type\": \"int\", \"logicalType\": \"timestamp-micros\"}\"#,\n        false,\n    ),\n];\n\nlazy_static! {\n    static ref EXAMPLES: Vec\u003c(\u0026'static str, bool)\u003e = Vec::new()\n        .iter()\n        .copied()\n        .chain(PRIMITIVE_EXAMPLES.iter().copied())\n        .chain(FIXED_EXAMPLES.iter().copied())\n        .chain(ENUM_EXAMPLES.iter().copied())\n        .chain(ARRAY_EXAMPLES.iter().copied())\n        .chain(MAP_EXAMPLES.iter().copied())\n        .chain(UNION_EXAMPLES.iter().copied())\n        .chain(RECORD_EXAMPLES.iter().copied())\n        .chain(DOC_EXAMPLES.iter().copied())\n        .chain(OTHER_ATTRIBUTES_EXAMPLES.iter().copied())\n        .chain(DECIMAL_LOGICAL_TYPE.iter().copied())\n        .chain(DECIMAL_LOGICAL_TYPE_ATTRIBUTES.iter().copied())\n        .chain(DATE_LOGICAL_TYPE.iter().copied())\n        .chain(TIMEMILLIS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMEMICROS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMESTAMPMILLIS_LOGICAL_TYPE.iter().copied())\n        .chain(TIMESTAMPMICROS_LOGICAL_TYPE.iter().copied())\n        .collect();\n    static ref VALID_EXAMPLES: Vec\u003c(\u0026'static str, bool)\u003e =\n        EXAMPLES.iter().copied().filter(|s| s.1).collect();\n}\n\n/*\n// TODO: (#92) properly support recursive types and uncomment\n\nThis test is failing unwrapping the outer schema with ParseSchemaError(\"Unknown type: X\"). It seems\nthat recursive types are not properly supported.\n\n#[test]\nfn test_correct_recursive_extraction() {\n    let raw_outer_schema = r#\"{\n        \"type\": \"record\",\n        \"name\": \"X\",\n        \"fields\": [\n            {\n                \"name\": \"y\",\n                \"type\": {\n                    \"type\": \"record\",\n                    \"name\": \"Y\",\n                    \"fields\": [\n                        {\n                            \"name\": \"Z\",\n                            \"type\": \"X\"\n                        }\n                    ]\n                }\n            }\n        ]\n    }\"#;\n    let outer_schema = Schema::parse_str(raw_outer_schema).unwrap();\n    if let Schema::Record { fields: outer_fields, .. } = outer_schema {\n        let raw_inner_schema = outer_fields[0].schema.canonical_form();\n        let inner_schema = Schema::parse_str(raw_inner_schema.as_str()).unwrap();\n        if let Schema::Record { fields: inner_fields, .. } = inner_schema {\n            if let Schema::Record {name: recursive_type, .. } = \u0026inner_fields[0].schema {\n                assert_eq!(\"X\", recursive_type.name.as_str());\n            }\n        } else {\n            panic!(\"inner schema {} should have been a record\", raw_inner_schema)\n        }\n    } else {\n        panic!(\"outer schema {} should have been a record\", raw_outer_schema)\n    }\n}\n*/\n\n#[test]\nfn test_parse() {\n    for (raw_schema, valid) in EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema);\n        if *valid {\n            assert!(\n                schema.is_ok(),\n                \"schema {} was supposed to be valid; error: {:?}\",\n                raw_schema,\n                schema,\n            )\n        } else {\n            assert!(\n                schema.is_err(),\n                \"schema {} was supposed to be invalid\",\n                raw_schema\n            )\n        }\n    }\n}\n\n#[test]\n/// Test that the string generated by an Avro Schema object is, in fact, a valid Avro schema.\nfn test_valid_cast_to_string_after_parse() {\n    for (raw_schema, _) in VALID_EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        Schema::parse_str(schema.canonical_form().as_str()).unwrap();\n    }\n}\n\n#[test]\n/// 1. Given a string, parse it to get Avro schema \"original\".\n/// 2. Serialize \"original\" to a string and parse that string to generate Avro schema \"round trip\".\n/// 3. Ensure \"original\" and \"round trip\" schemas are equivalent.\nfn test_equivalence_after_round_trip() {\n    for (raw_schema, _) in VALID_EXAMPLES.iter() {\n        let original_schema = Schema::parse_str(raw_schema).unwrap();\n        let round_trip_schema =\n            Schema::parse_str(original_schema.canonical_form().as_str()).unwrap();\n        assert_eq!(original_schema, round_trip_schema);\n    }\n}\n\n#[test]\n/// Test that a list of schemas whose definitions do not depend on each other produces the same\n/// result as parsing each element of the list individually\nfn test_parse_list_without_cross_deps() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"fixed\",\n        \"size\": 16\n    }\"#;\n    let schema_strs = [schema_str_1, schema_str_2];\n    let schemas = Schema::parse_list(\u0026schema_strs).expect(\"Test failed\");\n\n    for schema_str in \u0026schema_strs {\n        let parsed = Schema::parse_str(schema_str).expect(\"Test failed\");\n        assert!(schemas.contains(\u0026parsed));\n    }\n}\n\n#[test]\n/// Test that the parsing of a list of schemas, whose definitions do depend on each other, can\n/// perform the necessary schema composition. This should work regardless of the order in which\n/// the schemas are input.\n/// However, the output order is guaranteed to be the same as the input order.\nfn test_parse_list_with_cross_deps_basic() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n            \"type\": {\n                \"name\": \"A\",\n                \"type\": \"record\",\n                \"fields\": [\n                    {\"name\": \"field_one\", \"type\": \"float\"}\n                    ]\n                }\n            }\n        ]\n\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let schemas_first = Schema::parse_list(\u0026schema_strs_first).expect(\"Test failed\");\n    let schemas_second = Schema::parse_list(\u0026schema_strs_second).expect(\"Test failed\");\n\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_composite).expect(\"Test failed\");\n    assert_eq!(schemas_first, vec!(parsed_1.clone(), parsed_2.clone()));\n    assert_eq!(schemas_second, vec!(parsed_2, parsed_1));\n}\n\n#[test]\n/// Test that if a cycle of dependencies occurs in the input schema jsons, the algorithm terminates\n/// and returns an error. N.B. In the future, when recursive types are supported, this should be\n/// revisited.\nfn test_parse_list_recursive_type_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"B\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let _ = Schema::parse_list(\u0026schema_strs_first).expect_err(\"Test failed\");\n    let _ = Schema::parse_list(\u0026schema_strs_second).expect_err(\"Test failed\");\n}\n\n#[test]\n/// Test that schema composition resolves namespaces.\nfn test_parse_list_with_cross_deps_and_namespaces() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"namespace\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"namespace.A\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n            \"type\": {\n                \"name\": \"A\",\n                \"type\": \"record\",\n                \"namespace\": \"namespace\",\n                \"fields\": [\n                    {\"name\": \"field_one\", \"type\": \"float\"}\n                    ]\n                }\n            }\n        ]\n    }\"#;\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let schemas_first = Schema::parse_list(\u0026schema_strs_first).expect(\"Test failed\");\n    let schemas_second = Schema::parse_list(\u0026schema_strs_second).expect(\"Test failed\");\n\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_composite).expect(\"Test failed\");\n    assert_eq!(schemas_first, vec!(parsed_1.clone(), parsed_2.clone()));\n    assert_eq!(schemas_second, vec!(parsed_2, parsed_1));\n}\n\n#[test]\n/// Test that schema composition fails on namespace errors.\nfn test_parse_list_with_cross_deps_and_namespaces_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"namespace\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"float\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"A\"}\n        ]\n    }\"#;\n\n    let schema_strs_first = [schema_str_1, schema_str_2];\n    let schema_strs_second = [schema_str_2, schema_str_1];\n    let _ = Schema::parse_list(\u0026schema_strs_first).expect_err(\"Test failed\");\n    let _ = Schema::parse_list(\u0026schema_strs_second).expect_err(\"Test failed\");\n}\n\n/// Return all permutations of an input slice\nfn permutations\u003cT\u003e(list: \u0026[T]) -\u003e Vec\u003cVec\u003c\u0026T\u003e\u003e {\n    let size = list.len();\n    let indices = permutation_indices((0..size).collect());\n    let mut perms = Vec::new();\n    for perm_map in \u0026indices {\n        let mut perm = Vec::new();\n        for ix in perm_map {\n            perm.push(\u0026list[*ix]);\n        }\n        perms.push(perm)\n    }\n    perms\n}\n\n/// Return all permutations of the indices of a vector\nfn permutation_indices(indices: Vec\u003cusize\u003e) -\u003e Vec\u003cVec\u003cusize\u003e\u003e {\n    let size = indices.len();\n    let mut perms: Vec\u003cVec\u003cusize\u003e\u003e = Vec::new();\n    if size == 1 {\n        perms.push(indices);\n        return perms;\n    }\n    for index in 0..size {\n        let (head, tail) = indices.split_at(index);\n        let (first, rest) = tail.split_at(1);\n        let mut head = head.to_vec();\n        head.extend_from_slice(rest);\n        for mut sub_index in permutation_indices(head) {\n            sub_index.insert(0, first[0]);\n            perms.push(sub_index);\n        }\n    }\n\n    perms\n}\n\n#[test]\n/// Test that a type that depends on more than one other type is parsed correctly when all\n/// definitions are passed in as a list. This should work regardless of the ordering of the list.\nfn test_parse_list_multiple_dependencies() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": [\"null\", \"B\", \"C\"]}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"fixed\",\n        \"size\": 16\n    }\"#;\n    let schema_str_3 = r#\"{\n        \"name\": \"C\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"string\"}\n        ]\n    }\"#;\n    let schema_composite = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\n                \"name\": \"field_one\",\n                \"type\":  [\n                    \"null\",\n                    {\n                        \"name\": \"B\",\n                        \"type\": \"fixed\",\n                        \"size\": 16\n                    },\n                    {\n                        \"name\": \"C\",\n                        \"type\": \"record\",\n                        \"fields\": [\n                            {\"name\": \"field_one\", \"type\": \"string\"}\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\"#;\n\n    let parsed = vec![\n        Schema::parse_str(schema_str_2).expect(\"Test failed\"),\n        Schema::parse_str(schema_str_3).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite).expect(\"Test failed\"),\n    ];\n    let schema_strs = vec![schema_str_1, schema_str_2, schema_str_3];\n    for schema_str_perm in permutations(\u0026schema_strs) {\n        let schema_str_perm: Vec\u003c\u0026str\u003e = schema_str_perm.iter().map(|s| **s).collect();\n        let schemas = Schema::parse_list(\u0026schema_str_perm).expect(\"Test failed\");\n        assert_eq!(schemas.len(), 3);\n        for parsed_schema in \u0026parsed {\n            assert!(schemas.contains(parsed_schema));\n        }\n    }\n}\n\n#[test]\n/// Test that a type that is depended on by more than one other type is parsed correctly when all\n/// definitions are passed in as a list. This should work regardless of the ordering of the list.\nfn test_parse_list_shared_dependency() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": {\"type\": \"array\", \"items\": \"C\"}}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": {\"type\": \"map\", \"values\": \"C\"}}\n        ]\n    }\"#;\n    let schema_str_3 = r#\"{\n        \"name\": \"C\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"string\"}\n        ]\n    }\"#;\n    let schema_composite_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n              \"type\": {\"type\": \"array\",\n                       \"items\": {\n                            \"name\": \"C\",\n                            \"type\": \"record\",\n                            \"fields\": [\n                                {\"name\": \"field_one\", \"type\": \"string\"}\n                                ]\n                            }\n                      }\n            }\n        ]\n    }\"#;\n    let schema_composite_2 = r#\"{\n        \"name\": \"B\",\n        \"type\": \"record\",\n        \"fields\": [\n            { \"name\": \"field_one\",\n              \"type\": {\"type\": \"map\",\n                       \"values\": {\n                            \"name\": \"C\",\n                            \"type\":  \"record\",\n                            \"fields\": [\n                                {\"name\": \"field_one\", \"type\": \"string\"}\n                                ]\n                            }\n                      }\n                 }\n            ]\n    }\"#;\n\n    let parsed = vec![\n        Schema::parse_str(schema_str_3).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite_1).expect(\"Test failed\"),\n        Schema::parse_str(schema_composite_2).expect(\"Test failed\"),\n    ];\n    let schema_strs = vec![schema_str_1, schema_str_2, schema_str_3];\n    for schema_str_perm in permutations(\u0026schema_strs) {\n        let schema_str_perm: Vec\u003c\u0026str\u003e = schema_str_perm.iter().map(|s| **s).collect();\n        let schemas = Schema::parse_list(\u0026schema_str_perm).expect(\"Test failed\");\n        assert_eq!(schemas.len(), 3);\n        for parsed_schema in \u0026parsed {\n            assert!(schemas.contains(parsed_schema));\n        }\n    }\n}\n\n#[test]\n/// Test that trying to parse two schemas with the same fullname returns an Error\nfn test_name_collision_error() {\n    let schema_str_1 = r#\"{\n        \"name\": \"foo.A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"double\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"foo\",\n        \"fields\": [\n            {\"name\": \"field_two\", \"type\": \"string\"}\n        ]\n    }\"#;\n\n    let _ = Schema::parse_list(\u0026[schema_str_1, schema_str_2]).expect_err(\"Test failed\");\n}\n\n#[test]\n/// Test that having the same name but different fullnames does not return an error\nfn test_namespace_prevents_collisions() {\n    let schema_str_1 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"fields\": [\n            {\"name\": \"field_one\", \"type\": \"double\"}\n        ]\n    }\"#;\n    let schema_str_2 = r#\"{\n        \"name\": \"A\",\n        \"type\": \"record\",\n        \"namespace\": \"foo\",\n        \"fields\": [\n            {\"name\": \"field_two\", \"type\": \"string\"}\n        ]\n    }\"#;\n\n    let parsed = Schema::parse_list(\u0026[schema_str_1, schema_str_2]).expect(\"Test failed\");\n    let parsed_1 = Schema::parse_str(schema_str_1).expect(\"Test failed\");\n    let parsed_2 = Schema::parse_str(schema_str_2).expect(\"Test failed\");\n    assert_eq!(parsed, vec!(parsed_1, parsed_2));\n}\n\n// The fullname is determined in one of the following ways:\n//  * A name and namespace are both specified.  For example,\n//    one might use \"name\": \"X\", \"namespace\": \"org.foo\"\n//    to indicate the fullname \"org.foo.X\".\n//  * A fullname is specified.  If the name specified contains\n//    a dot, then it is assumed to be a fullname, and any\n//    namespace also specified is ignored.  For example,\n//    use \"name\": \"org.foo.X\" to indicate the\n//    fullname \"org.foo.X\".\n//  * A name only is specified, i.e., a name that contains no\n//    dots.  In this case the namespace is taken from the most\n//    tightly enclosing schema or protocol.  For example,\n//    if \"name\": \"X\" is specified, and this occurs\n//    within a field of the record definition ///    of \"org.foo.Y\", then the fullname is \"org.foo.X\".\n\n// References to previously defined names are as in the latter\n// two cases above: if they contain a dot they are a fullname, if\n// they do not contain a dot, the namespace is the namespace of\n// the enclosing definition.\n\n// Primitive type names have no namespace and their names may\n// not be defined in any namespace. A schema may only contain\n// multiple definitions of a fullname if the definitions are\n// equivalent.\n\n#[test]\nfn test_fullname_name_and_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": \"o.a.h\", \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(None);\n    assert_eq!(\"o.a.h.a\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_and_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": \"o.a.h\", \"aliases\": null}\"#)\n            .unwrap();\n    let fullname = name.fullname(None);\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_name_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": null, \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"b.c.d\"));\n    assert_eq!(\"b.c.d.a\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": null, \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_fullname_namespace_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a.b.c.d\", \"namespace\": \"o.a.a\", \"aliases\": null}\"#)\n            .unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"a.b.c.d\", fullname);\n}\n\n#[test]\nfn test_fullname_name_namespace_and_default_namespace_specified() {\n    let name: Name =\n        serde_json::from_str(r#\"{\"name\": \"a\", \"namespace\": \"o.a.a\", \"aliases\": null}\"#).unwrap();\n    let fullname = name.fullname(Some(\"o.a.h\"));\n    assert_eq!(\"o.a.a.a\", fullname);\n}\n\n#[test]\nfn test_doc_attributes() {\n    fn assert_doc(schema: \u0026Schema) {\n        match schema {\n            Schema::Enum { doc, .. } =\u003e assert!(doc.is_some()),\n            Schema::Record { doc, .. } =\u003e assert!(doc.is_some()),\n            _ =\u003e (),\n        }\n    }\n\n    for (raw_schema, _) in DOC_EXAMPLES.iter() {\n        let original_schema = Schema::parse_str(raw_schema).unwrap();\n        assert_doc(\u0026original_schema);\n        if let Schema::Record { fields, .. } = original_schema {\n            for f in fields {\n                assert_doc(\u0026f.schema)\n            }\n        }\n    }\n}\n\n/*\nTODO: (#94) add support for user-defined attributes and uncomment (may need some tweaks to compile)\n#[test]\nfn test_other_attributes() {\n    fn assert_attribute_type(attribute: (String, serde_json::Value)) {\n        match attribute.1.as_ref() {\n            \"cp_boolean\" =\u003e assert!(attribute.2.is_bool()),\n            \"cp_int\" =\u003e assert!(attribute.2.is_i64()),\n            \"cp_object\" =\u003e assert!(attribute.2.is_object()),\n            \"cp_float\" =\u003e assert!(attribute.2.is_f64()),\n            \"cp_array\" =\u003e assert!(attribute.2.is_array()),\n        }\n    }\n\n    for (raw_schema, _) in OTHER_ATTRIBUTES_EXAMPLES.iter() {\n        let schema = Schema::parse_str(raw_schema).unwrap();\n        // all inputs have at least some user-defined attributes\n        assert!(schema.other_attributes.is_some());\n        for prop in schema.other_attributes.unwrap().iter() {\n            assert_attribute_type(prop);\n        }\n        if let Schema::Record { fields, .. } = schema {\n           for f in fields {\n               // all fields in the record have at least some user-defined attributes\n               assert!(f.schema.other_attributes.is_some());\n               for prop in f.schema.other_attributes.unwrap().iter() {\n                   assert_attribute_type(prop);\n               }\n           }\n        }\n    }\n}\n*/\n\n#[test]\nfn test_root_error_is_not_swallowed_on_parse_error() -\u003e Result\u003c(), String\u003e {\n    let raw_schema = r#\"/not/a/real/file\"#;\n    let error = Schema::parse_str(raw_schema).unwrap_err();\n\n    if let Error::ParseSchemaJson(e) = error {\n        assert!(\n            e.to_string().contains(\"expected value at line 1 column 1\"),\n            \"{}\",\n            e\n        );\n        Ok(())\n    } else {\n        Err(format!(\n            \"Expected serde_json::error::Error, got {:?}\",\n            error\n        ))\n    }\n}\n\n/*\n// TODO: (#93) add support for logical type and attributes and uncomment (may need some tweaks to compile)\n#[test]\nfn test_decimal_valid_type_attributes() {\n    let fixed_decimal = Schema::parse_str(DECIMAL_LOGICAL_TYPE_ATTRIBUTES[0]).unwrap();\n    assert_eq!(4, fixed_decimal.get_attribute(\"precision\"));\n    assert_eq!(2, fixed_decimal.get_attribute(\"scale\"));\n    assert_eq!(2, fixed_decimal.get_attribute(\"size\"));\n\n    let bytes_decimal = Schema::parse_str(DECIMAL_LOGICAL_TYPE_ATTRIBUTES[1]).unwrap();\n    assert_eq!(4, bytes_decimal.get_attribute(\"precision\"));\n    assert_eq!(0, bytes_decimal.get_attribute(\"scale\"));\n}\n*/\n","traces":[{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","huolinhe","Projects","taosdata","taosx","mdsn","src","lib.rs"],"content":"//! M-DSN: A Multi-address DSN(Data Source Name) parser.\n//!\n//! M-DSN support two kind of DSN format:\n//!\n//! 1. `\u003cdriver\u003e[+\u003cprotocol\u003e]://\u003cusername\u003e:\u003cpassword\u003e@\u003caddresses\u003e/\u003cdatabase\u003e?\u003cparams\u003e`\n//! 2. `\u003cdriver\u003e[+\u003cprotocol\u003e]://\u003cusername\u003e:\u003cpassword\u003e@\u003cfragment\u003e?\u003cparams\u003e`\n//! 3. `\u003cdriver\u003e://\u003cusername\u003e:\u003cpassword\u003e@\u003cprotocol\u003e(\u003caddresses\u003e)/\u003cdatabase\u003e?\u003cparams\u003e`\n//!\n//! All the items will be parsed into struct [Dsn](crate::Dsn).\n//!\n//! ## Parser\n//!\n//! ```rust\n//! use mdsn::Dsn;\n//!\n//! # fn main() -\u003e Result\u003c(), mdsn::DsnError\u003e {\n//! // The two styles are equivalent.\n//! let dsn = Dsn::parse(\"taos://root:taosdata@host1:6030,host2:6030/db\")?;\n//! let dsn: Dsn = \"taos://root:taosdata@host1:6030,host2:6030/db\".parse()?;\n//!\n//! assert_eq!(dsn.driver, \"taos\");\n//! assert_eq!(dsn.username.unwrap(), \"root\");\n//! assert_eq!(dsn.password.unwrap(), \"taosdata\");\n//! assert_eq!(dsn.database.unwrap(), \"db\");\n//! assert_eq!(dsn.addresses.len(), 2);\n//! assert_eq!(dsn.addresses, vec![\n//!     mdsn::Address::new(\"host1\", 6030),\n//!     mdsn::Address::new(\"host2\", 6030),\n//! ]);\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## DSN Examples\n//!\n//! A DSN for [TDengine](https://taosdata.com) driver [taos](https://docs.rs/taos).\n//!\n//! ```dsn\n//! taos://root:taosdata@localhost:6030/db?timezone=Asia/Shanghai\u0026asyncLog=1\n//! ```\n//!\n//! With multi-address:\n//!\n//! ```dsn\n//! taos://root:taosdata@host1:6030,host2:6030/db?timezone=Asia/Shanghai\n//! ```\n//!\n//! A DSN for unix socket:\n//!\n//! ```dsn\n//! unix:///path/to/unix.sock?param1=value\n//! ```\n//!\n//! A DSN for postgresql with url-encoded socket directory path.\n//!\n//! ```dsn\n//! postgresql://%2Fvar%2Flib%2Fpostgresql/db\n//! ```\n//!\n//! A DSN for sqlite db file, note that you must use prefix `./` for a relative path file.\n//!\n//! ```dsn\n//! sqlite://./file.db\n//! ```\n//!\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\nuse itertools::Itertools;\nuse pest;\nuse pest::Parser;\nuse pest_derive::Parser;\nuse thiserror::Error;\n\n#[derive(Parser)]\n#[grammar = \"dsn.pest\"]\nstruct DsnParser;\n\n/// Error caused by [pest] DSN parser.\n#[derive(Debug, Error)]\npub enum DsnError {\n    #[error(\"{0}\")]\n    ParseErr(#[from] pest::error::Error\u003cRule\u003e),\n    #[error(\"unable to parse port from {0}\")]\n    PortErr(#[from] ParseIntError),\n    #[error(\"invalid driver {0}\")]\n    InvalidDriver(String),\n    #[error(\"invalid connection {0}\")]\n    InvalidConnection(String),\n    #[error(\"invalid addresses {0:?}\")]\n    InvalidAddresses(Vec\u003cAddress\u003e),\n    #[error(\"requires database: {0}\")]\n    RequireDatabase(String),\n}\n\n/// A simple struct to represent a server address, with host:port or socket path.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct Address {\n    /// Host or ip address of the server.\n    pub host: Option\u003cString\u003e,\n    /// Port to connect to the server.\n    pub port: Option\u003cu16\u003e,\n    /// Use unix socket path to connect.\n    pub path: Option\u003cString\u003e,\n}\n\nimpl Address {\n    /// Construct server address with host and port.\n    #[inline]\n    pub fn new(host: impl Into\u003cString\u003e, port: u16) -\u003e Self {\n        Self {\n            host: Some(host.into()),\n            port: Some(port),\n            ..Default::default()\n        }\n    }\n    /// Construct server address with host or ip address only.\n    #[inline]\n    pub fn from_host(host: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            host: Some(host.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Construct server address with unix socket path.\n    #[inline]\n    pub fn from_path(path: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            path: Some(path.into()),\n            ..Default::default()\n        }\n    }\n\n    #[inline]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.host.is_none() \u0026\u0026 self.port.is_none() \u0026\u0026 self.path.is_none()\n    }\n}\n\nimpl FromStr for Address {\n    type Err = DsnError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let mut addr = Self::default();\n        if let Some(dsn) = DsnParser::parse(Rule::address, \u0026s)?.next() {\n            for inner in dsn.into_inner() {\n                match inner.as_rule() {\n                    Rule::host =\u003e addr.host = Some(inner.as_str().to_string()),\n                    Rule::port =\u003e addr.port = Some(inner.as_str().parse()?),\n                    Rule::path =\u003e {\n                        addr.path = Some(\n                            urlencoding::decode(inner.as_str())\n                                .expect(\"UTF-8\")\n                                .to_string(),\n                        )\n                    }\n                    _ =\u003e unreachable!(),\n                }\n            }\n        }\n        Ok(addr)\n    }\n}\n\nimpl Display for Address {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match (\u0026self.host, self.port, \u0026self.path) {\n            (Some(host), None, None) =\u003e write!(f, \"{host}\"),\n            (Some(host), Some(port), None) =\u003e write!(f, \"{host}:{port}\"),\n            (None, Some(port), None) =\u003e write!(f, \":{port}\"),\n            (None, None, Some(path)) =\u003e write!(f, \"{}\", urlencoding::encode(path)),\n            (None, None, None) =\u003e Ok(()),\n            _ =\u003e unreachable!(\"path will be conflict with host/port\"),\n        }\n    }\n}\n\n#[test]\nfn addr_parse() {\n    let s = \"taosdata:6030\";\n    let addr = Address::from_str(s).unwrap();\n    assert_eq!(addr.to_string(), s);\n\n    let s = \"/var/lib/taos\";\n    let addr = Address::from_str(\u0026urlencoding::encode(s)).unwrap();\n    assert_eq!(addr.path.as_ref().unwrap(), s);\n    assert_eq!(addr.to_string(), urlencoding::encode(s));\n}\n\n/// A DSN(**Data Source Name**) parser.\n#[derive(Debug, Default, PartialEq, Eq, Clone)]\npub struct Dsn {\n    pub driver: String,\n    pub protocol: Option\u003cString\u003e,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n    pub addresses: Vec\u003cAddress\u003e,\n    pub fragment: Option\u003cString\u003e,\n    pub database: Option\u003cString\u003e,\n    pub params: BTreeMap\u003cString, String\u003e,\n}\n\npub trait IntoDsn {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e;\n}\n\nimpl IntoDsn for \u0026str {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        self.parse()\n    }\n}\n\nimpl IntoDsn for String {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        self.as_str().into_dsn()\n    }\n}\n\nimpl IntoDsn for \u0026String {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        self.as_str().into_dsn()\n    }\n}\n\nimpl IntoDsn for \u0026Dsn {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        Ok(self.clone())\n    }\n}\nimpl IntoDsn for Dsn {\n    fn into_dsn(self) -\u003e Result\u003cDsn, DsnError\u003e {\n        Ok(self)\n    }\n}\n\nimpl Display for Dsn {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.driver)?;\n        if let Some(protocol) = \u0026self.protocol {\n            write!(f, \"+{protocol}\")?;\n        }\n        write!(f, \"://\")?;\n        match (\u0026self.username, \u0026self.password) {\n            (Some(username), Some(password)) =\u003e write!(f, \"{username}:{password}@\")?,\n            (Some(username), None) =\u003e write!(f, \"{username}@\")?,\n            (None, Some(password)) =\u003e write!(f, \":{password}@\")?,\n            (None, None) =\u003e {}\n        }\n        if !self.addresses.is_empty() {\n            write!(\n                f,\n                \"{}\",\n                self.addresses.iter().map(ToString::to_string).join(\",\")\n            )?;\n        }\n        if let Some(database) = \u0026self.database {\n            write!(f, \"/{database}\")?;\n        }\n        if let Some(fragment) = \u0026self.fragment {\n            write!(f, \"{fragment}\")?;\n        }\n        if !self.params.is_empty() {\n            write!(\n                f,\n                \"?{}\",\n                self.params\n                    .iter()\n                    .map(|(k, v)| format!(\"{k}={v}\"))\n                    .join(\"\u0026\")\n            )?;\n        }\n        Ok(())\n    }\n}\n\nimpl Dsn {\n    /// Parse from a DSN string.\n    #[inline]\n    pub fn parse(dsn: impl AsRef\u003cstr\u003e) -\u003e Result\u003cSelf, DsnError\u003e {\n        dsn.as_ref().parse()\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Dsn::from_str(value)\n    }\n}\n\nimpl TryFrom\u003c\u0026String\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: \u0026String) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Dsn::from_str(value)\n    }\n}\n\nimpl TryFrom\u003cString\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: String) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Dsn::from_str(\u0026value)\n    }\n}\n\nimpl TryFrom\u003c\u0026Dsn\u003e for Dsn {\n    type Error = DsnError;\n\n    fn try_from(value: \u0026Dsn) -\u003e Result\u003cSelf, Self::Error\u003e {\n        Ok(value.clone())\n    }\n}\nimpl FromStr for Dsn {\n    type Err = DsnError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let dsn = DsnParser::parse(Rule::dsn, s)?.next().unwrap();\n\n        let mut to = Dsn::default();\n        for pair in dsn.into_inner() {\n            match pair.as_rule() {\n                Rule::scheme =\u003e {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::driver =\u003e to.driver = inner.as_str().to_string(),\n                            Rule::protocol =\u003e to.protocol = Some(inner.as_str().to_string()),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }\n                Rule::SCHEME_IDENT =\u003e (),\n                Rule::username_with_password =\u003e {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::username =\u003e to.username = Some(inner.as_str().to_string()),\n                            Rule::password =\u003e to.password = Some(inner.as_str().to_string()),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }\n                Rule::protocol_with_addresses =\u003e {\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::addresses =\u003e {\n                                for inner in inner.into_inner() {\n                                    match inner.as_rule() {\n                                        Rule::address =\u003e {\n                                            let mut addr = Address::default();\n                                            for inner in inner.into_inner() {\n                                                match inner.as_rule() {\n                                                    Rule::host =\u003e {\n                                                        addr.host = Some(inner.as_str().to_string())\n                                                    }\n                                                    Rule::port =\u003e {\n                                                        addr.port = Some(inner.as_str().parse()?)\n                                                    }\n                                                    Rule::path =\u003e {\n                                                        addr.path = Some(\n                                                            urlencoding::decode(inner.as_str())\n                                                                .expect(\"UTF-8\")\n                                                                .to_string(),\n                                                        )\n                                                    }\n                                                    _ =\u003e unreachable!(),\n                                                }\n                                            }\n                                            to.addresses.push(addr);\n                                        }\n                                        _ =\u003e unreachable!(),\n                                    }\n                                }\n                            }\n                            Rule::protocol =\u003e to.protocol = Some(inner.as_str().to_string()),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                }\n                Rule::database =\u003e {\n                    to.database = Some(pair.as_str().to_string());\n                }\n                Rule::fragment =\u003e {\n                    to.fragment = Some(pair.as_str().to_string());\n                }\n                Rule::param =\u003e {\n                    let (mut name, mut value) = (\"\".to_string(), \"\".to_string());\n                    for inner in pair.into_inner() {\n                        match inner.as_rule() {\n                            Rule::name =\u003e name = inner.as_str().to_string(),\n                            Rule::value =\u003e value = inner.as_str().to_string(),\n                            _ =\u003e unreachable!(),\n                        }\n                    }\n                    to.params.insert(name, value);\n                }\n                Rule::EOI =\u003e {}\n                _ =\u003e unreachable!(),\n            }\n        }\n        Ok(to)\n    }\n}\n\n#[test]\nfn username_with_password() {\n    let s = \"taos://\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos:///\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos://\");\n\n    let s = \"taos://root@\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n    let s = \"taos://root:taosdata@\";\n\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn host_port_mix() {\n    let s = \"taos://localhost\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@localhost:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n#[test]\nfn username_with_host() {\n    let s = \"taos://root@localhost\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                host: Some(\"localhost\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address {\n                port: Some(6030),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root@localhost:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address::new(\"localhost\", 6030)],\n            ..Default::default()\n        }\n    );\n\n    let s = \"taos://root:taosdata@localhost:6030\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            addresses: vec![Address::new(\"localhost\", 6030)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn username_with_multi_addresses() {\n    let s = \"taos://root@host1.domain:6030,host2.domain:6031\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![\n                Address::new(\"host1.domain\", 6030),\n                Address::new(\"host2.domain\", 6031)\n            ],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root:taosdata@host1:6030,host2:6031\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn db_only() {\n    let s = \"taos:///db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            database: Some(\"db1\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos:///db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            database: Some(\"db1\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn username_with_multi_addresses_database() {\n    let s = \"taos://root@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"taos://root:taosdata@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            database: Some(\"db1\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn protocol() {\n    let s = \"taos://root@tcp(host1:6030,host2:6031)/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            protocol: Some(\"tcp\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos+tcp://root@host1:6030,host2:6031/db1\");\n\n    let s = \"taos+tcp://root@host1:6030,host2:6031/db1\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            database: Some(\"db1\".to_string()),\n            protocol: Some(\"tcp\".to_string()),\n            addresses: vec![Address::new(\"host1\", 6030), Address::new(\"host2\", 6031)],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), \"taos+tcp://root@host1:6030,host2:6031/db1\");\n}\n\n#[test]\nfn fragment() {\n    let s = \"postgresql://%2Fvar%2Flib%2Fpostgresql/dbname\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"postgresql\".to_string(),\n            database: Some(\"dbname\".to_string()),\n            addresses: vec![Address {\n                path: Some(\"/var/lib/postgresql\".to_string()),\n                ..Default::default()\n            }],\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"unix:///path/to/unix.sock\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"unix\".to_string(),\n            fragment: Some(\"/path/to/unix.sock\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite:///c:/full/windows/path/to/file.db\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            fragment: Some(\"/c:/full/windows/path/to/file.db\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite://./file.db\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            fragment: Some(\"./file.db\".to_string()),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = \"sqlite://root:pass@/full/unix/path/to/file.db?mode=0666\u0026readonly=true\";\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"sqlite\".to_string(),\n            username: Some(\"root\".to_string()),\n            password: Some(\"pass\".to_string()),\n            fragment: Some(\"/full/unix/path/to/file.db\".to_string()),\n            params: BTreeMap::from_iter(vec![\n                (\"mode\".to_string(), \"0666\".to_string()),\n                (\"readonly\".to_string(), \"true\".to_string())\n            ]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn params() {\n    let s = r#\"taos://?abc=abc\"#;\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            params: BTreeMap::from_iter(vec![(\"abc\".to_string(), \"abc\".to_string())]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n\n    let s = r#\"taos://root@localhost?abc=abc\"#;\n    let dsn = Dsn::from_str(\u0026s).unwrap();\n    assert_eq!(\n        dsn,\n        Dsn {\n            driver: \"taos\".to_string(),\n            username: Some(\"root\".to_string()),\n            addresses: vec![Address::from_host(\"localhost\")],\n            params: BTreeMap::from_iter(vec![(\"abc\".to_string(), \"abc\".to_string())]),\n            ..Default::default()\n        }\n    );\n    assert_eq!(dsn.to_string(), s);\n}\n\n#[test]\nfn parse_taos_tmq() {\n    let s = \"taos://root:taosdata@localhost/aa23d04011eca42cf7d8c1dd05a37985?topics=aa23d04011eca42cf7d8c1dd05a37985\u0026group.id=tg2\";\n    let _ = Dsn::from_str(\u0026s).unwrap();\n\n}\n","traces":[{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[14154192],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":139,"address":[14154206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[14156495,14154320,14155802],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":147,"address":[14154350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[14154463,14154768,14154838,14154371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[14154912,14155033,14156079,14156364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[14155233,14155304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[14155388,14156178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[14155845,14155420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[14155625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[14155452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[14156425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[14157899,14156512],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":170,"address":[14156683,14156546,14157213,14156726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[14157055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[14156794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[14157299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[14157468,14157701,14157929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[14157455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[14157952],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":212,"address":[14157973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[14125808,14125919],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":218,"address":[14125896,14125833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[14125952],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":224,"address":[14125984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[14158000],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":230,"address":[14158024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[14158096],"length":1,"stats":{"Line":0},"fn_name":"into_dsn"},{"line":235,"address":[14158113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[14158192,14160224],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":241,"address":[14158456,14158231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[14158417,14158506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[14158514,14158604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[14158546,14158923,14158783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[14158870,14158950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[14159374,14159062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[14159011,14159417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[14159590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[14159352,14159832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[14160254,14160026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[14159905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[14159846,14160335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[14160430,14160343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[14160600,14160377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[14160674,14160608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[14160642,14160843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[14160947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[14160870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[14267136,14267177],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":275,"address":[14160849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[8222944,8222848],"length":1,"stats":{"Line":1},"fn_name":"parse\u003c\u0026str\u003e"},{"line":283,"address":[8222872,8222931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[14161232],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":291,"address":[14161253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[14161280],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":299,"address":[14161312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[14161360,14161471],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":307,"address":[14161448,14161385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[14161504],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":315,"address":[14161528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[14161600,14162117],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":322,"address":[14162015,14162143,14161651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[14162175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[14169558,14162220,14162328,14169590,14166837],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[14162539,14162613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[14168724,14169526,14162718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[14168927,14168998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[14169372,14169072],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[14169104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[14168692,14167858,14162788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[14168061,14168132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[14168206,14168506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[14168238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[14162896,14167602,14166810,14167570,14164653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[14164938,14164864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[14166783,14165056,14167317,14167256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[14165408,14165334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[14165437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[14165601,14165477,14166694,14167120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[14165881,14165804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[14165977,14166918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[14166639,14166015,14166455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[14166224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[14166053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[14167125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[14165018,14167384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[14163237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[14162995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[14167853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[14162858,14167672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[14163242,14162966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":391,"address":[14164402,14163564,14163456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[14163767,14163844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[14163924,14164232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[14163962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[14164434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[14169636],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":104},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","metrics.rs"],"content":"use std::{thread, time};\n\nuse anyhow::Result;\nuse taosx::metrics::*;\n\nfn main() -\u003e Result\u003c()\u003e {\n    Metrics::default().init().unwrap();\n\n    loop {\n        thread::sleep(time::Duration::from_secs(1));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","backup.rs"],"content":"use clap::Args;\nuse futures::Future;\nuse parquet::{basic::Compression, schema::types::Type};\nuse std::{\n    fmt::Debug,\n    fs::{self, File},\n    io::Write,\n    path::PathBuf,\n    sync::Arc,\n};\nuse taos::prelude::*;\nuse taos::TaosOptions;\n\nuse taosx::{Database, TaosOpts};\nuse thread_id;\nuse tokio::runtime::Builder;\n\nuse crate::commands::backup::{\n    fetch::{fetch_database_info, fetch_table_list},\n    schema::TaosParquetSchema,\n};\n\nuse self::{fetch::fetch_stable_tag_buffer, serialize::Serialize};\n\nmod fetch;\nmod schema;\nmod serialize;\n\n#[derive(Debug, Args, Clone)]\n/// Backup database or tables to specific files.\n///\n/// Basically, an alternative command to `taosdump`.\npub(crate) struct App {\n    #[clap(short, long)]\n    database: Option\u003cString\u003e,\n    #[clap(short, long)]\n    output: Option\u003cString\u003e,\n    #[clap(short, long)]\n    thread: Option\u003cu32\u003e,\n}\n\nfn allocate_task\u003cFut: 'static\u003e(\n    table_list: Vec\u003cString\u003e,\n    schema: Arc\u003cType\u003e,\n    dir: PathBuf,\n    path: \u0026str,\n    mut threads: u32,\n    db: String,\n    f: impl Fn(Arc\u003cType\u003e, Vec\u003cString\u003e, PathBuf, String) -\u003e Fut,\n) where\n    Fut: Future\u003cOutput = ()\u003e + std::marker::Send,\n{\n    let mut own_path = dir;\n    own_path.push(path);\n    fs::create_dir(own_path.clone()).unwrap_or_else(|_| {\n        fs::remove_dir_all(own_path.clone()).unwrap_or_else(|_| {\n            fs::remove_dir(own_path.clone()).unwrap();\n        });\n        fs::create_dir(own_path.clone()).unwrap();\n    });\n    if threads \u003e table_list.len() as _ {\n        threads = table_list.len() as _;\n    }\n    let tables_per_thread = if table_list.len() as u32 % threads == 0 {\n        table_list.len() as u32 / threads\n    } else {\n        table_list.len() as u32 / threads + 1\n    };\n\n    let mut handles = Vec::with_capacity(threads as _);\n    let chunks: Vec\u003c\u0026[String]\u003e = table_list.chunks(tables_per_thread as _).collect();\n    threads = chunks.len() as _;\n\n    log::info!(\n        \"{} threads each deal at most {} tables\",\n        threads,\n        tables_per_thread\n    );\n\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(threads as usize)\n        .enable_all()\n        .build()\n        .unwrap();\n\n    for chunk in chunks {\n        handles.push(runtime.spawn(f(\n            schema.clone(),\n            chunk.to_owned(),\n            own_path.clone(),\n            db.clone(),\n        )));\n    }\n    for handle in handles {\n        runtime.block_on(handle).unwrap();\n    }\n}\n\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        log::info!(\"prepare config options\");\n\n        let database = self.database.as_deref().unwrap_or(\"test\");\n        let db = String::from(database);\n        let threads = self.thread.unwrap_or(1);\n        let output = self.output.as_deref().unwrap_or(\"./\");\n        let path = PathBuf::from(output);\n\n        log::info!(\"prepare parquet schema\");\n\n        let schema = TaosParquetSchema::default().build();\n\n        log::info!(\"start backup database info\");\n\n        let database = fetch_database_info(db.clone());\n\n        backup_database(database, path.clone());\n\n        log::info!(\"finish backup database info\");\n\n        let (select_list, describe_list, stable_list) = fetch_table_list(db.clone());\n\n        log::info!(\n            \"select list: {:?}; describe list {:?}; stable_list{:?}\",\n            select_list,\n            describe_list,\n            stable_list\n        );\n\n        log::info!(\"start backup table meta info\");\n        allocate_task(\n            describe_list,\n            schema.clone(),\n            path.clone(),\n            \"table.info\",\n            threads,\n            db.clone(),\n            backup_table_schema,\n        );\n        log::info!(\"finish backup table meta info\");\n        log::info!(\"start backup table tags\");\n        allocate_task(\n            stable_list,\n            schema.clone(),\n            path.clone(),\n            \"tags\",\n            threads,\n            db.clone(),\n            backup_stable_tags,\n        );\n        log::info!(\"finish backup table tags\");\n        log::info!(\"start backup data\");\n        allocate_task(select_list, schema, path, \"chunk\", threads, db, backup_data);\n        log::info!(\"finish backup data\");\n    }\n}\n\nfn backup_database(database: Database, mut path: PathBuf) {\n    path.push(\"db.info\");\n    let mut file = File::create(path.as_path()).unwrap();\n    let j = serde_json::to_string_pretty(\u0026database).unwrap();\n    file.write_all(j.as_bytes()).unwrap();\n}\n\nasync fn backup_table_schema(\n    schema: Arc\u003cType\u003e,\n    table_list: Vec\u003cString\u003e,\n    mut path: PathBuf,\n    db: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let taos = TaosOptions::new().database(db.clone()).build().unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    for tbname in table_list {\n        let describe = taos.describe(\u0026tbname).await.unwrap();\n        serialize.serialze_table_meta(\u0026tbname, describe);\n    }\n}\n\nasync fn backup_stable_tags(\n    schema: Arc\u003cType\u003e,\n    table_list: Vec\u003cString\u003e,\n    mut path: PathBuf,\n    database: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    for tbname in table_list {\n        let tag_buffer = fetch_stable_tag_buffer(database.clone(), tbname.clone()).await;\n        let mut res = taos\n            .query(format!(\"select tbname{} from {}\", tag_buffer, tbname).as_str())\n            .await\n            .unwrap();\n        let stream = res.block_stream();\n        serialize.serialize_tag(\u0026tbname, stream).await;\n    }\n}\n\nasync fn backup_data(\n    schema: Arc\u003cType\u003e,\n    tbname_list: Vec\u003cString\u003e,\n    mut path: PathBuf,\n    database: String,\n) {\n    let thread_id = thread_id::get();\n    path.push(format!(\"{}.parquet\", thread_id));\n    let file = File::create(path.as_path()).unwrap();\n    let taos = TaosOptions::new().database(database).build().unwrap();\n    let mut serialize = Serialize::new(file, Compression::SNAPPY, schema);\n    for tbname in tbname_list {\n        let mut res = taos\n            .query(format!(\"select * from {}\", tbname).as_str())\n            .await\n            .unwrap();\n        let stream = res.block_stream();\n        serialize.serialize_data(\u0026tbname, stream).await;\n    }\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","backup_parquet.rs"],"content":"use libtaos::Taos;\nuse parquet::{\n    basic::{\n        Compression, ConvertedType, LogicalType, Repetition, TimeUnit, TimestampType,\n        Type as PhysicalType,\n    },\n    file::{\n        properties::WriterProperties,\n        writer::{FileWriter, SerializedFileWriter},\n    },\n    schema::types::Type,\n};\nuse std::{fs, path::PathBuf, sync::Arc};\nuse taos::r2d2::TaosPool;\nuse taos::BlockExt;\n\npub async fn generate_parquet_schema(taos: \u0026Taos, db: String, stb: \u0026str) -\u003e Arc\u003cType\u003e {\n    let mut fields = vec![];\n    taos.use_database(\u0026db).await.unwrap();\n    let res = taos.describe(stb).await.unwrap();\n    for i in 0..res.cols.len() {\n        match res.cols[i].type_ {\n            libtaos::TaosDataType::Null =\u003e todo!(),\n            libtaos::TaosDataType::Bool =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::BOOLEAN)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::TinyInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::INT_8)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::SmallInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::INT_16)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Int =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::BigInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Float =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::FLOAT)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Double =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::DOUBLE)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Binary =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::BYTE_ARRAY)\n                    .with_repetition(Repetition::REQUIRED)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Timestamp =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_logical_type(Some(LogicalType::TIMESTAMP(TimestampType {\n                        is_adjusted_to_u_t_c: false,\n                        unit: TimeUnit::MILLIS(Default::default()),\n                    })))\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::NChar =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::BYTE_ARRAY)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_logical_type(Some(LogicalType::STRING(Default::default())))\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UTinyInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_8)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::USmallInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_16)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT32)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_32)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::UBigInt =\u003e fields.push(Arc::new(\n                Type::primitive_type_builder(\u0026i.to_string(), PhysicalType::INT64)\n                    .with_repetition(Repetition::REQUIRED)\n                    .with_converted_type(ConvertedType::UINT_64)\n                    .build()\n                    .unwrap(),\n            )),\n            libtaos::TaosDataType::Json =\u003e todo!(),\n            libtaos::TaosDataType::Unknown =\u003e todo!(),\n        }\n    }\n    Arc::new(\n        Type::group_type_builder(\"schema\")\n            .with_fields(\u0026mut fields)\n            .build()\n            .unwrap(),\n    )\n}\n\npub async fn backup_data_parquet(\n    pool: TaosPool,\n    db: String,\n    tb: String,\n    schema: Arc\u003cType\u003e,\n    target: PathBuf,\n) {\n    let props = Arc::new(\n        WriterProperties::builder()\n            .set_compression(Compression::SNAPPY)\n            .build(),\n    );\n    let mut path = target.clone();\n    path.push(format!(\"{}.parquet\", tb));\n    let file = fs::File::create(path).unwrap();\n    let mut writer = SerializedFileWriter::new(file, schema, props).unwrap();\n    let taos = pool.get().unwrap();\n    let res = taos\n        .query(format!(\"select * from {}.{} \", db, tb).as_str())\n        .await\n        .unwrap();\n    let stream = res.fetch_block_stream();\n    use futures::future;\n    use futures::stream::StreamExt;\n    stream\n        .enumerate()\n        .for_each(|(_, partial)| {\n            // log::debug!(\"num of row in block: {}\", partial.num_of_rows());\n            let mut row_group_writer = writer.next_row_group().unwrap();\n            for col in partial.columns_iter() {\n                let data_writer = row_group_writer.next_column().unwrap();\n                if let Some(mut writer) = data_writer {\n                    use taos::block::BorrowedColumn::*;\n                    match writer {\n                        parquet::column::writer::ColumnWriter::BoolColumnWriter(ref mut typed) =\u003e {\n                            match col {\n                                Bool(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                        }\n                        parquet::column::writer::ColumnWriter::Int32ColumnWriter(ref mut typed) =\u003e {\n                            // let values;\n                            match col {\n                                TinyInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                    // std::mem::transmute::\u003c*const i32\u003e(values.ptr()).\n\n                                    // values = values\n                                    //     .into_iter()\n                                    //     .map(|v| match v {\n                                    //         Some(u) =\u003e Some(u as i32),\n                                    //         None =\u003e None,\n                                    //     })\n                                    //     .collect::\u003cOption\u003cVec\u003ci32\u003e\u003e\u003e()\n                                    //     .unwrap()\n                                }\n                                SmallInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                Int(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                UTinyInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                USmallInt(is_nulls, values) =\u003e {\n                                    let values: Vec\u003ci32\u003e =\n                                        values.into_iter().map(|v| *v as _).collect();\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                UInt(is_nulls, values) =\u003e {\n                                    // let values: Vec\u003ci32\u003e = values.into_iter().map(|v| *v as _).collect();\n                                    let len = values.len();\n                                    let ptr: *mut i32 = values.as_ptr() as _;\n                                    let values = unsafe { std::slice::from_raw_parts(ptr, len) };\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n\n                                _ =\u003e unreachable!(),\n                            }\n                            // typed.write_batch(\u0026values, None, None).unwrap();\n                        }\n                        parquet::column::writer::ColumnWriter::Int64ColumnWriter(ref mut typed) =\u003e {\n                            // let values;\n                            match col {\n                                BigInt(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                UBigInt(is_nulls, values) =\u003e {\n                                    // let values: Vec\u003ci32\u003e = values.into_iter().map(|v| *v as _).collect();\n                                    let len = values.len();\n                                    let ptr: *mut i64 = values.as_ptr() as _;\n                                    let values = unsafe { std::slice::from_raw_parts(ptr, len) };\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                Timestamp(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                            // typed.write_batch(\u0026values, None, None).unwrap();\n                        }\n                        parquet::column::writer::ColumnWriter::FloatColumnWriter(ref mut typed) =\u003e {\n                            // let values;\n                            match col {\n                                Float(is_nulls, values) =\u003e {\n                                    typed.write_batch(\u0026values, None, None).unwrap();\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                        }\n                        parquet::column::writer::ColumnWriter::DoubleColumnWriter(\n                            ref mut typed,\n                        ) =\u003e match col {\n                            Double(is_nulls, values) =\u003e {\n                                typed.write_batch(\u0026values, None, None).unwrap();\n                            }\n                            _ =\u003e unreachable!(),\n                        },\n                        parquet::column::writer::ColumnWriter::ByteArrayColumnWriter(\n                            ref mut typed,\n                        ) =\u003e {\n                            let mut values = vec![];\n                            match col {\n                                Binary(v) =\u003e {\n                                    for f in v.into_iter() {\n                                        match f {\n                                            Some(u) =\u003e values.push(\n                                                parquet::data_type::ByteArray::from(u.to_vec()),\n                                            ),\n                                            None =\u003e {\n                                                values.push(parquet::data_type::ByteArray::from(\"\"))\n                                            }\n                                        }\n                                    }\n                                }\n                                NChar(v) =\u003e {\n                                    for f in v.into_iter() {\n                                        match f {\n                                            Some(u) =\u003e values.push(\n                                                parquet::data_type::ByteArray::from(u),\n                                            ),\n                                            None =\u003e {\n                                                values.push(parquet::data_type::ByteArray::from(\"\"))\n                                            }\n                                        }\n                                    }\n                                }\n                                _ =\u003e unreachable!(),\n                            }\n                            typed.write_batch(\u0026values, None, None).unwrap();\n                        }\n                        _ =\u003e unreachable!(),\n                    }\n                    row_group_writer.close_column(writer).unwrap();\n                }\n            }\n            writer.close_row_group(row_group_writer).unwrap();\n            future::ready(())\n        })\n        .await;\n    writer.close().unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","fetch.rs"],"content":"use futures::TryStreamExt;\nuse taos::prelude::*;\nuse taosx::Database;\nuse tokio::runtime::Builder;\n#[derive(::serde::Deserialize, Debug)]\npub struct Table {\n    pub table_name: String,\n    pub stable_name: String,\n}\n\npub fn fetch_table_list(database: String) -\u003e (Vec\u003cString\u003e, Vec\u003cString\u003e, Vec\u003cString\u003e) {\n    let mut select_list = vec![];\n    let mut describe_list = vec![];\n    let mut stable_list = vec![];\n    let taos = TaosOptions::new().database(database).build().unwrap();\n    let tables: Vec\u003cTable\u003e = Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(\"show tables\")\n                .await\n                .unwrap()\n                .deserialize_stream()\n                .try_collect()\n                .await\n                .unwrap()\n        });\n    for table in tables {\n        select_list.push(table.table_name.clone());\n        if table.stable_name.is_empty() {\n            describe_list.push(table.table_name);\n        } else if !describe_list.contains(\u0026table.stable_name) {\n            stable_list.push(table.stable_name.clone());\n            describe_list.push(table.stable_name);\n        }\n    }\n    (select_list, describe_list, stable_list)\n}\n\npub fn fetch_database_info(database: String) -\u003e Database {\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    let dbs: Vec\u003cDatabase\u003e = Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(\"show databases\")\n                .await\n                .unwrap()\n                .deserialize_stream()\n                .try_collect()\n                .await\n                .unwrap()\n        });\n    for db in dbs {\n        if db.name == database {\n            return db;\n        }\n    }\n    panic!(\"cannot find database {}\", database);\n}\n\npub async fn fetch_stable_tag_buffer(database: String, stable: String) -\u003e String {\n    let mut tag_buffer = String::from(\"\");\n    let taos = TaosOptions::new()\n        .database(database.clone())\n        .build()\n        .unwrap();\n    let describe = taos\n        .describe(format!(\"{}.{}\", database.clone(), stable).as_str())\n        .await\n        .unwrap();\n    for col in describe {\n        if col.is_tag() {\n            tag_buffer += \",\";\n            tag_buffer += col.field();\n        }\n    }\n    tag_buffer\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","schema.rs"],"content":"use parquet::basic::{Repetition, Type as PhysicalType};\nuse parquet::schema::types::Type;\nuse std::sync::Arc;\n\n#[derive(Debug, Clone, Default)]\npub struct TaosParquetSchema {\n    fields: Vec\u003cArc\u003cType\u003e\u003e,\n}\n\nimpl TaosParquetSchema {\n    fn add_required_byte_array_col(mut self, name: \u0026str) -\u003e Self {\n        self.fields.push(Arc::new(\n            Type::primitive_type_builder(name, PhysicalType::BYTE_ARRAY)\n                .with_repetition(Repetition::REQUIRED)\n                .build()\n                .unwrap(),\n        ));\n        self\n    }\n\n    fn add_group(mut self, group: Arc\u003cType\u003e) -\u003e Self {\n        self.fields.push(group);\n        self\n    }\n\n    fn build_repeated_group(mut self, name: \u0026str) -\u003e Arc\u003cType\u003e {\n        Arc::new(\n            Type::group_type_builder(name)\n                .with_fields(\u0026mut self.fields)\n                .with_repetition(Repetition::REPEATED)\n                .build()\n                .unwrap(),\n        )\n    }\n\n    fn build_schema(mut self, name: \u0026str) -\u003e Arc\u003cType\u003e {\n        Arc::new(\n            Type::group_type_builder(name)\n                .with_fields(\u0026mut self.fields)\n                .build()\n                .unwrap(),\n        )\n    }\n\n    pub fn build(self) -\u003e Arc\u003cType\u003e {\n        self.add_group(\n            TaosParquetSchema::default()\n                .add_required_byte_array_col(\"data\")\n                .build_repeated_group(\"table_info\"),\n        )\n        .build_schema(\"table\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","backup","serialize.rs"],"content":"use std::{fmt::Debug, sync::Arc};\n\nuse futures::{future, StreamExt};\nuse parquet::{\n    basic::Compression,\n    column::writer::*,\n    data_type::{ByteArray, ByteArrayType},\n    file::{\n        properties::WriterProperties,\n        writer::{FileWriter, ParquetWriter, SerializedFileWriter},\n    },\n    schema::types::Type,\n};\n\nuse taos::{\n    block::{BlockStream, Describe},\n    helpers::ColumnMeta,\n    prelude::BlockExt,\n};\nuse taosx::{TaosBlock, TaosDescribe, TaosTag};\n\npub struct Serialize\u003cW: ParquetWriter + 'static\u003e {\n    writer: SerializedFileWriter\u003cW\u003e,\n}\n\nimpl\u003cW: ParquetWriter + 'static\u003e Serialize\u003cW\u003e {\n    pub fn new(target: W, compression: Compression, schema: Arc\u003cType\u003e) -\u003e Self {\n        let props = Arc::new(\n            WriterProperties::builder()\n                .set_compression(compression)\n                .build(),\n        );\n        let writer = SerializedFileWriter::new(target, schema, props).unwrap();\n\n        Self { writer }\n    }\n\n    fn serialize\u003cT\u003e(\u0026mut self, source: T)\n    where\n        T: serde::Serialize + serde::de::DeserializeOwned + Debug,\n    {\n        let mut row_group = self.writer.next_row_group().unwrap();\n        let mut column_writer = row_group.next_column().unwrap().unwrap();\n        let typed = get_typed_column_writer_mut::\u003cByteArrayType\u003e(\u0026mut column_writer);\n        let encoded = bincode::serialize(\u0026source).unwrap();\n        typed\n            .write_batch(\u0026[ByteArray::from(encoded)], Some(\u0026[1]), Some(\u0026[0]))\n            .unwrap();\n        row_group.close_column(column_writer).unwrap();\n        self.writer.close_row_group(row_group).unwrap();\n    }\n\n    pub fn serialze_table_meta(\u0026mut self, name: \u0026str, describe: Describe) {\n        let taos_describe = TaosDescribe::new(name.to_string(), describe);\n        self.serialize(taos_describe);\n    }\n\n    pub async fn serialize_tag(\u0026mut self, name: \u0026str, stream: BlockStream) {\n        stream\n            .enumerate()\n            .for_each(|(_, block)| {\n                let taos_tags = TaosTag::new(name.to_string(), block.iter_rows());\n                self.serialize(taos_tags);\n                future::ready(())\n            })\n            .await;\n    }\n\n    pub async fn serialize_data(\u0026mut self, name: \u0026str, stream: BlockStream) {\n        stream\n            .enumerate()\n            .for_each(|(_, block)| {\n                let taos_block = TaosBlock::new(name.to_string(), block.columns_iter());\n                self.serialize(taos_block);\n                future::ready(())\n            })\n            .await;\n    }\n}\n\nimpl\u003cW: ParquetWriter + 'static\u003e Drop for Serialize\u003cW\u003e {\n    fn drop(\u0026mut self) {\n        self.writer.close().unwrap();\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","export.rs"],"content":"use clap::Args;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Export db or table to specific files.\npub(crate) struct App {\n    name: Option\u003cString\u003e,\n}\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        todo!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","import.rs"],"content":"use clap::Args;\nuse taos::query::Dsn;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Import external files to TDengine.\npub(crate) struct App {\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for source TDengine: taos:///db1, for eg.\n    from: Dsn,\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for target TDengine: taos:///db2, for eg.\n    to: Dsn,\n}\n\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        todo!()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","mod.rs"],"content":"#[path = \"backup/backup.rs\"]\npub mod backup;\npub mod export;\npub mod import;\n#[path = \"restore/restore.rs\"]\npub mod restore;\n\npub mod sync;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","deserialize.rs"],"content":"use parquet::{\n    file::{reader::FileReader, serialized_reader::SerializedFileReader},\n    record::Field,\n};\nuse std::io::BufReader;\nuse std::{fs::File, path::PathBuf};\n\nuse taosx::Database;\n\npub fn deserialize_database(path: PathBuf) -\u003e Database {\n    let file = File::open(path).unwrap();\n    let reader = BufReader::new(file);\n    serde_json::from_reader(reader).unwrap()\n}\n\npub struct Deserialize\u003cT: serde::de::DeserializeOwned\u003e {\n    parquet_reader: SerializedFileReader\u003cFile\u003e,\n    pub output: Vec\u003cT\u003e,\n}\n\nimpl\u003cT: serde::de::DeserializeOwned\u003e Deserialize\u003cT\u003e {\n    pub fn new(source: String) -\u003e Self {\n        let parquet_reader = SerializedFileReader::try_from(source).unwrap();\n        let output: Vec\u003cT\u003e = Vec::new();\n        Self {\n            parquet_reader,\n            output,\n        }\n    }\n\n    pub async fn deserialize(\u0026mut self) {\n        let iter = self.parquet_reader.get_row_iter(None).unwrap();\n        for row in iter {\n            let (_, field) = row.get_column_iter().next().unwrap();\n            if let Field::ListInternal(list) = field {\n                for element in list.elements() {\n                    if let Field::Group(g) = element {\n                        let (_, fields) = g.get_column_iter().next().unwrap();\n                        if let Field::Bytes(b) = fields {\n                            self.output\n                                .push(bincode::deserialize::\u003cT\u003e(b.data()).unwrap());\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","restore.rs"],"content":"use clap::Args;\nuse futures::Future;\nuse std::path::PathBuf;\nuse tokio::runtime::Builder;\n\nuse taos::prelude::*;\nuse taosx::{TaosBlock, TaosDescribe, TaosOpts, TaosTag};\npub(crate) mod deserialize;\n\nuse self::deserialize::{deserialize_database, Deserialize};\n#[derive(Debug, Args)]\n/// Restore from a backup output directory.\n\npub(crate) struct App {\n    #[clap(short, long)]\n    database: Option\u003cString\u003e,\n    #[clap(short, long)]\n    input: Option\u003cString\u003e,\n    #[clap(short, long)]\n    thread: Option\u003cu32\u003e,\n}\n\nfn allocate_task\u003cFut: 'static\u003e(\n    db: String,\n    mut dir: PathBuf,\n    path: \u0026str,\n    mut threads: u32,\n    f: impl Fn(Vec\u003cString\u003e, String) -\u003e Fut,\n) where\n    Fut: Future\u003cOutput = ()\u003e + std::marker::Send,\n{\n    dir.push(path);\n    let mut filelist = vec![];\n    for element in dir.read_dir().unwrap() {\n        let filename = element.unwrap().path();\n        if let Some(extension) = filename.extension() {\n            if extension == \"parquet\" {\n                filelist.push(filename.to_str().unwrap().to_string());\n            }\n        }\n    }\n    if threads \u003e filelist.len() as _ {\n        threads = filelist.len() as _;\n    }\n    let file_per_threads = if filelist.len() as u32 % threads == 0 {\n        filelist.len() as u32 / threads\n    } else {\n        filelist.len() as u32 / threads + 1\n    };\n\n    let mut handles = Vec::with_capacity(threads as _);\n    let chunks: Vec\u003c\u0026[String]\u003e = filelist.chunks(file_per_threads as _).collect();\n    threads = chunks.len() as _;\n\n    log::info!(\n        \"{} threads each deal with at most {} files\",\n        threads,\n        file_per_threads\n    );\n\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(threads as usize)\n        .enable_all()\n        .build()\n        .unwrap();\n    for chunk in chunks {\n        handles.push(runtime.spawn(f(chunk.to_owned(), db.clone())))\n    }\n    for handle in handles {\n        runtime.block_on(handle).unwrap();\n    }\n}\n\nimpl App {\n    pub fn run_with_taos_opts(\u0026self, _opts: \u0026TaosOpts) {\n        let threads = self.thread.unwrap_or(1);\n        let input = self.input.as_deref().unwrap_or(\"./\");\n        let path = PathBuf::from(input);\n\n        let db = restore_database(path.clone());\n\n        allocate_task(\n            db.clone(),\n            path.clone(),\n            \"table.info\",\n            threads,\n            restore_table_info,\n        );\n\n        allocate_task(db.clone(), path.clone(), \"tags\", threads, restore_tags);\n\n        allocate_task(db, path, \"chunk\", threads, restore_data);\n    }\n}\n\nfn restore_database(mut path: PathBuf) -\u003e String {\n    path.push(\"db.info\");\n    let taos = TaosOptions::new().build().unwrap();\n    let database = deserialize_database(path);\n    Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap()\n        .block_on(async {\n            taos.query(format!(\"create database if not exists {}\", database.name))\n                .await\n                .unwrap()\n        });\n\n    database.name\n}\n\nasync fn restore_table_info(filelist: Vec\u003cString\u003e, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::\u003cTaosDescribe\u003e::new(file);\n        deserialize.deserialize().await;\n        let describes = deserialize.output;\n        for describe in describes {\n            let mut col_buffer = String::from(\"\");\n            let mut tag_buffer = String::from(\"\");\n            for col in describe.describe {\n                match col {\n                    taosx::TaosColumnMeta::Column(des) =\u003e {\n                        if des.ty == Ty::VarChar || des.ty == Ty::NChar {\n                            col_buffer +=\n                                format!(\"{} {}({}),\", des.field.as_str(), des.ty, des.length)\n                                    .as_str();\n                        } else {\n                            col_buffer += format!(\"{} {},\", des.field.as_str(), des.ty,).as_str();\n                        }\n                    }\n                    taosx::TaosColumnMeta::Tag(des) =\u003e {\n                        if des.ty == Ty::VarChar || des.ty == Ty::NChar {\n                            tag_buffer +=\n                                format!(\"{} {}({}),\", des.field.as_str(), des.ty, des.length)\n                                    .as_str();\n                        } else {\n                            tag_buffer += format!(\"{} {},\", des.field.as_str(), des.ty,).as_str();\n                        }\n                    }\n                }\n            }\n            col_buffer.pop();\n            tag_buffer.pop();\n            let sql = format!(\n                \"create table {} ({}) tags ({})\",\n                describe.name, col_buffer, tag_buffer\n            );\n            taos.stmt(sql).unwrap().execute().unwrap();\n        }\n    }\n}\n\nasync fn restore_tags(filelist: Vec\u003cString\u003e, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::\u003cTaosTag\u003e::new(file);\n        deserialize.deserialize().await;\n        let taostags = deserialize.output;\n        for taostag in taostags {\n            let stbname = taostag.name;\n            for tag in taostag.tags {\n                let mut sql = String::new();\n                for (index, value) in tag.into_iter().enumerate() {\n                    if index == 0 {\n                        if let Value::VarChar(b) = value {\n                            sql = format!(\"create table {} using {} tags (\", b, \u0026stbname);\n                        }\n                    } else {\n                        match value {\n                            Value::Null =\u003e sql += \"NULL,\",\n                            Value::Bool(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::TinyInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::SmallInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Int(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::BigInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Float(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Double(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::VarChar(v) =\u003e {\n                                sql += format!(\"\\'{}\\',\", v).as_str();\n                            }\n                            Value::Timestamp(v) =\u003e sql += format!(\"{},\", v.as_raw_i64()).as_str(),\n                            Value::NChar(v) =\u003e sql += format!(\"\\'{}\\',\", v).as_str(),\n                            Value::UTinyInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::USmallInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::UInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::UBigInt(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            Value::Json(v) =\u003e sql += format!(\"{},\", v).as_str(),\n                            _ =\u003e todo!(),\n                        }\n                    }\n                }\n                sql.pop();\n                sql += \")\";\n                taos.stmt(sql).unwrap().execute().unwrap();\n            }\n        }\n    }\n}\n\nasync fn restore_data(filelist: Vec\u003cString\u003e, db: String) {\n    let taos = TaosOptions::new().database(db).build().unwrap();\n    for file in filelist {\n        let mut deserialize = Deserialize::\u003cTaosBlock\u003e::new(file);\n        deserialize.deserialize().await;\n        let taos_blocks = deserialize.output;\n        for taos_block in taos_blocks {\n            let col_num = taos_block.data.len();\n            let mut prepare = format!(\"insert into {} values (\", taos_block.name);\n            for _ in 0..col_num {\n                prepare += \"?,\";\n            }\n            prepare.pop();\n            prepare += \")\";\n            let mut stmt = taos.stmt(prepare).expect(\"prepare\");\n            let col_vec = taos_block.to_column_vec();\n            let bind: Vec\u003c_\u003e = col_vec.iter().map(|v| v.into()).collect();\n            stmt.multi_bind(\u0026bind).expect(\"bind erro\");\n            stmt.execute().expect(\"execute error\");\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","restore","restore_parquet.rs"],"content":"use bitvec_simd::BitVec;\nuse glob::glob;\nuse parquet::basic::ConvertedType;\nuse parquet::column::reader::{ColumnReader, ColumnReaderImpl};\nuse parquet::data_type::{ByteArray, ByteArrayType, DataType};\nuse parquet::file::reader::FileReader;\nuse parquet::file::serialized_reader::SerializedFileReader;\nuse std::path::PathBuf;\n// use taos::block::serde::Block;\n// use taos::block::Block;\nuse taos::block::Column as Block;\nuse taos::r2d2::TaosPool;\n\npub fn get_parquet_files\u003c'a\u003e(path: PathBuf) -\u003e Vec\u003cString\u003e {\n    let mut file_list = vec![];\n    let paths = glob(format!(\"{}/*.parquet\", path.as_os_str().to_str().unwrap()).as_str()).unwrap();\n    for entry in paths {\n        match entry {\n            Ok(path) =\u003e {\n                let filename = path.to_str().unwrap().split(\"/\").last().unwrap();\n                file_list.push(filename.to_string())\n            }\n            Err(e) =\u003e println!(\"{:?}\", e),\n        }\n    }\n    file_list\n}\n\nfn read\u003cT\u003e(mut column_reader: ColumnReaderImpl\u003cT\u003e, num_rows: usize) -\u003e Vec\u003cT::T\u003e\nwhere\n    T: DataType,\n    T::T: Default + Copy,\n{\n    let mut data = vec![];\n    const BATCH_SIZE: usize = 100;\n    let mut values = [T::T::default(); BATCH_SIZE];\n    for _ in 0..(num_rows + BATCH_SIZE - 1) / BATCH_SIZE {\n        let (num, _) = column_reader\n            .read_batch(BATCH_SIZE, None, None, \u0026mut values)\n            .unwrap();\n        data.extend(\u0026values[0..num]);\n    }\n    data\n}\n\nfn read_str(mut column_reader: ColumnReaderImpl\u003cByteArrayType\u003e, num_rows: usize) -\u003e Vec\u003cByteArray\u003e {\n    let mut data = vec![];\n    const BATCH_SIZE: usize = 10;\n    for _ in 0..(num_rows + BATCH_SIZE - 1 / BATCH_SIZE) {\n        let mut values = vec![];\n        for _ in 0..BATCH_SIZE {\n            values.push(ByteArray::new());\n        }\n        column_reader\n            .read_batch(BATCH_SIZE, None, None, \u0026mut values)\n            .unwrap();\n        data.extend(values);\n    }\n    let _ = data.split_off(num_rows);\n    log::debug!(\"data: {:?}\", data);\n    data\n}\n\npub async fn restore_parquet(pool: TaosPool, path: PathBuf, filename: String, database: String) {\n    let taos = pool.get().unwrap();\n    taos.query(format!(\"use {}\", database)).await.unwrap();\n    let tb = filename.split(\".\").next().unwrap();\n    let parquet_reader =\n        SerializedFileReader::try_from(format!(\"{}/{}.parquet\", path.to_str().unwrap(), tb))\n            .unwrap();\n    let read_schema = parquet_reader.metadata().file_metadata().schema();\n    let mut sql = format!(\"insert into {} values(\", tb);\n    let fields = read_schema.get_fields();\n    let column_num = fields.len();\n    for i in 0..column_num {\n        if i != column_num - 1 {\n            sql += \"?,\";\n        } else {\n            sql += \"?)\";\n        }\n    }\n\n    for row_group in 0..parquet_reader.num_row_groups() {\n        let row_group_reader = parquet_reader.get_row_group(row_group).unwrap();\n        let blocks: Vec\u003c_\u003e = (0..row_group_reader.num_columns())\n            .map(|col_num| {\n                let col_reader = row_group_reader.get_column_reader(col_num).unwrap();\n                let row_num = row_group_reader.metadata().num_rows() as usize;\n                let nulls = BitVec::zeros(row_num);\n\n                match col_reader {\n                    ColumnReader::BoolColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        Block::Bool(nulls, column)\n                    }\n                    ColumnReader::ByteArrayColumnReader(v) =\u003e {\n                        let column = read_str(v, row_num);\n                        match fields.get(col_num).unwrap().get_basic_info().logical_type() {\n                            Some(_) =\u003e Block::NChar(\n                                column\n                                    .into_iter()\n                                    .map(|v| {\n                                        Some(std::str::from_utf8(v.data()).unwrap().to_string())\n                                    })\n                                    .collect(),\n                            ),\n                            None =\u003e Block::Binary(\n                                column\n                                    .into_iter()\n                                    .map(|v| Some(v.data().to_vec()))\n                                    .collect::\u003cVec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e\u003e()\n                                    .to_vec(),\n                            ),\n                        }\n                    }\n                    ColumnReader::DoubleColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        Block::Double(nulls, column)\n                    }\n                    ColumnReader::FloatColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        Block::Float(nulls, column)\n                    }\n                    ColumnReader::Int32ColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n\n                        let values = match fields\n                            .get(col_num)\n                            .unwrap()\n                            .get_basic_info()\n                            .converted_type()\n                        {\n                            ConvertedType::UINT_8 =\u003e Block::UTinyInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u8).collect::\u003cVec\u003cu8\u003e\u003e(),\n                            ),\n                            ConvertedType::UINT_16 =\u003e Block::USmallInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u16).collect::\u003cVec\u003cu16\u003e\u003e(),\n                            ),\n                            ConvertedType::UINT_32 =\u003e Block::UInt(\n                                nulls,\n                                column.into_iter().map(|v| v as u32).collect::\u003cVec\u003cu32\u003e\u003e(),\n                            ),\n                            ConvertedType::INT_8 =\u003e Block::TinyInt(\n                                nulls,\n                                column.into_iter().map(|v| v as i8).collect::\u003cVec\u003ci8\u003e\u003e(),\n                            ),\n                            ConvertedType::INT_16 =\u003e Block::SmallInt(\n                                nulls,\n                                column.into_iter().map(|v| v as i16).collect::\u003cVec\u003ci16\u003e\u003e(),\n                            ),\n                            ConvertedType::NONE =\u003e Block::Int(nulls, column),\n                            _ =\u003e unreachable!(),\n                        };\n                        values\n                    }\n                    ColumnReader::Int64ColumnReader(v) =\u003e {\n                        let column = read(v, row_num);\n                        match fields.get(col_num).unwrap().get_basic_info().logical_type() {\n                            Some(_) =\u003e Block::Timestamp(nulls, column),\n                            None =\u003e match fields\n                                .get(col_num)\n                                .unwrap()\n                                .get_basic_info()\n                                .converted_type()\n                            {\n                                ConvertedType::NONE =\u003e Block::BigInt(nulls, column),\n                                ConvertedType::UINT_64 =\u003e Block::UBigInt(\n                                    nulls,\n                                    column.into_iter().map(|v| v as u64).collect::\u003cVec\u003cu64\u003e\u003e(),\n                                ),\n                                _ =\u003e unreachable!(),\n                            },\n                        }\n                    }\n                    _ =\u003e unreachable!(),\n                }\n            })\n            .collect();\n\n        let bind: Vec\u003c_\u003e = blocks.iter().map(|b| b.into()).collect();\n        let mut stmt = taos.stmt(\u0026sql).unwrap();\n        stmt.multi_bind(\u0026bind).unwrap();\n        stmt.execute().unwrap();\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","commands","sync","mod.rs"],"content":"use anyhow::Result;\nuse clap::Args;\nuse futures::prelude::*;\nuse taos::query::Dsn;\nuse taosx::plugins::sink::taos::TaosSinkBuilder;\nuse taosx::plugins::source::taos::TaosSourceBuilder;\nuse taosx::stream::source::XSourceBuilder;\nuse taosx::stream::stream::XSinkBuilder;\n\nuse taosx::stream::transformer::Action;\nuse taosx::TaosOpts;\n\n#[derive(Debug, Args)]\n/// Import external files to TDengine.\npub(crate) struct App {\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for source TDengine: taos:///db1, for eg.\n    from: Dsn,\n    #[clap(short, long)]\n    /// A DSN(database source name) format string for target TDengine: taos:///db2, for eg.\n    to: Dsn,\n\n    /// Transformer actions.\n    ///\n    /// Supported action format:\n    ///\n    /// - 'add-tag:tag1=value1': add a tag named `tag1`, and valued `value1`.\n    /// - 'select:subset:a,b,c': select three columns: `a`, `b`, `c`\n    /// - 'select:exclude:a,b,c': select all columns except the three: `a`, `b`, `c`\n    /// - 'rename-table:prefix:v1_': rename all tables as `v1_{{ name }}`\n    /// - 'rename-super-table:suffix:_stb': rename all super tables as suffixed '_stb'\n    /// - 'rename-child-stable:template:prefix_{{ name }}_stb': rename all super tables with prefix 'prefix_' and suffix '_stb'\n    #[clap(short = 'T', long)]\n    transform: Vec\u003cAction\u003e,\n    /// Number of workers for TMQ consumers.\n    #[clap(short = 'j', long)]\n    workers: Option\u003cusize\u003e,\n}\n\nimpl App {\n    pub async fn run_with_taos_opts(self, _opts: \u0026TaosOpts) -\u003e Result\u003c()\u003e {\n        log::debug!(\"app: {self:?}\");\n\n        let mut source_builder = TaosSourceBuilder::from_dsn(self.from)?;\n        let max_workers = source_builder.max_workers();\n\n        let sink_builder = TaosSinkBuilder::from_dsn(self.to)?.with_transformer(self.transform);\n\n        let mut workers = self.workers.unwrap_or(max_workers);\n        if max_workers != 0 \u0026\u0026 workers \u003e max_workers {\n            log::warn!(\"maximum workers for the stream is {max_workers} while you want {workers}, reduce to limit\");\n            workers = max_workers;\n        }\n        if workers == 0 {\n            workers = 1;\n        }\n        let mut handlers = Vec::new();\n        log::info!(\"use {workers} workers (max: {max_workers})\");\n\n        for _ in 0..workers {\n            let source = source_builder.build_source()?;\n            let sink = sink_builder.build_sink()?;\n            handlers.push(tokio::spawn(async move { source.forward(sink).await }));\n        }\n\n        for hd in handlers {\n            hd.await??;\n        }\n\n        let summary = sink_builder.summary();\n\n        log::info!(\n            \"Summary: total synced {} blocks with {} rows\",\n            summary.blocks(),\n            summary.rows()\n        );\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","bin","taosx","main.rs"],"content":"mod commands;\nuse clap::{Parser, Subcommand};\nuse log::Level;\nuse pretty_env_logger::env_logger::fmt::Color;\nuse std::io::prelude::*;\nuse taosx::TaosOpts;\n\n#[derive(Parser, Debug)]\n#[clap(author, version, about)]\nstruct Cli {\n    #[clap(flatten)]\n    options: TaosOpts,\n    #[clap(short, long)]\n    log_level: Option\u003clog::LevelFilter\u003e,\n    #[clap(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    Export(commands::export::App),\n    Import(commands::import::App),\n    Backup(commands::backup::App),\n    Restore(commands::restore::App),\n    Sync(commands::sync::App),\n    #[clap(external_subcommand)]\n    External(Vec\u003cString\u003e),\n}\n\npub fn cli\u003c'help\u003e() -\u003e clap::Command\u003c'help\u003e {\n    clap::Command::new(\"taosx\")\n}\n\n#[tokio::main(flavor = \"multi_thread\", worker_threads = 10)]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    let cli = Cli::parse();\n\n    let mut builder = pretty_env_logger::formatted_timed_builder();\n    if let Some(level) = cli.log_level {\n        builder.filter_level(level);\n    } else if let Ok(s) = ::std::env::var(\"RUST_LOG\") {\n        builder.parse_filters(\u0026s);\n    } else {\n        builder.filter_level(log::LevelFilter::Info);\n    }\n    builder\n        .format_module_path(true)\n        .format(|buf, record| -\u003e std::result::Result\u003c(), std::io::Error\u003e {\n            fn colored_level\u003c'a\u003e(\n                style: \u0026'a mut pretty_env_logger::env_logger::fmt::Style,\n                level: Level,\n            ) -\u003e pretty_env_logger::env_logger::fmt::StyledValue\u003c'a, \u0026'static str\u003e {\n                match level {\n                    Level::Trace =\u003e style.set_color(Color::Magenta).value(\"TRACE\"),\n                    Level::Debug =\u003e style.set_color(Color::Blue).value(\"DEBUG\"),\n                    Level::Info =\u003e style.set_color(Color::Green).value(\"INFO\"),\n                    Level::Warn =\u003e style.set_color(Color::Yellow).value(\"WARN \"),\n                    Level::Error =\u003e style.set_color(Color::Red).value(\"ERROR\"),\n                }\n            }\n            let mut style = buf.style();\n            let level = colored_level(\u0026mut style, record.level());\n            let mut mod_path = buf.style();\n\n            let mod_path = mod_path.set_bold(true).value(format!(\n                \"{}:{}\",\n                record.file().unwrap_or(\"unknown\"),\n                record.line().unwrap_or(0),\n            ));\n            writeln!(\n                buf,\n                \"[{:29} {: \u003c5}] {} \u003e {}\",\n                chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                level,\n                mod_path,\n                record.args()\n            )\n        })\n        // .is_test(true)\n        .init();\n    let command = cli.command;\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match command {\n        Commands::Export(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Import(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Backup(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Restore(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options);\n        }\n        Commands::Sync(app) =\u003e {\n            app.run_with_taos_opts(\u0026cli.options).await?;\n        }\n\n        Commands::External(args) =\u003e {\n            let (name, args) = args.split_first().unwrap();\n            println!(\"Call external plugin taosx-{name}: {args:?}\");\n            let cmd = format!(\"taosx-{name}\");\n            std::process::Command::new(\u0026cmd)\n                .args(args)\n                .spawn()\n                .expect(\u0026format!(\"unable to run command {cmd}\"));\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","config","mod.rs"],"content":"use anyhow::Result;\nuse linked_hash_map::LinkedHashMap as HashMap;\nuse mdsn::Dsn;\nuse serde::{Deserialize, Serialize};\n\npub struct XSource {\n    plugin: String,\n    dsn: Dsn,\n    options: HashMap\u003cString, String\u003e,\n}\n\npub struct XTransformer {\n    pub name: String,\n    pub options: HashMap\u003cString, String\u003e,\n}\n\npub struct XSink {\n    dsn: Dsn,\n    options: HashMap\u003cString, String\u003e,\n}\npub struct XStream {\n    pub from: Vec\u003cXSource\u003e,\n    pub transformer: Vec\u003cXTransformer\u003e,\n    pub to: Vec\u003cXSink\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use anyhow::Result;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","lib.rs"],"content":"use bitvec_simd::BitVec;\nuse chrono_tz::Tz;\nuse clap::Args;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse taos::prelude::*;\nuse taos::{block::*, helpers::ColumnMeta};\n\nuse url::Url;\n\npub mod config;\npub mod metrics;\npub mod plugins;\npub mod stream;\npub mod task;\npub mod util;\n\n#[derive(Debug, Args)]\npub struct TaosUri {\n    pub uri: Url,\n}\n#[derive(Debug, Args)]\npub struct TaosOpts {\n    /// TDengine host\n    #[clap(short, long, env = \"TAOS_HOST\", group = \"taos-opts\")]\n    pub host: Option\u003cString\u003e,\n    /// TDengine port\n    #[clap(short, long, env = \"TAOS_PORT\", group = \"taos-opts\")]\n    pub port: Option\u003cu16\u003e,\n    /// TDengine username\n    #[clap(short, long, env = \"TAOS_USERNAME\", group = \"taos-opts\")]\n    pub username: Option\u003cString\u003e,\n    /// TDengine password for the user\n    #[clap(short = 'P', long, env = \"TAOS_PASSWORD\", group = \"taos-opts\")]\n    pub password: Option\u003cString\u003e,\n    /// Choose database for the connection\n    #[clap(short, long, env = \"TAOS_DATABASE\", group = \"taos-opts\")]\n    pub database: Option\u003cString\u003e,\n    #[clap(short, long, env = \"TZ\")]\n    /// Timezone, example: Asia/Shanghai\n    pub timezone: Option\u003cTz\u003e,\n    #[clap(short, long, env = \"TAOS_CFG_DIR\")]\n    /// TDengine config directory\n    pub cfg_dir: Option\u003cPathBuf\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Database {\n    pub name: String,\n    pub replica: i16,\n    pub quorum: i16,\n    pub days: i16,\n    pub keep: Option\u003cString\u003e,\n    // pub cache: i32,\n    pub blocks: i32,\n    pub minrows: i32,\n    pub maxrows: i32,\n    pub wallevel: i8,\n    pub fsync: i32,\n    pub comp: i8,\n    pub cachelast: i8,\n    pub precision: String,\n    pub update: i8,\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct TaosDescribe {\n    pub name: String,\n    pub describe: Describe,\n}\n\npub type TaosColumnMeta = ColumnMeta;\nimpl TaosDescribe {\n    pub fn new(name: String, describe: Describe) -\u003e Self {\n        Self { name, describe }\n    }\n}\n\n// #[derive(Debug, Deserialize, Serialize, Clone)]\n// pub enum TaosColumnMeta {\n//     Column(TaosDescribed),\n//     Tag(TaosDescribed),\n// }\n\n// #[derive(Debug, Deserialize, Serialize, Clone)]\n// pub struct TaosDescribed {\n//     pub field: String,\n//     pub r#type: TaosDataType,\n//     pub length: usize,\n// }\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct TaosTag {\n    pub name: String,\n    pub tags: Vec\u003cVec\u003cValue\u003e\u003e,\n}\n\nimpl TaosTag {\n    pub fn new\u003c'b, T: BlockExt\u003e(name: String, iter: taos::query::RowsIter\u003c'b, T\u003e) -\u003e Self {\n        let mut values = vec![];\n        for row in iter {\n            let mut tmp = vec![];\n            for bv in row {\n                tmp.push(bv.1.into_value());\n            }\n            values.push(tmp);\n        }\n        Self { name, tags: values }\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct TaosBlock {\n    pub name: String,\n    pub data: Vec\u003cTaosColumn\u003e,\n}\n\nimpl TaosBlock {\n    pub fn new\u003c'b\u003e(name: String, iter: impl Iterator\u003cItem = BorrowedColumn\u003c'b\u003e\u003e) -\u003e Self {\n        let mut data = vec![];\n        for col in iter {\n            data.push(TaosColumn::new(col.into_owned()));\n        }\n        Self { name, data }\n    }\n\n    pub fn to_column_vec(\u0026self) -\u003e Vec\u003cColumn\u003e {\n        self.data.to_vec().iter().map(|v| v.to_column()).collect()\n    }\n\n    // pub fn to_multi_bind(\u0026self) -\u003e Vec\u003cMultiBind\u003e {\n    //     self.data\n    //         .to_vec()\n    //         .iter()\n    //         .map(|v| v.to_column().to_multi_bind())\n    //         .collect()\n    // }\n}\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\n\npub enum TaosColumn {\n    Null(usize),\n    Bool(Vec\u003cbool\u003e, Vec\u003cbool\u003e),  // 1\n    TinyInt(Vec\u003cbool\u003e, Vec\u003ci8\u003e), // 2\n    SmallInt(Vec\u003cbool\u003e, Vec\u003ci16\u003e),\n    Int(Vec\u003cbool\u003e, Vec\u003ci32\u003e),\n    BigInt(Vec\u003cbool\u003e, Vec\u003ci64\u003e),\n    Float(Vec\u003cbool\u003e, Vec\u003cf32\u003e),\n    Double(Vec\u003cbool\u003e, Vec\u003cf64\u003e),\n    Binary(Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e),\n    Timestamp(Vec\u003cbool\u003e, Vec\u003ci64\u003e),\n    NChar(Vec\u003cOption\u003cString\u003e\u003e),\n    UTinyInt(Vec\u003cbool\u003e, Vec\u003cu8\u003e),\n    USmallInt(Vec\u003cbool\u003e, Vec\u003cu16\u003e),\n    UInt(Vec\u003cbool\u003e, Vec\u003cu32\u003e),\n    UBigInt(Vec\u003cbool\u003e, Vec\u003cu64\u003e), // 14\n    Json(Vec\u003cbool\u003e, Vec\u003cu8\u003e),\n    VarChar(Vec\u003cbool\u003e, Vec\u003cVec\u003cu8\u003e\u003e),\n    VarBinary(Vec\u003cbool\u003e, Vec\u003cVec\u003cu8\u003e\u003e),\n    Decimal(Vec\u003cbool\u003e, Vec\u003cf64\u003e),\n    Blob(Vec\u003cbool\u003e, Vec\u003cVec\u003cu8\u003e\u003e),\n}\n\nimpl TaosColumn {\n    pub fn new(column: Column) -\u003e Self {\n        match column {\n            Column::Null(v) =\u003e Self::Null(v),\n            Column::Bool(is_nulls, v) =\u003e Self::Bool(is_nulls.into_bools(), v),\n            Column::TinyInt(is_nulls, v) =\u003e Self::TinyInt(is_nulls.into_bools(), v),\n            Column::SmallInt(is_nulls, v) =\u003e Self::SmallInt(is_nulls.into_bools(), v),\n            Column::Int(is_nulls, v) =\u003e Self::Int(is_nulls.into_bools(), v),\n            Column::BigInt(is_nulls, v) =\u003e Self::BigInt(is_nulls.into_bools(), v),\n            Column::Float(is_nulls, v) =\u003e Self::Float(is_nulls.into_bools(), v),\n            Column::Double(is_nulls, v) =\u003e Self::Double(is_nulls.into_bools(), v),\n            Column::Binary(v) =\u003e Self::Binary(v),\n            Column::Timestamp(is_nulls, v) =\u003e Self::Timestamp(is_nulls.into_bools(), v),\n            Column::NChar(v) =\u003e Self::NChar(v),\n            Column::UTinyInt(is_nulls, v) =\u003e Self::UTinyInt(is_nulls.into_bools(), v),\n            Column::USmallInt(is_nulls, v) =\u003e Self::USmallInt(is_nulls.into_bools(), v),\n            Column::UInt(is_nulls, v) =\u003e Self::UInt(is_nulls.into_bools(), v),\n            Column::UBigInt(is_nulls, v) =\u003e Self::UBigInt(is_nulls.into_bools(), v),\n            Column::Json(is_nulls, v) =\u003e Self::Json(is_nulls.into_bools(), v),\n            Column::VarChar(is_nulls, v) =\u003e Self::VarChar(is_nulls.into_bools(), v),\n            Column::VarBinary(is_nulls, v) =\u003e Self::VarBinary(is_nulls.into_bools(), v),\n            Column::Decimal(is_nulls, v) =\u003e Self::Decimal(is_nulls.into_bools(), v),\n            Column::Blob(is_nulls, v) =\u003e Self::Blob(is_nulls.into_bools(), v),\n        }\n    }\n\n    pub fn to_multi_bind(\u0026self) -\u003e Column {\n        match self {\n            TaosColumn::Null(v) =\u003e Column::Null(v.to_owned()),\n            TaosColumn::Bool(is_nulls, v) =\u003e Column::Bool(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::TinyInt(is_nulls, v) =\u003e Column::TinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::SmallInt(is_nulls, v) =\u003e Column::SmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Int(is_nulls, v) =\u003e Column::Int(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::BigInt(is_nulls, v) =\u003e Column::BigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Float(is_nulls, v) =\u003e Column::Float(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Double(is_nulls, v) =\u003e Column::Double(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Binary(v) =\u003e Column::Binary(v.to_owned()),\n            TaosColumn::Timestamp(is_nulls, v) =\u003e Column::Timestamp(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::NChar(v) =\u003e Column::NChar(v.to_owned()),\n            TaosColumn::UTinyInt(is_nulls, v) =\u003e Column::UTinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::USmallInt(is_nulls, v) =\u003e Column::USmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UInt(is_nulls, v) =\u003e Column::UInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UBigInt(is_nulls, v) =\u003e Column::UBigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Json(is_nulls, v) =\u003e Column::Json(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarChar(is_nulls, v) =\u003e Column::VarChar(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarBinary(is_nulls, v) =\u003e Column::VarBinary(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Decimal(is_nulls, v) =\u003e Column::Decimal(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Blob(is_nulls, v) =\u003e Column::Blob(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n        }\n    }\n\n    pub fn to_column(\u0026self) -\u003e Column {\n        match self {\n            TaosColumn::Null(v) =\u003e Column::Null(v.to_owned()),\n            TaosColumn::Bool(is_nulls, v) =\u003e Column::Bool(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::TinyInt(is_nulls, v) =\u003e Column::TinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::SmallInt(is_nulls, v) =\u003e Column::SmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Int(is_nulls, v) =\u003e Column::Int(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::BigInt(is_nulls, v) =\u003e Column::BigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Float(is_nulls, v) =\u003e Column::Float(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Double(is_nulls, v) =\u003e Column::Double(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Binary(v) =\u003e Column::Binary(v.to_owned()),\n            TaosColumn::Timestamp(is_nulls, v) =\u003e Column::Timestamp(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::NChar(v) =\u003e Column::NChar(v.to_owned()),\n            TaosColumn::UTinyInt(is_nulls, v) =\u003e Column::UTinyInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::USmallInt(is_nulls, v) =\u003e Column::USmallInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UInt(is_nulls, v) =\u003e Column::UInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::UBigInt(is_nulls, v) =\u003e Column::UBigInt(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Json(is_nulls, v) =\u003e Column::Json(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarChar(is_nulls, v) =\u003e Column::VarChar(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::VarBinary(is_nulls, v) =\u003e Column::VarBinary(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Decimal(is_nulls, v) =\u003e Column::Decimal(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n            TaosColumn::Blob(is_nulls, v) =\u003e Column::Blob(\n                BitVec::from_bool_iterator(is_nulls.iter().copied()),\n                v.to_owned(),\n            ),\n        }\n    }\n}\n","traces":[{"line":72,"address":[4323058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4323144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4738550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4739056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4738930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[4739069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[5032539,5031568],"length":1,"stats":{"Line":0},"fn_name":"deunicode_with_tofu_cow"},{"line":87,"address":[5035809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5032576,5032589,5031713],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":89,"address":[4739136],"length":1,"stats":{"Line":0},"fn_name":"into_owned"},{"line":98,"address":[4592352,4592606,4592472,4592496,4592185,4592278,4592144,4592233],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":99,"address":[5035856],"length":1,"stats":{"Line":0},"fn_name":"try_init_timed"},{"line":100,"address":[5032137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5035883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4739184],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":103,"address":[4592560,4592372,4592538,4592158,4592416,4592223,4592394,4592516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5032308,5032251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4739233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4742664,4742616,4742592],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":119,"address":[10784511,10784413,10784254,10784558,10784478,10784211,10784349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4742654,4742611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4592931,4592976,4593022,4592892,4592668,4592707,4593115,4593229,4592752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8564064],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":127,"address":[5032738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[5036030,5036090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4739831,4740605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4739941,4739995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4740063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[4740070,4740101,4740152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[4740074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4582503,4579904,4582538],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":165,"address":[4396050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[4396091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[10780386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5037249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4581124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5266816],"length":1,"stats":{"Line":0},"fn_name":"is_synchronous\u003cstd::io::util::Sink\u003e"},{"line":171,"address":[4450784],"length":1,"stats":{"Line":0},"fn_name":"nfd\u003cunicode_normalization::stream_safe::StreamSafe\u003ccore::str::iter::Chars\u003e\u003e"},{"line":172,"address":[4450795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4450845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4581149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[10780611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[4457712],"length":1,"stats":{"Line":0},"fn_name":"nfkd\u003ccore::str::iter::Chars\u003e"},{"line":177,"address":[4457733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4457743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[4146004,4146229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4146024,4146235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4450864],"length":1,"stats":{"Line":0},"fn_name":"nfc\u003cunicode_normalization::stream_safe::StreamSafe\u003ccore::str::iter::Chars\u003e\u003e"},{"line":182,"address":[4146064,4146247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[4457791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[4146317,4146104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4146374,4146124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[4457808],"length":1,"stats":{"Line":0},"fn_name":"nfkc\u003ccore::str::iter::Chars\u003e"},{"line":187,"address":[4457829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4146656,4146673],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":192,"address":[4717797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4717800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4581786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[4457856],"length":1,"stats":{"Line":0},"fn_name":"stream_safe\u003ccore::str::iter::Chars\u003e"},{"line":199,"address":[5033512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[4083632],"length":1,"stats":{"Line":0},"fn_name":"base_url"},{"line":203,"address":[4083667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[11894392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[4083680],"length":1,"stats":{"Line":0},"fn_name":"encoding_override"},{"line":208,"address":[4083701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[5033664,5033585],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":212,"address":[4581918,4580481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[4582017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5034037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[4944884,4944756,4945012,4945780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[5034400,5034464,5034366],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":222,"address":[4582368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4582296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4582336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[4582553,4582423,4582522,4580145,4580085,4580260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5033647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[5034649,5034556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4083728],"length":1,"stats":{"Line":0},"fn_name":"syntax_violation_callback"},{"line":237,"address":[4083771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[5034712,5034851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4083907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4083840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4083899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[10781255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4083991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5039715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5039972,5039817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[5039787,5040002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5039924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[12448734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[7686436,7686370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[4582576,4584706,4584601],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":267,"address":[4582659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[4813472,4813461,4813456,4813758,4813491,4813744],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":269,"address":[4582806,4582870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[11013056,11012992,11013038,11013008,11012981,11012976,11013086,11012997],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":272,"address":[4582962,4583386,4583054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[4084000],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":276,"address":[4084033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[4584013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5070190,5070255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[10781440],"length":1,"stats":{"Line":1},"fn_name":"ensure"},{"line":284,"address":[5070425,5070518,5070473,5070384],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":287,"address":[5070508,5070411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[4584485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[4584523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[4945811,4945555,4945427,4946067,4945043,4945939,4945171,4945299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[4584569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[13990765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[12456738,12456840,12456585,12455040,12456032,12455986,12456021,12456432,12456483,12454033,12454016,12456789,12456381,12456273,12456016,12456636,12456687,12456330,12454064,12455010,12456534],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":301,"address":[4583165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[4583245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[4582997,4584721,4582821,4583364,4582924,4584620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[11010800],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":310,"address":[4584752,4584877],"length":1,"stats":{"Line":0},"fn_name":"reordered_levels"},{"line":313,"address":[4584840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[4957233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[8565383,8565646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[4585106,4584912],"length":1,"stats":{"Line":0},"fn_name":"reordered_levels_per_char"},{"line":321,"address":[8565792,8565337,8565822,8565706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5149977,5150103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[4585137,4585093,4584998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[4953969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[4585216,4586672,4586515],"length":1,"stats":{"Line":1},"fn_name":"reorder_line"},{"line":333,"address":[5150238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[4585451,4586688,4586702,4585543],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":337,"address":[5150302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[4585659,4585888],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":128},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","metrics","mod.rs"],"content":"use metrics::{counter, describe_gauge, gauge, histogram, register_gauge, register_histogram};\nuse metrics_exporter_prometheus::PrometheusBuilder;\nuse std::{\n    collections::HashSet,\n    net::SocketAddr,\n    time::{Duration, Instant},\n};\n\n#[derive(Debug, Default)]\npub struct Metrics {\n    listen: Option\u003cSocketAddr\u003e,\n    push: Option\u003cString\u003e,\n    push_interval: Option\u003cDuration\u003e,\n    interval: Option\u003cu16\u003e,\n}\n\npub fn process_metrics_init() {\n    register_gauge!(\"taosx_process_cpu_percent\");\n\n    describe_gauge!(\"taosx_process_cpu_percent\", \"CPU percent of the process\");\n}\n\npub fn process_metrics() -\u003e anyhow::Result\u003c()\u003e {\n    let ps = procfs::process::Process::myself()?;\n    let stat = \u0026ps.stat;\n    let ticks = procfs::ticks_per_second()?;\n    let mut proc = psutil::process::Process::current()?;\n\n    let cpu = proc.cpu_percent()?;\n    gauge!(\"taosx_process_cpu_percent\", cpu as f64);\n\n    let mem = proc.memory_percent()?;\n    gauge!(\n        \"taosx_process_mem_percent\",\n        (mem * 10000.0) as u64 as f64 / 100.0\n    );\n\n    let threads = ps.tasks()?.count();\n    gauge!(\"taosx_process_threads\", threads as f64);\n\n    let open_files = proc.open_files()?.len();\n    gauge!(\"taosx_process_open_files\", open_files as f64);\n\n    let uptime = (ps.stat.utime + ps.stat.stime) as f64 / ticks as f64;\n    gauge!(\"taosx_process_uptime\", uptime as f64);\n\n    let io = ps.io()?;\n    gauge!(\"taosx_process_io_read_bytes\", io.read_bytes as f64);\n    gauge!(\"taosx_process_io_write_bytes\", io.write_bytes as f64);\n\n    let fd = ps.fd()?;\n    let mut inodes = HashSet::new();\n    for fd in fd {\n        use procfs::process::FDTarget;\n        match fd.target {\n            FDTarget::Net(inode) =\u003e {\n                inodes.insert(inode);\n            }\n            FDTarget::Socket(inode) =\u003e {\n                inodes.insert(inode);\n            }\n            _ =\u003e {}\n        }\n    }\n\n    let (mut rx, mut tx) = (0, 0);\n\n    let tcp = procfs::net::tcp().unwrap();\n    let tcp6 = procfs::net::tcp6().unwrap();\n    for entry in tcp.into_iter().chain(tcp6) {\n        // find the process (if any) that has an open FD to this entry's inode\n        let local_address = format!(\"{}\", entry.local_address);\n        let remote_addr = format!(\"{}\", entry.remote_address);\n        let state = format!(\"{:?}\", entry.state);\n        if inodes.contains(\u0026entry.inode) {\n            log::debug!(\n                \"{:\u003c26} {:\u003c26} {:\u003c15} {:\u003c12} {}/{} {}/{}\",\n                local_address,\n                remote_addr,\n                state,\n                entry.inode,\n                stat.pid,\n                stat.comm,\n                entry.rx_queue,\n                entry.tx_queue\n            );\n            rx += entry.rx_queue;\n            tx += entry.tx_queue;\n        }\n    }\n\n    gauge!(\"taosx_process_net_rx\", rx as f64);\n    gauge!(\"taosx_process_net_tx\", tx as f64);\n    Ok(())\n}\n\nimpl Metrics {\n    pub fn init(self) -\u003e anyhow::Result\u003c()\u003e {\n        let mut exporter = PrometheusBuilder::new();\n        let interval = self.interval();\n        let dur = Duration::from_secs(interval as u64);\n\n        if let Some(listen) = self.listen {\n            exporter = exporter.with_http_listener(listen);\n        }\n        if let Some(push) = self.push {\n            let interval = self.push_interval.unwrap_or(Duration::from_secs(30));\n            exporter = exporter.with_push_gateway(push, interval)?;\n        }\n        let _ = exporter.install()?;\n        process_metrics_init();\n        std::thread::spawn(move || loop {\n            let _ = process_metrics();\n            metrics::increment_counter!(\"up seconds\");\n            std::thread::sleep(dur);\n        });\n        Ok(())\n    }\n\n    pub fn interval(\u0026self) -\u003e u16 {\n        self.interval.unwrap_or(1)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","mod.rs"],"content":"mod sync;\n\npub mod sink;\npub mod source;\npub mod transformer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sink","mod.rs"],"content":"pub mod taos;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sink","taos","mod.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::IntoDsn;\nuse std::{\n    cell::Cell,\n    fmt::Debug,\n    sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc,\n    },\n    task::Poll,\n};\n\nuse futures::{Sink, Stream, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, Describe, Ty},\n    helpers::{ColumnMeta, Described},\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{\n    stream::{\n        stream::*,\n        transformer::{Action, AddTag, AddTagOpts, Select},\n    },\n    util::sync_table,\n};\nuse taos::prelude::sync::*;\n\npub struct TaosSinkBuilder {\n    dsn: Dsn,\n    builder: Manager,\n    worker: AtomicUsize,\n    transformer: Arc\u003cOption\u003cVec\u003cAction\u003e\u003e\u003e,\n    metrics: Arc\u003cSummary\u003e,\n}\n\n#[derive(Debug)]\npub struct TaosSink {\n    id: usize,\n    taos: Taos,\n    transformer: Arc\u003cOption\u003cVec\u003cAction\u003e\u003e\u003e,\n    metrics: Arc\u003cSummary\u003e,\n}\n\nimpl XSinkBuilder for TaosSinkBuilder {\n    type Error = Error;\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut dsn = dsn.into_dsn()?;\n        if let Some(db) = dsn.database.take() {\n            let taos = Taos::from_dsn(\u0026dsn)?;\n            let db_info: Option\u003cString\u003e = taos.query_one(format!(\n                \"select * from information_schema.user_databases where name = \\\"{db}\\\"\"\n            ))?;\n            if db_info.is_none() {\n                log::warn!(\"create database {db} with default parameters since it's not exist\");\n                taos.exec(format!(\"create database if not exists {db}\"))?;\n            } else {\n                taos.exec(format!(\"create topic if not exists {db} as database {db}\"))?;\n                dsn.params.insert(\"topics\".to_string(), db.to_string());\n            }\n            dsn.database = Some(db);\n        } else {\n            return Err(Error::InvalidDatabase(\n                \"taos sink plugin requires a database name\".to_string(),\n            ));\n        }\n\n        let builder = Manager::from_dsn(\u0026dsn)?;\n        Ok(Self {\n            dsn,\n            builder,\n            transformer: Arc::new(None),\n            worker: AtomicUsize::new(0),\n            metrics: Default::default(),\n        })\n    }\n\n    fn with_transformer(mut self, transformer: Vec\u003cAction\u003e) -\u003e Self {\n        self.transformer = Arc::new(Some(transformer));\n        self\n    }\n\n    fn build_sink(\u0026self) -\u003e Result\u003cXSink\u003cSelf::Error\u003e, Self::Error\u003e {\n        let id = self\n            .worker\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n        Ok(TaosSink {\n            id,\n            taos: self.builder.connect()?,\n            transformer: self.transformer.clone(),\n            metrics: self.metrics.clone(),\n        }\n        .into())\n    }\n\n    fn summary(\u0026self) -\u003e \u0026Summary {\n        \u0026self.metrics\n    }\n}\n\npub fn sync_table_with_transformer(\n    from: \u0026Taos,\n    to: \u0026Taos,\n    db: \u0026str,\n    table: \u0026str,\n    transformer: \u0026[Action],\n) -\u003e Result\u003c(), Error\u003e {\n    use taos::prelude::sync::*;\n    assert!(transformer.len() \u003e 0);\n\n    let stable: Option\u003cString\u003e = from\n        .query_one(format!(\n            \"select stable_name from information_schema.user_tables where db_name = '{db}' and table_name = \\\"{table}\\\"\"\n        ))?\n        .unwrap();\n\n    if let Some(stable) = stable {\n        let desc = from.describe(\u0026format!(\"{db}.`{stable}`\"))?;\n        let mut stable2 = stable.to_string();\n\n        let transformed_desc =\n            transformer\n                .iter()\n                .fold(desc.clone(), |mut desc, action| match action {\n                    Action::AddTag(add_tag) =\u003e {\n                        desc.push(ColumnMeta::Tag(Described {\n                            field: add_tag.name.clone(),\n                            ty: Ty::VarChar,\n                            length: add_tag.len,\n                        }));\n                        desc\n                    }\n                    Action::Select(select) =\u003e match select {\n                        Select::Subset { subset } =\u003e desc\n                            .into_iter()\n                            .filter(|f| subset.contains(\u0026f.field))\n                            .collect(),\n                        Select::Rename { rename } =\u003e desc\n                            .into_iter()\n                            .map(|mut f| {\n                                if let Some(v) = rename.get(f.field()) {\n                                    f.field = v.to_string();\n                                    f\n                                } else {\n                                    f\n                                }\n                            })\n                            .collect(),\n                        Select::Exclude { exclude } =\u003e desc\n                            .into_iter()\n                            .filter(|f| !exclude.contains(\u0026f.field))\n                            .collect(),\n                    },\n                    Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e {\n                        match rename {\n                            crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n                                stable2 = format!(\"{prefix}{stable}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n                                stable2 = format!(\"{stable}{suffix}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n                                stable2 = template.replace(\"{{ name }}\", \u0026stable);\n                            }\n                        }\n                        desc\n                    }\n                    _ =\u003e desc,\n                });\n\n        log::trace!(\"create {stable2}\");\n        let sql = transformed_desc.to_create_table_sql(\u0026stable2);\n        to.exec(sql)?;\n\n        let names = transformer.iter().fold(\n            desc.tag_names().map(ToString::to_string).collect_vec(),\n            |names, action| match action {\n                Action::Select(select) =\u003e match select {\n                    Select::Subset { subset } =\u003e names\n                        .into_iter()\n                        .filter(|name| subset.contains(name))\n                        .collect_vec(),\n                    Select::Rename { rename } =\u003e names\n                        .into_iter()\n                        .map(|f| {\n                            if let Some(v) = rename.get(\u0026f) {\n                                format!(\"`{f}` as `{v}`\")\n                            } else {\n                                f\n                            }\n                        })\n                        .collect_vec(),\n                    Select::Exclude { exclude } =\u003e names\n                        .into_iter()\n                        .filter(|name| !exclude.contains(name))\n                        .collect_vec(),\n                },\n                _ =\u003e names,\n            },\n        );\n\n        let names = names.join(\",\");\n        let children: Vec\u003cVec\u003cValue\u003e\u003e = from\n            .query(format!(\"select tbname,{names} from {stable}\"))?\n            .deserialize()\n            .try_collect()?;\n\n        let children = transformer\n            .iter()\n            .fold(children, |children, action| match action {\n                Action::AddTag(add_tag) =\u003e match \u0026add_tag.opts {\n                    AddTagOpts::Value { value } =\u003e children\n                        .into_iter()\n                        .map(|mut v| {\n                            v.push(Value::VarChar(value.clone()));\n                            v\n                        })\n                        .collect_vec(),\n                    AddTagOpts::Template { template: _ } =\u003e todo!(),\n                },\n                Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e match rename {\n                    crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(format!(\"{prefix}{name}\"));\n                            child\n                        })\n                        .collect_vec(),\n                    crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(format!(\"{name}{suffix}\"));\n                            child\n                        })\n                        .collect_vec(),\n                    crate::stream::transformer::RenameOpts::Template { template } =\u003e children\n                        .into_iter()\n                        .map(|mut child| {\n                            let name = child[0].strict_as_str();\n                            child[0] = Value::VarChar(template.replace(\"{{ name }}\", name));\n                            child\n                        })\n                        .collect_vec(),\n                },\n                _ =\u003e children,\n            });\n\n        // todo: use par_iter to speed up tables creation.\n        // todo: single table not work, blocked by https://jira.taosdata.com:18080/browse/TD-16117\n        for child in children {\n            let tbname = child[0].to_string().unwrap();\n            let tags_values = child[1..].into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {tbname} using {stable2} tags({tags_values})\"\n            ))\n            .unwrap();\n        }\n\n        // let fields: Vec\u003cValue\u003e = from\n        //     .query_one(format!(\n        //         \"select {names} from {stable} where tbname = '{table}'\"\n        //     ))?\n        //     .unwrap();\n\n        // let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n        // to.exec(format!(\n        //     \"create table if not exists {table} using {stable} tags({tags_values})\"\n        // ))?;\n    } else {\n        let mut table = table.to_string();\n        log::info!(\"describe table {table}\");\n        let desc = from.describe(\u0026format!(\"{db}.`{table}`\"))?;\n        log::info!(\"table {table}: {desc:?}\");\n\n        let desc = transformer\n            .iter()\n            .fold(desc.clone(), |desc, action| match action {\n                Action::Select(select) =\u003e match select {\n                    Select::Subset { subset } =\u003e desc\n                        .into_iter()\n                        .filter(|f| subset.contains(\u0026f.field))\n                        .collect(),\n                    Select::Rename { rename } =\u003e desc\n                        .into_iter()\n                        .map(|mut f| {\n                            if let Some(v) = rename.get(f.field()) {\n                                f.field = v.to_string();\n                                f\n                            } else {\n                                f\n                            }\n                        })\n                        .collect(),\n                    Select::Exclude { exclude } =\u003e desc\n                        .into_iter()\n                        .filter(|f| !exclude.contains(\u0026f.field))\n                        .collect(),\n                },\n                Action::RenameTable(rename) =\u003e {\n                    match rename {\n                        crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n                            table = format!(\"{prefix}{table}\");\n                        }\n                        crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n                            table = format!(\"{table}{suffix}\");\n                        }\n                        crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n                            table = template.replace(\"{{ name }}\", \u0026table);\n                        }\n                    }\n                    desc\n                }\n                _ =\u003e desc,\n            });\n        let sql = desc.to_create_table_sql(\u0026table);\n        log::info!(\"exec sql: {sql}\");\n        to.exec(sql).unwrap();\n    }\n    Ok(())\n}\n\nimpl Sink\u003c(\u0026Taos, SyncBlock)\u003e for TaosSink {\n    type Error = Error;\n\n    fn poll_ready(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        Poll::Ready(Ok(()))\n    }\n\n    fn start_send(\n        mut self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        item: (\u0026Taos, SyncBlock),\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.consume_block(item.0, \u0026item.1)\n    }\n\n    fn poll_flush(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        Poll::Ready(Ok(()))\n    }\n\n    fn poll_close(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        Poll::Ready(Ok(()))\n    }\n}\n\nimpl TaosxSink for TaosSink {\n    type Error = Error;\n\n    fn batch_size(\u0026self) -\u003e usize {\n        1\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn consume_block(\u0026mut self, taos: \u0026Taos, block: \u0026SyncBlock) -\u003e Result\u003c(), Self::Error\u003e {\n        let idx = self.id;\n        let db = block.tmq_db_name().unwrap();\n        taos.exec(format!(\"use {db}\"))?;\n        let table = block.tmq_table_name().unwrap();\n        log::debug!(\"[{idx}] db: {db}, table: {table}\");\n\n        if let Some(transformer) = self.transformer.as_ref() {\n            // if self.taos.exec(format!(\"describe {table}\")).is_err() {\n            //     sync_table_with_transformer(taos, \u0026self.taos, db, \u0026table, \u0026transformer)?;\n            // }\n            // let mut table = table.to_string();\n            // let fields = block.fields();\n\n            // let mut bind: Vec\u003cTaosMultiBind\u003e = Vec::new();\n\n            // for action in transformer {\n            //     match action {\n            //         Action::Select(Select::Subset { subset }) =\u003e {\n            //             bind = block\n            //                 .columns_iter()\n            //                 .zip(fields)\n            //                 .filter_map(|(col, field)| {\n            //                     if subset.contains(\u0026field.name().to_string()) {\n            //                         Some(col.into())\n            //                     } else {\n            //                         None\n            //                     }\n            //                 })\n            //                 .collect()\n            //         }\n            //         Action::Select(Select::Exclude { exclude }) =\u003e {\n            //             bind = block\n            //                 .columns_iter()\n            //                 .zip(fields)\n            //                 .filter_map(|(col, field)| {\n            //                     if !exclude.contains(\u0026field.name().to_string()) {\n            //                         Some(col.into())\n            //                     } else {\n            //                         None\n            //                     }\n            //                 })\n            //                 .collect()\n            //         }\n            //         Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e {\n            //             match rename {\n            //                 crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n            //                     table = format!(\"{prefix}{table}\");\n            //                 }\n            //                 crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n            //                     table = format!(\"{table}{suffix}\");\n            //                 }\n            //                 crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n            //                     table = template.replace(\"{{ name }}\", \u0026table);\n            //                 }\n            //             }\n            //         }\n            //         _ =\u003e (),\n            //     }\n            // }\n            // if bind.is_empty() {\n            //     bind = block.columns_iter().map(Into::into).collect();\n            // }\n\n            // let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n            // let mut stmt = self\n            //     .taos\n            //     .stmt(format!(\"insert into {table} values({questions})\"))?;\n            // stmt.multi_bind(\u0026bind)?;\n            // stmt.execute()?;\n            // let inserted = stmt.affected_rows();\n            // log::info!(\"[{idx}] inserted {inserted} rows into {table}\");\n            // return Ok(());\n            let mut table2 = table.to_string();\n            let fields = block.fields();\n\n            let mut bind: Vec\u003cTaosMultiBind\u003e = Vec::new();\n\n            for action in transformer {\n                match action {\n                    Action::Select(Select::Subset { subset }) =\u003e {\n                        bind = block\n                            .columns_iter()\n                            .zip(fields)\n                            .filter_map(|(col, field)| {\n                                if subset.contains(\u0026field.name().to_string()) {\n                                    Some(col.into())\n                                } else {\n                                    None\n                                }\n                            })\n                            .collect()\n                    }\n                    Action::Select(Select::Exclude { exclude }) =\u003e {\n                        bind = block\n                            .columns_iter()\n                            .zip(fields)\n                            .filter_map(|(col, field)| {\n                                if !exclude.contains(\u0026field.name().to_string()) {\n                                    Some(col.into())\n                                } else {\n                                    None\n                                }\n                            })\n                            .collect()\n                    }\n                    Action::RenameChildTable(rename) | Action::RenameTable(rename) =\u003e {\n                        match rename {\n                            crate::stream::transformer::RenameOpts::Prefix { prefix } =\u003e {\n                                table2 = format!(\"{prefix}{table}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Suffix { suffix } =\u003e {\n                                table2 = format!(\"{table}{suffix}\");\n                            }\n                            crate::stream::transformer::RenameOpts::Template { template } =\u003e {\n                                table2 = template.replace(\"{{ name }}\", \u0026table);\n                            }\n                        }\n                    }\n                    _ =\u003e (),\n                }\n            }\n            if bind.is_empty() {\n                bind = block.columns_iter().map(Into::into).collect();\n            }\n\n            if self.taos.exec(format!(\"describe {table2}\")).is_err() {\n                sync_table_with_transformer(taos, \u0026self.taos, db, \u0026table, \u0026transformer)?;\n            }\n            let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n            let mut stmt = self\n                .taos\n                .stmt(format!(\"insert into {table2} values({questions})\"))?;\n            stmt.multi_bind(\u0026bind)?;\n            stmt.execute()?;\n            let inserted = stmt.affected_rows();\n            self.metrics.blocks.fetch_add(1, Ordering::SeqCst);\n            self.metrics.rows.fetch_add(inserted, Ordering::SeqCst);\n            log::info!(\"[{idx}] inserted {inserted} rows into {table2}\");\n            return Ok(());\n        }\n\n        if self.taos.exec(format!(\"describe {table}\")).is_err() {\n            log::info!(\"[{idx}] synchronize table schema {table}\");\n            sync_table(taos, \u0026self.taos, \u0026db, \u0026table)?;\n            log::info!(\"[{idx}] synchronize table {table} done\");\n        }\n\n        let bind: Vec\u003cTaosMultiBind\u003e = block.columns_iter().map(|col| col.into()).collect();\n        let questions = std::iter::repeat(\"?\").take(bind.len()).join(\",\");\n        let mut stmt = self\n            .taos\n            .stmt(format!(\"insert into {table} values({questions})\"))?;\n        stmt.multi_bind(\u0026bind)?;\n        stmt.execute()?;\n        let inserted = stmt.affected_rows();\n        self.metrics.blocks.fetch_add(1, Ordering::SeqCst);\n        self.metrics.rows.fetch_add(inserted, Ordering::SeqCst);\n        log::info!(\"[{idx}] inserted {inserted} rows into {table}\");\n        Ok(())\n    }\n\n    fn consume_raw_block(\u0026mut self, _: \u0026[u8]) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_line(\n        \u0026mut self,\n        item: \u0026str,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Line, precision)?;\n        Ok(())\n    }\n\n    fn consume_schemaless_telnet(\n        \u0026mut self,\n        item: \u0026str,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Telnet, precision)?;\n        Ok(())\n    }\n\n    fn consume_schemaless_json(\n        \u0026mut self,\n        item: \u0026str,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        self.taos\n            .schemaless_insert([item], SchemalessProtocol::Json, precision)?;\n        Ok(())\n    }\n}\n\n#[taos::test(log_level = \"debug\", databases = 2)]\nasync fn test(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq = TmqBuilder::from_dsn(format!(\n        \"taos:///{db1}?topics={db1}\u0026group.id={db1}\u0026wait=1000\"\n    ))?\n    .build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n\n    let mut rs = taos2.query(\"select * from stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test_with_action_add_tag(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq =\n        TmqBuilder::from_dsn(format!(\"taos:///{db1}?topics={db1}\u0026group.id={db1}\"))?.build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .with_transformer(vec![Action::AddTag(AddTag {\n            name: \"f1\".to_string(),\n            len: 10,\n            opts: AddTagOpts::value(\"v1\"),\n        })])\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n    taos2.exec(\"reset query cache\")?;\n\n    let mut rs = taos2.query(\"select tbname, f1 from stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from tb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from tb2\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test_with_transformer(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c(), Error\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut tmq =\n        TmqBuilder::from_dsn(format!(\"taos:///{db1}?topics={db1}\u0026group.id={db1}\"))?.build()?;\n\n    let db2 = databases[1];\n\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?\n        .with_transformer(vec![\n            Action::AddTag(AddTag {\n                name: \"f1\".to_string(),\n                len: 10,\n                opts: AddTagOpts::value(\"v1\"),\n            }),\n            Action::Select(crate::stream::transformer::Select::exclude(vec![\n                \"c_bool\".to_string()\n            ])),\n            Action::RenameTable(crate::stream::transformer::RenameOpts::prefix(\"p_\")),\n        ])\n        .build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    while let Some(rs) = tmq.poll() {\n        let mut rs = rs?;\n        for block in rs.blocks_iter() {\n            log::info!(\"send block\");\n            sink.send((taos, block)).await?;\n        }\n    }\n    drop(tmq);\n\n    taos.exec(format!(\"drop topic {db1}\"))?;\n\n    let taos2 = Taos::from_dsn(format!(\"taos:///{db2}\"))?;\n\n    let mut rs = taos2.query(\"select * from p_stb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from p_tb1\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    let mut rs = taos2.query(\"select * from p_tb2\")?;\n    let values = rs.to_rows_vec();\n    dbg!(values);\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"debug\", precision = \"ns\")]\nasync fn sink_sml_line(taos: \u0026Taos) -\u003e Result\u003c(), Error\u003e {\n    let database = \"_rs_sml_\";\n    taos.exec(format!(\"drop database if exists {database}\"))?;\n    taos.exec(format!(\"create database {database} schemaless 1\"))?;\n    let lines = vec![\"st,t1=abc c1=3i64,c3=\\\"def\\\",c2=false 1626006833639000000\"];\n    let builder = TaosSinkBuilder::from_dsn(format!(\"taos:///{database}\"))?;\n    let mut sink = builder.build_sink_for_protocol(SinkProtocol::Block)?;\n\n    use futures::sink::SinkExt;\n\n    for line in lines {\n        sink.send(XLine::new_line(line)).await?;\n    }\n\n    let taos = builder.builder.connect()?;\n    let table = taos.describe(\"st\")?;\n    dbg!(table);\n\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Weather {\n        _ts: String,\n        c1: i64,\n        c2: bool,\n        c3: String,\n    }\n    let mut rs = taos.query(\"select * from st\")?;\n    for block in rs.blocks_iter() {\n        dbg!(block.deserialize_into_vec::\u003cWeather\u003e());\n    }\n    Ok(())\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","csv","mod.rs"],"content":"use taos::query::Dsn;\n\npub struct Csv {\n    dsn: Dsn,\n}\n\nimpl Csv {\n    fn from_dsn(dsn: impl Into\u003cDsn\u003e) -\u003e Result\u003cSelf, anyhow::Error\u003e {\n        let dsn = dsn.into();\n        Ok(Self { dsn })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","mod.rs"],"content":"pub mod csv;\npub mod taos;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","source","taos.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::{DsnError, IntoDsn};\nuse serde::Deserialize;\n\nuse std::{\n    any::Any,\n    borrow::Cow,\n    collections::{BTreeSet, HashMap},\n    ffi::c_void,\n    fmt::Debug,\n    marker::PhantomData,\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    sync::{Arc, Weak},\n    task::Poll, str::FromStr,\n};\n\nuse futures::{Sink, Stream, StreamExt, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, BlockStream, Field, Ty},\n    prelude::AsyncFetchable,\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{\n    plugins::sink::taos::TaosSinkBuilder,\n    stream::{source::XSourceBuilder, stream::XSinkBuilder, transformer::Action},\n    util::sync_table,\n};\n\nuse crate::stream::stream::{SinkProtocol, TaosxSinkItem};\n\npub use taos::prelude::sync::*;\n\n#[derive(Debug)]\npub enum TaosItem {\n    Block(Arc\u003cTaos\u003e, SyncBlock),\n}\n\nimpl\u003c'a\u003e TaosxSinkItem for TaosItem {\n    fn protocol(\u0026self) -\u003e SinkProtocol {\n        match self {\n            Self::Block(_, _) =\u003e SinkProtocol::Block,\n        }\n    }\n\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        match self {\n            Self::Block(taos, block) =\u003e (taos.as_ref(), \u0026block),\n        }\n    }\n\n    fn as_raw_block(\u0026self) -\u003e Option\u003cstd::borrow::Cow\u003c[u8]\u003e\u003e {\n        None\n    }\n\n    fn as_record(\u0026self) -\u003e Option\u003cstd::borrow::Cow\u003c[Value]\u003e\u003e {\n        None\n    }\n\n    fn precision(\u0026self) -\u003e SchemalessPrecision {\n        SchemalessPrecision::NonConfigured\n    }\n\n    fn as_schemaless_line(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_telnet(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_json(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    const PROTOCOL: SinkProtocol = SinkProtocol::__NoneExhaustive;\n}\n\npub struct TaosSourceBuilder {\n    from: Dsn,\n    manager: Manager,\n    tmq_builder: TmqBuilder,\n    max_workers: usize,\n    protocol: SinkProtocol,\n}\n\n#[derive(Debug)]\npub struct TaosSource {\n    taos: Arc\u003cTaos\u003e,\n    consumer: Consumer,\n    protocol: SinkProtocol,\n    rs: Option\u003cResultSet\u003e,\n    blocks: Option\u003cBlockStream\u003e,\n}\n\nimpl Drop for TaosSource {\n    fn drop(\u0026mut self) {\n        self.blocks.take();\n        self.rs.take();\n    }\n}\n\nuse taos::prelude::Error;\n\nimpl XSourceBuilder for TaosSourceBuilder {\n    type Error = Error;\n\n    type Item = TaosItem;\n    type XSource = TaosSource;\n\n    const NAME: \u0026'static str = \"taos\";\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut dsn = dsn.into_dsn()?;\n        if dsn.database.is_none() {\n            Err(DsnError::RequireDatabase(\n                \"please input a database or topic/stream name\".to_string(),\n            ))?;\n        }\n\n        let mut max_workers = 0;\n        let db = dsn.database.take().unwrap(); // unwrap is safe.\n\n        let taos = Taos::from_dsn(\u0026dsn)?;\n\n        let topics: HashMap\u003c_, _\u003e = taos\n            .topics()?\n            .into_iter()\n            .map(|topic| (topic.name().to_string(), topic))\n            .collect();\n\n        #[derive(Default, Deserialize)]\n        struct VGroups {\n            vgroups: usize,\n        }\n        // For `?topics=` options.\n        if let Some(opt) = dsn.params.get(\"topics\") {\n            let topic_names = opt.split(\",\").map(|s| s.to_string()).collect_vec();\n            if topic_names.is_empty() {\n                return Err(Error::InvalidTopic(\"topics is empty\".to_string()));\n            }\n            let mut db_name = None;\n            {\n                for topic_name in topic_names {\n                    if let Some(topic) = topics.get(\u0026topic_name) {\n                        let db = topic.db_name();\n                        let vgroups: VGroups = taos\n                            .query_one(format!(\n                            \"select * from information_schema.user_databases where name = '{db}'\"))?\n                            .unwrap_or_default();\n                        if max_workers \u003c vgroups.vgroups {\n                            max_workers = vgroups.vgroups;\n                        }\n                        if let Some(db1) = db_name.as_ref() {\n                            if db1 != topic.db_name() {\n                                // return Err(Error::InvalidTopic(\n                                //     \"topics should be in same database\".to_string(),\n                                // ));\n                                log::warn!(\"subscribe topics in different database\");\n                            }\n                        } else {\n                            db_name = Some(topic.db_name().to_string());\n                        }\n                    } else {\n                        return Err(Error::InvalidTopic(format!(\"topic {topic_name} not found\")));\n                    }\n                }\n            }\n            dsn.database = db_name;\n            // check group id\n            if !dsn.params.contains_key(\"group.id\") {\n                let opt = opt.to_string();\n                dsn.params.insert(\"group.id\".to_string(), opt);\n            }\n        } else {\n            // If no `topics` option in params, check if the database identity is topic(s) or not.\n            dsn.params.insert(\"topics\".to_string(), db.to_string());\n            for db in db.split(\",\") {\n                if let Some(topic) = topics.get(db) {\n                    let db_name = topic.db_name();\n                    dsn.database = Some(db_name.to_string());\n                } else {\n                    // todo: support subscribe stable/table.\n                    let db_info: Option\u003cString\u003e = taos.query_one(format!(\n                        \"select * from information_schema.user_databases where name = \\\"{db}\\\"\"\n                    ))?;\n                    if db_info.is_none() {\n                        return Err(Error::InvalidDatabase(db.to_string()));\n                    }\n                    taos.exec(format!(\"create topic if not exists {db} as database {db}\"))?;\n                    dsn.database = Some(db.to_string());\n                }\n\n                let vgroups: VGroups = taos\n                    .query_one(format!(\n                        \"select * from information_schema.user_databases where name = '{db}'\"\n                    ))?\n                    .unwrap_or_default();\n                if max_workers \u003c vgroups.vgroups {\n                    max_workers = vgroups.vgroups;\n                }\n            }\n\n            if !dsn.params.contains_key(\"group.id\") {\n                dsn.params.insert(\"group.id\".to_string(), db.to_string());\n            }\n        }\n        // check group id\n        if !dsn.params.contains_key(\"wait\") {\n            dsn.params.insert(\"wait\".to_string(), \"10\".to_string());\n        }\n        let manager = Manager::from_dsn(dsn.clone())?;\n\n        Ok(Self {\n            from: dsn.clone(),\n            manager,\n            tmq_builder: TmqBuilder::from_dsn(dsn)?,\n            max_workers,\n            protocol: SinkProtocol::Block,\n        })\n    }\n\n    fn dsn(\u0026self) -\u003e Cow\u003cDsn\u003e {\n        Cow::Borrowed(\u0026self.from)\n    }\n\n    fn build_source(\u0026mut self) -\u003e Result\u003cSelf::XSource, Self::Error\u003e {\n        Ok(TaosSource {\n            taos: Arc::new(self.manager.connect()?),\n            consumer: self.tmq_builder.build()?,\n            protocol: SinkProtocol::Block,\n            rs: None,\n            blocks: None,\n        })\n    }\n\n    fn protocol(\u0026self) -\u003e SinkProtocol {\n        todo!()\n    }\n\n    fn max_workers(\u0026self) -\u003e usize {\n        self.max_workers\n    }\n\n    fn database_options(\u0026self) -\u003e Vec\u003c(String, String)\u003e {\n        unimplemented!()\n    }\n\n    fn schema_iter\u003cI\u003e(\u0026self) -\u003e I\n    where\n        I: Iterator\u003cItem = crate::stream::source::XSchema\u003e,\n    {\n        unimplemented!()\n    }\n}\n\nimpl Stream for TaosSource {\n    type Item = Result\u003cTaosItem, Error\u003e;\n\n    fn poll_next(\n        mut self: Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        match self.protocol {\n            SinkProtocol::ResultSet =\u003e todo!(),\n            SinkProtocol::Block =\u003e {\n                if let Some(blocks) = self.blocks.as_mut() {\n                    match blocks.poll_next_unpin(cx) {\n                        Poll::Pending =\u003e Poll::Pending,\n                        Poll::Ready(None) =\u003e {\n                            self.blocks = None;\n                            self.rs = None;\n                            match self.consumer.poll_next_unpin(cx) {\n                                Poll::Pending =\u003e Poll::Pending,\n                                Poll::Ready(None) =\u003e Poll::Ready(None),\n                                Poll::Ready(Some(rs)) =\u003e match rs {\n                                    Ok(mut rs) =\u003e {\n                                        self.blocks = Some(rs.block_stream());\n                                        self.rs = Some(rs);\n                                        self.blocks.as_mut().unwrap().poll_next_unpin(cx).map(\n                                            |block| {\n                                                block.map(|block| {\n                                                    Ok(TaosItem::Block(self.taos.clone(), block))\n                                                })\n                                            },\n                                        )\n                                    }\n                                    Err(err) =\u003e Poll::Ready(Some(Err(err.into()))),\n                                },\n                            }\n                        }\n                        Poll::Ready(Some(block)) =\u003e {\n                            Poll::Ready(Some(Ok(TaosItem::Block(self.taos.clone(), block))))\n                        }\n                    }\n                } else {\n                    match self.consumer.poll_next_unpin(cx) {\n                        Poll::Pending =\u003e Poll::Pending,\n                        Poll::Ready(None) =\u003e Poll::Ready(None),\n                        Poll::Ready(Some(rs)) =\u003e match rs {\n                            Ok(mut rs) =\u003e {\n                                self.blocks = Some(rs.block_stream());\n                                self.rs = Some(rs);\n                                self.blocks\n                                    .as_mut()\n                                    .unwrap()\n                                    .poll_next_unpin(cx)\n                                    .map(|block| {\n                                        block.map(|block| {\n                                            Ok(TaosItem::Block(self.taos.clone(), block))\n                                        })\n                                    })\n                            }\n                            Err(_) =\u003e Poll::Ready(None),\n                        },\n                    }\n                }\n            }\n            SinkProtocol::RawBlock =\u003e todo!(),\n            SinkProtocol::Record =\u003e todo!(),\n            SinkProtocol::SmlLine =\u003e todo!(),\n            SinkProtocol::SmlTelnet =\u003e todo!(),\n            SinkProtocol::SmlJson =\u003e todo!(),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\n#[taos::test(log_level = \"trace\", databases = 2)]\nasync fn test(taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e anyhow::Result\u003c()\u003e {\n    taos.exec_many([\n        \"create table tb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table tb2 (ts timestamp, c_bool bool, c_int int, c_binary binary(10))\",\n        \"create table stb1 (ts timestamp, c_bool bool, c_int int, c_binary binary(10)) tags(c_i8 tinyint)\",\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db1 = databases[0];\n    taos.exec(format!(\"create topic {db1} as database {db1}\"))?;\n\n    let mut source_builder = TaosSourceBuilder::from_dsn(format!(\"taos:///{db1}?wait=1000\"))?;\n    let mut source = source_builder.build_source()?;\n\n    let mut rows = 0;\n    let mut tables = std::collections::BTreeSet::new();\n    while let Some(Ok(item)) = source.next().await {\n        println!(\"{:?}\", item);\n        let block = item.as_block().1;\n        rows += block.num_of_rows();\n        let table = block.tmq_table_name().unwrap();\n        tables.insert(table.to_string());\n    }\n    anyhow::ensure!(rows == 8);\n    anyhow::ensure!(tables.into_iter().collect_vec() == vec![\"tb1\", \"tb2\", \"tb3\", \"tb4\"]);\n\n    taos.exec_many([\n        \"insert into tb1 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb2 values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb3 using stb1 tags(3) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n        \"insert into tb4 using stb1 tags(4) values(now, NULL, NULL, NULL) (now+1s, false, 0, 'abc')\",\n    ])?;\n\n    let db2 = databases[1];\n    let transformers = vec![Action::from_str(\"add-tag:f1(10)=value1\")?];\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?.with_transformer(transformers).build_sink()?;\n\n    source.forward(\u0026mut sink).await?;\n\n    Ok(())\n}\n\n#[taos::test(log_level = \"debug\")]\nasync fn test_sync() -\u003e anyhow::Result\u003c()\u003e {\n    return Ok(());\n    let db1 = \"abc1\";\n    // if taos.query_one::\u003cString\u003e(\"select name from information_schema.user_databases where name = abc1\")?.is_none() {\n    //     return Ok(());\n    // }\n    let mut source_builder =\n        TaosSourceBuilder::from_dsn(format!(\"taos:///{db1}?group.id=1\u0026wait=20000\"))?;\n    let source = source_builder.build_source()?;\n    let db2 = \"abc2\";\n    let mut sink = TaosSinkBuilder::from_dsn(format!(\"taos:///{db2}\"))?.build_sink()?;\n\n    source.forward(\u0026mut sink).await?;\n\n    Ok(())\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","sync","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","plugins","transformer","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","mod.rs"],"content":"pub mod sink;\npub mod source;\npub mod transformer;\n\npub mod stream;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","sink.rs"],"content":"use std::iter::Product;\n\nuse linked_hash_map::LinkedHashMap;\nuse taos::query::Dsn;\n\n#[repr(C)]\npub enum SourceType {\n    Database,\n}\npub trait ISSourceType {\n    const SOURCE_TYPE: SourceType;\n}\n\npub trait TaosxSource: Sized {\n    type Error;\n    const NAME: \u0026'static str;\n    const KEYS: \u0026'static [\u0026'static str];\n\n    fn new(dsn: Dsn, opts: LinkedHashMap\u003c\u0026'static str, String\u003e) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    type Product;\n    fn produce(\u0026mut self) -\u003e Self::Product;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","source.rs"],"content":"use itertools::Itertools;\nuse linked_hash_map::LinkedHashMap;\nuse mdsn::{DsnError, IntoDsn};\n\nuse std::{\n    any::Any,\n    borrow::Cow,\n    collections::{BTreeSet, HashMap},\n    ffi::c_void,\n    fmt::Debug,\n    marker::PhantomData,\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    sync::{Arc, Weak},\n    task::Poll,\n};\n\nuse futures::{Sink, Stream, StreamExt, TryStreamExt};\nuse taos::{\n    block::{itypes::IsValue, BlockStream, Field, Ty},\n    prelude::AsyncFetchable,\n    query::Dsn,\n    tmq::{Consumer, TmqBuilder},\n};\n\nuse crate::{plugins::sink::taos::TaosSinkBuilder, stream::stream::XSinkBuilder, util::sync_table};\n\nuse super::stream::{SinkProtocol, TaosxSinkItem};\n\npub use taos::prelude::sync::*;\n\npub enum XSchema {\n    STableBegin,\n    STableSpan {\n        name: String,\n        tags: Vec\u003cField\u003e,\n        fields: Vec\u003cField\u003e,\n        options: Vec\u003c(String, String)\u003e,\n    },\n    STableEnd,\n    TableBegin,\n    Table {\n        name: String,\n        fields: Vec\u003cField\u003e,\n        options: Vec\u003c(String, String)\u003e,\n    },\n    TableEnd,\n    ChildTableBegin,\n    ChildTable {\n        name: String,\n        stable: String,\n        fields: Vec\u003cValue\u003e,\n    },\n    ChildTableEnd,\n}\n\npub trait XSourceBuilder\nwhere\n    Self: Sized,\n{\n    type Error: std::error::Error;\n    type Item: TaosxSinkItem;\n    type XSource: Stream\u003cItem = Result\u003cSelf::Item, Self::Error\u003e\u003e;\n\n    const NAME: \u0026'static str;\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    fn dsn(\u0026self) -\u003e Cow\u003cDsn\u003e;\n\n    fn max_workers(\u0026self) -\u003e usize {\n        0\n    }\n\n    fn database_options(\u0026self) -\u003e Vec\u003c(String, String)\u003e {\n        unimplemented!()\n    }\n\n    fn schema_iter\u003cI\u003e(\u0026self) -\u003e I\n    where\n        I: Iterator\u003cItem = XSchema\u003e,\n    {\n        unimplemented!()\n    }\n\n    fn protocol(\u0026self) -\u003e SinkProtocol;\n\n    fn build_source(\u0026mut self) -\u003e Result\u003cSelf::XSource, Self::Error\u003e;\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","stream","mod.rs"],"content":"use derive_more::{Deref, DerefMut};\nuse mdsn::IntoDsn;\nuse std::{\n    borrow::Cow,\n    fmt::Debug,\n    pin::Pin,\n    sync::atomic::{AtomicUsize, Ordering},\n};\n\nuse taos::prelude::{SchemalessPrecision, SyncBlock, Taos, Value};\n\nuse super::transformer::Action;\n\n#[derive(Debug, Clone, Copy)]\n#[non_exhaustive]\npub enum SinkProtocol {\n    /// TDengine result set type for [taos::Taos] only.\n    ResultSet,\n    /// A stream data block from tmq consumer.\n    Block,\n    /// Raw block as a single bytes.\n    RawBlock,\n    /// A record for a table or stable.\n    Record,\n    /// InfluxDB line protocol record.\n    SmlLine,\n    /// OpenTSDB telnet protocol record string.\n    SmlTelnet,\n    /// OpenTSDB json protocol.\n    SmlJson,\n    #[non_exhaustive]\n    __NoneExhaustive,\n}\n\n#[derive(Debug, Default)]\npub struct Summary {\n    pub blocks: AtomicUsize,\n    pub rows: AtomicUsize,\n}\n\nimpl Summary {\n    pub fn blocks(\u0026self) -\u003e usize {\n        self.blocks.load(Ordering::Acquire)\n    }\n    pub fn rows(\u0026self) -\u003e usize {\n        self.rows.load(Ordering::Acquire)\n    }\n}\n\npub trait XSinkBuilder\nwhere\n    Self: Sized,\n{\n    type Error: std::error::Error;\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Error\u003e;\n\n    fn with_transformer(self, transformers: Vec\u003cAction\u003e) -\u003e Self;\n\n    fn build_sink(\u0026self) -\u003e Result\u003cXSink\u003cSelf::Error\u003e, Self::Error\u003e;\n\n    fn summary(\u0026self) -\u003e \u0026Summary;\n\n    fn build_sink_for_protocol(\u0026self, _: SinkProtocol) -\u003e Result\u003cXSink\u003cSelf::Error\u003e, Self::Error\u003e {\n        self.build_sink()\n    }\n}\n\n#[derive(Debug, Deref, DerefMut)]\npub struct XSink\u003cE\u003e(Box\u003cdyn TaosxSink\u003cError = E\u003e\u003e);\n\nimpl\u003cE, T\u003e From\u003cT\u003e for XSink\u003cE\u003e\nwhere\n    E: 'static + Send + Sync + std::error::Error,\n    T: 'static + TaosxSink\u003cError = E\u003e,\n{\n    fn from(value: T) -\u003e Self {\n        XSink(Box::new(value))\n    }\n}\n\nimpl\u003cE, I\u003e futures::Sink\u003cI\u003e for XSink\u003cE\u003e\nwhere\n    E: 'static + Send + Sync + std::error::Error,\n    I: TaosxSinkItem,\n{\n    type Error = E;\n\n    fn poll_ready(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        std::task::Poll::Ready(Ok(()))\n    }\n\n    fn start_send(self: std::pin::Pin\u003c\u0026mut Self\u003e, item: I) -\u003e Result\u003c(), Self::Error\u003e {\n        let sink = Pin::into_inner(self);\n        match item.protocol() {\n            SinkProtocol::ResultSet =\u003e todo!(),\n            SinkProtocol::Block =\u003e {\n                let (taos, block) = item.as_block();\n                sink.consume_block(taos, block)\n            }\n            SinkProtocol::RawBlock =\u003e {\n                if let Some(block) = item.as_raw_block() {\n                    sink.consume_raw_block(\u0026block)\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::Record =\u003e todo!(),\n            SinkProtocol::SmlLine =\u003e {\n                if let Some(line) = item.as_schemaless_line() {\n                    sink.consume_schemaless_line(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::SmlTelnet =\u003e {\n                if let Some(line) = item.as_schemaless_telnet() {\n                    sink.consume_schemaless_telnet(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            SinkProtocol::SmlJson =\u003e {\n                if let Some(line) = item.as_schemaless_json() {\n                    sink.consume_schemaless_json(line, item.precision())\n                } else {\n                    Ok(())\n                }\n            }\n            _ =\u003e todo!(),\n        }\n    }\n\n    fn poll_flush(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        std::task::Poll::Ready(Ok(()))\n    }\n\n    fn poll_close(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cResult\u003c(), Self::Error\u003e\u003e {\n        std::task::Poll::Ready(Ok(()))\n    }\n}\n\npub type TaosxSinkError = anyhow::Error;\npub trait TaosxSink: Debug + Send {\n    type Error: 'static + Send + Sync + std::error::Error;\n    fn batch_size(\u0026self) -\u003e usize {\n        1\n    }\n\n    fn flush(\u0026mut self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn consume_block(\u0026mut self, _: \u0026Taos, _: \u0026SyncBlock) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_raw_block(\u0026mut self, _: \u0026[u8]) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_line(\n        \u0026mut self,\n        _: \u0026str,\n        _: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_telnet(\n        \u0026mut self,\n        _: \u0026str,\n        _: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n\n    fn consume_schemaless_json(\n        \u0026mut self,\n        _: \u0026str,\n        _: SchemalessPrecision,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        unimplemented!()\n    }\n}\n\npub trait TaosxSinkItem: Send {\n    const PROTOCOL: SinkProtocol;\n\n    fn protocol(\u0026self) -\u003e SinkProtocol {\n        Self::PROTOCOL\n    }\n\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        unimplemented!()\n    }\n\n    fn as_raw_block(\u0026self) -\u003e Option\u003cCow\u003c[u8]\u003e\u003e {\n        None\n    }\n\n    fn as_record(\u0026self) -\u003e Option\u003cCow\u003c[Value]\u003e\u003e {\n        None\n    }\n\n    fn precision(\u0026self) -\u003e SchemalessPrecision {\n        SchemalessPrecision::NonConfigured\n    }\n\n    fn as_schemaless_line(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_telnet(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n\n    fn as_schemaless_json(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None\n    }\n}\n\nimpl TaosxSinkItem for (\u0026Taos, SyncBlock) {\n    const PROTOCOL: SinkProtocol = SinkProtocol::Block;\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        (self.0, \u0026self.1)\n    }\n}\n\nimpl TaosxSinkItem for (\u0026Taos, \u0026SyncBlock) {\n    const PROTOCOL: SinkProtocol = SinkProtocol::Block;\n    fn as_block(\u0026self) -\u003e (\u0026Taos, \u0026SyncBlock) {\n        (self.0, self.1)\n    }\n}\n\npub struct XLine\u003c'a\u003e(\u0026'a str, SchemalessPrecision);\n\nimpl\u003c'a\u003e XLine\u003c'a\u003e {\n    pub fn new_line(input: \u0026'a str) -\u003e Self {\n        XLine(input, SchemalessPrecision::Nanoseconds)\n    }\n    pub fn new_line_with_precision(input: \u0026'a str, precision: SchemalessPrecision) -\u003e Self {\n        XLine(input, precision)\n    }\n}\n\nimpl\u003c'a\u003e TaosxSinkItem for XLine\u003c'a\u003e {\n    const PROTOCOL: SinkProtocol = SinkProtocol::SmlLine;\n    fn precision(\u0026self) -\u003e SchemalessPrecision {\n        self.1\n    }\n    fn as_schemaless_line(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        Some(self.0)\n    }\n}\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":58},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","stream","transformer.rs"],"content":"use std::str::FromStr;\n\nuse linked_hash_map::LinkedHashMap as HashMap;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum AddTagOpts {\n    Value { value: String },\n    Template { template: String },\n}\n\nimpl AddTagOpts {\n    pub fn value(value: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Value {\n            value: value.into(),\n        }\n    }\n    pub fn template(template: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Template {\n            template: template.into(),\n        }\n    }\n}\n\nconst fn default_tag_length() -\u003e usize {\n    100\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\npub struct AddTag {\n    pub name: String,\n    #[serde(flatten)]\n    pub opts: AddTagOpts,\n\n    #[serde(default = \"default_tag_length\")]\n    pub len: usize,\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum AddTagParseError {\n    #[error(\"Empty AddTag option\")]\n    Empty,\n    #[error(\"Invalid AddTag option: {0}\")]\n    Invalid(String),\n}\n\nimpl FromStr for AddTag {\n    type Err = AddTagParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if s.is_empty() {\n            return Err(AddTagParseError::Empty);\n        }\n        use lazy_static::lazy_static;\n        use regex::Regex;\n        lazy_static! {\n            static ref RE: Regex =\n                Regex::new(r\"(?P\u003cf\u003e[^=()\\s]+)(\\((?P\u003cl\u003e\\d+)\\))?=((?P\u003ct\u003e.*\\{\\{.*\\}\\}.*)|(?P\u003cv\u003e.*))\")\n                    .unwrap();\n        }\n        // RE.matches(s).into_iter()\n        if let Some(cap) = RE.captures(s) {\n            let name = cap[\"f\"].to_string();\n            let len = cap\n                .name(\"l\")\n                .and_then(|m| m.as_str().parse().ok())\n                .unwrap_or_else(default_tag_length);\n            if let Some(v) = cap.name(\"v\") {\n                Ok(AddTag {\n                    name,\n                    len,\n                    opts: AddTagOpts::value(v.as_str()),\n                })\n            } else if let Some(t) = cap.name(\"t\") {\n                Ok(AddTag {\n                    name,\n                    len,\n                    opts: AddTagOpts::template(t.as_str()),\n                })\n            } else {\n                unreachable!()\n            }\n        } else {\n            Err(AddTagParseError::Invalid(s.to_string()))\n        }\n    }\n}\n\n#[test]\nfn parse_add_tag() {\n    let errors = [\n        (\"\", AddTagParseError::Empty),\n        (\"a\", AddTagParseError::Invalid(\"\".to_string())),\n    ];\n    for (s, e) in errors {\n        let ee = AddTag::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let add_tags = [\n        (\n            \"f1=v1\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Value {\n                    value: \"v1\".to_string(),\n                },\n                len: 100,\n            },\n        ),\n        (\n            \"f1(200)=v1\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Value {\n                    value: \"v1\".to_string(),\n                },\n                len: 200,\n            },\n        ),\n        (\n            \"f1(200)={{ host }}\",\n            AddTag {\n                name: \"f1\".to_string(),\n                opts: AddTagOpts::Template {\n                    template: \"{{ host }}\".to_string(),\n                },\n                len: 200,\n            },\n        ),\n    ];\n    for (s, a) in add_tags {\n        let aa = AddTag::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum RenameOpts {\n    Prefix { prefix: String },\n    Suffix { suffix: String },\n    Template { template: String },\n}\n\nimpl RenameOpts {\n    pub fn prefix(prefix: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Prefix {\n            prefix: prefix.into(),\n        }\n    }\n    pub fn suffix(input: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Suffix {\n            suffix: input.into(),\n        }\n    }\n    pub fn template(input: impl Into\u003cString\u003e) -\u003e Self {\n        Self::Template {\n            template: input.into(),\n        }\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum RenameParseError {\n    #[error(\"Empty rename option is not valid\")]\n    Empty,\n    #[error(\"Empty rename option for variant: {0}\")]\n    EmptyOptionForVariant(\u0026'static str),\n    #[error(\n        \"Invalid rename option: {0} which should match pattern `\u003cprefix|suffix|template\u003e:\u003cvalue\u003e`\"\n    )]\n    FormatError(String),\n    #[error(\"Invalid rename variant: {0} while parsing `{1}`\")]\n    InvalidVariant(String, String),\n}\n\nimpl FromStr for RenameOpts {\n    type Err = RenameParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        use RenameParseError::*;\n        if s.is_empty() {\n            return Err(Empty);\n        }\n        let (variant, option) = s.split_once(':').ok_or(FormatError(s.to_string()))?;\n        match variant {\n            \"prefix\" =\u003e {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"prefix\"))\n                } else {\n                    Ok(RenameOpts::prefix(option))\n                }\n            }\n            \"suffix\" =\u003e {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"suffix\"))\n                } else {\n                    Ok(RenameOpts::suffix(option))\n                }\n            }\n            \"template\" =\u003e {\n                if option.is_empty() {\n                    Err(EmptyOptionForVariant(\"template\"))\n                } else {\n                    Ok(RenameOpts::template(option))\n                }\n            }\n            variant =\u003e Err(InvalidVariant(variant.to_string(), s.to_string())),\n        }\n    }\n}\n\n#[test]\nfn test_rename_opts_from_str() {\n    use RenameParseError::*;\n    let errors = [\n        (\"\", Empty),\n        (\"a\", FormatError(\"a\".to_string())),\n        (\"a:\", InvalidVariant(\"a\".to_string(), \"a:\".to_string())),\n        (\"prefix:\", EmptyOptionForVariant(\"prefix\")),\n        (\"suffix:\", EmptyOptionForVariant(\"suffix\")),\n        (\"template:\", EmptyOptionForVariant(\"template\")),\n    ];\n    for (s, e) in errors {\n        let ee = RenameOpts::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let actions = [\n        (\"prefix:v1_\", RenameOpts::prefix(\"v1_\")),\n        (\"suffix:_v1\", RenameOpts::suffix(\"_v1\")),\n        (\"template:v1_v1\", RenameOpts::template(\"v1_v1\")),\n    ];\n    for (s, a) in actions {\n        let aa = RenameOpts::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\n#[serde(untagged)]\npub enum Select {\n    Subset { subset: Vec\u003cString\u003e },\n    Exclude { exclude: Vec\u003cString\u003e },\n    Rename { rename: HashMap\u003cString, String\u003e },\n}\n\nimpl Select {\n    pub fn subset(subset: Vec\u003cString\u003e) -\u003e Self {\n        Self::Subset { subset }\n    }\n\n    pub fn exclude(exclude: Vec\u003cString\u003e) -\u003e Self {\n        Self::Exclude { exclude }\n    }\n\n    pub fn rename\u003cI: IntoIterator\u003cItem = (impl Into\u003cString\u003e, impl Into\u003cString\u003e)\u003e\u003e(\n        rename: I,\n    ) -\u003e Self {\n        Self::Rename {\n            rename: rename\n                .into_iter()\n                .map(|(a, b)| (a.into(), b.into()))\n                .collect(),\n        }\n    }\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum SelectParseError {\n    #[error(\"Empty select option\")]\n    Empty,\n    #[error(\"Empty select option for variant: {0}\")]\n    EmptyOptionForVariant(\u0026'static str),\n    #[error(\"Invalid select option: {0}, use like `select:\u003ctype\u003e:\u003copts\u003e`\")]\n    InvalidSelect(String),\n    #[error(\"Invalid select variant: {0} while parsing `{1}`\")]\n    InvalidVariant(String, String),\n    #[error(\"Invalid rename option: {0} while parsing `{1}`\")]\n    InvalidRename(String, String),\n}\n\nimpl FromStr for Select {\n    type Err = SelectParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        if s.is_empty() {\n            return Err(SelectParseError::Empty);\n        }\n        let (select, fields) = s\n            .split_once(':')\n            .ok_or(SelectParseError::InvalidSelect(s.to_string()))?;\n        match select {\n            \"subset\" =\u003e {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"subset\"));\n                }\n                let v = fields.split(\",\").map(ToString::to_string).collect();\n                Ok(Select::subset(v))\n            }\n            \"exclude\" =\u003e {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"exclude\"));\n                }\n                let v = fields.split(\",\").map(ToString::to_string).collect();\n                Ok(Select::exclude(v))\n            }\n            \"rename\" =\u003e {\n                if fields.is_empty() {\n                    return Err(SelectParseError::EmptyOptionForVariant(\"rename\"));\n                }\n                use itertools::Itertools;\n                let v: Vec\u003c_\u003e = fields\n                    .split(\",\")\n                    .map(|f| {\n                        f.split_once(\"=\")\n                            .ok_or(SelectParseError::InvalidRename(\n                                f.to_string(),\n                                s.to_string(),\n                            ))\n                            .map(|(f, v)| (f.to_string(), v.to_string()))\n                    })\n                    .try_collect()?;\n                Ok(Select::rename(v))\n            }\n            t =\u003e Err(SelectParseError::InvalidVariant(\n                t.to_string(),\n                s.to_string(),\n            )),\n        }\n    }\n}\n\n#[test]\nfn test_select_from_str() {\n    let errors = [\n        (\"\", SelectParseError::Empty),\n        (\"a\", SelectParseError::InvalidSelect(\"a\".to_string())),\n        (\n            \"a:\",\n            SelectParseError::InvalidVariant(\"a\".to_string(), \"a:\".to_string()),\n        ),\n        (\"subset:\", SelectParseError::EmptyOptionForVariant(\"subset\")),\n        (\n            \"exclude:\",\n            SelectParseError::EmptyOptionForVariant(\"exclude\"),\n        ),\n        (\"rename:\", SelectParseError::EmptyOptionForVariant(\"rename\")),\n        (\n            \"rename:a,b\",\n            SelectParseError::InvalidRename(\"a\".to_string(), \"rename:a,b\".to_string()),\n        ),\n    ];\n    for (s, e) in errors {\n        let ee = Select::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let selects = [\n        (\n            \"subset:a,b\",\n            Select::subset(vec![\"a\".to_string(), \"b\".to_string()]),\n        ),\n        (\n            \"exclude:a,b\",\n            Select::exclude(vec![\"a\".to_string(), \"b\".to_string()]),\n        ),\n        (\"rename:a=b,c=d\", Select::rename([(\"a\", \"b\"), (\"c\", \"d\")])),\n    ];\n    for (s, a) in selects {\n        let aa = Select::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\n#[derive(Debug, Deserialize, PartialEq, Eq)]\n#[serde(tag = \"action\")]\npub enum Action {\n    Select(Select),\n    AddTag(AddTag),\n    RenameTable(RenameOpts),\n    RenameChildTable(RenameOpts),\n    RenameSuperTable(RenameOpts),\n}\n\n#[derive(thiserror::Error, Debug)]\npub enum ActionParseError {\n    #[error(\"Empty action option is not valid\")]\n    EmptyAction,\n    #[error(\"Invalid action: {0}, use `\u003caction\u003e:\u003coption\u003e` format\")]\n    FormatError(String),\n    #[error(\"Unsupported action type: {0}\")]\n    Unsupported(String),\n    #[error(\"AddTag parse error: {0}\")]\n    AddTagError(#[from] AddTagParseError),\n    #[error(\"Select parse error: {0}\")]\n    SelectError(#[from] SelectParseError),\n    #[error(\"Rename parse error: {0}\")]\n    RenameError(#[from] RenameParseError),\n}\n\nimpl FromStr for Action {\n    type Err = ActionParseError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        use ActionParseError::*;\n        if s.is_empty() {\n            return Err(EmptyAction);\n        }\n        use convert_case::{Case, Casing};\n        let (action, option) = s.split_once(\":\").ok_or(FormatError(s.to_string()))?;\n        match action.to_case(Case::Pascal).as_str() {\n            \"AddTag\" =\u003e Ok(Action::AddTag(AddTag::from_str(option)?)),\n            \"Select\" =\u003e Ok(Action::Select(Select::from_str(option)?)),\n            \"RenameTable\" =\u003e Ok(Action::RenameTable(RenameOpts::from_str(option)?)),\n            \"RenameSuperTable\" =\u003e Ok(Action::RenameSuperTable(RenameOpts::from_str(option)?)),\n            \"RenameChildTable\" =\u003e Ok(Action::RenameChildTable(RenameOpts::from_str(option)?)),\n            _ =\u003e Err(Unsupported(action.to_string())),\n        }\n    }\n}\n\n#[test]\nfn test_action_from_str() {\n    use ActionParseError::*;\n    let errors = [\n        (\"\", EmptyAction),\n        (\"a\", FormatError(\"a\".to_string())),\n        (\"a:\", Unsupported(\"a\".to_string())),\n        (\"add-tag:\", AddTagError(AddTagParseError::Empty)),\n        (\"select:\", SelectError(SelectParseError::Empty)),\n        (\"rename-table:\", RenameError(RenameParseError::Empty)),\n    ];\n    for (s, e) in errors {\n        let ee = Action::from_str(s).unwrap_err();\n        assert_eq!(ee.to_string(), e.to_string());\n    }\n\n    let actions = [\n        (\n            \"add-tag:a=b\",\n            Action::AddTag(AddTag {\n                name: \"a\".to_string(),\n                len: 100,\n                opts: AddTagOpts::value(\"b\"),\n            }),\n        ),\n        (\n            \"select:subset:a,b\",\n            Action::Select(Select::subset(vec![\"a\".to_string(), \"b\".to_string()])),\n        ),\n        (\n            \"rename-table:template:v1_v1\",\n            Action::RenameTable(RenameOpts::template(\"v1_v1\")),\n        ),\n    ];\n    for (s, a) in actions {\n        let aa = Action::from_str(s).unwrap();\n        assert_eq!(aa, a);\n    }\n}\n\npub trait Transform {\n    fn transform(\u0026mut self, action: \u0026Action) -\u003e anyhow::Result\u003c()\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n    use anyhow::Result;\n    #[test]\n    fn action() -\u003e Result\u003c()\u003e {\n        let json = r#\"[\n            { \"action\": \"AddTag\", \"name\": \"f1\", \"value\": \"f2\" },\n            { \"action\": \"AddTag\", \"name\": \"f1\", \"template\": \"{{ host }}\" },\n            { \"action\": \"Select\", \"subset\": [\"a\", \"b\"] },\n            { \"action\": \"Select\", \"rename\": { \"a\": \"a1\", \"b\": \"b1\" } }\n        ]\"#;\n        let addtag: Vec\u003cAction\u003e = serde_json::from_str(json)?;\n        dbg!(addtag);\n        Ok(())\n    }\n\n    #[test]\n    fn test_trait() {\n        struct A;\n        impl Transform for A {\n            fn transform(\u0026mut self, _: \u0026Action) -\u003e anyhow::Result\u003c()\u003e {\n                Ok(())\n            }\n        }\n        let action = Action::from_str(\"select:subset:a,b,c\").unwrap();\n        let mut a = A;\n        a.transform(\u0026action).unwrap();\n    }\n}\n","traces":[{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","task","mod.rs"],"content":"use linked_hash_map::LinkedHashMap;\nuse serde_json::Value;\n\n///\n// {\n//   \"source\": [\n//     \"dsn1\",\n//     \"dsn2\"\n//   ],\n//   \"transformer\": {\n//     \"AddTag\": {\n//       \"city\": {\n//         \"fromOptions\": \"host\"\n//       }\n//     },\n//     \"AlterTable\": {\n//       \"prefix\": \"taosx_\"\n//     }\n//   },\n//   \"sink\": [\n//     \"sink1\",\n//     \"sink2\"\n//   ]\n// }\npub struct Task {\n    source: Vec\u003cSource\u003e,\n    transformer: Transformers,\n    sink: Vec\u003cSink\u003e,\n}\n\npub struct Source {\n    plugin: String,\n    dsn: String,\n    options: Value,\n}\n\npub struct Sink {\n    dsn: String,\n    options: LinkedHashMap\u003cString, String\u003e,\n}\n\nimpl Sink {\n    pub fn plugin\u003cT\u003e(\u0026self) -\u003e Box\u003cdyn SinkPlugin\u003cStream = T\u003e\u003e {\n        unimplemented!()\n    }\n}\n\npub trait SinkPlugin {\n    type Stream;\n\n    fn accepted_content(\u0026self) -\u003e Vec\u003cString\u003e;\n\n    fn consume(\u0026mut self, stream: Self::Stream);\n}\n\npub struct Transformers(LinkedHashMap\u003cString, TransformerOptions\u003e);\n\npub struct TransformerOptions(Value);\n\n#[cfg(test)]\nmod tests {\n    use futures::sink::{self, SinkExt};\n    use taos::prelude::*;\n\n    #[taos::test]\n    async fn sink_unfold(taos: \u0026Taos, database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n        let unfold = sink::unfold(0, |mut sum, i: i32| async move {\n            sum += i;\n            eprintln!(\"sum: {sum}, i = {}\", i);\n            Ok::\u003c_, futures::never::Never\u003e(sum)\n        });\n        futures::pin_mut!(unfold);\n        unfold.send(5).await?;\n        unfold.send(5).await?;\n        unfold.send(5).await?;\n        Ok(())\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","huolinhe","Projects","taosdata","taosx","src","util","mod.rs"],"content":"use std::collections::HashMap;\n\nuse futures::prelude::*;\nuse log::info;\nuse serde::Deserialize;\nuse taos::prelude::{Error, Taos};\n\npub async fn sync_schema(from: \u0026Taos, to: \u0026Taos) -\u003e Result\u003c(), Error\u003e {\n    use taos::prelude::*;\n    let stables: Vec\u003cString\u003e = from\n        .query(\"show stables\")\n        .await?\n        .deserialize_stream()\n        .try_collect()\n        .await?;\n    let mut stable_fields = HashMap::new();\n    for stable in stables {\n        // todo: use \"show create\" sql?\n        // from.query(format!(\"show create stable {stable}\")).await?;\n        let desc = from.describe(\u0026stable).await?;\n        let sql = desc.to_create_table_sql(\u0026stable);\n        stable_fields.insert(stable, desc);\n        to.exec(sql).await?;\n    }\n\n    #[derive(Deserialize)]\n    struct Table {\n        table_name: String,\n        db_name: String,\n        stable_name: Option\u003cString\u003e,\n    }\n    let tables: Vec\u003cTable\u003e = from\n        .query(\"show tables\")\n        .await?\n        .deserialize_stream()\n        .try_collect()\n        .await?;\n    use itertools::Itertools;\n    for table in tables {\n        let table_name = \u0026table.table_name;\n        if let Some(stable) = table.stable_name {\n            let fields = \u0026stable_fields[\u0026stable];\n            let tags = fields.tag_names().collect_vec();\n            let names = fields.tag_names().join(\",\");\n            let fields: Vec\u003cValue\u003e = from\n                .query_one(format!(\n                    \"select {names} from {stable} where tbname = '{table_name}'\"\n                ))\n                .await?\n                .unwrap();\n\n            let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {table_name} using {stable} tags({tags_values})\"\n            ))\n            .await?;\n            // tags.iter().zip(fields).map(|(name, value)| format!(\"\"))\n            // let tags_stmt = tags.map(|_| '?').join(\",\");\n            // let mut stmt = to.stmt(format!(\"create table if not exists ? using ({tags_stmt})\"))?;\n            // stmt.set_tbname_tags(\u0026table.table_name, \u0026fields);\n        } else {\n            let desc = from.describe(table_name).await?;\n            let sql = desc.to_create_table_sql(table_name);\n            to.exec(sql).await?;\n        }\n    }\n\n    // let tables: Vec\u003c\n    Ok(())\n}\n\npub fn sync_table(from: \u0026Taos, to: \u0026Taos, db: \u0026str, table: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    use taos::prelude::sync::*;\n\n    let stable: Option\u003cString\u003e = from\n        .query_one(format!(\n            \"select stable_name from information_schema.user_tables where db_name = '{db}' and table_name = \\\"{table}\\\"\"\n        ))?\n        .unwrap();\n    use itertools::Itertools;\n\n    if let Some(stable) = stable {\n        let desc = from.describe(\u0026format!(\"{db}.`{stable}`\"))?;\n        let sql = desc.to_create_table_sql(\u0026stable);\n        to.exec(sql)?;\n\n        let names = desc.tag_names().join(\",\");\n        let children: Vec\u003cVec\u003cValue\u003e\u003e = from\n            .query(format!(\"select tbname,{names} from {stable}\"))?\n            .deserialize()\n            .try_collect()?;\n\n        // todo: use par_iter to speed up tables creation.\n        // todo: single table not work, blocked by https://jira.taosdata.com:18080/browse/TD-16117\n        for child in children {\n            let tbname = child[0].to_string().unwrap();\n            let tags_values = child[1..].into_iter().map(|v| v.to_sql_value()).join(\",\");\n            to.exec(format!(\n                \"create table if not exists {tbname} using {stable} tags({tags_values})\"\n            ))?;\n        }\n\n        // let fields: Vec\u003cValue\u003e = from\n        //     .query_one(format!(\n        //         \"select {names} from {stable} where tbname = '{table}'\"\n        //     ))?\n        //     .unwrap();\n\n        // let tags_values = fields.into_iter().map(|v| v.to_sql_value()).join(\",\");\n        // to.exec(format!(\n        //     \"create table if not exists {table} using {stable} tags({tags_values})\"\n        // ))?;\n    } else {\n        info!(\"describe table {table}\");\n        let desc = from.describe(\u0026format!(\"{db}.`{table}`\"))?;\n        info!(\"table {table}: {desc:?}\");\n        let sql = desc.to_create_table_sql(\u0026table);\n        info!(\"exec sql: {sql}\");\n        to.exec(sql)?;\n    }\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","benches","async_query.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\n\nuse taos::{Taos, TaosOptions};\n\nfn bench_query_sync0(taos: \u0026Taos) {\n    use taos::prelude::AsyncQueryable;\n    let _ = taos.query_sync(\"select * from log.logs\");\n}\n\nfn bench_query_sync1(taos: \u0026Taos) {\n    use taos::prelude::sync::Queryable;\n    let _ = taos.query(\"select * from log.logs\");\n}\n\nfn criterion_benchmark(c: \u0026mut Criterion) {\n    // Optionally include some setup\n    let taos = TaosOptions::new().build().unwrap();\n    let mut group = c.benchmark_group(\"query - do nothing\");\n    use criterion::*;\n    group.sampling_mode(SamplingMode::Linear);\n    group.measurement_time(std::time::Duration::from_secs(15));\n    use tokio::runtime;\n\n    let _rt = runtime::Runtime::new().unwrap();\n\n    group.bench_function(\"async\", |b| b.iter(|| bench_query_sync0(\u0026taos)));\n    group.bench_function(\"sync\", |b| b.iter(|| bench_query_sync1(\u0026taos)));\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","examples","benchmark-query.rs"],"content":"use anyhow::Result;\nuse taos::prelude::sync::*;\n\n// Refer to [Jira TD-15233](https://jira.taosdata.com:18080/browse/TD-15233)\nfn main() -\u003e Result\u003c()\u003e {\n    let taos = TaosOptions::new().database(\"abc1\").build()?;\n    let rs: (String, String) = taos\n        .query_one(\"select tbname, location from meters limit 1\")?\n        .unwrap();\n    dbg!(rs);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","examples","db-create-drop.rs"],"content":"use anyhow::Result;\nuse taos::prelude::sync::*;\n\n// Refer to [Jira TD-15233](https://jira.taosdata.com:18080/browse/TD-15233)\nfn main() -\u003e Result\u003c()\u003e {\n    let taos = TaosOptions::new().build()?;\n    taos.exec(\"create database abc\")?;\n    taos.exec(\"drop database abc\")?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","async_query.rs"],"content":"use std::{\n    ffi::c_void,\n    future::Future,\n    marker::PhantomData,\n    os::raw::c_int,\n    pin::Pin,\n    sync::Arc,\n    task::{Context, Poll, Waker},\n};\n\nuse std::sync::Mutex;\nuse taos_sys::ffi::TAOS_RES;\n\nuse crate::prelude::sync::ResultSet;\nuse crate::{util::IntoCStr, Result, Taos};\n\npub struct QueryFuture\u003c'query\u003e {\n    shared_state: Arc\u003cMutex\u003cSharedState\u003e\u003e,\n    _marker: PhantomData\u003c\u0026'query Taos\u003e,\n}\n\n/// Shared state between the future and the waiting thread\nstruct SharedState {\n    completed: bool,\n    result: *mut TAOS_RES,\n    code: i32,\n    waker: Option\u003cWaker\u003e,\n}\n\nunsafe impl Send for SharedState {}\nunsafe impl Sync for SharedState {}\n\nimpl Unpin for SharedState {}\nimpl\u003c'query\u003e Unpin for QueryFuture\u003c'query\u003e {}\nimpl\u003c'query\u003e Future for QueryFuture\u003c'query\u003e {\n    type Output = Result\u003cResultSet\u003e;\n    fn poll\u003c'a\u003e(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\n        // Look at the shared state to see if the timer has already completed.\n        let mut shared_state = self.shared_state.lock().unwrap();\n        if shared_state.completed {\n            Poll::Ready(Ok(ResultSet::from_ptr_with_code(\n                shared_state.result,\n                shared_state.code,\n            )?))\n        } else {\n            // Set waker so that the thread can wake up the current task\n            // when the timer has completed, ensuring that the future is polled\n            // again and sees that `completed = true`.\n            //\n            // It's tempting to do this once rather than repeatedly cloning\n            // the waker each time. However, the Future can move between\n            // tasks on the executor, which could cause a stale waker pointing\n            // to the wrong task, preventing from waking up\n            // correctly.\n            //\n            // N.B. it's possible to check for this using the `Waker::will_wake`\n            // function, but we omit that here to keep things simple.\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\nimpl\u003c'query\u003e QueryFuture\u003c'query\u003e {\n    /// Create a new `TimerFuture` which will complete after the provided\n    /// timeout.\n    pub fn new\u003c'a\u003e(taos: \u0026Taos, sql: impl IntoCStr\u003c'a\u003e) -\u003e Self {\n        let shared_state = Arc::new(Mutex::new(SharedState {\n            completed: false,\n            result: std::ptr::null_mut(),\n            code: 0,\n            waker: None,\n        }));\n\n        unsafe extern \"C\" fn async_query_callback(\n            param: *mut c_void,\n            res: *mut TAOS_RES,\n            code: c_int,\n        ) {\n            let param = param as *const Arc\u003cMutex\u003cSharedState\u003e\u003e;\n            let state = param.read();\n            let mut s = state.lock().unwrap();\n\n            (*s).completed = true;\n            (*s).result = res;\n            (*s).code = code;\n            if let Some(waker) = s.waker.take() {\n                waker.wake()\n            }\n        }\n\n        taos.0.query_a(\n            sql.into_c_str().as_ptr(),\n            async_query_callback as _,\n            Box::into_raw(Box::new(shared_state.clone())) as *mut _,\n        );\n\n        QueryFuture {\n            shared_state,\n            _marker: PhantomData,\n        }\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","block","mod.rs"],"content":"use std::{\n    ffi::c_void,\n    marker::PhantomData,\n    os::raw::c_int,\n    sync::{atomic::AtomicU64, Arc, Mutex, RwLock},\n    task::{Poll, Waker},\n};\n\nuse futures::Stream;\n\nuse taos_sys::ffi::*;\nuse taos_sys::*;\n\npub use taos_query::common::*;\n\nuse crate::impls::SyncBlock;\n\n#[derive(Debug)]\npub struct BlockStream {\n    raw: Arc\u003cRawRes\u003e,\n    summary: Arc\u003c(AtomicU64, AtomicU64)\u003e,\n    state: Arc\u003cMutex\u003cBlockState\u003e\u003e,\n}\n\nimpl BlockStream {\n    pub(crate) fn from_raw(raw: Arc\u003cRawRes\u003e, summary: Arc\u003c(AtomicU64, AtomicU64)\u003e) -\u003e Self {\n        let state = Arc::new(Mutex::new(BlockState {\n            completed: false,\n            result: std::ptr::null_mut(),\n            num_of_rows: 0,\n            waker: None,\n        }));\n\n        Self {\n            raw,\n            state,\n            summary,\n        }\n    }\n    pub(crate) fn append_num_of_rows(\u0026self, num_of_rows: i32) {\n        use std::sync::atomic::Ordering::SeqCst;\n        self.summary.0.fetch_add(1, SeqCst);\n        self.summary.1.fetch_add(num_of_rows as _, SeqCst);\n    }\n}\n\nunsafe impl Send for BlockStream {}\nunsafe impl Sync for BlockStream {}\n\n#[derive(Debug)]\nstruct BlockState {\n    /// Whether or not the sleep time has elapsed\n    completed: bool,\n    result: *mut TAOS_RES,\n    num_of_rows: i32,\n    waker: Option\u003cWaker\u003e,\n}\n\nimpl Stream for BlockStream {\n    // type Item = (*mut TAOS_RES, i32);\n    type Item = SyncBlock;\n\n    fn poll_next(\n        self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        // todo(3.0): remove these line to use taos_query_a in async/await impl.\n        if crate::client_info().starts_with(\"3\") {\n            let block = if let Ok(Some((data, num_of_rows, lengths))) = self.raw.fetch_block() {\n                log::trace!(\"fetch block: {num_of_rows}\");\n\n                self.append_num_of_rows(num_of_rows);\n\n                Some(SyncBlock {\n                    raw: self.raw.clone(),\n                    fields: None,\n                    precision: self.raw.precision(),\n                    data,\n                    lengths,\n                    num_of_rows: num_of_rows as _,\n                })\n            } else {\n                None\n            };\n            return Poll::Ready(block);\n        }\n\n        let mut s = self.state.lock().unwrap();\n        unsafe extern \"C\" fn async_fetch_callback(\n            param: *mut c_void,\n            res: *mut TAOS_RES,\n            num_of_rows: c_int,\n        ) {\n            let param = param as *const Arc\u003cMutex\u003cBlockState\u003e\u003e;\n            let state = param.read();\n            let mut s = state.lock().unwrap();\n\n            (*s).completed = true;\n            (*s).result = res;\n            (*s).num_of_rows = num_of_rows;\n            if let Some(waker) = s.waker.take() {\n                waker.wake()\n            }\n        }\n\n        if s.completed \u0026\u0026 s.num_of_rows != 0 {\n            let num_of_rows = s.num_of_rows;\n            s.completed = false;\n            s.num_of_rows = 0;\n            drop(s);\n\n            self.append_num_of_rows(num_of_rows);\n\n            // Wake up poll.\n            Poll::Ready(Self::Item::from_async_query(\n                self.raw.clone(),\n                self.raw.block(),\n                num_of_rows,\n            ))\n        } else if s.completed \u0026\u0026 s.num_of_rows == 0 {\n            Poll::Ready(None)\n        } else {\n            let res = if s.result.is_null() {\n                self.raw.as_ptr()\n            } else {\n                s.result\n            };\n            s.waker = Some(cx.waker().clone());\n            drop(s);\n\n            unsafe {\n                taos_fetch_rows_a(\n                    res,\n                    async_fetch_callback as _,\n                    Box::into_raw(Box::new(self.state.clone())) as *mut _,\n                );\n            }\n            Poll::Pending\n        }\n    }\n}\n","traces":[{"line":26,"address":[3686140,3686113,3685840],"length":1,"stats":{"Line":0},"fn_name":"from_raw"},{"line":27,"address":[3685975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3685963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[3686160],"length":1,"stats":{"Line":0},"fn_name":"append_num_of_rows"},{"line":42,"address":[3686182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[3686227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3687483,3687516,3686288],"length":1,"stats":{"Line":0},"fn_name":"poll_next"},{"line":68,"address":[3686335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3687478,3686560,3686462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[3686835,3686929,3686738,3686624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3687110,3686899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[3687357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3687124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[3687194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3687285,3687206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3687349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3686549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3687572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3687648,3686435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[3689890,3689440],"length":1,"stats":{"Line":0},"fn_name":"async_fetch_callback"},{"line":94,"address":[3689479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3689495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3689506,3689573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3689706,3689639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3689710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3689744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3689916,3689777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3690017,3689956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[3687735,3687843,3688443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[3687950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3688002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3688041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[3688083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3688118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3688378,3688425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3688167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[3688245,3688321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3689369,3687920,3688494,3688632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3688603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3688642,3688805,3688571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3688694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3688794,3688670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3688812,3689081,3688777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3689046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3689103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3689116,3689312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3689362],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","helpers","mod.rs"],"content":"// mod describe;\n// pub use describe::*;\n\n// mod database;\n// pub use database::*;\npub use taos_query::helpers::*;\n\n#[cfg(feature = \"test\")]\npub mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","helpers","tests.rs"],"content":"use std::{io::Write, ops::Deref, str::FromStr, sync::Once};\n\nuse log::Level;\nuse pretty_env_logger::env_logger::fmt::{Color, StyledValue};\n\nuse crate::prelude::sync::*;\n\nuse anyhow::Result;\n\nuse taos_query::common::Precision;\n\n/// Used in [test(naming = \"uuid-v1\")] macro to choose database naming strategy\n#[derive(Debug)]\npub enum NamingStrategy {\n    Random,\n    UuidV1,\n    Named(String),\n}\n\nimpl NamingStrategy {\n    fn name(\u0026self) -\u003e String {\n        use NamingStrategy::*;\n        match self {\n            Random =\u003e {\n                // randomly generate\n                use faker_rand::lorem::Word;\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option\u003cThreadRng\u003e = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let rng = unsafe { RNG.as_mut().unwrap() };\n                String::from_iter([rng.gen::\u003cWord\u003e().to_string(), rng.gen::\u003cWord\u003e().to_string()])\n            }\n            UuidV1 =\u003e {\n                // time-based uuid generator\n                use uuid::v1::{Context, Timestamp};\n                use uuid::Uuid;\n\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option\u003cThreadRng\u003e = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let context = Context::new(unsafe { RNG.as_mut().unwrap().gen() });\n                let dur = std::time::SystemTime::now()\n                    .duration_since(std::time::SystemTime::UNIX_EPOCH)\n                    .expect(\"\");\n                let ts = Timestamp::from_unix(\u0026context, dur.as_secs(), dur.subsec_nanos());\n\n                let mut node = [0u8; 6];\n                for i in 0..6 {\n                    node[i] = unsafe { RNG.as_mut().unwrap() }.gen();\n                }\n                let mut uuid: Vec\u003c_\u003e = Uuid::new_v1(ts, \u0026node)\n                    .as_hyphenated()\n                    .to_string()\n                    .replace(\"-\", \"\")\n                    .chars()\n                    .collect();\n                for _ in 0..uuid.len() {\n                    if uuid[0].is_alphabetic() {\n                        log::trace!(\n                            \"create database with name: {}\",\n                            String::from_iter(uuid.clone())\n                        );\n                        break;\n                    } else {\n                        uuid.rotate_left(1);\n                    }\n                }\n                if uuid[0].is_alphabetic() {\n                    String::from_iter(uuid)\n                } else {\n                    self.name()\n                }\n            }\n            Named(name) =\u003e name.clone(),\n        }\n    }\n}\n\nimpl Iterator for NamingStrategy {\n    type Item = String;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        Some(self.name())\n    }\n}\n\nimpl Default for NamingStrategy {\n    fn default() -\u003e Self {\n        NamingStrategy::UuidV1\n    }\n}\n\nimpl From\u003c()\u003e for NamingStrategy {\n    fn from(_: ()) -\u003e Self {\n        NamingStrategy::default()\n    }\n}\n\nimpl From\u003c\u0026str\u003e for NamingStrategy {\n    fn from(s: \u0026str) -\u003e Self {\n        match s {\n            \"random\" =\u003e NamingStrategy::Random,\n            \"uuid-v1\" | \"uuidv1\" | \"UuidV1\" =\u003e NamingStrategy::UuidV1,\n            _ =\u003e NamingStrategy::Named(s.to_string()),\n        }\n    }\n}\nimpl From\u003cString\u003e for NamingStrategy {\n    fn from(s: String) -\u003e Self {\n        match s.as_str() {\n            \"random\" =\u003e NamingStrategy::Random,\n            \"uuid-v1\" | \"uuidv1\" | \"UuidV1\" =\u003e NamingStrategy::UuidV1,\n            _ =\u003e NamingStrategy::Named(s),\n        }\n    }\n}\n\n#[derive(Debug)]\n/// Used in [test(drop = \"\u003cstrategy\u003e\")] macro to make sure to drop before/after test.\npub enum DroppingStrategy {\n    None,\n    Before,\n    After,\n    Always,\n}\n\nimpl DroppingStrategy {\n    fn drop_after(\u0026self) -\u003e bool {\n        use DroppingStrategy::*;\n        matches!(self, After | Always)\n    }\n    fn drop_before(\u0026self) -\u003e bool {\n        use DroppingStrategy::*;\n        matches!(self, Before | Always)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for DroppingStrategy {\n    fn from(s: \u0026str) -\u003e Self {\n        match s.as_ref() {\n            \"none\" =\u003e DroppingStrategy::None,\n            \"before\" =\u003e DroppingStrategy::Before,\n            \"after\" =\u003e DroppingStrategy::After,\n            \"always\" =\u003e DroppingStrategy::Always,\n            _ =\u003e unreachable!(\"invalid drop strategy used in [test] macro\"),\n        }\n    }\n}\n\nimpl From\u003cString\u003e for DroppingStrategy {\n    fn from(s: String) -\u003e Self {\n        Self::from(s.as_str())\n    }\n}\n\nimpl From\u003c()\u003e for DroppingStrategy {\n    fn from(_: ()) -\u003e Self {\n        DroppingStrategy::default()\n    }\n}\n\nimpl Default for DroppingStrategy {\n    fn default() -\u003e Self {\n        DroppingStrategy::Always\n    }\n}\n\n#[derive(Debug)]\npub enum PrecisionStrategy {\n    Preset(Precision),\n    Random,\n    Cyclic,\n}\n\nimpl PrecisionStrategy {\n    fn precision(\u0026self) -\u003e Precision {\n        use PrecisionStrategy::*;\n        match self {\n            Preset(p) =\u003e p.clone(),\n            Random =\u003e {\n                //\n                use rand::rngs::ThreadRng;\n                use rand::Rng;\n                static mut RNG: Option\u003cThreadRng\u003e = None;\n                const ONCE: Once = Once::new();\n                ONCE.call_once(|| unsafe {\n                    RNG = Some(rand::thread_rng());\n                });\n                let rng = unsafe { RNG.as_mut().unwrap() };\n                rng.gen::\u003cu8\u003e().into()\n            }\n            Cyclic =\u003e {\n                static mut ITER: u64 = 0;\n                let p = match unsafe { ITER % 3 } {\n                    0 =\u003e Precision::Millisecond,\n                    1 =\u003e Precision::Microsecond,\n                    2 =\u003e Precision::Nanosecond,\n                    _ =\u003e unreachable!(),\n                };\n                unsafe { ITER += 1 };\n                p\n            }\n        }\n    }\n}\n\nimpl Iterator for PrecisionStrategy {\n    type Item = Precision;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        Some(self.precision())\n    }\n}\n\nimpl From\u003c()\u003e for PrecisionStrategy {\n    fn from(_: ()) -\u003e Self {\n        PrecisionStrategy::default()\n    }\n}\n\nimpl Default for PrecisionStrategy {\n    fn default() -\u003e Self {\n        PrecisionStrategy::Preset(Precision::Millisecond)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for PrecisionStrategy {\n    fn from(s: \u0026str) -\u003e Self {\n        PrecisionStrategy::from_str(s).expect(\u0026format!(\"invalid precision strategy: {}\", s))\n    }\n}\n\nimpl FromStr for PrecisionStrategy {\n    type Err = crate::Error;\n\n    fn from_str(s: \u0026str) -\u003e crate::Result\u003cSelf\u003e {\n        use PrecisionStrategy::*;\n        match Precision::from_str(s) {\n            Ok(p) =\u003e Ok(Preset(p)),\n            Err(_) =\u003e match s {\n                \"random\" =\u003e Ok(Random),\n                \"cyclic\" =\u003e Ok(Cyclic),\n                _ =\u003e Err(err!('str \"unsupported strategy {}\")),\n            },\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum LogLevel {\n    /// Default,\n    Default,\n    /// A level lower than all log levels.\n    Off,\n    /// Corresponds to the `Error` log level.\n    Error,\n    /// Corresponds to the `Warn` log level.\n    Warn,\n    /// Corresponds to the `Info` log level.\n    Info,\n    /// Corresponds to the `Debug` log level.\n    Debug,\n    /// Corresponds to the `Trace` log level.\n    Trace,\n}\n\nimpl LogLevel {\n    fn to_log_level_filter(\u0026self) -\u003e Option\u003clog::LevelFilter\u003e {\n        use LogLevel::*;\n        match self {\n            Default =\u003e None,\n            Off =\u003e Some(log::LevelFilter::Off),\n            Error =\u003e Some(log::LevelFilter::Error),\n            Warn =\u003e Some(log::LevelFilter::Warn),\n            Info =\u003e Some(log::LevelFilter::Info),\n            Debug =\u003e Some(log::LevelFilter::Debug),\n            Trace =\u003e Some(log::LevelFilter::Trace),\n        }\n    }\n}\nimpl Default for LogLevel {\n    fn default() -\u003e Self {\n        LogLevel::Default\n    }\n}\n\nimpl From\u003c\u0026str\u003e for LogLevel {\n    fn from(s: \u0026str) -\u003e Self {\n        use LogLevel::*;\n        match s {\n            \"off\" =\u003e Off,\n            \"error\" =\u003e Error,\n            \"warn\" =\u003e Warn,\n            \"info\" =\u003e Info,\n            \"debug\" =\u003e Debug,\n            \"trace\" =\u003e Trace,\n            _ =\u003e Off,\n        }\n    }\n}\n\nimpl From\u003c()\u003e for LogLevel {\n    fn from(_: ()) -\u003e Self {\n        Self::default()\n    }\n}\n\n#[derive(Debug, Default)]\npub struct Common {\n    log_level: LogLevel,\n}\n\nimpl Common {\n    pub fn log_level(mut self, level: impl Into\u003cLogLevel\u003e) -\u003e Self {\n        self.log_level = level.into();\n        self\n    }\n\n    pub fn init(\u0026self) -\u003e Result\u003c()\u003e {\n        println!(\"* common init started\");\n        static LOGGER_INIT: Once = Once::new();\n        LOGGER_INIT.call_once(|| {\n            let mut builder = pretty_env_logger::formatted_timed_builder();\n            if let Some(lv) = self.log_level.to_log_level_filter() {\n                builder.filter_level(lv);\n            } else {\n                if let Ok(s) = ::std::env::var(\"RUST_LOG\") {\n                    builder.parse_filters(\u0026s);\n                }\n            }\n            builder\n                .format_module_path(true)\n                .format(|buf, record| -\u003e std::result::Result\u003c(), std::io::Error\u003e {\n                    fn colored_level\u003c'a\u003e(\n                        style: \u0026'a mut pretty_env_logger::env_logger::fmt::Style,\n                        level: Level,\n                    ) -\u003e StyledValue\u003c'a, \u0026'static str\u003e {\n                        match level {\n                            Level::Trace =\u003e style.set_color(Color::Magenta).value(\"TRACE\"),\n                            Level::Debug =\u003e style.set_color(Color::Blue).value(\"DEBUG\"),\n                            Level::Info =\u003e style.set_color(Color::Green).value(\"INFO\"),\n                            Level::Warn =\u003e style.set_color(Color::Yellow).value(\"WARN \"),\n                            Level::Error =\u003e style.set_color(Color::Red).value(\"ERROR\"),\n                        }\n                    }\n                    let mut style = buf.style();\n                    let level = colored_level(\u0026mut style, record.level());\n                    let mut mod_path = buf.style();\n\n                    let mod_path = mod_path.set_bold(true).value(format!(\n                        \"{}:{}\",\n                        record.file().unwrap_or(\"unknown\"),\n                        record.line().unwrap_or(0),\n                    ));\n                    writeln!(\n                        buf,\n                        \"[{:29} {: \u003c5}] {} \u003e {}\",\n                        chrono::Local::now().format(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                        level,\n                        mod_path,\n                        record.args()\n                    )\n                })\n                // .is_test(true)\n                .init();\n        });\n        log::info!(\"common init done\");\n        Ok(())\n    }\n}\n#[derive(Debug, Default)]\n\npub struct Builder {\n    naming: NamingStrategy,\n    precision: PrecisionStrategy,\n    dropping: DroppingStrategy,\n    databases: usize,\n}\nimpl Builder {\n    pub fn new(\n        naming: impl Into\u003cNamingStrategy\u003e,\n        drop: impl Into\u003cDroppingStrategy\u003e,\n        precision: impl Into\u003cPrecisionStrategy\u003e,\n        databases: usize,\n    ) -\u003e Self {\n        Self {\n            naming: naming.into(),\n            precision: precision.into(),\n            dropping: drop.into(),\n            databases,\n        }\n    }\n\n    pub fn naming(mut self, naming: impl Into\u003cNamingStrategy\u003e) -\u003e Self {\n        self.naming = naming.into();\n        self\n    }\n    pub fn dropping(mut self, drop: impl Into\u003cDroppingStrategy\u003e) -\u003e Self {\n        self.dropping = drop.into();\n        self\n    }\n    pub fn precision(mut self, precision: impl Into\u003cPrecisionStrategy\u003e) -\u003e Self {\n        self.precision = precision.into();\n        self\n    }\n    pub fn databases(mut self, databases: usize) -\u003e Self {\n        self.databases = databases.into();\n        self\n    }\n\n    pub fn build(self) -\u003e Result\u003cTaosWrapper\u003e {\n        let opts = TaosOptions::new();\n        log::trace!(\"use options: {opts:#?}\");\n\n        let taos = opts.build()?;\n        log::info!(\"connected\");\n\n        let db: Vec\u003c_\u003e = self\n            .naming\n            .into_iter()\n            .zip(self.precision.into_iter())\n            .take(self.databases)\n            .collect();\n        let mut used = false;\n        for (name, precision) in \u0026db {\n            if self.dropping.drop_before() {\n                taos.exec(format!(\"drop database if exists {}\", name))?;\n            }\n            taos.exec(format!(\n                \"create database if not exists {} precision '{}' keep 36500\",\n                name, precision\n            ))?;\n            if !used {\n                taos.exec(format!(\"use {}\", name))?;\n                used = true;\n            }\n        }\n        Ok(TaosWrapper {\n            taos,\n            db,\n            drop: self.dropping,\n        })\n    }\n}\n\npub struct TaosWrapper {\n    taos: Taos,\n    db: Vec\u003c(String, Precision)\u003e,\n    drop: DroppingStrategy,\n}\n\nimpl Deref for TaosWrapper {\n    type Target = Taos;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.taos\n    }\n}\n\nimpl Drop for TaosWrapper {\n    fn drop(\u0026mut self) {\n        self.clean().unwrap();\n    }\n}\n\nimpl TaosWrapper {\n    pub fn taos(\u0026self) -\u003e \u0026Taos {\n        \u0026self.taos\n    }\n\n    pub fn databases_with_precision(\u0026self) -\u003e \u0026[(String, Precision)] {\n        \u0026self.db\n    }\n\n    pub fn databases(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.db.iter().map(|v| v.0.as_str()).collect()\n    }\n\n    pub fn default_database(\u0026self) -\u003e \u0026str {\n        \u0026self.db[0].0\n    }\n\n    fn clean(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.drop.drop_after() {\n            for (name, _) in \u0026self.db {\n                log::trace!(\"drop database: {}\", name);\n                self.taos\n                    .exec(format!(\"drop database if exists {}\", name))?;\n                log::trace!(\"dropped database: {}\", name);\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":21,"address":[3801008,3802275],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":23,"address":[3801047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3801093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[3754929,3754852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3803420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[3803474,3803564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3801134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3755041,3754964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[3801222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3801319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[3801428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[3801530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3801550,3801742,3801880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3801766,3801893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3802050,3801916,3801712,3802190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3802399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3802647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3802982,3802866,3802742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3802928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[3803214,3802710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[3803240,3802609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3803294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[3803279,3803367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3801188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3803872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":91,"address":[3803891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3803952],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":97,"address":[3803955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3803968],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":103,"address":[3803980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3804000],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":110,"address":[3804119,3804050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3804140,3804091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3804254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[3804639,3804320],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":118,"address":[3804347,3804419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3804506,3804435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3804533,3804478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3804672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3804768],"length":1,"stats":{"Line":0},"fn_name":"drop_after"},{"line":138,"address":[3804777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3804832],"length":1,"stats":{"Line":0},"fn_name":"drop_before"},{"line":142,"address":[3804841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[3804880],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":148,"address":[3804903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[3804928,3804992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[3805052,3804969,3805013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[3805102,3805029,3805063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[3805155,3805113,3805079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[3805360,3805264],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":160,"address":[3805273,3805332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3805392],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":166,"address":[3805396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3805424],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":172,"address":[3805428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3805440],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":186,"address":[3805454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3805508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[3755072,3755125],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":195,"address":[3755076,3755153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3805779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3805830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[3805562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3805667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[3805677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3805687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3805740,3805695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3805730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3805872],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":219,"address":[3805881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[3805920],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":225,"address":[3805924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[3805952],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":231,"address":[3805956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3805984,3806250],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":237,"address":[3806001,3806276,3806401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[3806782,3806432],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":246,"address":[3806475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[3806506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[3806549,3806661,3806617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3806633,3806730,3806691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3806750,3806697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[3806832],"length":1,"stats":{"Line":1},"fn_name":"to_log_level_filter"},{"line":278,"address":[3806841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[3806870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[3806881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3806892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3806903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[3806914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3806925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3806936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[3806960],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":291,"address":[3806964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[3806976],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":299,"address":[3807064,3807000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[3807121,3807082,3807041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[3807171,3807132,3807098],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[3807221,3807148,3807182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[3807235,3807198,3807274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[3807288,3807304,3807251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[3807294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3807328],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":312,"address":[3807332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[3286720,3286768],"length":1,"stats":{"Line":2},"fn_name":"log_level\u003c()\u003e"},{"line":323,"address":[3286731,3286809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[3286748,3286826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[3807360],"length":1,"stats":{"Line":1},"fn_name":"init"},{"line":328,"address":[3807380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[3755184,3755583,3755793],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":331,"address":[3755204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[3755694,3755286,3755228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[3755741,3755343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3755362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[3755460,3755548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[3755748,3755715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[3757217,3755824,3757345],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":342,"address":[3807712],"length":1,"stats":{"Line":0},"fn_name":"colored_level"},{"line":346,"address":[3807747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[3807903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[3807876,3807974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3808004,3807849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[3807819,3808034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[3807789,3808064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3755871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[3755976,3755893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[3755991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[3756386,3756051,3756242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[3756132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[3756317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[3756716,3757228,3756952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3756677,3756614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[3756927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[3807460,3807551,3807614],"length":1,"stats":{"Line":8},"fn_name":null},{"line":376,"address":[3807592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":414,"address":[3808220,3808096],"length":1,"stats":{"Line":0},"fn_name":"databases"},{"line":415,"address":[3808196,3808133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[3808200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[3811598,3808256,3809727],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":420,"address":[3808293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[3808377,3808563,3808657,3808466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[3808627,3808977,3808863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[3809209,3808933,3809436,3809306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[3809738,3809378,3809623,3809678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[3809558,3809666,3809705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[3809674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[3809765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[3809868,3810134,3809773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[3810497,3810170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[3810239,3810502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[3810703,3810201,3811087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[3811391,3810977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[3811396,3811137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[3811383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[3810014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[3809971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[3809979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3810011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[3811632],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":469,"address":[3723040],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":470,"address":[3723049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[3811648],"length":1,"stats":{"Line":0},"fn_name":"taos"},{"line":479,"address":[3811664],"length":1,"stats":{"Line":0},"fn_name":"databases_with_precision"},{"line":480,"address":[3811673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[3811712],"length":1,"stats":{"Line":0},"fn_name":"databases"},{"line":484,"address":[3757376,3757401],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":487,"address":[3811856],"length":1,"stats":{"Line":0},"fn_name":"default_database"},{"line":488,"address":[3811865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[3811936],"length":1,"stats":{"Line":0},"fn_name":"clean"},{"line":492,"address":[3811956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[3811998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[3812296,3812201,3812101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[3812582,3812755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[3812455,3812699,3812267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[3812661,3812860,3812800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[3811979],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":175},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","impls","asyncs.rs"],"content":"use std::ffi::c_void;\nuse std::os::raw::c_int;\n\nuse async_trait::async_trait;\n\nuse taos_query::common::*;\nuse taos_query::{AsyncFetchable, AsyncQueryable};\nuse taos_sys::DroppableRawRes;\n\nuse super::ResultSet;\nuse crate::util::IntoCStr;\nuse crate::Taos;\n\nimpl AsyncFetchable for ResultSet {\n    type BlockStream = crate::block::BlockStream;\n\n    #[inline]\n    fn affected_rows(\u0026self) -\u003e i32 {\n        self.raw.affected_rows()\n    }\n\n    #[inline]\n    fn precision(\u0026self) -\u003e Precision {\n        self.raw.precision()\n    }\n\n    #[inline]\n    fn fields(\u0026self) -\u003e \u0026[Field] {\n        \u0026self.raw.fields()\n    }\n\n    #[inline]\n    fn summary(\u0026self) -\u003e (usize, usize) {\n        use std::sync::atomic::Ordering::SeqCst;\n        (\n            self.summary.0.load(SeqCst) as _,\n            self.summary.1.load(SeqCst) as _,\n        )\n    }\n\n    #[inline]\n    fn block_stream(\u0026mut self) -\u003e Self::BlockStream {\n        crate::block::BlockStream::from_raw(self.raw.raw(), self.summary.clone())\n    }\n}\n\n#[async_trait]\nimpl\u003c'q\u003e AsyncQueryable\u003c'q\u003e for Taos {\n    type Error = super::Error;\n\n    type AsyncResultSet = ResultSet;\n\n    /// Query use taosc query_a API.\n    async fn query\u003cT: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cSelf::AsyncResultSet, Self::Error\u003e {\n        // todo(3.0): remove these line to use taos_query_a in async/await impl.\n        if crate::client_info().starts_with(\"3\") {\n            let raw = self.0.query(sql.as_ref())?;\n            return Ok(ResultSet::new(raw));\n        }\n        use tokio::sync::oneshot::{channel, Sender};\n        let (sender, rx) = channel::\u003cResult\u003cSelf::AsyncResultSet, taos_error::Error\u003e\u003e();\n\n        pub unsafe extern \"C\" fn async_query_callback(\n            param: *mut c_void,\n            ptr: *mut c_void,\n            code: c_int,\n        ) {\n            let sender = param as *mut Sender\u003c_\u003e;\n            let sender = Box::from_raw(sender);\n            let code = if code \u003e 0 { 0 } else { code };\n            let res = DroppableRawRes::from_ptr_with_code(ptr, code.into()).map(ResultSet::new);\n\n            log::trace!(\n                \"in async query callback, got TAOS_RES: {res:?}, will be send to:{sender:?}\"\n            );\n\n            sender.send(res).unwrap();\n            log::trace!(\"ptr: {ptr:#?}, code: {code}\");\n        }\n        self.0.query_a(\n            sql.as_ref().into_c_str().as_ptr(),\n            async_query_callback as _,\n            Box::into_raw(Box::new(sender)) as *mut _,\n        );\n        Ok(rx.await.unwrap()?)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use anyhow::Result;\n    use taos_macros::test;\n\n    #[test(log_level = \"info\")]\n    async fn async_query_de(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        use taos_query::{AsyncFetchable, AsyncQueryable};\n        taos.exec(\n            \"create table tb1 (ts timestamp, level tinyint, content varchar(100),\\\n             dnode_id int, dnode_ep varchar(100))\",\n        )\n        .await?;\n        taos.exec(\"insert into tb1 values(now, 1, '', 1, 'abc')\")\n            .await?;\n        let mut rs = \u003cTaos as AsyncQueryable\u003e::query(taos, \"select * from tb1\").await?;\n\n        assert!(rs.fields().len() == 5);\n        #[derive(Debug, serde::Deserialize)]\n        #[allow(dead_code)]\n        struct Record {\n            ts: String,\n            level: i8,\n            content: String,\n            dnode_id: i32,\n            dnode_ep: String,\n        }\n\n        use futures::prelude::stream::*;\n        use taos_query::BlockExt;\n        while let Some(block) = rs.block_stream().next().await {\n            let des = itertools::Itertools::collect_vec(\n                block.deserialize::\u003c(i64, i32, \u0026str, i32, String)\u003e().take(1),\n            );\n            log::info!(\"first row in block: {:?}\", des);\n        }\n        let (blocks, records) = rs.summary();\n        println!(\"total blocks: {}, total rows: {}\", blocks, records);\n        assert!(records \u003c= 10000);\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[3482160],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":19,"address":[3482169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[3482208],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":24,"address":[3482217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3482256],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":29,"address":[3482265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[3482320],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":36,"address":[3482334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3482379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3482464,3482639,3482611],"length":1,"stats":{"Line":0},"fn_name":"block_stream"},{"line":43,"address":[3482623,3482496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3783552,3783280],"length":1,"stats":{"Line":0},"fn_name":"query\u003calloc::string::String\u003e"},{"line":59,"address":[3997539,3997448,3994792,3994859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3997621,3997830,3997695,3995019,3994941,3995154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3998039,3995363,3995116,3997792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3995481,3994902,3997582,3998178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4011072,4012517,4012468],"length":1,"stats":{"Line":0},"fn_name":"async_query_callback"},{"line":71,"address":[4011109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4011133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4011162],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4011194,4011291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[4011531,4011345,4011434,4011700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[4011948,4011595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[4012098,4011974,4012183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3998594,3995901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3995703,3998202,3998396,3995584,3998277,3995505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[3998408,3995867,3998560,3995715],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3706047,3705342],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","impls","mod.rs"],"content":"use std::{\n    ffi::c_void,\n    slice,\n    sync::{atomic::AtomicU64, Arc},\n};\n\nuse bitvec_simd::BitVec;\nuse itertools::Itertools;\nuse mdsn::IntoDsn;\nuse taos_error::Code;\nuse thiserror::Error;\n\nuse taos_query::{common::*, Address, BlockExt, Dsn, DsnError, Fetchable, FromDsn, Queryable};\nuse taos_sys::{DroppableRawRes, RawRes, ffi::TAOS_RES};\n\nuse crate::{util::IntoCStr, Taos, TaosOptions};\n\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"Parse dsn error: {0}\")]\n    DsnError(#[from] DsnError),\n    #[error(\"Internal error: {0}\")]\n    Driver(#[from] taos_error::Error),\n    #[error(\"Deserialization error {0}\")]\n    Deserialize(#[from] serde::de::value::Error),\n    #[error(\"Invalid topic: {0}\")]\n    InvalidTopic(String),\n    #[error(\"Invalid database: {0}\")]\n    InvalidDatabase(String),\n    #[error(\"Error: {0}\")]\n    Custom(String),\n    #[error(transparent)]\n    Other(#[from] anyhow::Error),\n}\n\nimpl Error {\n    pub(crate) fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::Custom(format!(\"{msg}\"))\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: std::fmt::Display,\n    {\n        Error::Custom(format!(\"{msg}\"))\n    }\n}\n\n// A result should not be clone-able.\n// Result set live shorter than query lifetime.\n#[derive(Debug)]\npub struct ResultSet {\n    raw: DroppableRawRes,\n    independent: bool,\n    summary: Arc\u003c(AtomicU64, AtomicU64)\u003e,\n}\n\nimpl ResultSet {\n    pub(crate) fn from_ptr(ptr: *mut c_void) -\u003e Result\u003cSelf, taos_error::Error\u003e {\n        let raw = RawRes::from_ptr(ptr).map(DroppableRawRes::new)?;\n        Ok(ResultSet {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        })\n    }\n    pub(crate) fn from_ptr_with_code(\n        ptr: *mut c_void,\n        code: impl Into\u003cCode\u003e,\n    ) -\u003e Result\u003cSelf, taos_error::Error\u003e {\n        let raw = RawRes::from_ptr_with_code(ptr, code.into()).map(DroppableRawRes::new)?;\n        Ok(ResultSet {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        })\n    }\n\n    pub(crate) fn as_ptr(\u0026self) -\u003e *mut TAOS_RES {\n        self.raw.as_ptr()\n    }\n\n    pub(crate) fn from_raw_res(raw: RawRes) -\u003e Self {\n        Self {\n            raw: DroppableRawRes::new(raw),\n            independent: false,\n            summary: Default::default(),\n        }\n    }\n\n    pub(crate) fn new(raw: DroppableRawRes) -\u003e Self {\n        Self {\n            raw,\n            independent: false,\n            summary: Default::default(),\n        }\n    }\n\n    pub(crate) fn independent(mut self) -\u003e Self {\n        self.independent = true;\n        self\n    }\n\n    pub(crate) fn append_num_of_rows(\u0026self, num_of_rows: i32) {\n        use std::sync::atomic::Ordering::SeqCst;\n        self.summary.0.fetch_add(1, SeqCst);\n        self.summary.1.fetch_add(num_of_rows as _, SeqCst);\n    }\n}\n\n#[derive(Debug)]\npub struct SyncBlock {\n    pub raw: Arc\u003cRawRes\u003e,\n    pub fields: Option\u003cVec\u003cField\u003e\u003e,\n    pub precision: Precision,\n    pub data: *mut *mut c_void,\n    pub lengths: *const i32,\n    pub num_of_rows: usize,\n}\n\nunsafe impl Send for SyncBlock {}\nunsafe impl Sync for SyncBlock {}\n\nimpl SyncBlock {\n    pub fn tmq_table_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.raw.tmq_table_name()\n    }\n    pub fn tmq_db_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.raw.tmq_db_name()\n    }\n}\n\nimpl\u003c'b\u003e BlockExt for SyncBlock {\n    // type Value = BorrowedValue\u003c'b\u003e;\n\n    fn num_of_rows(\u0026self) -\u003e usize {\n        self.num_of_rows\n    }\n\n    fn fields(\u0026self) -\u003e \u0026[Field] {\n        if let Some(fields) = self.fields.as_ref() {\n            fields\n        } else {\n            \u0026self.raw.fields()\n        }\n    }\n\n    fn precision(\u0026self) -\u003e Precision {\n        self.precision\n    }\n\n    fn is_null(\u0026self, row: usize, col: usize) -\u003e bool {\n        self.raw.is_null(row as _, col as _)\n    }\n\n    unsafe fn cell_unchecked(\u0026self, row: usize, col: usize) -\u003e (\u0026Field, BorrowedValue) {\n        let inner = self.data.add(col);\n        // log::debug!(\"inner: {inner:?} at ({row}, {col})\");\n\n        let field = self.get_field_unchecked(col);\n        let is_null = self.is_null(row, col);\n        if is_null {\n            return (field, BorrowedValue::Null);\n        }\n\n        macro_rules! parse_cell {\n            ($f:ident, $t:ty) =\u003e {\n                paste::paste! {\n                    BorrowedValue::$f({\n                        (*inner as *const $t).add(row).read()\n                    })\n                }\n            };\n        }\n\n        let read_bytes_from_ptr = |inner: *mut *mut c_void, col: usize| {\n            if crate::client_info().starts_with(\"3\") {\n                let offsets = self.raw.get_column_data_offset(col);\n                let offset = offsets.add(row).read();\n                if offset == -1 {\n                    \"\".as_bytes()\n                } else {\n                    let ptr = (*inner as *const u8).add(offset as usize);\n                    let len = ptr.cast::\u003ci16\u003e().read();\n                    let start = ptr.offset(2);\n\n                    slice::from_raw_parts(start, len as _)\n                }\n            } else {\n                let length = *self.lengths.add(col) as usize;\n                let ptr = (*inner as *const u8).add(row * length as usize);\n                let len = ptr.cast::\u003ci16\u003e().read();\n                let start = ptr.offset(2);\n\n                slice::from_raw_parts(start, len as _)\n            }\n        };\n\n        let value = match field.ty() {\n            Ty::Null =\u003e BorrowedValue::Null,\n            Ty::Bool =\u003e parse_cell!(Bool, bool),\n            Ty::TinyInt =\u003e parse_cell!(TinyInt, i8),\n            Ty::SmallInt =\u003e parse_cell!(SmallInt, i16),\n            Ty::Int =\u003e parse_cell!(Int, i32),\n            Ty::BigInt =\u003e parse_cell!(BigInt, i64),\n            Ty::UTinyInt =\u003e parse_cell!(UTinyInt, u8),\n            Ty::USmallInt =\u003e parse_cell!(USmallInt, u16),\n            Ty::UInt =\u003e parse_cell!(UInt, u32),\n            Ty::UBigInt =\u003e parse_cell!(UBigInt, u64),\n            Ty::Float =\u003e parse_cell!(Float, f32),\n            Ty::Double =\u003e parse_cell!(Double, f64),\n            Ty::Timestamp =\u003e {\n                let raw = (*inner as *const i64).add(row).read();\n                let precision = self.precision();\n                BorrowedValue::Timestamp(Timestamp::new(raw, precision))\n            }\n            Ty::VarChar =\u003e BorrowedValue::VarChar(std::str::from_utf8_unchecked(\n                read_bytes_from_ptr(inner, col),\n            )),\n            Ty::NChar =\u003e BorrowedValue::NChar(\n                std::str::from_utf8_unchecked(read_bytes_from_ptr(inner, col)).into(),\n            ),\n            Ty::Json =\u003e BorrowedValue::Json(read_bytes_from_ptr(inner, col).into()),\n            _ =\u003e BorrowedValue::Null,\n        };\n        (field as _, value)\n    }\n\n    unsafe fn get_col_unchecked(\u0026self, col: usize) -\u003e BorrowedColumn {\n        let inner = self.data.add(col);\n        let field = self.get_field_unchecked(col);\n        let num_of_rows = self.num_of_rows() as usize;\n        let is_nulls =\n            BitVec::from_bool_iterator((0..num_of_rows as usize).map(|row| self.is_null(row, col)));\n\n        macro_rules! column_transmute {\n            ($f:ident, $t:ty) =\u003e {\n                paste::paste! {\n                    BorrowedColumn::$f(is_nulls, {\n                        std::slice::from_raw_parts(*inner as *const $t, num_of_rows)\n                    })\n                }\n            };\n        }\n        match field.ty() {\n            Ty::Null =\u003e BorrowedColumn::Null(num_of_rows),\n            Ty::Bool =\u003e column_transmute!(Bool, bool),\n            Ty::TinyInt =\u003e column_transmute!(TinyInt, i8),\n            Ty::SmallInt =\u003e column_transmute!(SmallInt, i16),\n            Ty::Int =\u003e column_transmute!(Int, i32),\n            Ty::BigInt =\u003e column_transmute!(BigInt, i64),\n            Ty::UTinyInt =\u003e column_transmute!(UTinyInt, u8),\n            Ty::USmallInt =\u003e column_transmute!(USmallInt, u16),\n            Ty::UInt =\u003e column_transmute!(UInt, u32),\n            Ty::UBigInt =\u003e column_transmute!(UBigInt, u64),\n            Ty::Float =\u003e column_transmute!(Float, f32),\n            Ty::Double =\u003e column_transmute!(Double, f64),\n            Ty::Timestamp =\u003e {\n                let raw = std::slice::from_raw_parts(*inner as *const i64, num_of_rows);\n                BorrowedColumn::Timestamp(is_nulls, raw)\n            }\n            Ty::VarChar =\u003e {\n                let length = self.lengths.add(col);\n                let item = (0..num_of_rows)\n                    .map(|n| {\n                        let ptr = (*inner as *const u8).offset(n as isize * *length as isize);\n                        let len = ptr.cast::\u003ci16\u003e().read();\n                        let start = ptr.offset(2);\n                        if is_nulls.get_unchecked(n) {\n                            None\n                        } else {\n                            Some(slice::from_raw_parts(start, len as _))\n                        }\n                    })\n                    .collect_vec();\n\n                BorrowedColumn::Binary(item)\n            }\n            Ty::NChar =\u003e {\n                let length = self.lengths.add(col);\n                let item = (0..num_of_rows)\n                    .map(|n| {\n                        let ptr = (*inner as *const u8).offset(n as isize * *length as isize);\n                        let len = ptr.cast::\u003ci16\u003e().read();\n                        let start = ptr.offset(2);\n                        if is_nulls.get_unchecked(n) {\n                            None\n                        } else {\n                            Some(std::str::from_utf8_unchecked(slice::from_raw_parts(\n                                start as _, len as _,\n                            )))\n                        }\n                    })\n                    .collect_vec();\n\n                BorrowedColumn::NChar(item)\n            }\n            _ =\u003e unreachable!(\"unsupported borrowed column type\"),\n        }\n    }\n}\n\nimpl Fetchable for ResultSet {\n    fn fields(\u0026self) -\u003e \u0026[Field] {\n        \u0026self.raw.fields()\n    }\n\n    fn precision(\u0026self) -\u003e Precision {\n        self.raw.precision()\n    }\n\n    fn summary(\u0026self) -\u003e (usize, usize) {\n        use std::sync::atomic::Ordering::SeqCst;\n        (\n            self.summary.0.load(SeqCst) as _,\n            self.summary.1.load(SeqCst) as _,\n        )\n    }\n\n    fn affected_rows(\u0026self) -\u003e i32 {\n        self.raw.affected_rows()\n    }\n}\n\nimpl Iterator for ResultSet {\n    type Item = SyncBlock;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if let Ok(Some((data, num_of_rows, lengths))) = self.raw.fetch_block() {\n            log::debug!(\"fetch block with {num_of_rows} rows\");\n            self.append_num_of_rows(num_of_rows);\n            let fields = if self.independent {\n                Some(self.raw.fetch_fields())\n            } else {\n                None\n            };\n\n            Some(SyncBlock {\n                raw: self.raw.raw(),\n                fields,\n                precision: self.precision(),\n                data,\n                lengths,\n                num_of_rows: num_of_rows as _,\n            })\n        } else {\n            None\n        }\n    }\n}\n\nimpl\u003c'r, 'q\u003e SyncBlock {\n    #[inline]\n    pub fn from_raw_with_ptr(\n        raw: Arc\u003cRawRes\u003e,\n        data: *mut *mut c_void,\n        num_of_rows: i32,\n    ) -\u003e Option\u003cSelf\u003e {\n        let precision = raw.precision();\n        if num_of_rows \u003e 0 {\n            let lengths = raw.fetch_lengths();\n            Some(SyncBlock {\n                raw,\n                data,\n                fields: None,\n                precision: precision,\n                lengths,\n                num_of_rows: num_of_rows as _,\n            })\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    pub fn from_async_query(\n        raw: Arc\u003cRawRes\u003e,\n        data: *mut *mut c_void,\n        num_of_rows: i32,\n    ) -\u003e Option\u003cSelf\u003e {\n        Self::from_raw_with_ptr(raw, data, num_of_rows)\n    }\n}\n\nimpl\u003c'q\u003e Queryable\u003c'q\u003e for Taos {\n    type Error = Error;\n\n    type ResultSet = ResultSet;\n\n    fn query\u003cT: AsRef\u003cstr\u003e\u003e(\u0026self, sql: T) -\u003e Result\u003cResultSet, Self::Error\u003e {\n        log::trace!(\"sql: {}\", sql.as_ref());\n        let raw = self.0.query(sql.as_ref())?;\n        Ok(ResultSet::new(raw))\n    }\n}\n\nimpl FromDsn for Taos {\n    type Err = Error;\n\n    fn hygienize(dsn: Dsn) -\u003e Result\u003c(Dsn, Vec\u003cAddress\u003e), DsnError\u003e {\n        if dsn.driver != \"taos\" {\n            return Err(DsnError::InvalidDriver(dsn.driver));\n        }\n        Ok((dsn, vec![]))\n    }\n\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let dsn = dsn.into_dsn()?;\n        if dsn.addresses.len() == 0 {\n            Ok(Taos::new(\n                (),\n                \u0026dsn.username,\n                \u0026dsn.password,\n                \u0026dsn.database,\n                0,\n            )?)\n        } else {\n            let Address { host, port, .. } = \u0026dsn.addresses[0];\n            Ok(Taos::new(\n                host,\n                \u0026dsn.username,\n                \u0026dsn.password,\n                \u0026dsn.database,\n                port.unwrap_or_default(),\n            )?)\n        }\n    }\n\n    fn ping(_dsn: \u0026Dsn) -\u003e Result\u003c(), Self::Err\u003e {\n        Ok(())\n    }\n}\n\n#[taos_macros::test(log_level = \"debug\")]\nfn show_databases(taos: \u0026Taos) -\u003e Result\u003c(), Error\u003e {\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, \"show databases\")?;\n\n    log::debug!(\"{rs:?}\");\n\n    let fields = rs.fields();\n\n    log::debug!(\"fields[{}]: {fields:?}\", fields.len());\n\n    let precision = rs.precision();\n    log::debug!(\"precision: {}\", precision);\n\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        name: String,\n        ntables: u64,\n    }\n\n    for record in rs.deserialize() {\n        let record: Record = record?;\n        println!(\"{record:?}\");\n    }\n\n    Ok(())\n}\n\n#[taos_macros::test(crate, log_level = \"trace\")]\nfn sync_query_on_non_queryable_sql(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, format!(\"use {database}\"))?;\n\n    assert!(rs.precision() == Precision::Millisecond); // `ms` is the default precision.\n    assert!(rs.fields().len() == 0);\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        ts: String,\n        level: i8,\n        content: String,\n        dnode_id: i32,\n        dnode_ep: String,\n    }\n\n    for record in rs.deserialize() {\n        let _: Record = record?;\n    }\n\n    // Queried 0 rows.\n    assert_eq!(rs.summary(), (0, 0));\n    Ok(())\n}\n\n#[taos_macros::test(crate, log_level = \"info\")]\nfn sync_query_de(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    let affected_rows = \u003cTaos as Queryable\u003e::exec(taos, \"use log\")?;\n    assert!(affected_rows == 0);\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, \"select * from log.logs limit 10000\")?;\n\n    assert!(rs.fields().len() == 5);\n    #[derive(Debug, serde::Deserialize)]\n    #[allow(dead_code)]\n    struct Record {\n        ts: String,\n        level: i8,\n        content: String,\n        dnode_id: i32,\n        dnode_ep: String,\n    }\n\n    for record in rs.deserialize() {\n        let _: Record = record?;\n    }\n    let (blocks, records) = rs.summary();\n    println!(\"total blocks: {}, total rows: {}\", blocks, records);\n    Ok(())\n}\n\n#[taos_macros::test(crate)]\nfn sync_query_block_de_ref(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    use itertools::Itertools;\n    let mut rs = \u003cTaos as Queryable\u003e::query(taos, \"select * from log.logs limit 10000\")?;\n\n    for block in \u0026mut rs {\n        let des = block\n            .deserialize::\u003c(i64, i32, \u0026str)\u003e()\n            .take(1)\n            .collect_vec();\n        log::info!(\"first row in block: {:?}\", des);\n    }\n\n    let (blocks, records) = rs.summary();\n    println!(\"total blocks: {}, total rows: {}\", blocks, records);\n    Ok(())\n}\n\n#[test]\nfn two_cluster() -\u003e Result\u003c(), Error\u003e {\n    return Ok(());\n    let t1 = TaosOptions::default().port(6030u16).build()?;\n    let d1: (i32, String) = t1.query_one(\"show dnodes\")?.unwrap();\n    let t2 = TaosOptions::default().port(16030u16).build()?;\n    let d2: (i32, String) = t2.query_one(\"show dnodes\")?.unwrap();\n    dbg!(\u0026d1, \u0026d2);\n    assert!(d1 != d2);\n    Ok(())\n}\n\npub(crate) mod asyncs;\n","traces":[{"line":37,"address":[3767856,3768105],"length":1,"stats":{"Line":0},"fn_name":"custom\u003calloc::string::String\u003e"},{"line":41,"address":[3767884,3767955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[3768630,3768144,3768370,3768400],"length":1,"stats":{"Line":0},"fn_name":"custom\u003ccore::fmt::Arguments\u003e"},{"line":50,"address":[3768490,3768230,3768427,3768172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3472304,3472707,3472728],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":65,"address":[3472466,3472329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3472619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3472427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3472448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3769138,3768672,3769117],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code\u003ci32\u003e"},{"line":76,"address":[3768876,3768720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3769029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3768837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3768858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3472768],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":85,"address":[3472777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3472816,3472943],"length":1,"stats":{"Line":0},"fn_name":"from_raw_res"},{"line":90,"address":[3472830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[3472861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3473082,3472976],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":100,"address":[3472999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3473120],"length":1,"stats":{"Line":0},"fn_name":"independent"},{"line":105,"address":[3473123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[3473127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3473152],"length":1,"stats":{"Line":0},"fn_name":"append_num_of_rows"},{"line":111,"address":[3473174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3473219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3473280],"length":1,"stats":{"Line":0},"fn_name":"tmq_table_name"},{"line":131,"address":[3473289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3473344],"length":1,"stats":{"Line":0},"fn_name":"tmq_db_name"},{"line":134,"address":[3473353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[3473408],"length":1,"stats":{"Line":0},"fn_name":"num_of_rows"},{"line":142,"address":[3473413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3473424],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":146,"address":[3473593,3473438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[3473486,3473583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[3473509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[3473600],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":154,"address":[3473605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[3473616],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":158,"address":[3473645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[3473712],"length":1,"stats":{"Line":0},"fn_name":"cell_unchecked"},{"line":162,"address":[3473775,3473842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3473866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[3473904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3473941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[3474018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3473963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3769239,3770249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[3769414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3769556,3769484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[3769577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3769645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[3769678,3769740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[3769753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3769838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3769856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[3769950,3769401,3769331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3770057,3769961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3770102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3770187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[3770205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[3473987,3474067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3474126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3474147,3476351,3474217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[3474300,3476309,3474230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3476264,3474313,3474387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3474474,3474400,3476222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[3474561,3474487,3476177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[3475721,3475069,3474999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[3475156,3475676,3475082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[3475169,3475634,3475243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3475256,3475330,3475589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[3474574,3476129,3474648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[3474735,3474661,3476081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3475895,3474830,3474904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[3475922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[3475948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[3476019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[3474756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[3475771,3474925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3475490,3475351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[3474113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[3475408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[3480169,3476400,3478323],"length":1,"stats":{"Line":0},"fn_name":"get_col_unchecked"},{"line":235,"address":[3476530,3476455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[3476546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[3476584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[3476622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3476750,3476816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3476927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[3480051,3476943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[3477030,3479933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[3479815,3477117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3477204,3479697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[3477291,3479579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[3477768,3478574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[3478462,3477849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[3477930,3478353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[3478011,3478214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[3477378,3479461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[3477465,3479343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[3477648,3478959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3478975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[3479093,3477560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3479101,3479169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3479129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[3770437,3770347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[3770482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[3770567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[3770688,3770585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[3770641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[3770678,3770619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3479247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3478699,3477691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3478707,3478775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[3478735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[3770827,3770737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[3770872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[3770957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[3770975,3771103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[3771031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3771013,3771068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[3771009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[3478853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[3480240],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":310,"address":[3480249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3480304],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":314,"address":[3480313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[3480352],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":320,"address":[3480366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3480411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[3480496],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":326,"address":[3480505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3480544,3481595,3481650],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":334,"address":[3480647,3481590,3480582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3480886,3480966,3480804,3480705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[3480949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[3481160,3481134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[3481167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[3481140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[3481469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[3481335,3481268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[3481343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[3481383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3481461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[3480640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[3481680,3482036],"length":1,"stats":{"Line":0},"fn_name":"from_raw_with_ptr"},{"line":364,"address":[3481726,3481809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[3481835,3481852,3482034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3481857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[3481953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[3481926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3481939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[3481951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[3481845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[3482112],"length":1,"stats":{"Line":0},"fn_name":"from_async_query"},{"line":386,"address":[3482138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[3781117,3780176,3781152,3782093],"length":1,"stats":{"Line":0},"fn_name":"query\u003c\u0026str\u003e"},{"line":396,"address":[3780462,3781187,3780293,3780375,3781272,3781351,3780216,3781430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[3780690,3780830,3781784,3780433,3781644,3781405],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[3780787,3782012,3781741,3781042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[3981035,3980320,3980705],"length":1,"stats":{"Line":0},"fn_name":"hygienize"},{"line":406,"address":[3980445,3980350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[3980526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[3981071,3980456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[3981488],"length":1,"stats":{"Line":0},"fn_name":"ping"},{"line":435,"address":[3981496],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":201},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","lib.rs"],"content":"use std::sync::Once;\n\npub use impls::Error;\npub use taos_error::{Code, Error as TaosError};\n\npub use taos_query as query;\nuse taos_sys::*;\n\nmacro_rules! err {\n    (custom $err:expr) =\u003e {\n        \u003ccrate::Error as ::serde::de::Error\u003e::custom($err)\n    };\n    ('str $err:expr) =\u003e {\n        \u003ccrate::Error as ::serde::de::Error\u003e::custom($err)\n    };\n}\n\n// pub mod timestamp;\n\nmod options;\n\npub use options::TaosOptions;\n\nmod util;\nuse util::*;\n\n// deprecated method.\nmod async_query;\n\npub mod helpers;\n\npub mod stream;\n\nmod result;\n\npub mod tmq;\n\nmod schemaless;\n\nmod impls;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, crate::impls::Error\u003e;\n\n#[derive(Debug)]\npub struct Taos(RawTaos);\n\nunsafe impl Send for Taos {}\nunsafe impl Sync for Taos {}\n\nimpl Taos {\n    fn new\u003c'a\u003e(\n        host: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        user: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        pass: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        db: impl Into\u003cNullableCStr\u003c'a\u003e\u003e,\n        port: u16,\n    ) -\u003e Result\u003cSelf\u003e {\n        Ok(Self(RawTaos::connect(\n            host.into().as_ptr(),\n            user.into().as_ptr(),\n            pass.into().as_ptr(),\n            db.into().as_ptr(),\n            port,\n        )?))\n    }\n\n    /// Asynchronously query with sql\n    // pub fn query\u003c'a, 'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'a\u003e,\n    // ) -\u003e impl Future\u003cOutput = Result\u003cTaosResult\u003c'query\u003e\u003e\u003e {\n    //     async_query::QueryFuture::new(self, sql)\n    // }\n\n    /// Query without result.\n    // pub async fn exec\u003c'a, 'query\u003e(\u0026'query self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cusize\u003e {\n    //     let res = self.query(sql).await?;\n    //     Ok(res.affected_rows() as _)\n    // }\n\n    // pub fn exec_sync\u003c'a, 'query\u003e(\u0026'query self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cusize\u003e {\n    //     futures::executor::block_on(self.exec(sql))\n    // }\n\n    // pub fn query_sync\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     futures::executor::block_on(self.query(sql))\n    // }\n\n    // pub fn query_sync2\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     futures::executor::block_on(self.query2(sql))\n    // }\n    // pub fn query_sync3\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     futures::executor::block_on(self.query3(sql))\n    // }\n    // pub async fn query2\u003c'a, 'q\u003e(\u0026'q self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cTaosResult\u003c'q\u003e\u003e {\n    //     // use tokio::sync::oneshot;\n    //     use oneshot::channel;\n    //     use oneshot::Sender;\n    //     // use std::sync::mpsc::channel;\n    //     // use std::sync::mpsc::Sender;\n    //     let (sender, rx) = channel();\n\n    //     pub unsafe extern \"C\" fn async_query_callback(\n    //         param: *mut c_void,\n    //         res: *mut c_void,\n    //         code: c_int,\n    //     ) {\n    //         assert!(code == 0);\n    //         // let _ = RawRes::from_ptr(res);\n    //         let v = TaosResult::try_from_ptr(res);\n    //         // let param = param as *mut CallbackArg;\n    //         // let args = Box::from_raw(param);\n    //         // let CallbackArg { sender } = *args;\n    //         // sender.send(v).unwrap();\n    //         let sender = param as *mut Sender\u003c_\u003e;\n    //         let sender = Box::from_raw(sender);\n\n    //         sender.send(v).unwrap();\n    //     }\n    //     // let args = CallbackArg { sender };\n    //     // let args = Box::new(args);\n    //     // let ptr = Box::pin(tx);\n    //     self.0.query_a(\n    //         sql.into_c_str().as_ptr(),\n    //         async_query_callback as _,\n    //         Box::into_raw(Box::new(sender)) as *mut _,\n    //     );\n    //     rx.await.unwrap()\n    //     // rx.await.map_err(|e| Error::from_string(format!(\"{}\", e)))\n    // }\n    // pub async fn query3\u003c'a, 'q\u003e(\u0026'q self, sql: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003cTaosResult\u003c'q\u003e\u003e {\n    //     // use tokio::sync::oneshot;\n    //     use tokio::sync::oneshot::channel;\n    //     use tokio::sync::oneshot::Sender;\n    //     // use std::sync::mpsc::channel;\n    //     // use std::sync::mpsc::Sender;\n    //     let (sender, rx) = channel();\n\n    //     pub unsafe extern \"C\" fn async_query_callback(\n    //         param: *mut c_void,\n    //         res: *mut c_void,\n    //         code: c_int,\n    //     ) {\n    //         assert!(code == 0);\n    //         // let _ = RawRes::from_ptr(res);\n    //         let v = TaosResult::try_from_ptr(res);\n    //         // let param = param as *mut CallbackArg;\n    //         // let args = Box::from_raw(param);\n    //         // let CallbackArg { sender } = *args;\n    //         // sender.send(v).unwrap();\n    //         let sender = param as *mut Sender\u003c_\u003e;\n    //         let sender = Box::from_raw(sender);\n\n    //         sender.send(v).unwrap();\n    //     }\n    //     // let args = CallbackArg { sender };\n    //     // let args = Box::new(args);\n    //     // let ptr = Box::pin(tx);\n    //     self.0.query_a(\n    //         sql.into_c_str().as_ptr(),\n    //         async_query_callback as _,\n    //         Box::into_raw(Box::new(sender)) as *mut _,\n    //     );\n    //     rx.await.unwrap()\n    //     // rx.await.map_err(|e| Error::from_string(format!(\"{}\", e)))\n    // }\n\n    // pub fn query_sync0\u003c'query\u003e(\n    //     \u0026'query self,\n    //     sql: impl IntoCStr\u003c'query\u003e,\n    // ) -\u003e Result\u003cTaosResult\u003c'query\u003e\u003e {\n    //     self.0\n    //         .query(sql.into_c_str().as_ptr())\n    //         .map(TaosResult::from_raw)\n    // }\n\n    pub(crate) fn as_raw(\u0026self) -\u003e *mut taos_sys::ffi::TAOS {\n        self.0.as_ptr()\n    }\n}\n\npub mod block;\n\npub fn client_info() -\u003e \u0026'static str {\n    static ONCE: Once = Once::new();\n    static mut VERSION: \u0026str = \"\";\n    ONCE.call_once(|| unsafe {\n        VERSION = RawTaos::version()\n            .to_str()\n            .expect(\"get client info should always be ok\");\n    });\n    unsafe { VERSION }\n}\npub mod stmt;\n\n#[cfg(feature = \"r2d2\")]\npub mod r2d2;\n\npub mod prelude {\n    //! Preludes for async/await queries.\n    //!\n    //! ```rust\n    //! use taos::prelude::*;\n    //! use tokio;\n    //!\n    //! #[tokio::main]\n    //! async fn main() -\u003e anyhow::Result\u003c()\u003e {\n    //!     let taos = TaosOptions::default().build()?;\n    //!     taos.exec(\"drop database if exists test_prelude\").await?;\n    //!     taos.exec(\"create database test_prelude precision 'us'\").await?;\n    //!     taos.exec(\"use test_prelude\").await?;\n    //!     taos.exec(\"create stable meters (ts timestamp, current float, voltage int, phase float) \\\n    //!                tags(gid int, location binary(16))\").await?;\n    //!     let count: u32 = taos.query_one(\"select count(*) from meters\").await?.unwrap_or(0);\n    //!     assert!(count == 0);\n    //!\n    //!     let results = taos.query(\"select * from meters\").await?;\n    //!     assert!(results.precision() == \"us\");\n    //!     assert_eq!(results.num_of_fields(), 6);\n    //!     Ok(())\n    //! }\n    //! ```\n    pub use crate::impls::Error;\n    pub use crate::impls::ResultSet;\n    pub use crate::impls::SyncBlock;\n    pub use crate::options::TaosOptions;\n    pub use crate::query::FromDsn;\n    pub use crate::schemaless::{SchemalessPrecision, SchemalessProtocol};\n    pub use crate::stmt::{TaosBind, TaosMultiBind};\n    pub use crate::Taos;\n    pub use taos_query::common::{Precision, Timestamp, Ty, Value};\n    pub use taos_query::{common, AsyncFetchable, AsyncQueryable, BlockCodec, BlockExt};\n\n    #[cfg(feature = \"r2d2\")]\n    pub use crate::r2d2::TaosPool;\n\n    pub type Manager = taos_query::Manager\u003cTaos\u003e;\n\n    #[cfg(feature = \"r2d2\")]\n    pub type Pool = taos_query::Pool\u003cTaos\u003e;\n\n    pub mod sync {\n\n        pub use crate::impls::Error;\n        pub use crate::impls::ResultSet;\n        pub use crate::impls::SyncBlock;\n        pub use crate::options::TaosOptions;\n        pub use crate::query::FromDsn;\n        pub use crate::schemaless::{SchemalessPrecision, SchemalessProtocol};\n        pub use crate::stmt::{TaosBind, TaosMultiBind};\n        pub use crate::Taos;\n        // pub use mdsn::{Dsn, IntoDsn};\n\n        pub use taos_query::common::{Precision, Timestamp, Ty, Value};\n        pub use taos_query::{common, BlockCodec, BlockExt, Fetchable, Queryable};\n\n        #[cfg(feature = \"r2d2\")]\n        pub use crate::r2d2::TaosPool;\n\n        pub type Manager = taos_query::Manager\u003cTaos\u003e;\n\n        #[cfg(feature = \"r2d2\")]\n        pub type Pool = taos_query::Pool\u003cTaos\u003e;\n    }\n}\n#[cfg(feature = \"test\")]\npub use taos_macros::test;\n\n// pub use taos_query::BlockExt;\n#[cfg(test)]\nmod tests {\n    use super::{client_info, Taos, TaosOptions};\n    use taos_macros::test;\n\n    use crate::prelude::*;\n    use anyhow::Result;\n\n    #[test]\n    fn test_invalid_database() {\n        let res = TaosOptions::default().database(\"invalid_database\").build();\n        assert!(res.is_err());\n\n        let err = res.unwrap_err();\n        dbg!(err);\n    }\n\n    #[test(log_level = \"trace\")]\n    async fn test_information_schema(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n        let info: Vec\u003cValue\u003e = taos\n            .query_one(\"select * from information_schema.user_databases where name like 'infor%'\")\n            .await?\n            .unwrap();\n        dbg!(info);\n        Ok(())\n    }\n    #[test]\n    async fn test_describe(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n        let desc = taos.describe(\"log.logs\").await?;\n        dbg!(desc);\n        Ok(())\n    }\n    #[tokio::test]\n    async fn test_databases() -\u003e Result\u003c()\u003e {\n        let taos = TaosOptions::new().build()?;\n        let desc = taos.databases().await?;\n        println!(\"done\");\n        dbg!(desc);\n        Ok(())\n    }\n    #[test(crate)]\n    fn test_client_info() {\n        let version = client_info();\n        dbg!(format!(\"{version}\"));\n    }\n\n    #[test(crate)]\n    fn test_err() {\n        fn err_with_res() -\u003e Result\u003c()\u003e {\n            let taos = Taos::new(\n                \"localhost\",\n                std::ptr::null() as *const i8,\n                \"taosdata\",\n                std::ptr::null() as *const i8,\n                0,\n            )?;\n            taos.query_sync(\"select * from log.logs\")?;\n            Ok(())\n        }\n        err_with_res().unwrap();\n    }\n    #[test(crate)]\n    fn query_async_await_future_test() {\n        tokio::runtime::Builder::new_multi_thread()\n            .enable_all()\n            .build()\n            .unwrap()\n            .block_on(async {\n                let taos = Taos::new(\"localhost\", \"root\", \"taosdata\", \"log\", 0).unwrap();\n                let mut res = taos\n                    .query(\"select * from log.logs limit 10000\")\n                    .await\n                    .unwrap();\n                let stream = res.block_stream();\n\n                use futures::stream::StreamExt;\n                let lengths = stream\n                    .enumerate()\n                    .map(|(bi, partial)| {\n                        partial\n                            .iter_rows()\n                            .enumerate()\n                            .map(|(ri, values)| {\n                                println!(\"block {bi}, row {ri}: {values:?}\");\n                                return 1;\n                            })\n                            .sum::\u003cusize\u003e()\n                    })\n                    .fold(0, |acc, n| futures::future::ready(acc + n))\n                    .await;\n                println!(\"lengths is {lengths}\");\n            });\n    }\n}\n","traces":[{"line":51,"address":[3782985,3782128,3783151],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026core::option::Option\u003calloc::string::String\u003e, \u0026core::option::Option\u003calloc::string::String\u003e, \u0026core::option::Option\u003calloc::string::String\u003e, \u0026core::option::Option\u003calloc::string::String\u003e\u003e"},{"line":58,"address":[3782209,3782913,3782698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3782317,3782257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3782387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3782484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3782581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3981520],"length":1,"stats":{"Line":0},"fn_name":"as_raw"},{"line":187,"address":[3981529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[3981552],"length":1,"stats":{"Line":0},"fn_name":"client_info"},{"line":196,"address":[3783168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":197,"address":[3783172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3981573],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","options.rs"],"content":"use std::{\n    collections::BTreeMap,\n    ffi::{CStr, CString},\n    path::PathBuf,\n    sync::Once,\n};\n\nuse crate::{Result, Taos};\n\nuse taos_sys::*;\n\n#[derive(Debug, Default)]\npub struct TaosOptions {\n    pub(crate) host: Option\u003cString\u003e,\n    pub(crate) port: Option\u003cu16\u003e, // make it optional with concern for REST.\n    pub(crate) username: Option\u003cString\u003e,\n    pub(crate) password: Option\u003cString\u003e,\n    pub(crate) database: Option\u003cString\u003e,\n\n    locale: Option\u003cString\u003e,\n    charset: Option\u003cString\u003e,\n    timezone: Option\u003cString\u003e,\n    config_dir: Option\u003cPathBuf\u003e,\n    shell_activity_timer: Option\u003cu16\u003e,\n    pub(crate) params: BTreeMap\u003cString, String\u003e,\n}\n\nmacro_rules! _build_opt {\n    ($option:ident) =\u003e {\n        _build_opt!($option, String);\n    };\n    ($option:ident, $ty:ty) =\u003e {\n        pub fn $option\u003cT: Into\u003c$ty\u003e\u003e(mut self, $option: T) -\u003e Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n    ($option:ident, $setter:block) =\u003e {\n        pub fn $option\u003cT: Into\u003cString\u003e\u003e(mut self, $option: T) -\u003e Self {\n            $setter;\n            self\n        }\n    };\n    ($option:ident, $ty:ty, $setter:block) =\u003e {\n        pub fn $option\u003cT: Into\u003c$ty\u003e\u003e(mut self, $option: T) -\u003e Self {\n            let $option = $option.into();\n            $setter;\n            self.$option = Some($option);\n            self\n        }\n    };\n}\n\n#[test]\nfn test_options() {\n    let opts = TaosOptions::parse(\"taos+driver:///db\");\n    dbg!(opts);\n}\nimpl TaosOptions {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n    pub fn parse(dsn: \u0026str) -\u003e Result\u003cSelf\u003e {\n        if dsn.is_empty() {\n            return Ok(Self::new());\n        }\n        let dsn = url::Url::parse(dsn).unwrap();\n        dbg!(dsn);\n        Ok(Self::default())\n    }\n    _build_opt!(host);\n    _build_opt!(username);\n    _build_opt!(password);\n    _build_opt!(database);\n    _build_opt!(port, u16);\n\n    _build_opt!(locale, String, {\n        let cstr = CString::new(locale.clone()).expect(\"invalid locale\");\n        unsafe { taos_options(TSDB_OPTION_LOCALE, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(charset, String, {\n        let cstr = CString::new(charset.clone()).expect(\"invalid charset\");\n        unsafe { taos_options(TSDB_OPTION_CHARSET, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(timezone, String, {\n        let cstr = CString::new(timezone.clone()).expect(\"invalid timezone\");\n        unsafe { taos_options(TSDB_OPTION_TIMEZONE, cstr.as_c_str().as_ptr() as _) };\n    });\n    _build_opt!(config_dir, PathBuf, {\n        let config_dir = config_dir\n            .canonicalize()\n            .expect(\"invalid path for config dir\");\n        let cstr = CString::new(config_dir.to_string_lossy().as_bytes()).expect(\"path to c string\");\n        unsafe { taos_options(TSDB_OPTION_CONFIGDIR, cstr.as_c_str().as_ptr() as _) };\n    });\n\n    _build_opt!(shell_activity_timer, u16, {\n        let cstr = CString::new(format!(\"{}\", shell_activity_timer))\n            .expect(\"invalid shell activity timer\");\n        unsafe {\n            taos_options(\n                TSDB_OPTION_SHELL_ACTIVITY_TIMER,\n                cstr.as_c_str().as_ptr() as _,\n            )\n        };\n    });\n\n    pub fn set_config_json(\u0026self, json: \u0026str) {\n        let c_str = CString::new(json).expect(\"json to c string\");\n        unsafe {\n            let res = taos_set_config(c_str.as_ptr());\n            if res.code != SET_CONF_RET_SUCC {\n                let msg = CStr::from_ptr(\u0026res.msg as _);\n                panic!(\"set config failed: {}\", msg.to_string_lossy());\n            }\n        }\n    }\n\n    pub fn set_param(\u0026mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e \u0026mut Self {\n        self.params.insert(key.into(), value.into());\n        self\n    }\n\n    pub fn build(\u0026self) -\u003e Result\u003cTaos\u003e {\n        static SET_CONFIG: Once = Once::new();\n        SET_CONFIG.call_once(|| {\n            // println!(\"initialize taos options\");\n            if !self.params.is_empty() {\n                let json = serde_json::to_string(\u0026self.params).expect(\"params to json\");\n                self.set_config_json(\u0026json);\n            }\n        });\n\n        Taos::new(\n            \u0026self.host,\n            \u0026self.username,\n            \u0026self.password,\n            \u0026self.database,\n            self.port.unwrap_or(0),\n        )\n    }\n}\n\n#[test]\nfn test_options_builder() {\n    let opts = TaosOptions::new();\n    let _taos = opts.build().unwrap();\n}\n\n#[test]\nfn test_options_builder_all() {\n    use crate::prelude::*;\n    let opts = TaosOptions::new()\n        .locale(\"en_US\")\n        .charset(\"UTF-8\")\n        .timezone(\"Asia/Chongqing\")\n        .config_dir(\"/etc/taos\")\n        .host(\"localhost\")\n        .port(6030u16)\n        .username(\"root\")\n        .password(\"taosdata\");\n    let taos = opts.build().unwrap();\n    let _res = futures::executor::block_on(taos.query(\"show databases\")).unwrap();\n}\n","traces":[{"line":60,"address":[3606992],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":61,"address":[3607000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3607024,3607925],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":64,"address":[3607101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3607157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[3607142,3607232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3607261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[3607951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[3608491,3608016],"length":1,"stats":{"Line":0},"fn_name":"set_config_json"},{"line":109,"address":[3608047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3608106,3608174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3608207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[3608260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[3608308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3608528],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":126,"address":[3608552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3962670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3962707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3962837,3962774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[3608587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3608595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[3608607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3608619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3608631],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","r2d2.rs"],"content":"use super::{Error, Result, Taos, TaosOptions};\n\n/// Connection pool with r2d2.\npub type TaosPool = r2d2::Pool\u003cTaosOptions\u003e;\n\nimpl r2d2::ManageConnection for TaosOptions {\n    type Connection = Taos;\n    type Error = Error;\n\n    fn connect(\u0026self) -\u003e Result\u003cSelf::Connection\u003e {\n        self.build()\n    }\n\n    fn is_valid(\u0026self, _: \u0026mut Self::Connection) -\u003e Result\u003c()\u003e {\n        Ok(())\n    }\n\n    fn has_broken(\u0026self, _: \u0026mut Self::Connection) -\u003e bool {\n        false\n    }\n}\n\n#[test]\nfn test_r2d2() {\n    use crate::prelude::*;\n    use std::sync::mpsc::channel;\n    use std::thread;\n\n    let opts = TaosOptions::new();\n    let pool = TaosPool::builder().build(opts).expect(\"\");\n    let (tx, rx) = channel();\n    for _ in 0..4 {\n        let tx = tx.clone();\n        let pool = pool.clone();\n        thread::spawn(move || {\n            let taos = pool.get().unwrap();\n            let _ = taos.query_sync(\"show connections\").unwrap().affected_rows();\n            tx.send(10).unwrap();\n        });\n    }\n    for _ in 0..4 {\n        let j = rx.recv().unwrap();\n        println!(\"res: {j}\");\n    }\n}\n","traces":[{"line":10,"address":[3608720],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":11,"address":[3608737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[3608768],"length":1,"stats":{"Line":0},"fn_name":"is_valid"},{"line":15,"address":[3608784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3608800],"length":1,"stats":{"Line":0},"fn_name":"has_broken"}],"covered":0,"coverable":5},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","result.rs"],"content":"// // use block::Row;\n// use futures::Stream;\n// use serde::de::DeserializeOwned;\n\n// use taos_sys::{ffi::*, DroppableRawRes as RawRes, *};\n\n// use crate::*;\n\n// #[derive(Debug)]\n// pub enum TaosResult\u003c'a\u003e {\n//     WithFields(RawRes\u003c'a\u003e),\n//     WithoutFields(RawRes\u003c'a\u003e),\n// }\n\n// unsafe impl\u003c'a\u003e Send for TaosResult\u003c'a\u003e {}\n// unsafe impl\u003c'a\u003e Sync for TaosResult\u003c'a\u003e {}\n\n// impl\u003c'a\u003e TaosResult\u003c'a\u003e {\n//     pub(crate) const fn as_raw(\u0026self) -\u003e \u0026RawRes {\n//         match self {\n//             TaosResult::WithFields(res) =\u003e res,\n//             TaosResult::WithoutFields(res) =\u003e res,\n//         }\n//     }\n//     pub(crate) fn from_raw(raw: RawRes\u003c'a\u003e) -\u003e Self {\n//         match raw.num_fields() {\n//             0 =\u003e TaosResult::WithoutFields(raw),\n//             _ =\u003e TaosResult::WithFields(raw),\n//         }\n//     }\n\n//     pub(crate) fn new(result: *mut TAOS_RES, code: i32) -\u003e Result\u003cSelf\u003e {\n//         if code \u003c 0 {\n//             let code: Code = (code \u0026 0xffff).into();\n//             RawRes::from_ptr_with_code(result, code).map(Self::from_raw)\n//         } else {\n//             RawRes::from_ptr_with_code(result, Code::Success).map(Self::from_raw)\n//         }\n//     }\n\n//     pub fn num_of_fields(\u0026self) -\u003e usize {\n//         self.as_raw().fields().len()\n//     }\n\n//     pub fn precision(\u0026self) -\u003e Precision {\n//         self.as_raw().precision()\n//     }\n\n//     pub fn affected_rows(\u0026self) -\u003e usize {\n//         self.as_raw().affected_rows() as _\n//     }\n\n//     pub fn block_stream(\u0026self) -\u003e block::BlockStream {\n//         block::BlockStream::from_raw(self.as_raw().raw(), Default::default())\n//     }\n\n//     pub fn deserialize_stream\u003c'b, T: 'a + 'b\u003e(\n//         \u0026self,\n//     ) -\u003e impl Stream\u003cItem = std::result::Result\u003cT, serde::de::value::Error\u003e\u003e + '_\n//     where\n//         T: DeserializeOwned,\n//     {\n//         use futures::StreamExt;\n//         use taos_query::BlockExt;\n//         self.block_stream()\n//             .flat_map(|block| futures::stream::iter(block.deserialize_into_vec()))\n//     }\n// }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","schemaless.rs"],"content":"use crate::{taos_schemaless_insert, IntoCStr, Taos};\nuse taos_error::*;\n\nuse itertools::Itertools;\n\npub use taos_sys::{SchemalessPrecision, SchemalessProtocol};\n\nimpl Taos {\n    /// Schemaless insert with different protocol and timestamp precision.\n    ///\n    /// - InfluxDB line protocol\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [\"st,t1=abc,t2=def,t3=anything c1=3i64,c3=L\\\"pass\\\",c2=false,c4=4f64 1626006833639000000\"];\n    ///     taos.schemaless_insert(\u0026lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_NANOSECONDS)?;\n    ///     ```\n    ///\n    /// - OpenTSDB telnet protocol\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [\"sys.if.bytes.out 1479496100 1.3E3 host=web01 interface=eth0\"];\n    ///     taos.schemaless_insert(\u0026lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n    ///     ```\n    ///\n    /// - or OpenTSDB json protocol.\n    ///\n    ///     ```ignore,rust\n    ///     let lines = [r#\"\n    ///         {\n    ///             \"metric\":   \"st\",\n    ///             \"timestamp\":        1626006833,\n    ///             \"value\":    10,\n    ///             \"tags\":     {\n    ///                 \"t1\":   true,\n    ///                 \"t2\":   false,\n    ///                 \"t3\":   10,\n    ///                 \"t4\":   \"123_abc_.!@#$%^\u0026*:;,./?|+-=()[]{}\u003c\u003e\"\n    ///             }\n    ///         }\"#];\n    ///     taos.schemaless_insert(\u0026lines, TSDB_SML_LINE_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n    ///     ```\n    ///\n    pub fn schemaless_insert\u003c'a, T: IntoCStr\u003c'a\u003e\u003e(\n        \u0026self,\n        lines: impl IntoIterator\u003cItem = T\u003e,\n        protocol: SchemalessProtocol,\n        precision: SchemalessPrecision,\n    ) -\u003e Result\u003ci32\u003e {\n        let lines: Vec\u003c_\u003e = lines.into_iter().map(|line| line.into_c_str()).collect();\n        let mut lines = lines\n            .iter()\n            .map(|line| line.as_ptr() as *mut i8)\n            .collect_vec();\n        let lines = lines.as_mut_slice();\n        unsafe {\n            let res = taos_schemaless_insert(\n                self.as_raw(),\n                lines.as_mut_ptr() as *mut *mut i8,\n                lines.len() as _,\n                protocol,\n                precision,\n            );\n\n            taos_sys::RawRes::from_ptr(res).map(|res| res.affected_rows())\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::schemaless::*;\n\n    use crate::prelude::*;\n\n    use anyhow::Result;\n    use taos_sys::TSDB_SML_JSON_PROTOCOL;\n    use taos_sys::TSDB_SML_LINE_PROTOCOL;\n    use taos_sys::TSDB_SML_TELNET_PROTOCOL;\n    use taos_sys::TSDB_SML_TIMESTAMP_SECONDS;\n\n    #[crate::test]\n    /// Test schemaless insert with InfluxDB line protocol\n    async fn line_insert(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        let lines = [\"st,t1=abc c1=3i64,c3=\\\"def\\\",c2=false 1626006833639000000\"];\n        // let lines = [\"st,t1=abc c1=3i64,c2=false,c3=L\\\"def\\\" 1626006833639000000\"];\n        let res = taos.schemaless_insert(\n            \u0026lines,\n            TSDB_SML_LINE_PROTOCOL,\n            SchemalessPrecision::Nanoseconds,\n        )?;\n        assert_eq!(res, 1);\n\n        let res = taos.query(\"select * from st\").await?.to_records();\n        println!(\"{res:?}\");\n        Ok(())\n    }\n\n    #[crate::test]\n    /// Test schemaless insert with OpenTSDB telnet protocol\n    async fn telnet_insert(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        let lines = [\n            \"sys.if.bytes.out 1479496100 1.3E3 host=web01 interface=eth0\",\n            \"sys.if.bytes.out 1479496200 1.4E3 host=web02 interface=eth1\",\n            \"sys.if.bytes.out 1479496300 2.1E3 host=web03 interface=eth2\",\n            \"sys.if.bytes.out 1479496400 3.5E3 host=web04 interface=eth3\",\n        ];\n\n        let res =\n            taos.schemaless_insert(\u0026lines, TSDB_SML_TELNET_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n        assert_eq!(res, 4);\n\n        let res = taos.query(\"select * from `sys.if.bytes.out`\").await?;\n        println!(\"{res:?}\");\n        Ok(())\n    }\n\n    #[crate::test]\n    /// Test schemaless insert with OpenTSDB json protocol\n    async fn json_insert(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        let lines = [r#\"\n        {\n            \"metric\":   \"st\",\n            \"timestamp\":        1626006833,\n            \"value\":    10,\n            \"tags\":     {\n                \"t1\":   true,\n                \"t2\":   false,\n                \"t3\":   10,\n                \"t4\":   \"123_abc_.!@#$%^\u0026*:;,./?|+-=()[]{}\u003c\u003e\"\n            }\n        }\"#];\n        let _: serde_json::Value = serde_json::from_str(lines[0]).unwrap();\n\n        let res =\n            taos.schemaless_insert(\u0026lines, TSDB_SML_JSON_PROTOCOL, TSDB_SML_TIMESTAMP_SECONDS)?;\n        assert_eq!(res, 1);\n\n        let res = taos.query(\"select * from st\").await?;\n        println!(\"{res:?}\");\n\n        Ok(())\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","bind.rs"],"content":"use crate::util::IntoCStr;\n\nuse taos_query::common::Ty;\nuse taos_sys::*;\n\nuse chrono::{DateTime, NaiveDateTime};\nuse paste::paste;\n\nuse std::os::raw::{c_int, c_void};\nuse std::ptr;\nuse std::time::SystemTime;\n\n#[repr(transparent)]\npub struct BindParam(TaosBindV2);\n\nunsafe impl std::marker::Send for BindParam {}\nunsafe impl std::marker::Sync for BindParam {}\n\npub trait IntoBindParam {\n    fn into_bind_param(self) -\u003e BindParam;\n}\n\nimpl IntoBindParam for BindParam {\n    fn into_bind_param(self) -\u003e BindParam {\n        self\n    }\n}\nimpl BindParam {\n    pub fn new(buffer_type: Ty) -\u003e Self {\n        let buffer: *mut c_void = ptr::null_mut();\n        let length: *mut usize = ptr::null_mut();\n        let is_null: *mut c_int = ptr::null_mut();\n        let error: *mut c_int = ptr::null_mut();\n        Self(TaosBindV2 {\n            buffer_type: buffer_type as _,\n            buffer,\n            buffer_length: 0,\n            length,\n            is_null,\n            is_unsigned: 0,\n            error,\n            allocated: 0,\n            u: TaosBindUnionV2 { ts: 0 },\n        })\n    }\n    pub fn null() -\u003e Self {\n        let mut null = Self::new(Ty::Null);\n        let v = Box::new(1i8);\n        null.0.is_null = Box::into_raw(v) as _;\n        null\n    }\n\n    unsafe fn free(\u0026mut self) {\n        if !self.0.buffer.is_null() {\n            Vec::from_raw_parts(self.0.buffer as _, *self.0.length, *self.0.length);\n        }\n        if !self.0.length.is_null() {\n            Box::from_raw(self.0.length);\n        }\n        if !self.0.is_null.is_null() {\n            Box::from_raw(self.0.is_null);\n        }\n        if !self.0.error.is_null() {\n            Box::from_raw(self.0.error);\n        }\n    }\n}\n\nimpl Drop for BindParam {\n    fn drop(\u0026mut self) {\n        unsafe { self.free() }\n    }\n}\n\nmacro_rules! _impl_primitive_into_bind_param {\n    ($ty:ty, $target:ident, $v:expr) =\u003e {\n        impl IntoBindParam for $ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                let mut param = BindParam::new(Ty::$target);\n                param.0.buffer_length = std::mem::size_of::\u003c$ty\u003e();\n                let v = Box::new(self);\n                param.0.buffer = Box::into_raw(v) as _;\n                let l = Box::new(param.0.buffer_length);\n                param.0.length = Box::into_raw(l) as _;\n                param\n            }\n        }\n        impl IntoBindParam for \u0026$ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (*self).into_bind_param()\n            }\n        }\n        impl IntoBindParam for \u0026\u0026$ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (*self).into_bind_param()\n            }\n        }\n        paste! {\n            #[std::prelude::v1::test]\n            // #[proc_test_catalog::test_catalogue]\n            #[doc = \"Test bind param for type: \" $ty \" =\u003e \" $target]\n            fn [\u003ctest_ $ty:snake\u003e]() {\n                let v: $ty = $v;\n                let p = v.into_bind_param();\n                let v2 = unsafe { *(p.0.buffer as *const $ty) };\n                assert!(v == v2);\n            }\n        }\n    };\n}\nmacro_rules! _impl_ref_into_bind_param {\n    ($ty:ty) =\u003e {\n        impl IntoBindParam for $ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (\u0026self).into_bind_param()\n            }\n        }\n        impl IntoBindParam for \u0026\u0026$ty {\n            fn into_bind_param(self) -\u003e BindParam {\n                (*self).into_bind_param()\n            }\n        }\n    };\n}\n\nimpl\u003cT: IntoBindParam\u003e IntoBindParam for Option\u003cT\u003e {\n    fn into_bind_param(self) -\u003e BindParam {\n        match self {\n            None =\u003e BindParam::null(),\n            Some(v) =\u003e v.into_bind_param(),\n        }\n    }\n}\n\nimpl\u003cT: IntoBindParam, E: std::error::Error\u003e IntoBindParam for std::result::Result\u003cT, E\u003e {\n    fn into_bind_param(self) -\u003e BindParam {\n        match self {\n            Err(_) =\u003e BindParam::null(),\n            Ok(v) =\u003e v.into_bind_param(),\n        }\n    }\n}\n\nimpl IntoBindParam for bool {\n    fn into_bind_param(self) -\u003e BindParam {\n        let v: i8 = if self { 1 } else { 0 };\n        let mut param = BindParam::new(Ty::Bool);\n        param.0.buffer_length = std::mem::size_of::\u003ci8\u003e();\n        let v = Box::new(v);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\nimpl IntoBindParam for \u0026bool {\n    fn into_bind_param(self) -\u003e BindParam {\n        (*self).into_bind_param()\n    }\n}\nimpl IntoBindParam for \u0026\u0026bool {\n    fn into_bind_param(self) -\u003e BindParam {\n        (*self).into_bind_param()\n    }\n}\n\n_impl_primitive_into_bind_param!(i8, TinyInt, 0);\n_impl_primitive_into_bind_param!(i16, SmallInt, 0);\n_impl_primitive_into_bind_param!(i32, Int, 0);\n_impl_primitive_into_bind_param!(i64, BigInt, 0);\n_impl_primitive_into_bind_param!(u8, UTinyInt, 0);\n_impl_primitive_into_bind_param!(u16, USmallInt, 0);\n_impl_primitive_into_bind_param!(u32, UInt, 0);\n_impl_primitive_into_bind_param!(u64, UBigInt, 0);\n_impl_primitive_into_bind_param!(f32, Float, 0.);\n_impl_primitive_into_bind_param!(f64, Double, 0.);\n\n// impl IntoBindParam for \u0026BStr {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let mut param = BindParam::new(Ty::Binary);\n//         param.0.buffer_length = self.len();\n\n//         let cstr = self.to_c_string();\n//         param.0.buffer = cstr.as_ptr() as _;\n//         std::mem::forget(cstr);\n\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n\n// impl IntoBindParam for \u0026BString {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let bstr: \u0026BStr = self.as_ref();\n//         bstr.into_bind_param()\n//     }\n// }\n// _impl_ref_into_bind_param!(BString);\n\nimpl IntoBindParam for \u0026str {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::NChar);\n        param.0.buffer_length = self.len();\n\n        let cstr = self.into_c_str();\n        param.0.buffer = cstr.as_ptr() as _;\n        std::mem::forget(cstr);\n\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\nimpl IntoBindParam for \u0026String {\n    fn into_bind_param(self) -\u003e BindParam {\n        self.as_str().into_bind_param()\n    }\n}\n_impl_ref_into_bind_param!(String);\n\nimpl IntoBindParam for \u0026SystemTime {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        let duration = self\n            .duration_since(std::time::UNIX_EPOCH)\n            .expect(\"systemtime before unix epoch is not invalid\");\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(duration.as_millis());\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n_impl_ref_into_bind_param!(SystemTime);\n\nimpl IntoBindParam for \u0026NaiveDateTime {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        let timestamp = self.timestamp_millis();\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(timestamp);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n_impl_ref_into_bind_param!(NaiveDateTime);\n\nimpl\u003cTz: chrono::TimeZone\u003e IntoBindParam for \u0026DateTime\u003cTz\u003e {\n    fn into_bind_param(self) -\u003e BindParam {\n        let mut param = BindParam::new(Ty::Timestamp);\n        param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        let timestamp = self.timestamp_millis();\n        // FIXME(@huolinhe): an global flag for precision should be setted.\n        let v = Box::new(timestamp);\n        param.0.buffer = Box::into_raw(v) as _;\n        let l = Box::new(param.0.buffer_length);\n        param.0.length = Box::into_raw(l) as _;\n        param\n    }\n}\n\n// impl IntoBindParam for \u0026Timestamp {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let mut param = BindParam::new(Ty::Timestamp);\n//         param.0.buffer_length = std::mem::size_of::\u003ci64\u003e();\n//         let v = Box::new(self.timestamp);\n//         param.0.buffer = Box::into_raw(v) as _;\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n// _impl_ref_into_bind_param!(Timestamp);\n\n// impl IntoBindParam for \u0026serde_json::Value {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         let mut param = BindParam::new(Ty::Json);\n\n//         let data = serde_json::to_vec(self).expect(\"json to u8 vector\");\n//         param.0.buffer_length = data.len();\n\n//         param.0.buffer = data.as_ptr() as _;\n//         std::mem::forget(data);\n\n//         let l = Box::new(param.0.buffer_length);\n//         param.0.length = Box::into_raw(l) as _;\n//         param\n//     }\n// }\n// _impl_ref_into_bind_param!(serde_json::Value);\n\n// impl IntoBindParam for \u0026Field {\n//     fn into_bind_param(self) -\u003e BindParam {\n//         match self {\n//             Field::Null =\u003e BindParam::null(),\n//             Field::Timestamp(v) =\u003e v.into_bind_param(),\n//             Field::Bool(v) =\u003e v.into_bind_param(),\n//             Field::TinyInt(v) =\u003e v.into_bind_param(),\n//             Field::SmallInt(v) =\u003e v.into_bind_param(),\n//             Field::Int(v) =\u003e v.into_bind_param(),\n//             Field::BigInt(v) =\u003e v.into_bind_param(),\n//             Field::UTinyInt(v) =\u003e v.into_bind_param(),\n//             Field::USmallInt(v) =\u003e v.into_bind_param(),\n//             Field::UInt(v) =\u003e v.into_bind_param(),\n//             Field::UBigInt(v) =\u003e v.into_bind_param(),\n//             Field::Float(v) =\u003e v.into_bind_param(),\n//             Field::Double(v) =\u003e v.into_bind_param(),\n//             Field::Binary(v) =\u003e v.into_bind_param(),\n//             Field::NChar(v) =\u003e v.into_bind_param(),\n//             Field::Json(v) =\u003e v.into_bind_param(),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n// _impl_ref_into_bind_param!(Field);\n","traces":[{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","mod.rs"],"content":"use crate::{impls::ResultSet, Taos};\nuse taos_sys::stmt::RawStmt;\n\nuse std::marker::PhantomData;\n\npub use taos_sys::{TaosBind, TaosMultiBind};\n\ntype Result\u003cT\u003e = std::result::Result\u003cT, taos_error::Error\u003e;\n/// Stmt handler.\npub struct Stmt\u003c'stmt\u003e(RawStmt, PhantomData\u003c\u0026'stmt Taos\u003e);\n\nimpl\u003c'stmt\u003e Stmt\u003c'stmt\u003e {\n    pub fn execute(\u0026self) -\u003e Result\u003c()\u003e {\n        self.0.execute()\n    }\n\n    pub fn result(\u0026mut self) -\u003e ResultSet {\n        ResultSet::from_raw_res(self.0.use_result())\n    }\n\n    pub fn multi_bind(\u0026mut self, params: \u0026[TaosMultiBind]) -\u003e Result\u003c()\u003e {\n        self.0.bind_param_batch(params)?;\n        self.0.add_batch()?;\n        Ok(())\n    }\n\n    pub fn multi_bind_at(\u0026mut self, bind: \u0026TaosMultiBind, col: usize) -\u003e Result\u003c()\u003e {\n        self.0.bind_single_param_batch(bind, col as i32)\n    }\n\n    pub fn num_params(\u0026self) -\u003e Result\u003cusize\u003e {\n        Ok(self.0.num_params()? as _)\n    }\n\n    pub fn set_tbname_tags(\u0026mut self, name: impl AsRef\u003cstr\u003e, tags: \u0026[TaosBind]) -\u003e Result\u003c()\u003e {\n        self.0.set_tbname_tags_v3(name.as_ref(), tags)\n    }\n    pub fn set_tbname(\u0026mut self, name: impl AsRef\u003cstr\u003e) -\u003e Result\u003c()\u003e {\n        self.0.set_tbname(name.as_ref())\n    }\n    pub fn set_sub_tbname(\u0026mut self, name: impl AsRef\u003cstr\u003e) -\u003e Result\u003c()\u003e {\n        self.0.set_sub_tbname(name.as_ref())\n    }\n\n    pub fn is_insert(\u0026self) -\u003e bool {\n        self.0.is_insert().unwrap_or(false)\n    }\n\n    pub fn affected_rows(\u0026self) -\u003e usize {\n        self.0.affected_rows() as _\n    }\n}\n\n// impl\u003c'c\u003e From\u003c\u0026'c Column\u003e for MultiBind\u003c'c\u003e {\n//     fn from(col: \u0026'c Column) -\u003e Self {\n//         match col {\n//             Column::Null(n) =\u003e MultiBind::nulls(*n),\n//             Column::Bool(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Int(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::BigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::UInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Float(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Double(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             Column::Timestamp(nulls, values) =\u003e MultiBind::from_raw_timestamps(nulls, values),\n//             Column::Binary(values) =\u003e MultiBind::from_binary_vec(values),\n//             Column::NChar(values) =\u003e MultiBind::from_string_vec(values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\n// impl\u003c'b\u003e From\u003cBorrowedColumn\u003c'b\u003e\u003e for MultiBind\u003c'b\u003e {\n//     fn from(col: BorrowedColumn\u003c'b\u003e) -\u003e Self {\n//         match col {\n//             BorrowedColumn::Null(n) =\u003e MultiBind::nulls(n),\n//             BorrowedColumn::Bool(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Int(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::UInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Float(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Double(nulls, values) =\u003e MultiBind::from_primitives(\u0026nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) =\u003e {\n//                 MultiBind::from_raw_timestamps(\u0026nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) =\u003e MultiBind::from_binary_vec(\u0026values),\n//             BorrowedColumn::NChar(values) =\u003e MultiBind::from_string_vec(\u0026values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\n// impl\u003c'b, 'c\u003e From\u003c\u0026'c BorrowedColumn\u003c'b\u003e\u003e for MultiBind\u003c'c\u003e {\n//     fn from(col: \u0026'c BorrowedColumn\u003c'b\u003e) -\u003e Self {\n//         match col {\n//             BorrowedColumn::Null(n) =\u003e MultiBind::nulls(*n),\n//             BorrowedColumn::Bool(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Int(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Float(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Double(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) =\u003e {\n//                 MultiBind::from_raw_timestamps(nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) =\u003e MultiBind::from_binary_vec(values),\n//             BorrowedColumn::NChar(values) =\u003e MultiBind::from_string_vec(values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\nimpl Taos {\n    /// Create stmt with sql\n    pub fn stmt\u003c'a, 'stmt\u003e(\u0026'stmt self, sql: impl AsRef\u003cstr\u003e) -\u003e Result\u003cStmt\u003c'stmt\u003e\u003e {\n        let mut stmt = RawStmt::from_raw_taos(\u0026self.0);\n        let sql = sql.as_ref();\n        log::trace!(\"stmt: {sql}\");\n        stmt.prepare(sql)?;\n        Ok(Stmt(stmt, PhantomData))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use bitvec_simd::BitVec;\n    use itertools::Itertools;\n    use taos_query::common::itypes::ITimestamp;\n    use taos_sys::TaosBind;\n    use taos_sys::TaosMultiBind;\n\n    use crate::prelude::common::*;\n    use crate::prelude::sync::*;\n    use crate::test;\n    use anyhow::Result;\n\n    // todo: stmt query support.\n    // #[test]\n    // fn test_stmt(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n    //     let mut stmt = taos.stmt(\"show databases\")?;\n    //     stmt.execute()?;\n    //     let mut rs = stmt.result();\n    //     for block in rs {\n    //         println!(\"{block:?}\");\n    //     }\n    //     Ok(())\n    // }\n\n    #[test]\n    fn test_multi_bind(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(concat!(\n            \"create table if not exists tb (ts timestamp,\",\n            \"c1 bool, c2 tinyint, c3 smallint, c4 int,\",\n            \"c5 bigint,\",\n            \"c6 tinyint unsigned,\",\n            \"c7 smallint unsigned,\",\n            \"c8 int unsigned,\",\n            \"c9 bigint unsigned,\",\n            \"c10 float,\",\n            \"c11 double,\",\n            \"c12 timestamp,\",\n            \"c13 binary(100),\",\n            \"c14 nchar(100))\",\n        ))?;\n\n        const N: usize = 100;\n        let nulls = BitVec::zeros(N);\n\n        let ts = Column::Timestamp(\n            nulls.clone(),\n            (0..N).map(|ts| ts as i64 + 1_500_000_000_000).collect(),\n        );\n\n        macro_rules! col {\n            ($ty:ident) =\u003e {\n                dbg!(Column::$ty(\n                    nulls.clone(),\n                    (0..N).map(|_| rand::random()).collect()\n                ))\n            };\n        }\n        let c1 = col!(Bool);\n        let c2 = col!(TinyInt);\n        let c3 = col!(SmallInt);\n        let c4 = col!(Int);\n        let c5 = col!(BigInt);\n        let c6 = col!(UTinyInt);\n        let c7 = col!(USmallInt);\n        let c8 = col!(UInt);\n        let c9 = col!(UBigInt);\n        let c10 = col!(Float);\n        let c11 = col!(Double);\n        let c12 = col!(Timestamp);\n        let c13 = Column::Binary(\n            (0..N)\n                .map(|_| Some(String::from(\"abc\").into_bytes()))\n                .collect(),\n        );\n        let c14 = Column::NChar((0..N).map(|_| None).collect());\n\n        let block = vec![\n            ts, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14,\n        ];\n        let binds: Vec\u003cTaosMultiBind\u003e = block.iter().map(|c| dbg!(c.into())).collect();\n        let marks: String = std::iter::repeat(\"?\").take(15).join(\",\");\n        let mut stmt = taos\n            .stmt(format!(\"insert into tb values({marks})\"))\n            .unwrap();\n        stmt.multi_bind(\u0026binds).unwrap();\n\n        stmt.execute().unwrap();\n\n        let rows = stmt.affected_rows();\n        assert_eq!(N, rows as usize);\n\n        let mut rs = taos.query(\"select * from tb\")?;\n        for row in rs.rows_iter() {\n            for col in \u0026row {\n                println!(\"{:?}\", col);\n            }\n        }\n\n        Ok(())\n    }\n    #[crate::test(naming = \"abc\", dropping = \"none\")]\n    fn test_multi_bind_tags(taos: \u0026Taos, _database: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(concat!(\n            \"create table if not exists tb (ts timestamp, v binary(100)) tags(\",\n            \"c1 bool,\",\n            \"c2 tinyint,\",\n            \"c3 smallint,\",\n            \"c4 int,\",\n            \"c5 bigint,\",\n            \"c6 tinyint unsigned,\",\n            \"c7 smallint unsigned,\",\n            \"c8 int unsigned,\",\n            \"c9 bigint unsigned,\",\n            \"c10 float,\",\n            \"c11 double,\",\n            \"c12 timestamp)\",\n        ))?;\n        const N: usize = 5;\n        let nulls = BitVec::zeros(N);\n        let v: Vec\u003cOption\u003cString\u003e\u003e = (0..N).map(|_| Some(\"hello\".to_string())).collect();\n        let _ints = Column::NChar(v);\n        let v: Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e = (0..N)\n            .map(|_| Some(\"hello\".to_string().into_bytes()))\n            .collect();\n        let v = Column::Binary(v);\n\n        let ts = Column::Timestamp(\n            nulls.clone(),\n            (0..N).map(|ts| ts as i64 + 1500000000000).collect(),\n        );\n\n        macro_rules! tag {\n            ($v:expr) =\u003e {\n                dbg!(TaosBind::from(\u0026$v))\n            };\n        }\n        let c1 = tag!(true);\n        let c2 = tag!(1i8);\n        let c3 = tag!(1i16);\n        let c4 = tag!(1i32);\n        let c5 = tag!(1i64);\n        let c6 = tag!(1u8);\n        let c7 = tag!(1u16);\n        let c8 = tag!(1u32);\n        let c9 = tag!(1u64);\n        let c10 = tag!(0.0f32);\n        let c11 = tag!(0.0f64);\n        let c12 = tag!(ITimestamp(1500000000000));\n        // let c13 = tag!();\n        // let c14 = Column::NChar((0..N).map(|_| None).collect());\n\n        let tags = vec![c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12];\n        let marks: String = std::iter::repeat(\"?\").take(12).join(\",\");\n\n        let block = vec![ts, v];\n        let values: Vec\u003cTaosMultiBind\u003e = block.iter().map(|c| dbg!(c.into())).collect();\n\n        let mut stmt = taos\n            .stmt(format!(\"insert into ? using tb tags({marks}) values(?, ?)\"))\n            .unwrap();\n        stmt.set_tbname_tags(\"tb1\", \u0026tags)?;\n        println!(\"bind parmas: {values:#?}\");\n        stmt.multi_bind(\u0026values).unwrap();\n        stmt.execute().unwrap();\n\n        let rows = stmt.affected_rows();\n        assert_eq!(N, rows as usize);\n\n        let mut res = taos.query(\"select * from tb\").unwrap();\n\n        #[derive(Debug, PartialEq, serde::Deserialize)]\n        struct Row {\n            ts: i64,\n            v: String,\n            c1: bool,\n            c2: i8,\n            c3: i16,\n            c4: i32,\n            c5: i64,\n            c6: u8,\n            c7: u16,\n            c8: u32,\n            c9: u64,\n            c10: f32,\n            c11: f64,\n            c12: i64,\n        }\n        let data: Row = res\n            .deserialize()\n            .next()\n            .expect(\"there's no database\")\n            .expect(\"\");\n        dbg!(\u0026data);\n        assert!(\n            data == Row {\n                ts: 1500000000000,\n                v: \"hello\".to_string(),\n                c1: true,\n                c2: 1,\n                c3: 1,\n                c4: 1,\n                c5: 1,\n                c6: 1,\n                c7: 1,\n                c8: 1,\n                c9: 1,\n                c10: 0.0,\n                c11: 0.0,\n                c12: 1500000000000\n            }\n        );\n        Ok(())\n    }\n}\n\n// #[cfg(test)]\n// mod test {\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(format!(\n//         .await?;\n//         let mut stmt = taos.stmt(\"insert into ? values(?,?)\")?;\n//         stmt.set_tbname(\"tb0\")?;\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         stmt.bind(vec![ts, value.clone()].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select n from tb0\").await?;\n//         assert_eq!(value, res.rows[0][0]);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n\n//     macro_rules! _test_column_null {\n//         ($ty:ty, $v:expr) =\u003e {\n//             paste::paste! {\n//                 #[tokio::test]\n//                 #[test_catalogue()]\n//                 #[doc = \"Test bind null to type \" $ty]\n//                 async fn [\u003cnull_ $ty:snake\u003e]() -\u003e Result\u003c(), Error\u003e {\n//                     let db = stdext::function_name!()\n//                         .replace(\"::{{closure}}\", \"\")\n//                         .replace(\"::\", \"_\");\n//                     stmt_test(\u0026db, $v, Field::Null).await\n//                 }\n//             }\n//         };\n//     }\n//     _test_column_null!(bool, \"bool\");\n//     _test_column_null!(tinyint, \"tinyint\");\n//     _test_column_null!(smallint, \"smallint\");\n//     _test_column_null!(int, \"int\");\n//     _test_column_null!(bigint, \"bigint\");\n//     _test_column_null!(utinyint, \"tinyint unsigned\");\n//     _test_column_null!(usmallint, \"smallint unsigned\");\n//     _test_column_null!(uint, \"int unsigned\");\n//     _test_column_null!(ubigint, \"bigint unsigned\");\n//     _test_column_null!(timestamp, \"timestamp\");\n//     _test_column_null!(float, \"float\");\n//     _test_column_null!(double, \"double\");\n//     _test_column_null!(binary, \"binary(10)\");\n//     _test_column_null!(nchar, \"nchar(10)\");\n//     #[should_panic]\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test bind null to json tag, should panic because json is not supported in cols\n//     async fn null_json() -\u003e () {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"json\", Field::Null).await.unwrap()\n//     }\n\n//     async fn stmt_tag(db: \u0026str, ty: \u0026str, tag: Field) -\u003e Result\u003c(), Error\u003e {\n//         let taos = taos()?;\n//         println!(\"test {} using {}\", ty, db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(format!(\n//             \"create table if not exists stb0 (ts timestamp, v int) tags (n {})\",\n//             ty\n//         ))\n//         .await?;\n//         println!(\"start stmt\");\n//         let mut stmt = taos.stmt(\"insert into ? using stb0 tags(?) values(?,?)\")?;\n//         println!(\"set tags\");\n//         stmt.set_tbname_tags(\"tb0\", [\u0026tag])?;\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         println!(\"bind stmt\");\n//         stmt.bind(vec![ts, Field::Null].iter())?;\n//         println!(\"execute\");\n//         stmt.execute()?;\n//         println!(\"execute stmt done\");\n//         let res = taos.query(\"select n from tb0\").await?;\n//         assert_eq!(tag, res.rows[0][0]);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n//     macro_rules! _test_tag_null {\n//         ($ty:ty, $v:expr) =\u003e {\n//             paste::paste! {\n//                 #[tokio::test]\n//                 #[test_catalogue()]\n//                 #[doc = \"Test bind null to type \" $ty]\n//                 async fn [\u003cnull_tag_ $ty:snake\u003e]() -\u003e Result\u003c(), Error\u003e {\n//                     let db = stdext::function_name!()\n//                         .replace(\"::{{closure}}\", \"\")\n//                         .replace(\"::\", \"_\")\n//                         .replace(\"libtaos_\", \"\");\n//                     stmt_tag(\u0026db, $v, Field::Null).await\n//                 }\n//             }\n//         };\n//     }\n//     _test_tag_null!(bool, \"bool\");\n//     _test_tag_null!(tinyint, \"tinyint\");\n//     _test_tag_null!(smallint, \"smallint\");\n//     _test_tag_null!(int, \"int\");\n//     _test_tag_null!(bigint, \"bigint\");\n//     _test_tag_null!(utinyint, \"tinyint unsigned\");\n//     _test_tag_null!(usmallint, \"smallint unsigned\");\n//     _test_tag_null!(uint, \"int unsigned\");\n//     _test_tag_null!(ubigint, \"bigint unsigned\");\n//     _test_tag_null!(timestamp, \"timestamp\");\n//     _test_tag_null!(float, \"float\");\n//     _test_tag_null!(double, \"double\");\n//     _test_tag_null!(binary, \"binary(10)\");\n//     _test_tag_null!(nchar, \"nchar(10)\");\n//     // set null in json tag is currently abort taosd. see TD-12452.\n//     // TD-12452 is fixed by https://github.com/taosdata/TDengine/pull/9317\n//     _test_tag_null!(json, \"json\");\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with bool values.\n//     async fn bool() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"bool\", Field::Bool(true)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with tiny int values.\n//     async fn tinyint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"tinyint\", Field::TinyInt(-0x7f)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with small int values.\n//     async fn smallint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"smallint\", Field::SmallInt(0x7fff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with int values.\n//     async fn int() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"int\", Field::Int(0x7fffffff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with bigint values.\n//     async fn bigint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"bigint\", Field::BigInt(0x7fffffff_ffffffff)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned tinyint values.\n//     async fn utinyint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"tinyint unsigned\", Field::UTinyInt(0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned smallint values.\n//     async fn usmallint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"smallint unsigned\", Field::USmallInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned int values.\n//     async fn uint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"int unsigned\", Field::UInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with unsigned bigint values.\n//     async fn ubigint() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"bigint unsigned\", Field::UBigInt(1)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with float values.\n//     async fn float() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"float\", Field::Float(1.0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with double values.\n//     async fn double() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         stmt_test(\u0026db, \"double\", Field::Double(1.0)).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with binary values.\n//     async fn binary() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::Binary(\"0123456789\".into());\n//         stmt_test(\u0026db, \"binary(10)\", v).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with nchar(unicode) values.\n//     async fn nchar() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::NChar(\"\".into());\n//         stmt_test(\u0026db, \"nchar(10)\", v).await\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with json values.\n//     async fn json() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         let v = Field::Json(serde_json::from_str(\"{\\\"tag1\\\":\\\"\\\"}\").unwrap());\n\n//         let taos = taos()?;\n//         println!(\"test json using {}\", db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\"create stable if not exists stb0 (ts timestamp, n int) tags(j json)\")\n//             .await?;\n//         let mut stmt = taos.stmt(\"insert into ? using stb0 tags(?) values(?,?)\")?;\n//         println!(\"set tbname with tags\");\n//         stmt.set_tbname_tags(\"tb0\", [\u0026v])?;\n//         println!(\"bind values\");\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         stmt.bind(vec![ts, Field::Int(3)].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select j from stb0\").await?;\n//         let row = res.rows.iter().next().unwrap();\n//         assert_eq!(\u0026v, row.iter().next().unwrap());\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT inserting with all types of values.\n//     async fn all_types() -\u003e Result\u003c(), Error\u003e {\n//         let taos = taos()?;\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{}\", db);\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\n//             \"create table if not exists tb0 (ts timestamp,\n//              c1 tinyint, c2 smallint, c3 int, c4 bigint,\n//              c5 tinyint unsigned, c6 smallint unsigned, c7 int unsigned, c8 bigint unsigned,\n//              c9 float, c10 double, c11 binary(10), c12 nchar(10))\",\n//         )\n//         .await?;\n//         let mut stmt = taos.stmt(\"insert into ? values(?,?,?,?,?,?,?,?,?,?,?,?,?)\")?;\n//         stmt.set_tbname(\"tb0\")?;\n//         assert!(stmt.is_insert());\n\n//         assert_eq!(stmt.num_params(), 13);\n//         let ts = Field::Timestamp(Timestamp::now());\n//         let c1 = Field::TinyInt(1);\n//         let c2 = Field::SmallInt(2);\n//         let c3 = Field::Int(3);\n//         let c4 = Field::BigInt(4);\n//         let c5 = Field::UTinyInt(5);\n//         let c6 = Field::USmallInt(6);\n//         let c7 = Field::UInt(7);\n//         let c8 = Field::UBigInt(8);\n//         let c9 = Field::Float(9.0);\n//         let c10 = Field::Double(9.0);\n//         let c11 = Field::Binary(\"binary\".into());\n//         let c12 = Field::NChar(\"nchar\".into());\n//         stmt.bind(vec![ts, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12].iter())?;\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from tb0\").await?;\n//         println!(\"{:?}\", res);\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT set tbname with upper-case stable, see jira TD-12977\n//     async fn test_uppercase_tbname() -\u003e Result\u003c(), Error\u003e {\n//         let db = \"uppercase_test\";\n//         let taos = taos()?;\n//         taos.exec(format!(\"drop database if exists {db}\")).await?;\n//         taos.exec(format!(\"create database {db}\")).await?;\n//         taos.exec(format!(\"use {db}\")).await?;\n//         taos.exec(format!(\"create stable STB(ts timestamp, n int) tags(b int)\")).await?;\n//         let mut stmt = taos.stmt(\"insert into ? using STB tags(?) values(?, ?)\")?;\n\n//         stmt.set_tbname_tags(\"tb0\", [0i32])?;\n//         // stmt.bind(\u0026[0i32])?;\n//         let values = vec![Field::Timestamp(Timestamp::now()), Field::Int(10)];\n//         stmt.bind(\u0026values)?;\n\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n\n//         let _ = stmt.execute()?;\n//         const LIMIT: i64 = 100;\n\n//         for i in 1..LIMIT {\n//             stmt.set_tbname_tags(format!(\"tb{}\", i), \u0026[2i32])?;\n//             stmt.bind(\u0026values)?;\n//         }\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from stb\").await?;\n//         assert_eq!(res.rows[0][0], Field::BigInt(LIMIT));\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n\n//         Ok(())\n//     }\n//     #[tokio::test]\n//     #[test_catalogue()]\n//     /// Test STMT API insertion with tags\n//     async fn test_stmt_tags() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{:?}\", db);\n//         let taos = taos()?;\n//         taos.exec(format!(\"drop database if exists {}\", db)).await?;\n//         taos.exec(format!(\"create database if not exists {} keep 36500\", db))\n//             .await?;\n//         taos.exec(format!(\"use {}\", db)).await?;\n//         taos.exec(\"create table if not exists stb (ts timestamp, n int) tags(b int)\")\n//             .await?;\n\n//         let mut stmt = taos.stmt(\"insert into ? using stb tags(?) values(?, ?)\")?;\n\n//         stmt.set_tbname_tags(\"tb0\", [0i32])?;\n//         // stmt.bind(\u0026[0i32])?;\n//         let values = vec![Field::Timestamp(Timestamp::now()), Field::Int(10)];\n//         stmt.bind(\u0026values)?;\n\n//         assert!(stmt.is_insert());\n//         assert_eq!(stmt.num_params(), 2);\n\n//         let _ = stmt.execute()?;\n//         const LIMIT: i64 = 100;\n\n//         for i in 1..LIMIT {\n//             stmt.set_tbname_tags(format!(\"tb{}\", i), \u0026[2i32])?;\n//             stmt.bind(\u0026values)?;\n//         }\n//         let _ = stmt.execute()?;\n//         let res = taos.query(\"select count(*) as count from stb\").await?;\n//         assert_eq!(res.rows[0][0], Field::BigInt(LIMIT));\n//         taos.exec(format!(\"drop database {}\", db)).await?;\n//         Ok(())\n//     }\n// }\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stmt","multi_bind.rs"],"content":"use std::{marker::PhantomData, mem::ManuallyDrop};\n\nuse bitvec_simd::BitVec;\n\nuse taos_query::common::Ty;\nuse taos_sys::TaosMultiBind;\n\n#[derive(Debug)]\npub struct MultiBind\u003c'a\u003e(TaosMultiBind, PhantomData\u003c\u0026'a u8\u003e);\n\nunsafe impl\u003c'a\u003e Send for MultiBind\u003c'a\u003e {}\nunsafe impl\u003c'a\u003e Sync for MultiBind\u003c'a\u003e {}\n\npub(crate) trait TaosTypeOf {\n    fn taos_type_of() -\u003e Ty;\n}\n\nmacro_rules! impl_taos_type_of {\n    ($f:ty, $t:ident) =\u003e {\n        impl TaosTypeOf for $f {\n            #[inline]\n            fn taos_type_of() -\u003e Ty {\n                Ty::$t\n            }\n        }\n    };\n}\n\nimpl_taos_type_of!(bool, Bool);\nimpl_taos_type_of!(i8, TinyInt);\nimpl_taos_type_of!(i16, SmallInt);\nimpl_taos_type_of!(i32, Int);\nimpl_taos_type_of!(i64, BigInt);\nimpl_taos_type_of!(u8, UTinyInt);\nimpl_taos_type_of!(u16, USmallInt);\nimpl_taos_type_of!(u32, UInt);\nimpl_taos_type_of!(u64, UBigInt);\nimpl_taos_type_of!(f32, Float);\nimpl_taos_type_of!(f64, Double);\n\nimpl\u003c'a\u003e MultiBind\u003c'a\u003e {\n    pub(crate) fn nulls(n: usize) -\u003e Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::Null as _,\n                buffer: std::ptr::null_mut(),\n                buffer_length: 0,\n                length: n as _,\n                is_null: std::ptr::null_mut(),\n                num: n as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_primitives\u003cT: TaosTypeOf\u003e(nulls: \u0026BitVec, values: \u0026[T]) -\u003e Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: T::taos_type_of() as _,\n                buffer: values.as_ptr() as _,\n                buffer_length: std::mem::size_of::\u003cT\u003e(),\n                length: values.len() as _,\n                is_null: ManuallyDrop::new(nulls.clone().into_bools()).as_ptr() as _,\n                num: values.len() as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_raw_timestamps(nulls: \u0026BitVec, values: \u0026[i64]) -\u003e Self {\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::Timestamp as _,\n                buffer: values.as_ptr() as _,\n                buffer_length: std::mem::size_of::\u003ci64\u003e(),\n                length: values.len() as _,\n                is_null: ManuallyDrop::new(nulls.clone().into_bools()).as_ptr() as _,\n                num: values.len() as _,\n            },\n            PhantomData,\n        )\n    }\n\n    pub(crate) fn from_binary_vec(values: \u0026[Option\u003cimpl AsRef\u003c[u8]\u003e\u003e]) -\u003e Self {\n        let mut buffer_length = 0;\n        let num = values.len();\n        let mut nulls = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { nulls.set_len(num) };\n        nulls.fill(false);\n        let mut length: ManuallyDrop\u003cVec\u003ci32\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { length.set_len(num) };\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                length[i] = v.len() as _;\n                if v.len() \u003e buffer_length {\n                    buffer_length = v.len();\n                }\n            } else {\n                nulls[i] = true;\n            }\n        }\n        let buffer_size = buffer_length * values.len();\n        let mut buffer: ManuallyDrop\u003cVec\u003cu8\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(buffer_size));\n        unsafe { buffer.set_len(buffer_size) };\n        buffer.fill(0);\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                unsafe {\n                    let dst = buffer.as_mut_ptr().add(buffer_length * i);\n                    std::intrinsics::copy_nonoverlapping(v.as_ptr(), dst, v.len());\n                }\n            }\n        }\n        Self(\n            TaosMultiBind {\n                buffer_type: Ty::VarChar as _,\n                buffer: buffer.as_ptr() as _,\n                buffer_length,\n                length: length.as_ptr() as _,\n                is_null: nulls.as_ptr() as _,\n                num: num as _,\n            },\n            PhantomData,\n        )\n    }\n    pub(crate) fn from_string_vec(values: \u0026[Option\u003cimpl AsRef\u003cstr\u003e\u003e]) -\u003e Self {\n        let values: Vec\u003c_\u003e = values\n            .iter()\n            .map(|f| {\n                f.as_ref()\n                    .map(|s| dbg!(s.as_ref().to_string()).into_bytes())\n            })\n            .collect();\n        let mut s = Self::from_binary_vec(\u0026values);\n        s.0.buffer_type = Ty::NChar as _;\n        s\n    }\n}\n\nimpl\u003c'a\u003e Drop for MultiBind\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        let ty = Ty::from(self.0.buffer_type as u8);\n        if ty == Ty::VarChar || ty == Ty::NChar {\n            let len = self.0.buffer_length * self.0.num as usize;\n            unsafe { Vec::from_raw_parts(self.0.buffer as *mut u8, len, len as _) };\n            unsafe {\n                Vec::from_raw_parts(self.0.length as *mut i32, self.0.num as _, self.0.num as _)\n            };\n        }\n        unsafe { Vec::from_raw_parts(self.0.is_null as *mut i8, self.0.num as _, self.0.num as _) };\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":74},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","stream","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","timestamp.rs"],"content":"use serde::{Deserialize, Serialize};\nuse taos_sys::Precision;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\npub enum TimestampValue {\n    Milliseconds(i64),\n    Microseconds(i64),\n    Nanoseconds(i64),\n}\n\nimpl TimestampValue {\n    pub fn new(raw: i64, precision: Precision) -\u003e Self {\n        match precision {\n            Precision::Millisecond =\u003e TimestampValue::Milliseconds(raw),\n            Precision::Microsecond =\u003e TimestampValue::Microseconds(raw),\n            Precision::Nanosecond =\u003e TimestampValue::Nanoseconds(raw),\n        }\n    }\n    pub fn as_raw_i64(\u0026self) -\u003e \u0026i64 {\n        match self {\n            TimestampValue::Milliseconds(raw)\n            | TimestampValue::Microseconds(raw)\n            | TimestampValue::Nanoseconds(raw) =\u003e raw,\n        }\n    }\n    pub fn to_naive_datetime(\u0026self) -\u003e chrono::NaiveDateTime {\n        let duration = match self {\n            TimestampValue::Milliseconds(raw) =\u003e chrono::Duration::milliseconds(*raw),\n            TimestampValue::Microseconds(raw) =\u003e chrono::Duration::microseconds(*raw),\n            TimestampValue::Nanoseconds(raw) =\u003e chrono::Duration::nanoseconds(*raw),\n        };\n        chrono::NaiveDateTime::from_timestamp(0, 0)\n            .checked_add_signed(duration)\n            .unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","conf.rs"],"content":"use crate::{IntoCStr, TaosOptions};\nuse taos_error::*;\n\nuse std::{ffi::c_void, iter::Iterator};\nuse taos_query::Dsn;\nuse taos_sys::*;\n\nuse super::Consumer;\n/* tmq conf */\npub struct TmqConf(*mut tmq_conf_t);\n\nimpl TmqConf {\n    pub(crate) fn as_ptr(\u0026self) -\u003e *mut tmq_conf_t {\n        self.0\n    }\n    pub(crate) fn new() -\u003e Self {\n        Self(unsafe { tmq_conf_new() })\n    }\n\n    pub(crate) fn from_dsn(dsn: \u0026Dsn) -\u003e Result\u003cSelf\u003e {\n        let mut conf = Self::new();\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        // todo: host port?\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(database, \"db\");\n        conf.with(dsn.params.iter().filter(|(k, _)| k.contains(\".\")))\n    }\n\n    pub fn from_opts(opts: \u0026TaosOptions) -\u003e Result\u003cSelf\u003e {\n        let mut conf = Self::new();\n\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) =\u003e {\n                if let Some($f) = \u0026opts.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) =\u003e {\n                if let Some($f) = \u0026opts.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        _set_opt!(host, \"ip\");\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(port, \"port\");\n        _set_opt!(database, \"db\");\n\n        conf.with(opts.params.iter().filter(|(k, _)| k.contains(\".\")))\n    }\n\n    pub fn group_id(mut self, id: \u0026str) -\u003e Self {\n        self.set(\"group.id\", id)\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n    pub fn client_id(mut self, id: \u0026str) -\u003e Self {\n        self.set(\"client.id\", id)\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n\n    pub fn enable_auto_commit(mut self, enabled: bool) -\u003e Self {\n        self.set(\"enable.auto.commit\", if enabled { \"true\" } else { \"false\" })\n            .expect(\"set group.id should always be ok\");\n        self\n    }\n\n    pub fn with\u003cK: AsRef\u003cstr\u003e, V: AsRef\u003cstr\u003e\u003e(\n        mut self,\n        iter: impl Iterator\u003cItem = (K, V)\u003e,\n    ) -\u003e Result\u003cSelf\u003e {\n        for (k, v) in iter {\n            self.set(k, v)?;\n        }\n        Ok(self)\n    }\n\n    pub fn set\u003cK: AsRef\u003cstr\u003e, V: AsRef\u003cstr\u003e\u003e(\u0026mut self, key: K, value: V) -\u003e Result\u003c\u0026mut Self\u003e {\n        let ret = unsafe {\n            tmq_conf_set(\n                self.0,\n                key.as_ref().into_c_str().as_ptr(),\n                value.as_ref().into_c_str().as_ptr(),\n            )\n        };\n        match ret {\n            tmq_conf_res_t::Ok =\u003e Ok(self),\n            tmq_conf_res_t::Invalid =\u003e Err(Error::from_string(\"invalid key value set for tmq\")),\n            tmq_conf_res_t::Unknown =\u003e Err(Error::from_string(\"unknown key for tmq conf\")),\n        }\n    }\n\n    pub fn set_auto_commit_cb(\u0026mut self, cb: tmq_commit_cb, param: *mut c_void) -\u003e () {\n        unsafe {\n            tmq_conf_set_auto_commit_cb(self.0, cb, param);\n        }\n    }\n\n    pub fn consumer(\u0026self) -\u003e Result\u003cConsumer\u003e {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.0, err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                Err(Error::from_string(\n                    String::from_utf8_lossy(\u0026err).to_string(),\n                ))\n            } else {\n                Ok(Consumer::new(tmq, 0))\n            }\n        }\n    }\n}\n\nimpl Drop for TmqConf {\n    fn drop(\u0026mut self) {\n        log::trace!(\"tmq config destroy\");\n        unsafe { tmq_conf_destroy(self.0) };\n        log::trace!(\"tmq config destroyed safely\");\n    }\n}\n","traces":[{"line":13,"address":[3962992],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":14,"address":[3962997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[3963008],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":17,"address":[3963012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3965607,3963056,3963749],"length":1,"stats":{"Line":0},"fn_name":"from_dsn"},{"line":21,"address":[3963092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3963760,3963333,3963159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3963983,3964082,3963239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[3964705,3964024,3964817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3965585,3964746,3965457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3965648,3969712,3966394],"length":1,"stats":{"Line":0},"fn_name":"from_opts"},{"line":43,"address":[3965687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3965966,3966405,3965773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3965863,3966631,3966743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3967460,3966681,3967369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3968184,3967413,3968083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3968922,3968807,3968131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3944958,3944944],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":67,"address":[3969889,3969760],"length":1,"stats":{"Line":0},"fn_name":"group_id"},{"line":68,"address":[3969845,3969784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[3969880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[3970049,3969920],"length":1,"stats":{"Line":0},"fn_name":"client_id"},{"line":73,"address":[3970005,3969944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3970040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3970080,3970269],"length":1,"stats":{"Line":0},"fn_name":"enable_auto_commit"},{"line":79,"address":[3970101,3970224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3970259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3945696,3945663,3946319,3945040],"length":1,"stats":{"Line":0},"fn_name":"with\u003c\u0026alloc::string::String, \u0026alloc::string::String, core::iter::adapters::filter::Filter\u003calloc::collections::btree::map::Iter\u003calloc::string::String, alloc::string::String\u003e, taos::tmq::conf::{impl#0}::from_dsn::{closure_env#0}\u003e\u003e"},{"line":88,"address":[3946270,3945062,3945718,3945455,3945180,3946022,3945614,3946111,3945366,3945836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[3946049,3946121,3945465,3945998,3945393,3945342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3946301,3945645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3947088,3946352,3947538,3947057,3948267,3948567,3946818,3947808,3947777],"length":1,"stats":{"Line":0},"fn_name":"set\u003c\u0026str, \u0026str\u003e"},{"line":97,"address":[3946414,3947134,3947856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3946593,3947313,3947214,3947142,3946422,3947867,3948046,3946494,3947947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3947466,3948192,3948063,3947325,3946605,3946746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3947568,3946848,3948297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3947678,3946958,3948407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3948366,3947637,3947696,3946976,3948439,3946917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3947017,3948480,3947606,3947737,3948335,3946886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[3970304],"length":1,"stats":{"Line":0},"fn_name":"set_auto_commit_cb"},{"line":111,"address":[3970322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3970658,3970336],"length":1,"stats":{"Line":0},"fn_name":"consumer"},{"line":117,"address":[3970366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[3970388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3970451,3970727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3970576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3970488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3970463,3970712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3723584],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":132,"address":[3723752,3723695,3723604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3723741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3723924,3723985,3723830],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":52},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","consumer.rs"],"content":"use std::{intrinsics::transmute, task::Poll};\n\nuse crate::prelude::ResultSet;\nuse futures::{FutureExt, Stream};\nuse taos_error::*;\nuse taos_sys::*;\n\nuse super::TmqList;\n\n#[derive(Debug)]\npub struct ConsumerRef(*mut tmq_t);\n\nimpl ConsumerRef {\n    pub(crate) fn from_ptr(ptr: *mut tmq_t) -\u003e Self {\n        ConsumerRef(ptr)\n    }\n    pub fn commit(\u0026self, offsets: \u0026ResultSet) -\u003e Result\u003c()\u003e {\n        unsafe { tmq_commit_sync(self.0, offsets.as_ptr()) }.ok_or(\"commit failed\")\n    }\n}\n\n#[derive(Debug)]\npub struct Consumer {\n    ptr: *mut tmq_t,\n    wait: i64,\n}\n\nimpl Unpin for Consumer {}\n\nunsafe impl Send for Consumer {}\nunsafe impl Sync for Consumer {}\n\nimpl Consumer {\n    pub(crate) fn as_raw(\u0026self) -\u003e *mut tmq_t {\n        self.ptr\n    }\n    pub(crate) fn new(ptr: *mut tmq_t, wait: i64) -\u003e Self {\n        Self { ptr, wait }\n    }\n\n    pub(crate) fn subscribe(\u0026mut self, topic_list: \u0026TmqList) -\u003e Result\u003c()\u003e {\n        unsafe { tmq_subscribe(self.as_raw(), topic_list.0) }.ok_or(\"subscribe failed\")\n    }\n\n    pub fn subscription(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let tl = TmqList::new();\n\n        unsafe { tmq_subscription(self.as_raw(), \u0026mut tl.as_ptr()) }\n            .ok_or(\"get topic list failed\")\n            .map(|_| {\n                tl.to_str_vec()\n                    .into_iter()\n                    .map(ToString::to_string)\n                    .collect()\n            })\n    }\n\n    pub fn commit_sync(\u0026mut self, msg: \u0026ResultSet) -\u003e Result\u003c()\u003e {\n        unsafe { tmq_commit_sync(self.as_raw(), msg.as_ptr() as _) }.ok_or(\"commit failed\")\n    }\n\n    pub fn commit_non_blocking(\u0026mut self, msg: \u0026ResultSet, callback: fn(ConsumerRef, Result\u003c()\u003e)) {\n        unsafe {\n            tmq_commit_async(\n                self.as_raw(),\n                msg.as_ptr(),\n                super::tmq_commit_callback,\n                Box::into_raw(Box::new(callback)) as _,\n            )\n        }\n    }\n\n    pub async fn commit(\u0026mut self, msg: \u0026ResultSet) -\u003e Result\u003c()\u003e {\n        use tokio::sync::oneshot::{channel, Sender};\n        let (sender, rx) = channel::\u003cResult\u003c()\u003e\u003e();\n        unsafe extern \"C\" fn tmq_commit_async_cb(\n            _tmq: *mut tmq_t,\n            resp: tmq_resp_err_t,\n            param: *mut std::os::raw::c_void,\n        ) {\n            let offsets = resp.ok_or(\"commit failed\").map(|_| ());\n            let sender = param as *mut Sender\u003c_\u003e;\n            let sender = Box::from_raw(sender);\n            sender.send(offsets).unwrap();\n        }\n\n        unsafe {\n            tmq_commit_async(\n                self.as_raw(),\n                msg.as_ptr(),\n                tmq_commit_async_cb,\n                Box::into_raw(Box::new(sender)) as *mut _,\n            )\n        }\n        Ok(rx.await.unwrap()?)\n    }\n\n    pub fn poll(\u0026mut self) -\u003e Option\u003ccrate::Result\u003cResultSet\u003e\u003e {\n        let res = unsafe { tmq_consumer_poll(self.as_raw(), self.wait) };\n        if res.is_null() {\n            None\n        } else {\n            Some(\n                ResultSet::from_ptr(res)\n                    .map(|rs| rs.independent())\n                    .map_err(Into::into),\n            )\n        }\n    }\n\n    pub fn async_poll(\n        \u0026mut self,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e Poll\u003cOption\u003ccrate::Result\u003cResultSet\u003e\u003e\u003e {\n        struct TmqRef(*mut tmq_t);\n        unsafe impl Send for TmqRef {}\n        unsafe impl Sync for TmqRef {}\n        let wait = self.wait;\n        let ptr = TmqRef(self.as_raw());\n        tokio::task::spawn_blocking(move || {\n            let ptr = unsafe { transmute(ptr) };\n            let res = unsafe { tmq_consumer_poll(ptr, wait) };\n            if res.is_null() {\n                None\n            } else {\n                Some(\n                    ResultSet::from_ptr(res)\n                        .map(|rs| rs.independent())\n                        .map_err(Into::into),\n                )\n            }\n        })\n        .poll_unpin(cx)\n        .map(|res| res.unwrap())\n    }\n\n    pub async fn async_poll2(\u0026mut self) -\u003e Option\u003ccrate::Result\u003cResultSet\u003e\u003e {\n        struct TmqRef(*mut tmq_t);\n        unsafe impl Send for TmqRef {}\n        unsafe impl Sync for TmqRef {}\n        let wait = self.wait;\n        let ptr = TmqRef(self.as_raw());\n        tokio::task::spawn_blocking(move || {\n            let ptr = unsafe { transmute(ptr) };\n            let res = unsafe { tmq_consumer_poll(ptr, wait) };\n            if res.is_null() {\n                None\n            } else {\n                Some(\n                    ResultSet::from_ptr(res)\n                        .map(|rs| rs.independent())\n                        .map_err(Into::into),\n                )\n            }\n        })\n        .await\n        .unwrap_or(None)\n    }\n\n    pub fn poll_wait(\u0026mut self, wait_time: i64) -\u003e Option\u003ccrate::Result\u003cResultSet\u003e\u003e {\n        let res = unsafe { tmq_consumer_poll(self.as_raw(), wait_time) };\n        if res.is_null() {\n            None\n        } else {\n            Some(ResultSet::from_ptr(res).map_err(Into::into))\n        }\n    }\n\n    pub fn unsubscribe(\u0026mut self) {\n        unsafe {\n            log::trace!(\"close consumer\");\n            tmq_consumer_close(self.as_raw());\n            log::trace!(\"consumer closed safely\");\n        }\n    }\n}\n\nimpl Iterator for Consumer {\n    type Item = Result\u003cResultSet\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        todo!()\n    }\n}\n\nimpl Drop for Consumer {\n    fn drop(\u0026mut self) {\n        unsafe {\n            log::trace!(\"close consumer\");\n            tmq_consumer_close(self.as_raw());\n            log::trace!(\"consumer closed safely\");\n        }\n    }\n}\n\nimpl Stream for Consumer {\n    type Item = crate::Result\u003cResultSet\u003e;\n\n    fn poll_next(\n        mut self: std::pin::Pin\u003c\u0026mut Self\u003e,\n        cx: \u0026mut std::task::Context\u003c'_\u003e,\n    ) -\u003e std::task::Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n        // self.async_poll2().boxed().poll_unpin(cx)\n        Poll::Ready(self.poll())\n    }\n}\n","traces":[{"line":14,"address":[3890976],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":15,"address":[3890985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[3891008],"length":1,"stats":{"Line":0},"fn_name":"commit"},{"line":18,"address":[3891045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3891136],"length":1,"stats":{"Line":0},"fn_name":"as_raw"},{"line":35,"address":[3891141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3891152],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":41,"address":[3891200],"length":1,"stats":{"Line":0},"fn_name":"subscribe"},{"line":42,"address":[3891242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3891328,3891558],"length":1,"stats":{"Line":0},"fn_name":"subscription"},{"line":46,"address":[3891355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3891524,3891430,3891371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[3891519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[3423314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3891600],"length":1,"stats":{"Line":0},"fn_name":"commit_sync"},{"line":59,"address":[3891642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3891728],"length":1,"stats":{"Line":0},"fn_name":"commit_non_blocking"},{"line":65,"address":[3891757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3891773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3891866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[3891941,3891920],"length":1,"stats":{"Line":0},"fn_name":"commit"},{"line":76,"address":[3891984,3892308],"length":1,"stats":{"Line":0},"fn_name":"tmq_commit_async_cb"},{"line":81,"address":[3423392],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":82,"address":[3892079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3892087,3892149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3892272,3892157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3892368],"length":1,"stats":{"Line":0},"fn_name":"poll"},{"line":99,"address":[3892406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[3892582,3892455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3892501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[3892480,3892521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[3423408,3423419],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":111,"address":[3892849,3892592],"length":1,"stats":{"Line":0},"fn_name":"async_poll"},{"line":118,"address":[3892642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3892659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3423472],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":121,"address":[3423510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[3423549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[3423700,3423573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3423619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3423685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[3423639,3423598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3423723,3423712],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":134,"address":[3423792,3423776],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":137,"address":[3892896,3892912],"length":1,"stats":{"Line":0},"fn_name":"async_poll2"},{"line":160,"address":[3892944],"length":1,"stats":{"Line":0},"fn_name":"poll_wait"},{"line":161,"address":[3892995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3893145,3893040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[3893086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[3893106,3893065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[3893152],"length":1,"stats":{"Line":0},"fn_name":"unsubscribe"},{"line":171,"address":[3893322,3893263,3893172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[3893309,3893408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3893414,3893578,3893514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3893680],"length":1,"stats":{"Line":0},"fn_name":"next"},{"line":187,"address":[3724080],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":189,"address":[3724191,3724250,3724100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3724237,3724336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[3724342,3724506,3724442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[3893728],"length":1,"stats":{"Line":0},"fn_name":"poll_next"},{"line":204,"address":[3893758],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":61},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","tmq","mod.rs"],"content":"use std::{\n    ffi::{c_void, CStr},\n    fmt::Debug,\n    mem::ManuallyDrop,\n    slice,\n    sync::{Arc, Weak},\n};\n\nuse taos_error::*;\n\nuse crate::{IntoCStr, Taos};\nuse mdsn::IntoDsn;\nuse taos_query::Dsn;\nuse taos_sys::*;\n\nunsafe extern \"C\" fn tmq_commit_callback(\n    _tmq: *mut tmq_t,\n    resp: tmq_resp_err_t,\n    param: *mut c_void,\n) {\n    log::info!(\"commit {resp:?}\");\n    let cons = ConsumerRef::from_ptr(_tmq);\n    let cb: \u0026Weak\u003cfn(ConsumerRef, Result\u003c()\u003e)\u003e = std::mem::transmute(param);\n    (*cb.as_ptr())(cons, resp.ok_or(\"commit failed\"));\n}\n\n#[derive(Debug)]\npub struct TmqList(*mut tmq_list_t);\n\nimpl TmqList {\n    fn new() -\u003e Self {\n        Self(unsafe { tmq_list_new() })\n    }\n    fn as_ptr(\u0026self) -\u003e *mut tmq_list_t {\n        self.0\n    }\n    fn append\u003c'a\u003e(\u0026mut self, c_str: impl IntoCStr\u003c'a\u003e) -\u003e Result\u003c()\u003e {\n        let ret = unsafe { tmq_list_append(self.0, c_str.into_c_str().as_ptr()) };\n        if ret == 0 {\n            Ok(())\n        } else {\n            Err(Error::new(Code::Failed, \"append tmq list error\"))\n        }\n    }\n\n    fn from_topics\u003c'a, T: IntoCStr\u003c'a\u003e\u003e(topics: impl IntoIterator\u003cItem = T\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut list = Self::new();\n        for topic in topics {\n            list.append(topic)?;\n        }\n        Ok(list)\n    }\n\n    pub fn iter(\u0026self) -\u003e std::vec::IntoIter\u003c\u0026str\u003e {\n        self.to_str_vec().into_iter()\n    }\n\n    pub fn to_str_vec(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        unsafe {\n            let ptr = self.as_ptr();\n            let len = tmq_list_get_size(ptr);\n            if len == 0 {\n                return vec![];\n            }\n            let arr = tmq_list_to_c_array(ptr);\n            slice::from_raw_parts(arr, len as usize)\n                .into_iter()\n                .map(|ptr| {\n                    CStr::from_ptr(*ptr)\n                        .to_str()\n                        .expect(\"topic should always be utf-8 valid\")\n                })\n                .collect()\n        }\n    }\n}\n\nimpl\u003c'a\u003e IntoIterator for \u0026'a TmqList {\n    type Item = \u0026'a str;\n\n    type IntoIter = std::vec::IntoIter\u003c\u0026'a str\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.iter()\n    }\n}\n\n// todo: tmq_list_destroy cause double free error.\nimpl Drop for TmqList {\n    fn drop(\u0026mut self) {\n        unsafe {\n            log::trace!(\"list destroy\");\n            tmq_list_destroy(self.0);\n            log::trace!(\"list destroy destroyed\");\n        }\n    }\n}\n\nmod conf;\npub use conf::*;\n\nmod consumer;\npub use consumer::Consumer;\n\nuse self::consumer::ConsumerRef;\n\npub struct TmqBuilder {\n    conf: TmqConf,\n    wait: i64,\n    topics: TmqList,\n    on_commit: Option\u003cArc\u003cfn(ConsumerRef, Result\u003c()\u003e)\u003e\u003e,\n}\n\nimpl TmqBuilder {\n    pub fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e crate::Result\u003cSelf\u003e {\n        let dsn = dsn.into_dsn().unwrap();\n        log::debug!(\"build from {dsn}\");\n        let mut conf = TmqConf::new();\n        macro_rules! _set_opt {\n            ($f:ident, $c:literal) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", $c), format!(\"{}\", $f))?;\n                }\n            };\n            ($f:ident) =\u003e {\n                if let Some($f) = \u0026dsn.$f {\n                    conf.set(format!(\"td.connect.{}\", stringify!($c)), format!(\"{}\", $f))?;\n                }\n            };\n        }\n\n        // todo: host port?\n        _set_opt!(username, \"user\");\n        _set_opt!(password, \"pass\");\n        _set_opt!(database, \"db\");\n\n        if let Some(addr) = dsn.addresses.first() {\n            if let Some(host) = addr.host.as_ref() {\n                conf.set(\"td.connect.ip\", host)?;\n            }\n            if let Some(port) = addr.port.as_ref() {\n                conf.set(\"td.connect.port\", format!(\"{}\", port))?;\n            }\n        }\n        conf.set(\"msg.with.table.name\", \"true\")?;\n\n        // let tmq_params = dsn.params.iter_mut().filter(|(k, _)| k.contains(\".\")).collect();\n        let mut conf = conf.with(dsn.params.iter().filter(|(k, _)| k.contains(\".\")))?;\n        // conf.set(\"msg.with.table.name\".to_string(), \"true\".to_string()).unwrap();\n\n        let wait = dsn\n            .params\n            .get(\"wait\")\n            .and_then(|s| s.parse().ok())\n            .unwrap_or(100);\n        log::debug!(\"with wait time {wait}ms\");\n        let mut topics = TmqList::new();\n        if let Some(t) = dsn.params.get(\"topics\") {\n            for s in t.split(\",\") {\n                topics.append(s)?;\n            }\n        }\n        Ok(Self {\n            conf,\n            wait,\n            topics,\n            on_commit: None,\n        })\n    }\n\n    pub fn on_auto_commit(\u0026mut self, callback: fn(ConsumerRef, Result\u003c()\u003e)) -\u003e \u0026mut Self {\n        let on_commit = Arc::new(callback);\n        let cb = Arc::downgrade(\u0026on_commit);\n        self.on_commit = Some(on_commit);\n        // todo: callback pointer should be freed in Drop.\n        self.conf\n            .set_auto_commit_cb(tmq_commit_callback, Box::into_raw(Box::new(cb)) as _);\n        self\n    }\n\n    pub fn build(\u0026self) -\u003e crate::Result\u003cConsumer\u003e {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.conf.as_ptr(), err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                return Err(crate::Error::custom(\n                    String::from_utf8_lossy(\u0026err).to_string(),\n                ));\n            } else {\n                let mut cons = Consumer::new(tmq, self.wait);\n                cons.subscribe(\u0026self.topics)?;\n                Ok(cons)\n            }\n        }\n    }\n\n    pub fn subscribe\u003c'a, T: IntoCStr\u003c'a\u003e\u003e(\n        \u0026self,\n        topics: impl IntoIterator\u003cItem = T\u003e,\n    ) -\u003e crate::Result\u003cConsumer\u003e {\n        unsafe {\n            let mut err = [0; 256];\n            let tmq = tmq_consumer_new(self.conf.as_ptr(), err.as_mut_ptr() as _, 255);\n            if err[0] != 0 {\n                return Err(crate::Error::custom(\n                    String::from_utf8_lossy(\u0026err).to_string(),\n                ));\n            } else {\n                let mut cons = Consumer::new(tmq, self.wait);\n                let topics = TmqList::from_topics(topics)?;\n                cons.subscribe(\u0026topics)?;\n                Ok(cons)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::sync::atomic;\n    use std::sync::Arc;\n    use std::thread;\n    use std::time::Duration;\n\n    use crate::prelude::sync::*;\n    use crate::tmq::*;\n\n    use anyhow::Result;\n\n    #[crate::test(log_level = \"debug\")]\n    fn independent_blocks(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(\"create table tb1 (ts timestamp, v1 int)\")?;\n        taos.exec(\"create table tb2 (ts timestamp, v2 int)\")?;\n        taos.exec(\"create table tb3 (ts timestamp, v3 int)\")?;\n        taos.exec(\"create table tb4 (ts timestamp, v4 int)\")?;\n        taos.exec(\"create table tb5 (ts timestamp, v5 int)\")?;\n        taos.exec(concat!(\n            \"insert into tb1 values(now, 1) \",\n            \"tb2 values(now, 2) \",\n            \"tb3 values(now, 3)\",\n            \"tb4 values(now, 4)\",\n            \"tb5 values(now, 5)\",\n        ))?;\n        taos.exec(format!(\"create topic {database} as {database}\"))?;\n\n        let builder = TmqBuilder::from_dsn(format!(\n            \"taos:///{database}?topics={database}\u0026group.id={database}\u0026wait=1000\"\n        ))?;\n        let mut tmq = builder.build()?;\n        while let Some(Ok(mut rs)) = tmq.poll() {\n            for block in rs.blocks_iter() {\n                let fields = block.fields();\n                let tbname = block.tmq_table_name().unwrap();\n                log::info!(\"block table name: {tbname}\");\n                assert!(fields.len() == 2);\n                dbg!(fields);\n                for row in block.deserialize::\u003c(String, i32)\u003e() {\n                    let row = row?;\n                    dbg!(row);\n                }\n            }\n            let (blocks, records) = rs.summary();\n            log::info!(\"fetch {blocks} blocks, with {records} records\");\n        }\n        Ok(())\n    }\n\n    fn drop_topic(taos: \u0026Taos, topic: \u0026str) -\u003e Result\u003c()\u003e {\n        taos.exec(format!(\"drop topic if exists {topic}\"))?;\n        Ok(())\n    }\n\n    fn _build_consumer(taos: \u0026Taos) -\u003e Result\u003cConsumer\u003e {\n        println!(\"consumer config\");\n        let mut conf = TmqConf::new();\n        conf.set(\"group.id\", \"tg2\")?;\n        unsafe extern \"C\" fn tmq_commit_callback(\n            _tmq: *mut tmq_t,\n            resp: tmq_resp_err_t,\n            param: *mut c_void,\n        ) {\n            log::info!(\"commit {resp:?}\");\n        }\n        conf.set_auto_commit_cb(tmq_commit_callback, std::ptr::null_mut());\n        println!(\"build consumer\");\n        Ok(conf.consumer()?)\n    }\n\n    fn process_message(msg: \u0026mut ResultSet) {\n        let rows = msg.to_rows_vec();\n\n        for row in rows {\n            println!(\"{row:?}\");\n        }\n    }\n\n    fn insert(database: \u0026str, max_inserts: usize) -\u003e Result\u003c()\u003e {\n        println!(\"connect taos in a spawned thread\");\n        let taos = Taos::new((), \"root\", \"taosdata\", database, 0)?;\n        println!(\"start to insert 10 rows\");\n        for i in 0..max_inserts {\n            use crate::prelude::sync::*;\n            taos.exec(\u0026format!(\"insert into tu1 values (now, {i})\"))?;\n            println!(\"- {i} rows inserted\");\n        }\n        drop(taos);\n        println!(\"write data thread finish\");\n        Ok(())\n    }\n    fn sync_consume_loop(database: \u0026str, consumer: \u0026mut Consumer) -\u003e Result\u003c()\u003e {\n        println!(\"consume loop\");\n        let running = Arc::new(atomic::AtomicBool::new(true));\n        let msg_count = atomic::AtomicUsize::new(0);\n        let running2 = running.clone();\n\n        let database = database.to_string();\n        thread::spawn(move || match insert(\u0026database, 10) {\n            Ok(_) =\u003e {\n                running2.store(false, atomic::Ordering::SeqCst);\n            }\n            Err(err) =\u003e {\n                running2.store(false, atomic::Ordering::SeqCst);\n                eprintln!(\"{}\", err.to_string());\n            }\n        });\n\n        println!(\"inserting thread spawned.\");\n        while running.load(atomic::Ordering::SeqCst)\n            || msg_count.load(atomic::Ordering::SeqCst) \u003c 10\n        {\n            println!(\"looping...\");\n            if let Some(Ok(mut msg)) = consumer.poll_wait(1000) {\n                println!(\"msg: {}\", msg_count.load(atomic::Ordering::SeqCst));\n                process_message(\u0026mut msg);\n                msg_count.fetch_add(1, atomic::Ordering::SeqCst);\n\n                consumer.commit_sync(\u0026msg)?;\n                println!(\"msg summary: {:?}\", msg.summary());\n            }\n        }\n        println!(\"loop done\");\n        Ok(())\n    }\n\n    // todo: drop after consume will cause segmentation fault, use specific db name and no dropping.\n    // #[crate::test(log_level = \"trace\", naming = \"tmq_consume_test\", dropping = \"none\")]\n    #[crate::test(log_level = \"trace\")]\n    fn tmq_consume(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n        let version = crate::client_info();\n        println!(\"version: {}\", version);\n        if !version.starts_with(\"3\") {\n            return Ok(());\n        }\n        println!(\"connected\");\n        taos.exec_many([\n            \"create stable if not exists st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists tu1 using st1 tags(1)\",\n            \"create table if not exists tu2 using st1 tags(2)\",\n        ])?;\n        taos.create_topic_as_database(database, database)?;\n\n        let topic = database;\n        let gid = database;\n\n        let dsn = format!(\"taos:///{database}?topics={topic}\u0026group.id={gid}\u0026wait=1000\");\n        log::info!(\"subscribe with dsn: {dsn}\");\n        let mut consumer = TmqBuilder::from_dsn(\u0026dsn)?\n            .on_auto_commit(\n                |_: ConsumerRef, _: std::result::Result\u003c(), taos_error::Error\u003e| {\n                    log::info!(\"rust callback\");\n                },\n            )\n            .build()?;\n        println!(\"topics created\");\n        sync_consume_loop(database, \u0026mut consumer)?;\n        dbg!(consumer.subscription()?);\n        std::mem::drop(consumer);\n        drop_topic(\u0026taos, \u0026topic)?;\n        println!(\"finished\");\n        Ok(())\n    }\n\n    /// Consume from one database and write to another.\n    // #[crate::test(log_level = \"trace\")]\n    #[crate::test(log_level = \"trace\", naming = \"tmq1\")]\n    async fn tmq_stream(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n        let version = crate::client_info();\n        println!(\"version: {}\", version);\n        if !version.starts_with(\"3\") {\n            return Ok(());\n        }\n        println!(\"connected\");\n        taos.exec_many([\n            \"create stable if not exists st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists tu1 using st1 tags(1)\",\n            \"create table if not exists tu2 using st1 tags(2)\",\n        ])?;\n        taos.create_topic_as_database(database, database)?;\n\n        let topic = database;\n        let gid = database;\n\n        let dsn = format!(\n            \"taos:///{database}?topics={topic}\u0026group.id={gid}\u0026wait=2000\u0026msg.with.table.name=true\"\n        );\n        log::info!(\"subscribe with dsn: {dsn}\");\n        let consumer = TmqBuilder::from_dsn(\u0026dsn)?\n            .on_auto_commit(\n                |_: ConsumerRef, _: std::result::Result\u003c(), taos_error::Error\u003e| {\n                    log::info!(\"rust callback\");\n                },\n            )\n            .build()?;\n        println!(\"topics created\");\n\n        const MAX_INSERTS: usize = 10;\n        let database = database.to_string();\n        thread::spawn(move || insert(\u0026database, MAX_INSERTS));\n\n        taos.exec_many([\n            \"create database if not exists db2\",\n            \"create stable if not exists db2.st1 (ts timestamp, k int) tags(a int)\",\n            \"create table if not exists db2.tu1 using db2.st1 tags(1)\",\n            \"create table if not exists db2.tu2 using db2.st1 tags(2)\",\n        ])?;\n        let unfold = futures::sink::unfold(0, |mut sum, mut rs: ResultSet| async move {\n            for block in rs.blocks_iter() {\n                let bind: Vec\u003cTaosMultiBind\u003e = block.columns_iter().map(|col| col.into()).collect();\n                let table = block.tmq_table_name().unwrap();\n                let mut stmt = taos.stmt(format!(\"insert into db2.{table} values(?,?)\"))?;\n                stmt.multi_bind(\u0026bind)?;\n                stmt.execute()?;\n                let inserted = stmt.affected_rows();\n                log::info!(\"inserted {inserted} rows\");\n            }\n            let (blocks, rows) = rs.summary();\n            assert!(blocks == 1, \"tmq response blocks always should be 1\");\n            sum += rows;\n            eprintln!(\"sum: {sum}, rows in block = {rows}\");\n            Ok::\u003c_, crate::Error\u003e(sum)\n        });\n        futures::pin_mut!(unfold);\n        use futures::prelude::*;\n        consumer.forward(unfold).await?;\n\n        let db2_rows: usize = taos.query_one(\"select count(*) from db2.tu1\")?.unwrap_or(0);\n        drop_topic(\u0026taos, \u0026topic)?;\n        taos.exec(\"drop database db2\")?;\n        if db2_rows != MAX_INSERTS {\n            anyhow::bail!(\"inserted rows not match\");\n        }\n        println!(\"finished\");\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[3683488],"length":1,"stats":{"Line":0},"fn_name":"tmq_commit_callback"},{"line":21,"address":[3683685,3683525,3683616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[3683662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[3683827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[3683861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3683952],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":32,"address":[3683956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[3684000],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":35,"address":[3684005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3684016],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":55,"address":[3684035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3684080],"length":1,"stats":{"Line":0},"fn_name":"to_str_vec"},{"line":60,"address":[3684115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[3684135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[3684153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3684163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[3684176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[3684204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3602736],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":69,"address":[3602750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[3684320],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":84,"address":[3684337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[3723088],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":92,"address":[3723256,3723108,3723199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[3723245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[3723489,3723334,3723428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[3684368,3684883],"length":1,"stats":{"Line":0},"fn_name":"on_auto_commit"},{"line":172,"address":[3684413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3684498,3684429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3684508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[3684823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[3684797,3684598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[3684403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3684928,3685267],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":183,"address":[3684958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[3684980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[3685046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[3685185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[3685097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[3685063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[3685311,3685482,3685383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3685441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":95},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","src","util","mod.rs"],"content":"pub use taos_sys::into_c_str::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos","tests","de.rs"],"content":"#![allow(dead_code)]\nuse chrono::NaiveDateTime;\nuse futures::StreamExt;\nuse futures::TryStreamExt;\nuse std::ffi::CString;\n\nuse taos::helpers::ShowDatabase;\n\nuse taos::prelude::*;\n\npub use taos::helpers;\n#[derive(serde::Deserialize, Debug)]\nstruct JsonTag {\n    name: String,\n}\n\n#[derive(serde::Deserialize, Debug)]\nstruct Record {\n    ts: NaiveDateTime,\n    i8: i8,\n    i16: i16,\n    i32: i32,\n    i64: i64,\n    u8: u8,\n    u16: u16,\n    u32: u32,\n    u64: u64,\n    raw_ts: i64,\n    c_str: CString,\n    str: String,\n    json_tag: serde_json::Value,\n}\n#[derive(serde::Deserialize, Debug)]\nstruct RecordOption {\n    ts: Option\u003cNaiveDateTime\u003e,\n    i8: Option\u003ci8\u003e,\n    i16: Option\u003ci16\u003e,\n    i32: Option\u003ci32\u003e,\n    i64: Option\u003ci64\u003e,\n    u8: Option\u003cu8\u003e,\n    u16: Option\u003cu16\u003e,\n    u32: Option\u003cu32\u003e,\n    u64: Option\u003cu64\u003e,\n    raw_ts: Option\u003ci64\u003e,\n    c_str: Option\u003cCString\u003e,\n    str: Option\u003cString\u003e,\n    json_tag: Option\u003cserde_json::Value\u003e,\n}\n#[derive(serde::Deserialize, Debug)]\nstruct RecordOptionWithJsonTag {\n    ts: Option\u003cNaiveDateTime\u003e,\n    i8: Option\u003ci8\u003e,\n    i16: Option\u003ci16\u003e,\n    i32: Option\u003ci32\u003e,\n    i64: Option\u003ci64\u003e,\n    u8: Option\u003cu8\u003e,\n    u16: Option\u003cu16\u003e,\n    u32: Option\u003cu32\u003e,\n    u64: Option\u003cu64\u003e,\n    raw_ts: Option\u003ci64\u003e,\n    c_str: Option\u003cCString\u003e,\n    str: Option\u003cString\u003e,\n    json_tag: Option\u003cJsonTag\u003e,\n}\n\n#[cfg(any(feature = \"test\", test))]\n#[taos::test(log_level = \"trace\")]\nasync fn de_seq_value(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (gid int, location nchar(16))\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags(1, 'beijing') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags(2, 'shanghai') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos.query(\"select tbname,gid,location from stb1\").await?;\n    use futures::StreamExt;\n\n    use futures::future;\n    res.deserialize_stream::\u003cVec\u003cValue\u003e\u003e()\n        .enumerate()\n        .for_each(|(_, v)| {\n            let value = v.unwrap();\n            log::debug!(\"{:?}\", value);\n            future::ready(())\n        })\n        .await;\n\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_seq_value2(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (groupid int, location nchar(16))\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags(1, 'beijing') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags(2, 'shanghai') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos\n        .query(\"select tbname,groupid,location from stb1\")\n        .await?;\n    use futures::StreamExt;\n\n    // block.rows_iter()\n    // let mut stream = res.deserialize_stream();\n    use futures::future;\n    res.deserialize_stream::\u003cVec\u003cValue\u003e\u003e()\n        .enumerate()\n        .for_each(|(_, v)| {\n            let value = v.unwrap();\n            log::debug!(\"{:?}\", value);\n            future::ready(())\n        })\n        .await;\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_all(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    use futures::StreamExt;\n\n    // block.rows_iter()\n    let record: Record = res.deserialize_stream().next().await.unwrap()?;\n    log::debug!(\"fetched record {:?}\", record);\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\", dropping = \"none\")]\nasync fn de_all_option(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags('{\"name\":\"\"}') \"#,\n        r#\"values (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\"#\n    ))?;\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    // block.rows_iter()\n    let record: Vec\u003cRecordOption\u003e = res.deserialize_stream().try_collect().await?;\n    log::debug!(\"fetched record {:?}\", record);\n    Ok(())\n}\n\n#[taos::test(log_level = \"trace\")]\nasync fn de_all_option_with_json_tag_struct(taos: \u0026Taos, _database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n    log::info!(\"create table\");\n    taos.exec_sync(\n        \"create table if not exists stb1(ts timestamp,\n            i8 tinyint, i16 smallint, i32 int, i64 bigint,\n            u8 tinyint unsigned, u16 smallint unsigned, u32 int unsigned, u64 bigint unsigned,\n            raw_ts timestamp, c_str binary(100), str nchar(100)) tags (json_tag json)\",\n    )?;\n    log::info!(\"insert data\");\n    taos.exec_sync(concat!(\n        r#\"insert into tb1 using stb1 tags('{\"name\":\"abc\"}') \"#,\n        r#\"values (now,1,2,3,4,5,6,7,8, now, \"abc\", \"\")\"#\n    ))?;\n    taos.exec_sync(concat!(\n        r#\"insert into tb2 using stb1 tags('{\"name\":\"\"}') \"#,\n        r#\"values (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\"#\n    ))?;\n    log::info!(\"select\");\n    let mut res = taos.query(\"select * from stb1\").await?;\n    // block.rows_iter()\n    let record: Vec\u003cRecordOptionWithJsonTag\u003e = res.deserialize_stream().try_collect().await?;\n    log::debug!(\"fetched records {:#?}\", record);\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_string(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    let mut res = taos.query(\"select server_version() as version\").await?;\n    use futures::StreamExt;\n\n    let version: String = res\n        .deserialize_stream()\n        .next()\n        .await\n        .expect(\"select version\")?;\n    println!(\"version: {version}\");\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_wrapper_struct(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    let mut res = taos.query(\"select server_version() as version\").await?;\n    use futures::StreamExt;\n\n    #[derive(::serde::Deserialize, Debug)]\n    struct Version(String);\n    let version: Version = res\n        .deserialize_stream()\n        .next()\n        .await\n        .expect(\"select version\")?;\n    println!(\"version: {:?}\", version);\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_named_struct(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    macro_rules! de {\n        ($taos:expr, $sql:expr) =\u003e {\n            $taos\n                .query($sql)\n                .await?\n                .deserialize_stream()\n                .next()\n                .await\n                .unwrap()?\n        };\n    }\n    #[derive(::serde::Deserialize, Debug)]\n    struct Version {\n        version: String,\n    }\n    #[derive(::serde::Deserialize, Debug)]\n    struct WrapperVersion(String);\n    #[derive(::serde::Deserialize, Debug)]\n    struct WrapperOptionVersion(Option\u003cString\u003e);\n\n    // value\n    let _version: String = de!(taos, \"select server_version()\");\n    // tuple\n    let _version: (String,) = de!(taos, \"select server_version()\");\n    // struct\n    let _version: Version = de!(taos, \"select server_version() as version\");\n    // option\n    let _version: Option\u003cString\u003e = de!(taos, \"select server_version() as version\");\n    // wrapper struct\n    let _version: WrapperVersion = de!(taos, \"select server_version() as version\");\n    // wrapper struct with option\n    let _version: WrapperOptionVersion = dbg!(de!(taos, \"select server_version() as version\"));\n    Ok(())\n}\n\n#[taos::test]\nasync fn de_vec(taos: \u0026Taos) -\u003e anyhow::Result\u003c()\u003e {\n    // let taos = TaosOptions::new().build()?;\n    // std::env::set_var(\"RUST_LOG\", \"trace\");\n    // pretty_env_logger::init();\n\n    let db: Vec\u003cShowDatabase\u003e = taos.databases().await?;\n    println!(\"db: {:?}\", db);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-error","build.rs"],"content":"use std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::{error::Error, io::BufReader};\n\nuse heck::*;\nuse regex::Regex;\n\nfn code_from_header(\n    header: impl AsRef\u003cPath\u003e,\n    mut output: impl Write,\n) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let regex = Regex::new(\n        r\"#define TSDB_CODE_(?P\u003cname\u003e\\S+)\\s+TAOS_DEF_ERROR_CODE\\(0, (?P\u003ccode\u003e\\S+)\\)\\s+//.(?P\u003creason\u003e.*).\\)\",\n    )?;\n\n    let file = File::open(header)?;\n    let buf = BufReader::new(file);\n    const NAME: \u0026str = \"Code\";\n    writeln!(\n        output,\n        r#\"\nuse std::fmt;\n\nuse num_enum::{{FromPrimitive, IntoPrimitive}};\n\nmacro_rules! _impl_fmt {{\n    ($fmt:ident) =\u003e {{\n        impl fmt::$fmt for {NAME} {{\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {{\n                let val = *self as i32;\n                fmt::$fmt::fmt(\u0026val, f)\n            }}\n        }}\n    }};\n}}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum {NAME} {{\n    /// Success, 0\n    Success = 0x0000,\"#\n    )?;\n    let codes: Vec\u003c_\u003e = buf\n        .lines()\n        .flat_map(Result::ok)\n        .flat_map(|line| {\n            regex.captures(\u0026line).map(|caps| {\n                (\n                    caps.name(\"name\").unwrap().as_str().to_string(),\n                    caps.name(\"code\").unwrap().as_str().to_string(),\n                    caps.name(\"reason\").unwrap().as_str().to_string(),\n                )\n            })\n        })\n        .collect();\n    for (name, code, reason) in \u0026codes {\n        writeln!(output, \"    /// {}: {}\", name, reason)?;\n        writeln!(output, \"    {} = {},\", name.to_upper_camel_case(), code)?;\n    }\n    writeln!(\n        output,\n        r#\"\n    #[num_enum(default)]\n    Failed = 0xffff,\n}}\n\nimpl {NAME} {{\n    pub fn success(\u0026self) -\u003e bool {{\n        matches!(self, {NAME}::Success)\n    }}\"#\n    )?;\n\n    for (name, _, reason) in \u0026codes {\n        writeln!(output, \"    /// {}: {}\", name, reason)?;\n        writeln!(\n            output,\n            \"    pub fn {}(\u0026self) -\u003e bool {{\\n        matches!(self, {NAME}::{})\\n    }}\",\n            name.to_snake_case(),\n            name.to_upper_camel_case()\n        )?;\n    }\n    writeln!(output, r#\"}}\"#)?;\n\n    writeln!(\n        output,\n        r#\"\nimpl {NAME} {{\n    pub fn to_str(\u0026self) -\u003e \u0026'static str {{\n        use {NAME}::*;\n        match self {{\n            Success =\u003e \"Success\",\n\"#\n    )?;\n    for (name, _, reason) in \u0026codes {\n        writeln!(\n            output,\n            r#\"            {} =\u003e \"{reason}\",\"#,\n            name.to_upper_camel_case()\n        )?;\n    }\n    writeln!(\n        output,\n        r#\"            Failed =\u003e \"Unknown or needn't tell detail error\",\"#\n    )?;\n    writeln!(\n        output,\n        r#\"        }}\n    }}\n}}\n\"#\n    )?;\n    Ok(())\n}\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let header = \"src/taoserror.h\";\n    println!(\"cargo:rerun-if-changed={header}\");\n    println!(\"cargo:rerun-if-changed=build.rs\");\n\n    let out_dir = env::var_os(\"OUT_DIR\").unwrap();\n    let rs = File::create(Path::new(\u0026out_dir).join(\"code.rs\"))?;\n    code_from_header(header, rs)?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-error","src","lib.rs"],"content":"use std::{\n    borrow::Cow,\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nmod code {\n    include!(concat!(env!(\"OUT_DIR\"), \"/code.rs\"));\n}\n\npub use code::Code;\nuse serde::de;\n\n#[derive(Debug)]\npub struct Error {\n    code: Code,\n    err: Cow\u003c'static, str\u003e,\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\nimpl std::error::Error for Error {}\n\nimpl Error {\n    #[inline]\n    pub fn new(code: impl Into\u003cCode\u003e, err: impl Into\u003cCow\u003c'static, str\u003e\u003e) -\u003e Self {\n        Self {\n            code: code.into(),\n            err: err.into(),\n        }\n    }\n\n    #[inline]\n    pub fn from_code(code: impl Into\u003cCode\u003e) -\u003e Self {\n        Self {\n            code: code.into(),\n            err: \"\".into(),\n        }\n    }\n\n    #[inline]\n    pub fn from_string(err: impl Into\u003cCow\u003c'static, str\u003e\u003e) -\u003e Self {\n        Self {\n            code: Code::Failed,\n            err: err.into(),\n        }\n    }\n}\n\nimpl FromStr for Error {\n    type Err = ();\n\n    #[inline]\n    fn from_str(s: \u0026str) -\u003e std::result::Result\u003cSelf, Self::Err\u003e {\n        Ok(Self {\n            code: Code::Failed,\n            err: s.to_string().into(),\n        })\n    }\n}\n\nimpl Display for Error {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"[{:#06X}] {}\", self.code, self.err)\n    }\n}\n\nimpl de::Error for Error {\n    #[inline]\n    fn custom\u003cT: fmt::Display\u003e(msg: T) -\u003e Error {\n        Error::from_string(format!(\"{}\", msg))\n    }\n}\n\n#[test]\nfn test_display() {\n    let err = Error::new(Code::Success, \"Success\");\n    assert_eq!(format!(\"{err}\"), \"[0x0000] Success\");\n}\n","traces":[{"line":26,"address":[8118550,8118778,8118320,8118832,8118576,8119017,8118522,8118806],"length":1,"stats":{"Line":0},"fn_name":"new\u003ctaos_error::code::Code, alloc::string::String\u003e"},{"line":28,"address":[8118357,8118880,8118613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[8118419,8118675,8118939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[8119040],"length":1,"stats":{"Line":0},"fn_name":"from_code\u003ctaos_error::code::Code\u003e"},{"line":36,"address":[8119069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8119079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3841600,3841712],"length":1,"stats":{"Line":0},"fn_name":"from_string\u003c\u0026str\u003e"},{"line":45,"address":[3841631,3841733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8764448],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":55,"address":[8764515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8764477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[8764485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3972080],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":65,"address":[3972113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[8783192,8782992],"length":1,"stats":{"Line":0},"fn_name":"custom\u003ccore::fmt::Arguments\u003e"},{"line":72,"address":[8783080,8783022],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","src","lib.rs"],"content":"#[cfg(test)]\nmod tests {\n    use taos::Taos;\n    use taos_macros::test;\n\n    #[test]\n    fn sync() {}\n\n    #[test]\n    async fn async_unit() {}\n\n    #[test]\n    async fn async_with_taos(_taos: \u0026Taos) {}\n\n    #[test]\n    async fn async_with_taos_db(_taos: \u0026Taos, _database: \u0026str) {}\n\n    #[test(databases = 10)]\n    async fn async_with_taos_multi(taos: \u0026Taos, _databases: \u0026[\u0026str]) -\u003e taos::Result\u003c()\u003e {\n        let a = taos.databases().await?;\n        assert!(a.len() \u003e= 10);\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","anyhow-d6c2a10a550f3674","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(\u0026self) -\u003e Option\u003c\u0026Backtrace\u003e {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ =\u003e {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","anyhow-db2f151f47fbe6e5","out","probe.rs"],"content":"\n    #![feature(backtrace)]\n    #![allow(dead_code)]\n\n    use std::backtrace::{Backtrace, BacktraceStatus};\n    use std::error::Error;\n    use std::fmt::{self, Display};\n\n    #[derive(Debug)]\n    struct E;\n\n    impl Display for E {\n        fn fmt(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            unimplemented!()\n        }\n    }\n\n    impl Error for E {\n        fn backtrace(\u0026self) -\u003e Option\u003c\u0026Backtrace\u003e {\n            let backtrace = Backtrace::capture();\n            match backtrace.status() {\n                BacktraceStatus::Captured | BacktraceStatus::Disabled | _ =\u003e {}\n            }\n            unimplemented!()\n        }\n    }\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","taos-error-377b4e21fb40c858","out","code.rs"],"content":"\nuse std::fmt;\n\nuse num_enum::{FromPrimitive, IntoPrimitive};\n\nmacro_rules! _impl_fmt {\n    ($fmt:ident) =\u003e {\n        impl fmt::$fmt for Code {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                let val = *self as i32;\n                fmt::$fmt::fmt(\u0026val, f)\n            }\n        }\n    };\n}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum Code {\n    /// Success, 0\n    Success = 0x0000,\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    TscInvalidOperation = 0x0200,\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    TscInvalidQhandle = 0x0201,\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    TscInvalidTimeStamp = 0x0202,\n    /// TSC_INVALID_VALUE: Invalid value in client\n    TscInvalidValue = 0x0203,\n    /// TSC_INVALID_VERSION: Invalid client version\n    TscInvalidVersion = 0x0204,\n    /// TSC_INVALID_IE: Invalid client ie\n    TscInvalidIe = 0x0205,\n    /// TSC_INVALID_FQDN: Invalid host name\n    TscInvalidFqdn = 0x0206,\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    TscInvalidUserLength = 0x0207,\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    TscInvalidPassLength = 0x0208,\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    TscInvalidDbLength = 0x0209,\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    TscInvalidTableIdLength = 0x020A,\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    TscInvalidConnection = 0x020B,\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    TscOutOfMemory = 0x020C,\n    /// TSC_NO_DISKSPACE: System out of disk space\n    TscNoDiskspace = 0x020D,\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    TscQueryCacheErased = 0x020E,\n    /// TSC_QUERY_CANCELLED: Query terminated\n    TscQueryCancelled = 0x020F,\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    TscSortedResTooMany = 0x0210,\n    /// TSC_APP_ERROR: Application error\n    TscAppError = 0x0211,\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    TscActionInProgress = 0x0212,\n    /// TSC_DISCONNECTED: Disconnected from service\n    TscDisconnected = 0x0213,\n    /// TSC_NO_WRITE_AUTH: No write permission\n    TscNoWriteAuth = 0x0214,\n    /// TSC_CONN_KILLED: Connection killed\n    TscConnKilled = 0x0215,\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    TscSqlSyntaxError = 0x0216,\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    TscDbNotSelected = 0x0217,\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    TscInvalidTableName = 0x0218,\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    TscExceedSqlLimit = 0x0219,\n    /// TSC_FILE_EMPTY: File is empty\n    TscFileEmpty = 0x021A,\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    TscLineSyntaxError = 0x021B,\n    /// TSC_NO_META_CACHED: No table meta cached\n    TscNoMetaCached = 0x021C,\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    TscDupColNames = 0x021D,\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    TscInvalidTagLength = 0x021E,\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    TscInvalidColumnLength = 0x021F,\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    TscDupTagNames = 0x0220,\n    /// TSC_INVALID_JSON: Invalid JSON format\n    TscInvalidJson = 0x0221,\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    TscInvalidJsonType = 0x0222,\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    TscInvalidJsonConfig = 0x0223,\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    TscValueOutOfRange = 0x0224,\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    TscInvalidProtocolType = 0x0225,\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    TscInvalidPrecisionType = 0x0226,\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    TscResTooMany = 0x0227,\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    TscInvalidSchemaVersion = 0x0228,\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    MndInvalidTopic = 0x0392,\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    MndInvalidTopicOption = 0x0393,\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    MndInvalidTopicPartitons = 0x0394,\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    MndTopicAlreadyExist = 0x0395,\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    TdbInvalidTableId = 0x0600,\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    TdbInvalidTableType = 0x0601,\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    TdbIvdTbSchemaVersion = 0x0602,\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    TdbTableAlreadyExist = 0x0603,\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    TdbInvalidConfig = 0x0604,\n    /// TDB_INIT_FAILED: Tsdb init failed\n    TdbInitFailed = 0x0605,\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    TdbNoDiskspace = 0x0606,\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    TdbNoDiskPermissions = 0x0607,\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    TdbFileCorrupted = 0x0608,\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    TdbOutOfMemory = 0x0609,\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    TdbTagVerOutOfDate = 0x060A,\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    TdbTimestampOutOfRange = 0x060B,\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    TdbSubmitMsgMssedUp = 0x060C,\n    /// TDB_INVALID_ACTION: Invalid operation\n    TdbInvalidAction = 0x060D,\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    TdbInvalidCreateTbMsg = 0x060E,\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    TdbNoTableDataInMem = 0x060F,\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    TdbFileAlreadyExists = 0x0610,\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    TdbTableReconfigure = 0x0611,\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    TdbIvdCreateTableInfo = 0x0612,\n    /// TDB_NO_AVAIL_DISK: No available disk\n    TdbNoAvailDisk = 0x0613,\n    /// TDB_MESSED_MSG: TSDB messed message\n    TdbMessedMsg = 0x0614,\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    TdbIvldTagVal = 0x0615,\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    TdbNoCacheLastRow = 0x0616,\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    TdbIncompleteDfileset = 0x0617,\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    QryInvalidQhandle = 0x0700,\n    /// QRY_INVALID_MSG: Invalid message\n    QryInvalidMsg = 0x0701,\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    QryNoDiskspace = 0x0702,\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    QryOutOfMemory = 0x0703,\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    QryAppError = 0x0704,\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    QryDupJoinKey = 0x0705,\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    QryExceedTagsLimit = 0x0706,\n    /// QRY_NOT_READY: Query not ready\n    QryNotReady = 0x0707,\n    /// QRY_HAS_RSP: Query should response\n    QryHasRsp = 0x0708,\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    QryInExec = 0x0709,\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    QryTooManyTimewindow = 0x070A,\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    QryNotEnoughBuffer = 0x070B,\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    QryInconsistan = 0x070C,\n    /// QRY_SYS_ERROR: System error\n    QrySysError = 0x070D,\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    QryInvalidTimeCondition = 0x070E,\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    QryInvalidSchemaVersion = 0x0710,\n\n    #[num_enum(default)]\n    Failed = 0xffff,\n}\n\nimpl Code {\n    pub fn success(\u0026self) -\u003e bool {\n        matches!(self, Code::Success)\n    }\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    pub fn tsc_invalid_operation(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidOperation)\n    }\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    pub fn tsc_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidQhandle)\n    }\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    pub fn tsc_invalid_time_stamp(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTimeStamp)\n    }\n    /// TSC_INVALID_VALUE: Invalid value in client\n    pub fn tsc_invalid_value(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidValue)\n    }\n    /// TSC_INVALID_VERSION: Invalid client version\n    pub fn tsc_invalid_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidVersion)\n    }\n    /// TSC_INVALID_IE: Invalid client ie\n    pub fn tsc_invalid_ie(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidIe)\n    }\n    /// TSC_INVALID_FQDN: Invalid host name\n    pub fn tsc_invalid_fqdn(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidFqdn)\n    }\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    pub fn tsc_invalid_user_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidUserLength)\n    }\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    pub fn tsc_invalid_pass_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPassLength)\n    }\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    pub fn tsc_invalid_db_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidDbLength)\n    }\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    pub fn tsc_invalid_table_id_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableIdLength)\n    }\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    pub fn tsc_invalid_connection(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidConnection)\n    }\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    pub fn tsc_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TscOutOfMemory)\n    }\n    /// TSC_NO_DISKSPACE: System out of disk space\n    pub fn tsc_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoDiskspace)\n    }\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    pub fn tsc_query_cache_erased(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCacheErased)\n    }\n    /// TSC_QUERY_CANCELLED: Query terminated\n    pub fn tsc_query_cancelled(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCancelled)\n    }\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    pub fn tsc_sorted_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSortedResTooMany)\n    }\n    /// TSC_APP_ERROR: Application error\n    pub fn tsc_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscAppError)\n    }\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    pub fn tsc_action_in_progress(\u0026self) -\u003e bool {\n        matches!(self, Code::TscActionInProgress)\n    }\n    /// TSC_DISCONNECTED: Disconnected from service\n    pub fn tsc_disconnected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDisconnected)\n    }\n    /// TSC_NO_WRITE_AUTH: No write permission\n    pub fn tsc_no_write_auth(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoWriteAuth)\n    }\n    /// TSC_CONN_KILLED: Connection killed\n    pub fn tsc_conn_killed(\u0026self) -\u003e bool {\n        matches!(self, Code::TscConnKilled)\n    }\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    pub fn tsc_sql_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSqlSyntaxError)\n    }\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    pub fn tsc_db_not_selected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDbNotSelected)\n    }\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    pub fn tsc_invalid_table_name(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableName)\n    }\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    pub fn tsc_exceed_sql_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::TscExceedSqlLimit)\n    }\n    /// TSC_FILE_EMPTY: File is empty\n    pub fn tsc_file_empty(\u0026self) -\u003e bool {\n        matches!(self, Code::TscFileEmpty)\n    }\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    pub fn tsc_line_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscLineSyntaxError)\n    }\n    /// TSC_NO_META_CACHED: No table meta cached\n    pub fn tsc_no_meta_cached(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoMetaCached)\n    }\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    pub fn tsc_dup_col_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupColNames)\n    }\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    pub fn tsc_invalid_tag_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTagLength)\n    }\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    pub fn tsc_invalid_column_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidColumnLength)\n    }\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    pub fn tsc_dup_tag_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupTagNames)\n    }\n    /// TSC_INVALID_JSON: Invalid JSON format\n    pub fn tsc_invalid_json(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJson)\n    }\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    pub fn tsc_invalid_json_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonType)\n    }\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    pub fn tsc_invalid_json_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonConfig)\n    }\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    pub fn tsc_value_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TscValueOutOfRange)\n    }\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    pub fn tsc_invalid_protocol_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidProtocolType)\n    }\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    pub fn tsc_invalid_precision_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPrecisionType)\n    }\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    pub fn tsc_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscResTooMany)\n    }\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    pub fn tsc_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidSchemaVersion)\n    }\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    pub fn mnd_invalid_topic(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopic)\n    }\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    pub fn mnd_invalid_topic_option(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicOption)\n    }\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    pub fn mnd_invalid_topic_partitons(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicPartitons)\n    }\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    pub fn mnd_topic_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::MndTopicAlreadyExist)\n    }\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    pub fn tdb_invalid_table_id(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableId)\n    }\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    pub fn tdb_invalid_table_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableType)\n    }\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    pub fn tdb_ivd_tb_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdTbSchemaVersion)\n    }\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    pub fn tdb_table_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableAlreadyExist)\n    }\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    pub fn tdb_invalid_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidConfig)\n    }\n    /// TDB_INIT_FAILED: Tsdb init failed\n    pub fn tdb_init_failed(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInitFailed)\n    }\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    pub fn tdb_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskspace)\n    }\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    pub fn tdb_no_disk_permissions(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskPermissions)\n    }\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    pub fn tdb_file_corrupted(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileCorrupted)\n    }\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    pub fn tdb_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbOutOfMemory)\n    }\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    pub fn tdb_tag_ver_out_of_date(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTagVerOutOfDate)\n    }\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    pub fn tdb_timestamp_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTimestampOutOfRange)\n    }\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    pub fn tdb_submit_msg_mssed_up(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbSubmitMsgMssedUp)\n    }\n    /// TDB_INVALID_ACTION: Invalid operation\n    pub fn tdb_invalid_action(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidAction)\n    }\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    pub fn tdb_invalid_create_tb_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidCreateTbMsg)\n    }\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    pub fn tdb_no_table_data_in_mem(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoTableDataInMem)\n    }\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    pub fn tdb_file_already_exists(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileAlreadyExists)\n    }\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    pub fn tdb_table_reconfigure(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableReconfigure)\n    }\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    pub fn tdb_ivd_create_table_info(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdCreateTableInfo)\n    }\n    /// TDB_NO_AVAIL_DISK: No available disk\n    pub fn tdb_no_avail_disk(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoAvailDisk)\n    }\n    /// TDB_MESSED_MSG: TSDB messed message\n    pub fn tdb_messed_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbMessedMsg)\n    }\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    pub fn tdb_ivld_tag_val(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvldTagVal)\n    }\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    pub fn tdb_no_cache_last_row(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoCacheLastRow)\n    }\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    pub fn tdb_incomplete_dfileset(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIncompleteDfileset)\n    }\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    pub fn qry_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidQhandle)\n    }\n    /// QRY_INVALID_MSG: Invalid message\n    pub fn qry_invalid_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidMsg)\n    }\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    pub fn qry_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNoDiskspace)\n    }\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    pub fn qry_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::QryOutOfMemory)\n    }\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    pub fn qry_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QryAppError)\n    }\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    pub fn qry_dup_join_key(\u0026self) -\u003e bool {\n        matches!(self, Code::QryDupJoinKey)\n    }\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    pub fn qry_exceed_tags_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::QryExceedTagsLimit)\n    }\n    /// QRY_NOT_READY: Query not ready\n    pub fn qry_not_ready(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotReady)\n    }\n    /// QRY_HAS_RSP: Query should response\n    pub fn qry_has_rsp(\u0026self) -\u003e bool {\n        matches!(self, Code::QryHasRsp)\n    }\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    pub fn qry_in_exec(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInExec)\n    }\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    pub fn qry_too_many_timewindow(\u0026self) -\u003e bool {\n        matches!(self, Code::QryTooManyTimewindow)\n    }\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    pub fn qry_not_enough_buffer(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotEnoughBuffer)\n    }\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    pub fn qry_inconsistan(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInconsistan)\n    }\n    /// QRY_SYS_ERROR: System error\n    pub fn qry_sys_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QrySysError)\n    }\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    pub fn qry_invalid_time_condition(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidTimeCondition)\n    }\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    pub fn qry_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidSchemaVersion)\n    }\n}\n\nimpl Code {\n    pub fn to_str(\u0026self) -\u003e \u0026'static str {\n        use Code::*;\n        match self {\n            Success =\u003e \"Success\",\n\n            TscInvalidOperation =\u003e \"Invalid Operation\",\n            TscInvalidQhandle =\u003e \"Invalid qhandle\",\n            TscInvalidTimeStamp =\u003e \"Invalid combination of client/service time\",\n            TscInvalidValue =\u003e \"Invalid value in client\",\n            TscInvalidVersion =\u003e \"Invalid client version\",\n            TscInvalidIe =\u003e \"Invalid client ie\",\n            TscInvalidFqdn =\u003e \"Invalid host name\",\n            TscInvalidUserLength =\u003e \"Invalid user name\",\n            TscInvalidPassLength =\u003e \"Invalid password\",\n            TscInvalidDbLength =\u003e \"Database name too long\",\n            TscInvalidTableIdLength =\u003e \"Table name too long\",\n            TscInvalidConnection =\u003e \"Invalid connection\",\n            TscOutOfMemory =\u003e \"System out of memory\",\n            TscNoDiskspace =\u003e \"System out of disk space\",\n            TscQueryCacheErased =\u003e \"Query cache erased\",\n            TscQueryCancelled =\u003e \"Query terminated\",\n            TscSortedResTooMany =\u003e \"Result set too large to be sorted\",\n            TscAppError =\u003e \"Application error\",\n            TscActionInProgress =\u003e \"Action in progress\",\n            TscDisconnected =\u003e \"Disconnected from service\",\n            TscNoWriteAuth =\u003e \"No write permission\",\n            TscConnKilled =\u003e \"Connection killed\",\n            TscSqlSyntaxError =\u003e \"Syntax error in SQL\",\n            TscDbNotSelected =\u003e \"Database not specified or available\",\n            TscInvalidTableName =\u003e \"Table does not exist\",\n            TscExceedSqlLimit =\u003e \"SQL statement too long check maxSQLLength config\",\n            TscFileEmpty =\u003e \"File is empty\",\n            TscLineSyntaxError =\u003e \"Syntax error in Line\",\n            TscNoMetaCached =\u003e \"No table meta cached\",\n            TscDupColNames =\u003e \"duplicated column names\",\n            TscInvalidTagLength =\u003e \"Invalid tag length\",\n            TscInvalidColumnLength =\u003e \"Invalid column length\",\n            TscDupTagNames =\u003e \"duplicated tag names\",\n            TscInvalidJson =\u003e \"Invalid JSON format\",\n            TscInvalidJsonType =\u003e \"Invalid JSON data type\",\n            TscInvalidJsonConfig =\u003e \"Invalid JSON configuration\",\n            TscValueOutOfRange =\u003e \"Value out of range\",\n            TscInvalidProtocolType =\u003e \"Invalid line protocol type\",\n            TscInvalidPrecisionType =\u003e \"Invalid timestamp precision type\",\n            TscResTooMany =\u003e \"Result set too large to be output\",\n            TscInvalidSchemaVersion =\u003e \"invalid table schema version\",\n            MndInvalidTopic =\u003e \"Invalid topic nam\",\n            MndInvalidTopicOption =\u003e \"Invalid topic optio\",\n            MndInvalidTopicPartitons =\u003e \"Invalid topic partitons num, valid range: [1, 1000\",\n            MndTopicAlreadyExist =\u003e \"Topic already exist\",\n            TdbInvalidTableId =\u003e \"Invalid table ID\",\n            TdbInvalidTableType =\u003e \"Invalid table type\",\n            TdbIvdTbSchemaVersion =\u003e \"Invalid table schema version\",\n            TdbTableAlreadyExist =\u003e \"Table already exists\",\n            TdbInvalidConfig =\u003e \"Invalid configuration\",\n            TdbInitFailed =\u003e \"Tsdb init failed\",\n            TdbNoDiskspace =\u003e \"No diskspace for tsdb\",\n            TdbNoDiskPermissions =\u003e \"No permission for disk files\",\n            TdbFileCorrupted =\u003e \"Data file(s) corrupted\",\n            TdbOutOfMemory =\u003e \"Out of memory\",\n            TdbTagVerOutOfDate =\u003e \"Tag too old\",\n            TdbTimestampOutOfRange =\u003e \"Timestamp data out of range\",\n            TdbSubmitMsgMssedUp =\u003e \"Submit message is messed up\",\n            TdbInvalidAction =\u003e \"Invalid operation\",\n            TdbInvalidCreateTbMsg =\u003e \"Invalid creation of table\",\n            TdbNoTableDataInMem =\u003e \"No table data in memory skiplist\",\n            TdbFileAlreadyExists =\u003e \"File already exists\",\n            TdbTableReconfigure =\u003e \"Need to reconfigure table\",\n            TdbIvdCreateTableInfo =\u003e \"Invalid information to create table\",\n            TdbNoAvailDisk =\u003e \"No available disk\",\n            TdbMessedMsg =\u003e \"TSDB messed message\",\n            TdbIvldTagVal =\u003e \"TSDB invalid tag value\",\n            TdbNoCacheLastRow =\u003e \"TSDB no cache last row data\",\n            TdbIncompleteDfileset =\u003e \"TSDB incomplete DFileSet\",\n            QryInvalidQhandle =\u003e \"Invalid handle\",\n            QryInvalidMsg =\u003e \"Invalid message\",\n            QryNoDiskspace =\u003e \"No diskspace for query\",\n            QryOutOfMemory =\u003e \"System out of memory\",\n            QryAppError =\u003e \"Unexpected generic error in query\",\n            QryDupJoinKey =\u003e \"Duplicated join key\",\n            QryExceedTagsLimit =\u003e \"Tag condition too many\",\n            QryNotReady =\u003e \"Query not ready\",\n            QryHasRsp =\u003e \"Query should response\",\n            QryInExec =\u003e \"Multiple retrieval of this query\",\n            QryTooManyTimewindow =\u003e \"Too many time window in query\",\n            QryNotEnoughBuffer =\u003e \"Query buffer limit has reached\",\n            QryInconsistan =\u003e \"File inconsistency in replica\",\n            QrySysError =\u003e \"System error\",\n            QryInvalidTimeCondition =\u003e \"invalid time condition\",\n            QryInvalidSchemaVersion =\u003e \"invalid schema version\",\n            Failed =\u003e \"Unknown or needn't tell detail error\",\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","examples","macros-demo","target","debug","build","taos-error-9a878855c40049e3","out","code.rs"],"content":"\nuse std::fmt;\n\nuse num_enum::{FromPrimitive, IntoPrimitive};\n\nmacro_rules! _impl_fmt {\n    ($fmt:ident) =\u003e {\n        impl fmt::$fmt for Code {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                let val = *self as i32;\n                fmt::$fmt::fmt(\u0026val, f)\n            }\n        }\n    };\n}\n\n_impl_fmt!(Display);\n_impl_fmt!(LowerHex);\n_impl_fmt!(UpperHex);\n\n/// TDengine error code.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, FromPrimitive, IntoPrimitive)]\n#[repr(i32)]\n#[derive(serde::Deserialize)]\npub enum Code {\n    /// Success, 0\n    Success = 0x0000,\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    TscInvalidOperation = 0x0200,\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    TscInvalidQhandle = 0x0201,\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    TscInvalidTimeStamp = 0x0202,\n    /// TSC_INVALID_VALUE: Invalid value in client\n    TscInvalidValue = 0x0203,\n    /// TSC_INVALID_VERSION: Invalid client version\n    TscInvalidVersion = 0x0204,\n    /// TSC_INVALID_IE: Invalid client ie\n    TscInvalidIe = 0x0205,\n    /// TSC_INVALID_FQDN: Invalid host name\n    TscInvalidFqdn = 0x0206,\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    TscInvalidUserLength = 0x0207,\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    TscInvalidPassLength = 0x0208,\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    TscInvalidDbLength = 0x0209,\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    TscInvalidTableIdLength = 0x020A,\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    TscInvalidConnection = 0x020B,\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    TscOutOfMemory = 0x020C,\n    /// TSC_NO_DISKSPACE: System out of disk space\n    TscNoDiskspace = 0x020D,\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    TscQueryCacheErased = 0x020E,\n    /// TSC_QUERY_CANCELLED: Query terminated\n    TscQueryCancelled = 0x020F,\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    TscSortedResTooMany = 0x0210,\n    /// TSC_APP_ERROR: Application error\n    TscAppError = 0x0211,\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    TscActionInProgress = 0x0212,\n    /// TSC_DISCONNECTED: Disconnected from service\n    TscDisconnected = 0x0213,\n    /// TSC_NO_WRITE_AUTH: No write permission\n    TscNoWriteAuth = 0x0214,\n    /// TSC_CONN_KILLED: Connection killed\n    TscConnKilled = 0x0215,\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    TscSqlSyntaxError = 0x0216,\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    TscDbNotSelected = 0x0217,\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    TscInvalidTableName = 0x0218,\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    TscExceedSqlLimit = 0x0219,\n    /// TSC_FILE_EMPTY: File is empty\n    TscFileEmpty = 0x021A,\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    TscLineSyntaxError = 0x021B,\n    /// TSC_NO_META_CACHED: No table meta cached\n    TscNoMetaCached = 0x021C,\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    TscDupColNames = 0x021D,\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    TscInvalidTagLength = 0x021E,\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    TscInvalidColumnLength = 0x021F,\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    TscDupTagNames = 0x0220,\n    /// TSC_INVALID_JSON: Invalid JSON format\n    TscInvalidJson = 0x0221,\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    TscInvalidJsonType = 0x0222,\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    TscInvalidJsonConfig = 0x0223,\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    TscValueOutOfRange = 0x0224,\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    TscInvalidProtocolType = 0x0225,\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    TscInvalidPrecisionType = 0x0226,\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    TscResTooMany = 0x0227,\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    TscInvalidSchemaVersion = 0x0228,\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    MndInvalidTopic = 0x0392,\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    MndInvalidTopicOption = 0x0393,\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    MndInvalidTopicPartitons = 0x0394,\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    MndTopicAlreadyExist = 0x0395,\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    TdbInvalidTableId = 0x0600,\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    TdbInvalidTableType = 0x0601,\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    TdbIvdTbSchemaVersion = 0x0602,\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    TdbTableAlreadyExist = 0x0603,\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    TdbInvalidConfig = 0x0604,\n    /// TDB_INIT_FAILED: Tsdb init failed\n    TdbInitFailed = 0x0605,\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    TdbNoDiskspace = 0x0606,\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    TdbNoDiskPermissions = 0x0607,\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    TdbFileCorrupted = 0x0608,\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    TdbOutOfMemory = 0x0609,\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    TdbTagVerOutOfDate = 0x060A,\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    TdbTimestampOutOfRange = 0x060B,\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    TdbSubmitMsgMssedUp = 0x060C,\n    /// TDB_INVALID_ACTION: Invalid operation\n    TdbInvalidAction = 0x060D,\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    TdbInvalidCreateTbMsg = 0x060E,\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    TdbNoTableDataInMem = 0x060F,\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    TdbFileAlreadyExists = 0x0610,\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    TdbTableReconfigure = 0x0611,\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    TdbIvdCreateTableInfo = 0x0612,\n    /// TDB_NO_AVAIL_DISK: No available disk\n    TdbNoAvailDisk = 0x0613,\n    /// TDB_MESSED_MSG: TSDB messed message\n    TdbMessedMsg = 0x0614,\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    TdbIvldTagVal = 0x0615,\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    TdbNoCacheLastRow = 0x0616,\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    TdbIncompleteDfileset = 0x0617,\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    QryInvalidQhandle = 0x0700,\n    /// QRY_INVALID_MSG: Invalid message\n    QryInvalidMsg = 0x0701,\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    QryNoDiskspace = 0x0702,\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    QryOutOfMemory = 0x0703,\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    QryAppError = 0x0704,\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    QryDupJoinKey = 0x0705,\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    QryExceedTagsLimit = 0x0706,\n    /// QRY_NOT_READY: Query not ready\n    QryNotReady = 0x0707,\n    /// QRY_HAS_RSP: Query should response\n    QryHasRsp = 0x0708,\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    QryInExec = 0x0709,\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    QryTooManyTimewindow = 0x070A,\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    QryNotEnoughBuffer = 0x070B,\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    QryInconsistan = 0x070C,\n    /// QRY_SYS_ERROR: System error\n    QrySysError = 0x070D,\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    QryInvalidTimeCondition = 0x070E,\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    QryInvalidSchemaVersion = 0x0710,\n\n    #[num_enum(default)]\n    Failed = 0xffff,\n}\n\nimpl Code {\n    pub fn success(\u0026self) -\u003e bool {\n        matches!(self, Code::Success)\n    }\n    /// TSC_INVALID_OPERATION: Invalid Operation\n    pub fn tsc_invalid_operation(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidOperation)\n    }\n    /// TSC_INVALID_QHANDLE: Invalid qhandle\n    pub fn tsc_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidQhandle)\n    }\n    /// TSC_INVALID_TIME_STAMP: Invalid combination of client/service time\n    pub fn tsc_invalid_time_stamp(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTimeStamp)\n    }\n    /// TSC_INVALID_VALUE: Invalid value in client\n    pub fn tsc_invalid_value(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidValue)\n    }\n    /// TSC_INVALID_VERSION: Invalid client version\n    pub fn tsc_invalid_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidVersion)\n    }\n    /// TSC_INVALID_IE: Invalid client ie\n    pub fn tsc_invalid_ie(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidIe)\n    }\n    /// TSC_INVALID_FQDN: Invalid host name\n    pub fn tsc_invalid_fqdn(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidFqdn)\n    }\n    /// TSC_INVALID_USER_LENGTH: Invalid user name\n    pub fn tsc_invalid_user_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidUserLength)\n    }\n    /// TSC_INVALID_PASS_LENGTH: Invalid password\n    pub fn tsc_invalid_pass_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPassLength)\n    }\n    /// TSC_INVALID_DB_LENGTH: Database name too long\n    pub fn tsc_invalid_db_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidDbLength)\n    }\n    /// TSC_INVALID_TABLE_ID_LENGTH: Table name too long\n    pub fn tsc_invalid_table_id_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableIdLength)\n    }\n    /// TSC_INVALID_CONNECTION: Invalid connection\n    pub fn tsc_invalid_connection(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidConnection)\n    }\n    /// TSC_OUT_OF_MEMORY: System out of memory\n    pub fn tsc_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TscOutOfMemory)\n    }\n    /// TSC_NO_DISKSPACE: System out of disk space\n    pub fn tsc_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoDiskspace)\n    }\n    /// TSC_QUERY_CACHE_ERASED: Query cache erased\n    pub fn tsc_query_cache_erased(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCacheErased)\n    }\n    /// TSC_QUERY_CANCELLED: Query terminated\n    pub fn tsc_query_cancelled(\u0026self) -\u003e bool {\n        matches!(self, Code::TscQueryCancelled)\n    }\n    /// TSC_SORTED_RES_TOO_MANY: Result set too large to be sorted\n    pub fn tsc_sorted_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSortedResTooMany)\n    }\n    /// TSC_APP_ERROR: Application error\n    pub fn tsc_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscAppError)\n    }\n    /// TSC_ACTION_IN_PROGRESS: Action in progress\n    pub fn tsc_action_in_progress(\u0026self) -\u003e bool {\n        matches!(self, Code::TscActionInProgress)\n    }\n    /// TSC_DISCONNECTED: Disconnected from service\n    pub fn tsc_disconnected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDisconnected)\n    }\n    /// TSC_NO_WRITE_AUTH: No write permission\n    pub fn tsc_no_write_auth(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoWriteAuth)\n    }\n    /// TSC_CONN_KILLED: Connection killed\n    pub fn tsc_conn_killed(\u0026self) -\u003e bool {\n        matches!(self, Code::TscConnKilled)\n    }\n    /// TSC_SQL_SYNTAX_ERROR: Syntax error in SQL\n    pub fn tsc_sql_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscSqlSyntaxError)\n    }\n    /// TSC_DB_NOT_SELECTED: Database not specified or available\n    pub fn tsc_db_not_selected(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDbNotSelected)\n    }\n    /// TSC_INVALID_TABLE_NAME: Table does not exist\n    pub fn tsc_invalid_table_name(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTableName)\n    }\n    /// TSC_EXCEED_SQL_LIMIT: SQL statement too long check maxSQLLength config\n    pub fn tsc_exceed_sql_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::TscExceedSqlLimit)\n    }\n    /// TSC_FILE_EMPTY: File is empty\n    pub fn tsc_file_empty(\u0026self) -\u003e bool {\n        matches!(self, Code::TscFileEmpty)\n    }\n    /// TSC_LINE_SYNTAX_ERROR: Syntax error in Line\n    pub fn tsc_line_syntax_error(\u0026self) -\u003e bool {\n        matches!(self, Code::TscLineSyntaxError)\n    }\n    /// TSC_NO_META_CACHED: No table meta cached\n    pub fn tsc_no_meta_cached(\u0026self) -\u003e bool {\n        matches!(self, Code::TscNoMetaCached)\n    }\n    /// TSC_DUP_COL_NAMES: duplicated column names\n    pub fn tsc_dup_col_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupColNames)\n    }\n    /// TSC_INVALID_TAG_LENGTH: Invalid tag length\n    pub fn tsc_invalid_tag_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidTagLength)\n    }\n    /// TSC_INVALID_COLUMN_LENGTH: Invalid column length\n    pub fn tsc_invalid_column_length(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidColumnLength)\n    }\n    /// TSC_DUP_TAG_NAMES: duplicated tag names\n    pub fn tsc_dup_tag_names(\u0026self) -\u003e bool {\n        matches!(self, Code::TscDupTagNames)\n    }\n    /// TSC_INVALID_JSON: Invalid JSON format\n    pub fn tsc_invalid_json(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJson)\n    }\n    /// TSC_INVALID_JSON_TYPE: Invalid JSON data type\n    pub fn tsc_invalid_json_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonType)\n    }\n    /// TSC_INVALID_JSON_CONFIG: Invalid JSON configuration\n    pub fn tsc_invalid_json_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidJsonConfig)\n    }\n    /// TSC_VALUE_OUT_OF_RANGE: Value out of range\n    pub fn tsc_value_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TscValueOutOfRange)\n    }\n    /// TSC_INVALID_PROTOCOL_TYPE: Invalid line protocol type\n    pub fn tsc_invalid_protocol_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidProtocolType)\n    }\n    /// TSC_INVALID_PRECISION_TYPE: Invalid timestamp precision type\n    pub fn tsc_invalid_precision_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidPrecisionType)\n    }\n    /// TSC_RES_TOO_MANY: Result set too large to be output\n    pub fn tsc_res_too_many(\u0026self) -\u003e bool {\n        matches!(self, Code::TscResTooMany)\n    }\n    /// TSC_INVALID_SCHEMA_VERSION: invalid table schema version\n    pub fn tsc_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TscInvalidSchemaVersion)\n    }\n    /// MND_INVALID_TOPIC: Invalid topic nam\n    pub fn mnd_invalid_topic(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopic)\n    }\n    /// MND_INVALID_TOPIC_OPTION: Invalid topic optio\n    pub fn mnd_invalid_topic_option(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicOption)\n    }\n    /// MND_INVALID_TOPIC_PARTITONS: Invalid topic partitons num, valid range: [1, 1000\n    pub fn mnd_invalid_topic_partitons(\u0026self) -\u003e bool {\n        matches!(self, Code::MndInvalidTopicPartitons)\n    }\n    /// MND_TOPIC_ALREADY_EXIST: Topic already exist\n    pub fn mnd_topic_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::MndTopicAlreadyExist)\n    }\n    /// TDB_INVALID_TABLE_ID: Invalid table ID\n    pub fn tdb_invalid_table_id(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableId)\n    }\n    /// TDB_INVALID_TABLE_TYPE: Invalid table type\n    pub fn tdb_invalid_table_type(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidTableType)\n    }\n    /// TDB_IVD_TB_SCHEMA_VERSION: Invalid table schema version\n    pub fn tdb_ivd_tb_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdTbSchemaVersion)\n    }\n    /// TDB_TABLE_ALREADY_EXIST: Table already exists\n    pub fn tdb_table_already_exist(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableAlreadyExist)\n    }\n    /// TDB_INVALID_CONFIG: Invalid configuration\n    pub fn tdb_invalid_config(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidConfig)\n    }\n    /// TDB_INIT_FAILED: Tsdb init failed\n    pub fn tdb_init_failed(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInitFailed)\n    }\n    /// TDB_NO_DISKSPACE: No diskspace for tsdb\n    pub fn tdb_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskspace)\n    }\n    /// TDB_NO_DISK_PERMISSIONS: No permission for disk files\n    pub fn tdb_no_disk_permissions(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoDiskPermissions)\n    }\n    /// TDB_FILE_CORRUPTED: Data file(s) corrupted\n    pub fn tdb_file_corrupted(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileCorrupted)\n    }\n    /// TDB_OUT_OF_MEMORY: Out of memory\n    pub fn tdb_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbOutOfMemory)\n    }\n    /// TDB_TAG_VER_OUT_OF_DATE: Tag too old\n    pub fn tdb_tag_ver_out_of_date(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTagVerOutOfDate)\n    }\n    /// TDB_TIMESTAMP_OUT_OF_RANGE: Timestamp data out of range\n    pub fn tdb_timestamp_out_of_range(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTimestampOutOfRange)\n    }\n    /// TDB_SUBMIT_MSG_MSSED_UP: Submit message is messed up\n    pub fn tdb_submit_msg_mssed_up(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbSubmitMsgMssedUp)\n    }\n    /// TDB_INVALID_ACTION: Invalid operation\n    pub fn tdb_invalid_action(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidAction)\n    }\n    /// TDB_INVALID_CREATE_TB_MSG: Invalid creation of table\n    pub fn tdb_invalid_create_tb_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbInvalidCreateTbMsg)\n    }\n    /// TDB_NO_TABLE_DATA_IN_MEM: No table data in memory skiplist\n    pub fn tdb_no_table_data_in_mem(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoTableDataInMem)\n    }\n    /// TDB_FILE_ALREADY_EXISTS: File already exists\n    pub fn tdb_file_already_exists(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbFileAlreadyExists)\n    }\n    /// TDB_TABLE_RECONFIGURE: Need to reconfigure table\n    pub fn tdb_table_reconfigure(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbTableReconfigure)\n    }\n    /// TDB_IVD_CREATE_TABLE_INFO: Invalid information to create table\n    pub fn tdb_ivd_create_table_info(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvdCreateTableInfo)\n    }\n    /// TDB_NO_AVAIL_DISK: No available disk\n    pub fn tdb_no_avail_disk(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoAvailDisk)\n    }\n    /// TDB_MESSED_MSG: TSDB messed message\n    pub fn tdb_messed_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbMessedMsg)\n    }\n    /// TDB_IVLD_TAG_VAL: TSDB invalid tag value\n    pub fn tdb_ivld_tag_val(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIvldTagVal)\n    }\n    /// TDB_NO_CACHE_LAST_ROW: TSDB no cache last row data\n    pub fn tdb_no_cache_last_row(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbNoCacheLastRow)\n    }\n    /// TDB_INCOMPLETE_DFILESET: TSDB incomplete DFileSet\n    pub fn tdb_incomplete_dfileset(\u0026self) -\u003e bool {\n        matches!(self, Code::TdbIncompleteDfileset)\n    }\n    /// QRY_INVALID_QHANDLE: Invalid handle\n    pub fn qry_invalid_qhandle(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidQhandle)\n    }\n    /// QRY_INVALID_MSG: Invalid message\n    pub fn qry_invalid_msg(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidMsg)\n    }\n    /// QRY_NO_DISKSPACE: No diskspace for query\n    pub fn qry_no_diskspace(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNoDiskspace)\n    }\n    /// QRY_OUT_OF_MEMORY: System out of memory\n    pub fn qry_out_of_memory(\u0026self) -\u003e bool {\n        matches!(self, Code::QryOutOfMemory)\n    }\n    /// QRY_APP_ERROR: Unexpected generic error in query\n    pub fn qry_app_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QryAppError)\n    }\n    /// QRY_DUP_JOIN_KEY: Duplicated join key\n    pub fn qry_dup_join_key(\u0026self) -\u003e bool {\n        matches!(self, Code::QryDupJoinKey)\n    }\n    /// QRY_EXCEED_TAGS_LIMIT: Tag condition too many\n    pub fn qry_exceed_tags_limit(\u0026self) -\u003e bool {\n        matches!(self, Code::QryExceedTagsLimit)\n    }\n    /// QRY_NOT_READY: Query not ready\n    pub fn qry_not_ready(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotReady)\n    }\n    /// QRY_HAS_RSP: Query should response\n    pub fn qry_has_rsp(\u0026self) -\u003e bool {\n        matches!(self, Code::QryHasRsp)\n    }\n    /// QRY_IN_EXEC: Multiple retrieval of this query\n    pub fn qry_in_exec(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInExec)\n    }\n    /// QRY_TOO_MANY_TIMEWINDOW: Too many time window in query\n    pub fn qry_too_many_timewindow(\u0026self) -\u003e bool {\n        matches!(self, Code::QryTooManyTimewindow)\n    }\n    /// QRY_NOT_ENOUGH_BUFFER: Query buffer limit has reached\n    pub fn qry_not_enough_buffer(\u0026self) -\u003e bool {\n        matches!(self, Code::QryNotEnoughBuffer)\n    }\n    /// QRY_INCONSISTAN: File inconsistency in replica\n    pub fn qry_inconsistan(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInconsistan)\n    }\n    /// QRY_SYS_ERROR: System error\n    pub fn qry_sys_error(\u0026self) -\u003e bool {\n        matches!(self, Code::QrySysError)\n    }\n    /// QRY_INVALID_TIME_CONDITION: invalid time condition\n    pub fn qry_invalid_time_condition(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidTimeCondition)\n    }\n    /// QRY_INVALID_SCHEMA_VERSION: invalid schema version\n    pub fn qry_invalid_schema_version(\u0026self) -\u003e bool {\n        matches!(self, Code::QryInvalidSchemaVersion)\n    }\n}\n\nimpl Code {\n    pub fn to_str(\u0026self) -\u003e \u0026'static str {\n        use Code::*;\n        match self {\n            Success =\u003e \"Success\",\n\n            TscInvalidOperation =\u003e \"Invalid Operation\",\n            TscInvalidQhandle =\u003e \"Invalid qhandle\",\n            TscInvalidTimeStamp =\u003e \"Invalid combination of client/service time\",\n            TscInvalidValue =\u003e \"Invalid value in client\",\n            TscInvalidVersion =\u003e \"Invalid client version\",\n            TscInvalidIe =\u003e \"Invalid client ie\",\n            TscInvalidFqdn =\u003e \"Invalid host name\",\n            TscInvalidUserLength =\u003e \"Invalid user name\",\n            TscInvalidPassLength =\u003e \"Invalid password\",\n            TscInvalidDbLength =\u003e \"Database name too long\",\n            TscInvalidTableIdLength =\u003e \"Table name too long\",\n            TscInvalidConnection =\u003e \"Invalid connection\",\n            TscOutOfMemory =\u003e \"System out of memory\",\n            TscNoDiskspace =\u003e \"System out of disk space\",\n            TscQueryCacheErased =\u003e \"Query cache erased\",\n            TscQueryCancelled =\u003e \"Query terminated\",\n            TscSortedResTooMany =\u003e \"Result set too large to be sorted\",\n            TscAppError =\u003e \"Application error\",\n            TscActionInProgress =\u003e \"Action in progress\",\n            TscDisconnected =\u003e \"Disconnected from service\",\n            TscNoWriteAuth =\u003e \"No write permission\",\n            TscConnKilled =\u003e \"Connection killed\",\n            TscSqlSyntaxError =\u003e \"Syntax error in SQL\",\n            TscDbNotSelected =\u003e \"Database not specified or available\",\n            TscInvalidTableName =\u003e \"Table does not exist\",\n            TscExceedSqlLimit =\u003e \"SQL statement too long check maxSQLLength config\",\n            TscFileEmpty =\u003e \"File is empty\",\n            TscLineSyntaxError =\u003e \"Syntax error in Line\",\n            TscNoMetaCached =\u003e \"No table meta cached\",\n            TscDupColNames =\u003e \"duplicated column names\",\n            TscInvalidTagLength =\u003e \"Invalid tag length\",\n            TscInvalidColumnLength =\u003e \"Invalid column length\",\n            TscDupTagNames =\u003e \"duplicated tag names\",\n            TscInvalidJson =\u003e \"Invalid JSON format\",\n            TscInvalidJsonType =\u003e \"Invalid JSON data type\",\n            TscInvalidJsonConfig =\u003e \"Invalid JSON configuration\",\n            TscValueOutOfRange =\u003e \"Value out of range\",\n            TscInvalidProtocolType =\u003e \"Invalid line protocol type\",\n            TscInvalidPrecisionType =\u003e \"Invalid timestamp precision type\",\n            TscResTooMany =\u003e \"Result set too large to be output\",\n            TscInvalidSchemaVersion =\u003e \"invalid table schema version\",\n            MndInvalidTopic =\u003e \"Invalid topic nam\",\n            MndInvalidTopicOption =\u003e \"Invalid topic optio\",\n            MndInvalidTopicPartitons =\u003e \"Invalid topic partitons num, valid range: [1, 1000\",\n            MndTopicAlreadyExist =\u003e \"Topic already exist\",\n            TdbInvalidTableId =\u003e \"Invalid table ID\",\n            TdbInvalidTableType =\u003e \"Invalid table type\",\n            TdbIvdTbSchemaVersion =\u003e \"Invalid table schema version\",\n            TdbTableAlreadyExist =\u003e \"Table already exists\",\n            TdbInvalidConfig =\u003e \"Invalid configuration\",\n            TdbInitFailed =\u003e \"Tsdb init failed\",\n            TdbNoDiskspace =\u003e \"No diskspace for tsdb\",\n            TdbNoDiskPermissions =\u003e \"No permission for disk files\",\n            TdbFileCorrupted =\u003e \"Data file(s) corrupted\",\n            TdbOutOfMemory =\u003e \"Out of memory\",\n            TdbTagVerOutOfDate =\u003e \"Tag too old\",\n            TdbTimestampOutOfRange =\u003e \"Timestamp data out of range\",\n            TdbSubmitMsgMssedUp =\u003e \"Submit message is messed up\",\n            TdbInvalidAction =\u003e \"Invalid operation\",\n            TdbInvalidCreateTbMsg =\u003e \"Invalid creation of table\",\n            TdbNoTableDataInMem =\u003e \"No table data in memory skiplist\",\n            TdbFileAlreadyExists =\u003e \"File already exists\",\n            TdbTableReconfigure =\u003e \"Need to reconfigure table\",\n            TdbIvdCreateTableInfo =\u003e \"Invalid information to create table\",\n            TdbNoAvailDisk =\u003e \"No available disk\",\n            TdbMessedMsg =\u003e \"TSDB messed message\",\n            TdbIvldTagVal =\u003e \"TSDB invalid tag value\",\n            TdbNoCacheLastRow =\u003e \"TSDB no cache last row data\",\n            TdbIncompleteDfileset =\u003e \"TSDB incomplete DFileSet\",\n            QryInvalidQhandle =\u003e \"Invalid handle\",\n            QryInvalidMsg =\u003e \"Invalid message\",\n            QryNoDiskspace =\u003e \"No diskspace for query\",\n            QryOutOfMemory =\u003e \"System out of memory\",\n            QryAppError =\u003e \"Unexpected generic error in query\",\n            QryDupJoinKey =\u003e \"Duplicated join key\",\n            QryExceedTagsLimit =\u003e \"Tag condition too many\",\n            QryNotReady =\u003e \"Query not ready\",\n            QryHasRsp =\u003e \"Query should response\",\n            QryInExec =\u003e \"Multiple retrieval of this query\",\n            QryTooManyTimewindow =\u003e \"Too many time window in query\",\n            QryNotEnoughBuffer =\u003e \"Query buffer limit has reached\",\n            QryInconsistan =\u003e \"File inconsistency in replica\",\n            QrySysError =\u003e \"System error\",\n            QryInvalidTimeCondition =\u003e \"invalid time condition\",\n            QryInvalidSchemaVersion =\u003e \"invalid schema version\",\n            Failed =\u003e \"Unknown or needn't tell detail error\",\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","cfg.rs"],"content":"use proc_macro2::*;\nuse quote::*;\nuse syn::{ForeignItemFn, ItemFn};\n\n/// Replace official `[cfg]` macro to add empty backport functions after the foreign mod block.\npub fn cfg(attr: impl Into\u003cTokenStream\u003e, item: impl Into\u003cTokenStream\u003e) -\u003e TokenStream {\n    let cfg = attr.into();\n\n    let item = item.into();\n    // taos cfg only focus on foreign mod.\n    let syn: syn::ItemForeignMod = match syn::parse2(item.clone()) {\n        Ok(it) =\u003e it,\n        Err(_) =\u003e {\n            return quote! {\n              #[cfg(#cfg)]\n              #item\n            }\n        }\n    };\n\n    let mut backport = TokenStream::new();\n\n    for item_fn in syn.items {\n        assert!(matches!(item_fn, syn::ForeignItem::Fn(_)));\n        if let syn::ForeignItem::Fn(item_fn) = item_fn {\n            let item_fn = foreign_fn_to_item_fn(item_fn);\n            backport.extend(quote! {\n                #[cfg(not(#cfg))]\n                #[no_mangle]\n                #item_fn\n            });\n        }\n    }\n    return quote! {\n        #[cfg(#cfg)]\n        #item\n\n        #backport\n    };\n}\n\n/// Convert a extern \"C\" foreign function to a no_mangle Rust fn.\nfn foreign_fn_to_item_fn(item: ForeignItemFn) -\u003e ItemFn {\n    let mut sig = item.sig;\n    // use extern \"C\"\n    let abi: syn::Abi = syn::parse_quote!(extern \"C\");\n    sig.abi = Some(abi);\n    let un: syn::token::Unsafe = syn::parse_quote!(unsafe);\n    sig.unsafety = Some(un);\n\n    // add panic block\n    let err = Literal::string(\u0026format!(\n        \"C function {} is not supported in this build\",\n        sig.ident\n    ));\n    let block: syn::Block = syn::parse_quote! {\n        {\n            panic!(#err);\n        }\n    };\n    ItemFn {\n        attrs: item.attrs,\n        vis: item.vis,\n        sig: sig,\n        block: Box::new(block),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::cfg;\n    use quote::quote;\n    use syn::{ForeignItemFn, ItemFn};\n\n    #[test]\n    fn nothing() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            #[doc = \"doc\"]\n            fn abc() {}\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            #[doc = \"doc\"]\n            fn abc() {}\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn simple() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            // doc\n            extern \"C\" {\n                pub fn a();\n            }\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            extern \"C\" {\n                pub fn a();\n            }\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn a () {\n              panic!(\"C function a is not supported in this build\");\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn test_foreign_to_item() {\n        let c: ForeignItemFn = syn::parse_quote! {\n\n            pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n        };\n        let r = super::foreign_fn_to_item_fn(c);\n\n        let e: ItemFn = syn::parse_quote!(\n            pub unsafe extern \"C\" fn tmq_list_new() -\u003e *mut tmq_list_t {\n                panic!(\"C function tmq_list_new is not supported in this build\");\n            }\n        );\n        assert_eq!(r, e);\n        dbg!(\u0026r);\n    }\n\n    #[test]\n    fn tmq_demo() {\n        let attr = quote!(tmq);\n        let fn_item = quote! {\n            // doc\n            extern \"C\" {\n                pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n                pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32;\n            }\n        };\n\n        let tokens = cfg(attr, fn_item);\n\n        let expect = quote! {\n            #[cfg(tmq)]\n            extern \"C\" {\n                pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n                pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32;\n            }\n\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn tmq_list_new() -\u003e *mut tmq_list_t {\n                panic!(\"C function tmq_list_new is not supported in this build\");\n            }\n            #[cfg(not(tmq))]\n            #[no_mangle]\n            pub unsafe extern \"C\" fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32 {\n                panic!(\"C function tmq_list_append is not supported in this build\");\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","lib.rs"],"content":"extern crate proc_macro;\n\nmod cfg;\nmod test;\n\n/// A `[cfg]`-like macro to add backport code for extern \"C\" foreign mod.\n///\n/// ```rust\n/// # use taos_macros::c_cfg;\n///\n/// #[c_cfg(feature = \"ft1\")]\n/// extern \"C\" {\n///     pub fn raw_c_fn(arg1: *mut std::os::raw::c_void) -\u003e std::os::raw::c_int;\n/// }\n/// ```\n///\n/// The code will expand to:\n///\n/// ```rust\n/// #[cfg(feature = \"ft1\")]\n/// extern \"C\" {\n///     pub fn raw_c_fn(arg1: *mut std::os::raw::c_void) -\u003e std::os::raw::c_int;\n/// }\n/// #[cfg(not(feature = \"ft1\"))]\n/// #[no_mangle]\n/// pub extern \"C\" fn raw_c_fn(arg1: *mut std::os::raw::c_void) -\u003e std::os::raw::c_int {\n///     panic!(\"C function raw_c_fn is not supported in this build\");\n/// }\n/// ```\n#[proc_macro_attribute]\npub fn c_cfg(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -\u003e proc_macro::TokenStream {\n    cfg::cfg(attr, item).into()\n}\n\n/// A powerful test macro for taos, you can replace std test macro in your taos test cases.\n///\n/// ## Use as [`[test]`](https://doc.rust-lang.org/std/prelude/v1/macro.test.html) does\n///\n/// ```rust\n/// use taos_macros::test;\n/// #[test]\n/// fn test1() {}\n/// ```\n///\n/// ## Use with taos connection.\n///\n/// ```rust\n/// use taos_macros::test;\n///\n/// #[test]\n/// async fn show_databases(taos: \u0026Taos) -\u003e Result\u003c()\u003e {\n///     let _ = taos.databases().await;\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Use with taos connection and a prebuilt database\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test]\n/// async fn use_database(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Use with taos connection and a prebuilt database with specific precision\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(precision = \"ns\")]\n/// async fn with_precision(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(databases\n///         .iter()\n///         .any(|db| db.name == database \u0026\u0026 db.props.precision.as_ref().unwrap().eq(\"ns\")));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Specify a custom database name\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(naming = \"abc1\")]\n/// async fn custom_database(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(database == \"abc1\");\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Naming the database with random words\n///\n/// By default, `[test]` macro use [uuid v1](https://docs.rs/uuid/latest/uuid/struct.Uuid.html#method.new_v1)\n/// naming strategy. It will satisfy most cases. But if you want to use another naming strategy, you can use\n/// `\"random\"` to generate database names with [faker_rand](https://docs.rs/faker_rand).\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(naming = \"random\")]\n/// async fn random_naming(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n///     let databases = taos.databases().await?;\n///     assert!(databases.iter().any(|db| db.name == database));\n///     Ok(())\n/// }\n/// ```\n///\n/// ## Generate many databases in one case\n///\n/// ```rust\n/// use taos_macros::test;\n/// use taos::{Taos, Result};\n///\n/// #[test(databases = 10)]\n/// async fn multi_databases(_taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c()\u003e {\n///     assert!(databases.len() == 10);\n///     Ok(())\n/// }\n/// ```\n///\n#[proc_macro_attribute]\npub fn test(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -\u003e proc_macro::TokenStream {\n    test::test(attr, item)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","src","test.rs"],"content":"use proc_macro2::*;\nuse quote::*;\n\n#[derive(Debug, PartialEq, Eq)]\nenum Requires {\n    None,\n    TaosOnly,\n    WithDatabase,\n    WithMulti,\n}\n\nimpl Default for Requires {\n    fn default() -\u003e Self {\n        Self::None\n    }\n}\n\n#[derive(Default, Debug, PartialEq, Eq)]\nstruct Params {\n    is_async: bool,\n    fn_name: String,\n    requires: Requires,\n    is_result: bool,\n}\n\nimpl Params {\n    fn from_tokens(item: TokenStream) -\u003e Self {\n        // let item_fn: syn::ItemFn = match syn::parse(item.clone().into()) {\n        //     Ok(item) =\u003e item,\n        //     Err(e) =\u003e panic!(\"#[test] only used in function\"),\n        // };\n        // dbg!(item_fn);\n        let tokens: Vec\u003c_\u003e = item.into_iter().collect();\n        let mut iter = tokens.iter();\n\n        let mut params = Params::default();\n        while let Some(token) = iter.next() {\n            use TokenTree::*;\n            match token {\n                // Function comment\n                Punct(punct) if punct.as_char() == '#' =\u003e {\n                    let _ = iter.next();\n                }\n                // Check if is async function\n                Ident(ident) if ident.to_string() == \"async\" =\u003e {\n                    params.is_async = true;\n                }\n                // Parse function name and parameters\n                Ident(ident) if ident.to_string() == \"fn\" =\u003e {\n                    if let Some(Ident(ident)) = iter.next() {\n                        params.fn_name = ident.to_string();\n                    } else {\n                        panic!(\"can't parse fn name\");\n                    }\n\n                    if let Some(Group(fn_params)) = iter.next() {\n                        let tt: Vec\u003c_\u003e = fn_params.stream().into_iter().collect();\n                        params.requires = parse_database_requires(\u0026tt);\n                    }\n                }\n                // Parse return type\n                Punct(punct) if punct.as_char() == '-' =\u003e {\n                    // \u003e\n                    let _ = iter.next();\n                    let mut return_type_tt = Vec::new();\n                    if let Some(ident) = iter.next() {\n                        // dbg!(\u0026ty);\n                        if let Ident(ty) = ident {\n                            if ty.to_string().ends_with(\"Result\") {\n                                params.is_result = true;\n                                break;\n                            }\n                        }\n                        return_type_tt.push(ident.clone());\n                    }\n\n                    while let Some(token) = iter.next() {\n                        if let Group(group) = token {\n                            let v = group.delimiter();\n                            if v == Delimiter::Brace {\n                                break;\n                            }\n                        }\n                        return_type_tt.push(token.clone());\n                    }\n\n                    params.is_result = return_type_tt.into_iter().any(|t| {\n                        if let Ident(ty) = t {\n                            ty.to_string().ends_with(\"Result\")\n                        } else {\n                            false\n                        }\n                    });\n                }\n                _ =\u003e {\n                    // dbg!(\u0026token);\n                }\n            }\n        }\n        params\n    }\n}\n\n#[derive(Default, Debug)]\nstruct Attr {\n    rt: Option\u003cString\u003e,\n    databases: Option\u003cusize\u003e,\n    naming: Option\u003cLiteral\u003e,\n    precision: Option\u003cLiteral\u003e,\n    dropping: Option\u003cLiteral\u003e,\n    log_level: Option\u003cLiteral\u003e,\n}\n\nimpl PartialEq for Attr {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        macro_rules! _literal_eq {\n            ($attr:ident) =\u003e {\n                match (self.$attr.as_ref(), other.$attr.as_ref()) {\n                    (None, None) =\u003e true,\n                    (Some(lhs), Some(rhs)) if lhs.to_string() == rhs.to_string() =\u003e true,\n                    _ =\u003e false,\n                }\n            };\n        }\n        self.rt == other.rt\n            \u0026\u0026 self.databases == other.databases\n            \u0026\u0026 _literal_eq!(naming)\n            \u0026\u0026 _literal_eq!(precision)\n            \u0026\u0026 _literal_eq!(dropping)\n    }\n}\n\nimpl Attr {\n    fn from_iter(iter: impl IntoIterator\u003cItem = TokenTree\u003e) -\u003e Attr {\n        let mut iter = iter.into_iter();\n        let mut attr = Attr::default();\n        while let Some(t) = iter.next() {\n            // panic!(\"{}\", \u0026t);\n            // dbg!(\u0026t);\n            match t {\n                TokenTree::Ident(ident) if ident.to_string() == \"databases\" =\u003e {\n                    const EXPECT: \u0026str = \"expect `[test(databases = \\\"\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e {\n                            attr.databases = Some(value.to_string().parse().expect(EXPECT))\n                        }\n                        _ =\u003e unreachable!(\"expect `[test(databases = \\\"\\\")]`\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"rt\" =\u003e {\n                    const EXPECT: \u0026str = \"`[test(rt = \\\"tokio|async_std\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.rt = Some(value.to_string()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"naming\" =\u003e {\n                    const EXPECT: \u0026str =\n                        \"`[test(naming = \\\"random|uuid-v1|sequential|\u003ccustom\u003e\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.naming = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"dropping\" =\u003e {\n                    const EXPECT: \u0026str = \"`[test(drop = \\\"none|before|after|always\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.dropping = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                TokenTree::Ident(ident) if ident.to_string() == \"precision\" =\u003e {\n                    const EXPECT: \u0026str = \"`[test(drop = \\\"ms|us|ns|random|cyclic\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.precision = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n\n                TokenTree::Ident(ident)\n                    if ident.to_string() == \"log_level\" || ident.to_string() == \"log-level\" =\u003e\n                {\n                    const EXPECT: \u0026str = \"`[test(log_level = \\\"trace|debug|info|warn|error\\\")]`\";\n                    let _ = iter.next();\n                    let value = iter.next().expect(EXPECT);\n                    match value {\n                        TokenTree::Literal(value) =\u003e attr.log_level = Some(value.clone()),\n                        _ =\u003e unreachable!(\"expect {EXPECT}\"),\n                    }\n                }\n                _ =\u003e (),\n            }\n        }\n        attr\n    }\n\n    fn naming_token_stream(\u0026self) -\u003e TokenStream {\n        match \u0026self.naming {\n            Some(naming) =\u003e naming.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n\n    fn drop_token_stream(\u0026self) -\u003e TokenStream {\n        match \u0026self.dropping {\n            Some(drop) =\u003e drop.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n    fn precision_token_stream(\u0026self) -\u003e TokenStream {\n        match \u0026self.precision {\n            Some(precision) =\u003e precision.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n\n    fn crate_token_stream(\u0026self) -\u003e TokenStream {\n        let crate_name = std::env::var(\"CARGO_PKG_NAME\").unwrap();\n\n        if crate_name == \"taos\" {\n            quote!(crate)\n        } else {\n            quote!(taos)\n        }\n    }\n\n    fn databases(\u0026self, requires: \u0026Requires) -\u003e usize {\n        match requires {\n            Requires::None =\u003e 0,\n            Requires::TaosOnly =\u003e 0,\n            Requires::WithDatabase =\u003e 1,\n            Requires::WithMulti =\u003e self.databases.unwrap_or(1),\n        }\n    }\n\n    fn log_level(\u0026self) -\u003e TokenStream {\n        match \u0026self.log_level {\n            Some(log_level) =\u003e log_level.into_token_stream(),\n            None =\u003e quote!(()),\n        }\n    }\n\n    fn with_params(\u0026self, tokens: TokenStream) -\u003e TokenStream {\n        let Params {\n            is_async,\n            fn_name,\n            requires,\n            is_result,\n        } = Params::from_tokens(tokens.clone());\n\n        let fn_name = Ident::new(\u0026fn_name, Span::call_site());\n        let naming = self.naming_token_stream();\n        let drop = self.drop_token_stream();\n        let precision = self.precision_token_stream();\n        let log_level = self.log_level();\n        let _crate = self.crate_token_stream();\n        let databases = self.databases(\u0026requires);\n\n        let common = quote! {\n            #_crate::helpers::tests::Common::default()\n                .log_level(#log_level)\n                .init()?;\n        };\n\n        let builder = quote! {\n            let __taos = #_crate::helpers::tests::Builder::default()\n               .naming(#naming)\n               .precision(#precision)\n               .dropping(#drop)\n               .databases(#databases)\n               .build()?;\n            let _taos = __taos.taos();\n        };\n        let builder = match requires {\n            Requires::None =\u003e quote!(\n                #fn_name()\n            ),\n            Requires::TaosOnly =\u003e quote! {\n                #builder\n                #fn_name(_taos)\n            },\n            Requires::WithDatabase =\u003e quote! {\n                #builder\n                let _database = __taos.default_database();\n                #fn_name(_taos, _database)\n            },\n            Requires::WithMulti =\u003e quote! {\n                #builder\n                let _databases = __taos.databases();\n                #fn_name(_taos, \u0026_databases)\n            },\n        };\n\n        match (is_async, is_result) {\n            (true, true) =\u003e {\n                quote! {\n                    #[tokio::test]\n                    async fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder.await?;\n                        Ok(())\n                    }\n                }\n            }\n            (true, false) =\u003e {\n                quote! {\n                    #[tokio::test]\n                    async fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder.await;\n                        Ok(())\n                    }\n                }\n            }\n            (false, true) =\u003e {\n                quote! {\n                    #[std::prelude::v1::test]\n                    fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder?;\n                        Ok(())\n                    }\n                }\n            }\n            _ =\u003e {\n                quote! {\n                    #[std::prelude::v1::test]\n                    fn #fn_name() -\u003e anyhow::Result\u003c()\u003e {\n                        #tokens\n                        #common\n                        #builder;\n                        Ok(())\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn parse_database_requires(params: \u0026[TokenTree]) -\u003e Requires {\n    let mut iter = params.iter();\n    let mut has_taos = false;\n    let mut ret = Requires::None;\n    while let Some(t) = iter.next() {\n        use TokenTree::*;\n        match t {\n            Ident(ident) if ident.to_string() == \"taos\" || ident.to_string() == \"_taos\" =\u003e {\n                let _ = iter.next();\n                let _ = iter.next();\n                let ty = iter.next().unwrap();\n                assert!(ty.to_string().ends_with(\"Taos\"));\n                has_taos = true;\n                ret = Requires::TaosOnly;\n            }\n            Ident(ident) if ident.to_string() == \"database\" || ident.to_string() == \"_database\" =\u003e {\n                if !has_taos {\n                    panic!(\"please use test fn parameters: `taos: \u0026Taos, database: \u0026str`\");\n                }\n                ret = Requires::WithDatabase;\n            }\n            Ident(ident)\n                if ident.to_string() == \"databases\" || ident.to_string() == \"_databases\" =\u003e\n            {\n                if !has_taos {\n                    panic!(\"please use test fn parameters: `taos: \u0026Taos, databases: \u0026[String]`\");\n                }\n                ret = Requires::WithMulti;\n            }\n            _ =\u003e (),\n        }\n    }\n    ret\n}\npub(crate) fn test(\n    attr: proc_macro::TokenStream,\n    item: proc_macro::TokenStream,\n) -\u003e proc_macro::TokenStream {\n    Attr::from_iter(TokenStream::from(attr))\n        .with_params(TokenStream::from(item))\n        .into()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Attr;\n    use proc_macro2::*;\n    use quote::quote;\n\n    #[test]\n    fn default_sync() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            fn test_fn() { }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[std::prelude::v1::test]\n            fn test_fn() -\u003e anyhow::Result\u003c()\u003e {\n                fn test_fn() { }\n\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test_fn();\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn default_async() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            async fn async_simple() { }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[tokio::test]\n            async fn async_simple() -\u003e anyhow::Result\u003c()\u003e {\n                async fn async_simple() { }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                async_simple().await;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn sync_with_result() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            fn test() -\u003e Result\u003c()\u003e {\n                Ok(())\n            }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[std::prelude::v1::test]\n            fn test() -\u003e anyhow::Result\u003c()\u003e {\n                fn test() -\u003e Result\u003c()\u003e {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test()?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n\n    #[test]\n    fn async_with_result() {\n        let attr = Attr::default();\n        let fn_item = quote! {\n            async fn test() -\u003e Result\u003c()\u003e {\n                Ok(())\n            }\n        };\n        let tokens = attr.with_params(fn_item);\n        let expect = quote! {\n            #[tokio::test]\n            async fn test() -\u003e anyhow::Result\u003c()\u003e {\n                async fn test() -\u003e Result\u003c()\u003e {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                test().await?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n    }\n    #[test]\n    fn attr_from_iter() {\n        let attr = quote! {\n            databases = 10, rt = \"tokio\", naming = \"random\", dropping = \"always\"\n        };\n\n        let attr = super::Attr::from_iter(attr);\n\n        assert_eq!(\n            attr,\n            Attr {\n                databases: Some(10),\n                rt: Some(\"\\\"tokio\\\"\".to_string()),\n                naming: Some(Literal::string(\"random\")),\n                precision: None,\n                dropping: Some(Literal::string(\"always\")),\n                log_level: None,\n            }\n        );\n\n        let fn_item = quote! {\n            /// Comment.\n            ///\n            /// Long comment.\n            async fn test_a(taos: \u0026Taos, database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n                Ok(())\n            }\n        };\n        let params = super::Params::from_tokens(fn_item.clone().into());\n        dbg!(params);\n        let tokens = attr.with_params(fn_item);\n\n        let expect = quote! {\n            #[tokio::test]\n            async fn test_a() -\u003e anyhow::Result\u003c()\u003e {\n                /// Comment.\n                ///\n                /// Long comment.\n                async fn test_a(taos: \u0026Taos, database: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n                    Ok(())\n                }\n                taos::helpers::tests::Common::default()\n                    .log_level(())\n                    .init()?;\n                let __taos = taos::helpers::tests::Builder::default()\n                       .naming(\"random\")\n                       .precision(())\n                       .dropping(\"always\")\n                       .databases(1usize)\n                       .build()?;\n                let _taos = __taos.taos();\n                let _database = __taos.default_database();\n                test_a(_taos, _database).await?;\n                Ok(())\n            }\n        };\n        assert_eq!(tokens.to_string(), expect.to_string());\n        dbg!(tokens.to_string());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","tests","taos_cfg.rs"],"content":"use taos_macros::c_cfg;\n\n#[c_cfg(v3)]\nextern \"C\" {\n    fn test_cfg(_a: usize, _b: *mut usize);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-macros","tests","test.rs"],"content":"use anyhow::Result;\nuse taos::prelude::*;\nuse taos_macros::test;\n\n#[test()]\nfn sync() {}\n\n#[test]\nasync fn async_unit() {}\n\n#[test]\nasync fn async_with_taos(taos: \u0026Taos) {\n    dbg!(taos);\n}\n\n#[test]\nasync fn async_with_taos_db(_taos: \u0026Taos, _database: \u0026str) {}\n\n#[test]\nasync fn show_databases(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n    let databases = taos.databases().await?;\n    assert!(databases.iter().any(|db| db.name == database));\n    Ok(())\n}\n\n#[test(precision = \"ns\")]\nasync fn with_precision(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n    let databases = taos.databases().await?;\n    assert!(databases\n        .iter()\n        .any(|db| db.name == database \u0026\u0026 db.props.precision.as_ref().unwrap().as_str().eq(\"ns\")));\n    Ok(())\n}\n\n#[test(naming = \"abc1\")]\nasync fn custom_database(taos: \u0026Taos, database: \u0026str) -\u003e Result\u003c()\u003e {\n    let databases = taos.databases().await?;\n    assert!(database == \"abc1\");\n    assert!(databases.iter().any(|db| db.name == database));\n    Ok(())\n}\n\n#[test(databases = 10)]\nasync fn multi_databases(_taos: \u0026Taos, databases: \u0026[\u0026str]) -\u003e Result\u003c()\u003e {\n    assert!(databases.len() == 10);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","build.rs"],"content":"fn main() {\n    if rustc_version::version_meta().unwrap().channel == rustc_version::Channel::Nightly {\n        println!(\"cargo:rustc-cfg=nightly\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","column","mod.rs"],"content":"use bitvec_simd::BitVec;\nuse itertools::Itertools;\n\n// use crate::stmt::MultiBind;\n\nuse super::value::BorrowedValue;\n\n#[derive(Debug, serde::Serialize)]\npub enum BorrowedColumn\u003c'b\u003e {\n    Null(usize),\n    Bool(BitVec, \u0026'b [bool]),  // 1\n    TinyInt(BitVec, \u0026'b [i8]), // 2\n    SmallInt(BitVec, \u0026'b [i16]),\n    Int(BitVec, \u0026'b [i32]),\n    BigInt(BitVec, \u0026'b [i64]),\n    Float(BitVec, \u0026'b [f32]),\n    Double(BitVec, \u0026'b [f64]),\n    Binary(Vec\u003cOption\u003c\u0026'b [u8]\u003e\u003e),\n    Timestamp(BitVec, \u0026'b [i64]),\n    NChar(Vec\u003cOption\u003c\u0026'b str\u003e\u003e),\n    UTinyInt(BitVec, \u0026'b [u8]),\n    USmallInt(BitVec, \u0026'b [u16]),\n    UInt(BitVec, \u0026'b [u32]),\n    UBigInt(BitVec, \u0026'b [u64]), // 14\n    Json(BitVec, \u0026'b [u8]),\n    VarChar(BitVec, Vec\u003c\u0026'b [u8]\u003e),\n    VarBinary(BitVec, Vec\u003c\u0026'b [u8]\u003e),\n    Decimal(BitVec, \u0026'b [f64]),\n    Blob(BitVec, Vec\u003c\u0026'b [u8]\u003e),\n}\n\n#[derive(Debug, serde::Serialize, serde::Deserialize)]\npub enum Column {\n    Null(usize),\n    Bool(BitVec, Vec\u003cbool\u003e),  // 1\n    TinyInt(BitVec, Vec\u003ci8\u003e), // 2\n    SmallInt(BitVec, Vec\u003ci16\u003e),\n    Int(BitVec, Vec\u003ci32\u003e),\n    BigInt(BitVec, Vec\u003ci64\u003e),\n    Float(BitVec, Vec\u003cf32\u003e),\n    Double(BitVec, Vec\u003cf64\u003e),\n    Binary(Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e),\n    Timestamp(BitVec, Vec\u003ci64\u003e),\n    NChar(Vec\u003cOption\u003cString\u003e\u003e),\n    UTinyInt(BitVec, Vec\u003cu8\u003e),\n    USmallInt(BitVec, Vec\u003cu16\u003e),\n    UInt(BitVec, Vec\u003cu32\u003e),\n    UBigInt(BitVec, Vec\u003cu64\u003e), // 14\n    Json(BitVec, Vec\u003cu8\u003e),\n    VarChar(BitVec, Vec\u003cVec\u003cu8\u003e\u003e),\n    VarBinary(BitVec, Vec\u003cVec\u003cu8\u003e\u003e),\n    Decimal(BitVec, Vec\u003cf64\u003e),\n    Blob(BitVec, Vec\u003cVec\u003cu8\u003e\u003e),\n}\n\nimpl\u003c'block\u003e BorrowedColumn\u003c'block\u003e {\n    pub fn get(\u0026self, index: usize) -\u003e BorrowedValue\u003c'block\u003e {\n        macro_rules! get_primitive {\n            ($target:ident, $nulls:expr, $values:expr) =\u003e {\n                paste::paste! {\n                    if $nulls.get_unchecked(index) {\n                        BorrowedValue::Null\n                    } else {\n                        BorrowedValue::$target(*unsafe { $values.get_unchecked(index) })\n                    }\n                }\n            };\n        }\n        match self {\n            Self::Null(_n) =\u003e BorrowedValue::Null,\n            Self::Bool(nulls, values) =\u003e get_primitive!(Bool, nulls, values),\n            Self::TinyInt(nulls, values) =\u003e get_primitive!(TinyInt, nulls, values),\n            Self::SmallInt(nulls, values) =\u003e get_primitive!(SmallInt, nulls, values),\n            Self::Int(nulls, values) =\u003e get_primitive!(Int, nulls, values),\n            Self::BigInt(nulls, values) =\u003e get_primitive!(BigInt, nulls, values),\n            Self::UTinyInt(nulls, values) =\u003e get_primitive!(UTinyInt, nulls, values),\n            Self::USmallInt(nulls, values) =\u003e get_primitive!(USmallInt, nulls, values),\n            Self::UInt(nulls, values) =\u003e get_primitive!(UInt, nulls, values),\n            Self::UBigInt(nulls, values) =\u003e get_primitive!(UBigInt, nulls, values),\n            Self::Float(nulls, values) =\u003e get_primitive!(Float, nulls, values),\n            Self::Double(nulls, values) =\u003e get_primitive!(Double, nulls, values),\n            Self::Timestamp(nulls, _values) =\u003e {\n                if nulls.get_unchecked(index) {\n                    BorrowedValue::Null\n                } else {\n                    // BorrowedValue::Timestamp(TimestampValue::new(*unsafe { values.get_unchecked(index) }, self.precision()))\n                    todo!()\n                }\n            }\n            Self::Binary(values) =\u003e match unsafe { values.get_unchecked(index) } {\n                Some(bytes) =\u003e {\n                    BorrowedValue::VarChar(unsafe { std::str::from_utf8_unchecked(bytes) })\n                }\n                None =\u003e BorrowedValue::Null,\n            },\n            Self::NChar(_values) =\u003e BorrowedValue::Null,\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl\u003c'block\u003e BorrowedColumn\u003c'block\u003e {\n    pub fn into_owned(self) -\u003e Column {\n        match self {\n            BorrowedColumn::Null(rows) =\u003e Column::Null(rows),\n            BorrowedColumn::Bool(is_nulls, slice) =\u003e Column::Bool(is_nulls, slice.to_owned()),\n            BorrowedColumn::TinyInt(is_nulls, slice) =\u003e Column::TinyInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::SmallInt(is_nulls, slice) =\u003e {\n                Column::SmallInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::Int(is_nulls, slice) =\u003e Column::Int(is_nulls, slice.to_owned()),\n            BorrowedColumn::BigInt(is_nulls, slice) =\u003e Column::BigInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::UTinyInt(is_nulls, slice) =\u003e {\n                Column::UTinyInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::USmallInt(is_nulls, slice) =\u003e {\n                Column::USmallInt(is_nulls, slice.to_owned())\n            }\n            BorrowedColumn::UInt(is_nulls, slice) =\u003e Column::UInt(is_nulls, slice.to_owned()),\n            BorrowedColumn::UBigInt(is_nulls, slice) =\u003e Column::UBigInt(is_nulls, slice.to_owned()),\n\n            BorrowedColumn::Float(is_nulls, slice) =\u003e Column::Float(is_nulls, slice.to_owned()),\n            BorrowedColumn::Double(is_nulls, slice) =\u003e Column::Double(is_nulls, slice.to_owned()),\n            BorrowedColumn::Binary(binary) =\u003e Column::Binary(\n                binary\n                    .into_iter()\n                    .map(|val| val.map(ToOwned::to_owned))\n                    .collect_vec(),\n            ),\n            BorrowedColumn::NChar(binary) =\u003e Column::NChar(\n                binary\n                    .into_iter()\n                    .map(|val| val.map(|val| val.to_string()))\n                    .collect_vec(),\n            ),\n            BorrowedColumn::Timestamp(is_nulls, slice) =\u003e {\n                Column::Timestamp(is_nulls, slice.to_owned())\n            }\n            _ =\u003e unreachable!(\"unsupported data type\"),\n        }\n    }\n}\n\n#[test]\nfn test_serde() {\n    const N: usize = 100;\n    let nulls = BitVec::zeros(N);\n    let v: Vec\u003ci32\u003e = (0..N).map(|_| rand::random()).collect();\n    let ints = BorrowedColumn::Int(nulls, \u0026v);\n\n    let json = serde_json::to_string(\u0026ints).unwrap();\n\n    let ints2: Column = serde_json::from_str(\u0026json).unwrap();\n\n    println!(\"{ints:?}\");\n    println!(\"{ints2:?}\");\n}\n","traces":[{"line":57,"address":[2712096],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2712151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2712238],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2712274,2714286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2712343,2714195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2712412,2714102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2714011,2712481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2713918,2712550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2712901,2713430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2712970,2713337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2713039,2713252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[2713233,2713108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2713823,2712619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2713728,2712688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[2712804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2713521,2712831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2713565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2712749,2713597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2713654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[2713665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2713641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2712865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2717466,2714384,2719377],"length":1,"stats":{"Line":0},"fn_name":"into_owned"},{"line":104,"address":[2714429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2714752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2714788,2719011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2718881,2714974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[2715160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2718751,2715298],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2718621,2715346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2715532,2718491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2716480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[2717767,2716618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2716666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2717637,2716792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2716840,2717507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2716996,2717339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2718361,2715718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2718231,2715904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2718145,2716122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2002976,2003029],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2716410,2717913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2003056,2003109,2003158,2003136],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2716192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2717999,2716330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2034976,2034981],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":147,"address":[2729871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[2035022,2035008],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":149,"address":[2730025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[2730291,2730214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[2730329,2730405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[2730517,2730450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[2730601],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":63},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","describe.rs"],"content":"use std::ops::{Deref, DerefMut};\n\nuse itertools::Itertools;\nuse serde::{Deserialize, Serialize};\n\nuse crate::helpers::ColumnMeta;\n\n#[derive(Debug, Deserialize, Serialize, Clone)]\npub struct Describe(pub(crate) Vec\u003cColumnMeta\u003e);\n\nimpl IntoIterator for Describe {\n    type Item = ColumnMeta;\n\n    type IntoIter = std::vec::IntoIter\u003cSelf::Item\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl FromIterator\u003cColumnMeta\u003e for Describe {\n    fn from_iter\u003cT: IntoIterator\u003cItem = ColumnMeta\u003e\u003e(iter: T) -\u003e Self {\n        Describe(iter.into_iter().collect())\n    }\n}\n\nimpl Deref for Describe {\n    type Target = Vec\u003cColumnMeta\u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for Describe {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\nimpl Describe {\n    #[inline]\n    fn fields(\u0026self) -\u003e \u0026[ColumnMeta] {\n        \u0026self.0\n    }\n    pub fn is_stable(\u0026self) -\u003e bool {\n        self.fields().iter().any(|f| f.is_tag())\n    }\n    pub fn names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026str\u003e {\n        self.fields().iter().map(|f| f.field())\n    }\n\n    pub fn tag_names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026str\u003e {\n        self.fields()\n            .iter()\n            .filter(|f| f.is_tag())\n            .map(|f| f.field())\n    }\n    pub fn to_create_table_sql(\u0026self, table: \u0026str) -\u003e String {\n        let (cols, tags): (Vec\u003c_\u003e, Vec\u003c_\u003e) = self.fields().iter().partition(|f| !f.is_tag());\n        let col_sql = cols.into_iter().map(|f| f.sql_repr()).join(\",\");\n\n        if tags.is_empty() {\n            format!(\"create table if not exists {table} ({col_sql})\")\n        } else {\n            let tags_sql = tags.into_iter().map(|f| f.sql_repr()).join(\",\");\n            format!(\"create table if not exists {table} ({col_sql}) tags({tags_sql})\")\n        }\n    }\n}\n","traces":[{"line":16,"address":[8430160],"length":1,"stats":{"Line":0},"fn_name":"into_iter"},{"line":17,"address":[8430172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[8430224],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":36,"address":[8430240],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":42,"address":[8430256],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":43,"address":[2276393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[8430304],"length":1,"stats":{"Line":0},"fn_name":"is_stable"},{"line":46,"address":[2824160,2824187],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":48,"address":[2276512],"length":1,"stats":{"Line":0},"fn_name":"names"},{"line":49,"address":[2276521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[8430496],"length":1,"stats":{"Line":0},"fn_name":"tag_names"},{"line":53,"address":[2276617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2277183,2276720,2278183],"length":1,"stats":{"Line":0},"fn_name":"to_create_table_sql"},{"line":59,"address":[2824224,2824238],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":60,"address":[8430983,8430875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2277246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2277339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2277273,2277614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2277755],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","field.rs"],"content":"use std::fmt::{Debug, Display};\n\nuse crate::util::{Inlinable, InlinableRead, InlinableWrite};\n\nuse super::ty::Ty;\n\n/// A `Field` represents the name and data type of one column or tag.\n///\n/// For example, a table as \"create table tb1 (ts timestamp, n nchar(100))\".\n///\n/// When query with \"select * from tb1\", you will get two fields:\n///\n/// 1. `{ name: \"ts\", ty: Timestamp, bytes: 8 }`, a `TIMESTAMP` field with name `ts`,\n///    bytes length 8 which is the byte-width of `i64`.\n/// 2. `{ name: \"n\", ty: NChar, bytes: 100 }`, a `NCHAR` filed with name `n`,\n///    bytes length 100 which is the length of the variable-length data.\n\n#[derive(Debug)]\npub struct Field {\n    name: String,\n    ty: Ty,\n    bytes: u32,\n}\n\nimpl Inlinable for Field {\n    fn write_inlined\u003cW: std::io::Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        let mut l = wtr.write_u8(self.ty as u8)?;\n        l += wtr.write_u32(self.bytes)?;\n        l += wtr.write_inlined_str::\u003c2\u003e(\u0026self.name)?;\n        Ok(l)\n    }\n\n    fn read_inlined\u003cR: std::io::Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        let ty = Ty::from(reader.read_u8()?);\n        let bytes = reader.read_u32()?;\n        let name = reader.read_inlined_str::\u003c2\u003e()?;\n        Ok(Self { name, ty, bytes })\n    }\n}\n\nimpl Field {\n    pub fn new(name: impl Into\u003cString\u003e, ty: Ty, bytes: u32) -\u003e Self {\n        let name = name.into();\n        Self { name, ty, bytes }\n    }\n\n    /// Field name.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// Data type of the field.\n    pub const fn ty(\u0026self) -\u003e Ty {\n        self.ty\n    }\n\n    /// Preset length of variable length data type.\n    ///\n    /// It's the byte-width in other types.\n    pub const fn bytes(\u0026self) -\u003e u32 {\n        self.bytes\n    }\n\n    /// Represent the data type in sql.\n    ///\n    /// For example: \"INT\", \"VARCHAR(100)\".\n    pub fn sql_repr(\u0026self) -\u003e String {\n        let ty = self.ty();\n        if ty.is_var_type() {\n            format!(\"{}({})\", ty.name(), self.bytes())\n        } else {\n            ty.name().to_string()\n        }\n    }\n}\n\nimpl Display for Field {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let ty = self.ty();\n        if ty.is_var_type() {\n            write!(f, \"({}: {}({}))\", self.name(), ty.name(), self.bytes())\n        } else {\n            write!(f, \"({}: {})\", self.name(), ty.name())\n        }\n    }\n}\n","traces":[{"line":26,"address":[3238560,3239260,3239280,3239980],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":27,"address":[3238642,3239450,3239315,3238730,3238595,3239362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3239422,3239665,3239515,3238702,3238967,3238945,3238795,3239687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3239742,3239022,3239227,3239204,3238950,3239670,3239924,3239947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[3239209,3239929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[3240000,3240723],"length":1,"stats":{"Line":0},"fn_name":"read_inlined\u003c\u0026mut \u0026[u8]\u003e"},{"line":34,"address":[3240191,3240076,3240032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[3240294,3240208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[3240282,3240661,3240369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3240498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[3240752],"length":1,"stats":{"Line":2},"fn_name":"new\u003c\u0026str\u003e"},{"line":43,"address":[8094800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[2085200],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":49,"address":[2085209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2085248],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":54,"address":[2085253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[8158624],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":61,"address":[8158629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2085280],"length":1,"stats":{"Line":0},"fn_name":"sql_repr"},{"line":68,"address":[2085318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2085327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2085381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2085351,2085629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[2085648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":79,"address":[2085681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[2085693,2086290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2085756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2085725,2086077],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":28},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","itypes.rs"],"content":"use std::{fmt::Display, ops::Deref};\n\nuse derive_more::{Deref, DerefMut, Display, From};\n\nuse rust_decimal::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as Json;\n\nuse super::{Column, Ty, Value};\n\npub type INull = ();\npub type IBool = bool;\npub type ITinyInt = i8;\npub type ISmallInt = i16;\npub type IInt = i32;\npub type IBigInt = i64;\npub type IUTinyInt = u8;\npub type IUSmallInt = u16;\npub type IUInt = u32;\npub type IUBigInt = u64;\npub type IFloat = f32;\npub type IDouble = f64;\npub type IJson = Json;\npub type IDecimal = Decimal;\n\n#[derive(Debug, Clone, Copy, Deref, DerefMut, Deserialize, Serialize, Display, From)]\npub struct ITimestamp(pub i64);\n\n#[derive(Debug, Deref, DerefMut, Clone, Deserialize, Serialize)]\npub struct IVarChar(String);\n\n/// Alias of [IVarChar].\npub type IBinary = IVarChar;\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct INChar(String);\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IVarBinary(Vec\u003cu8\u003e);\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IMediumBlob(Vec\u003cu8\u003e);\n\n#[derive(Debug, Deref, DerefMut, Clone, From, Deserialize, Serialize)]\npub struct IBlob(Vec\u003cu8\u003e);\n\nimpl From\u003cString\u003e for IVarChar {\n    fn from(v: String) -\u003e Self {\n        Self(v)\n    }\n}\nimpl From\u003c\u0026str\u003e for IVarChar {\n    fn from(v: \u0026str) -\u003e Self {\n        Self(v.to_string())\n    }\n}\n\nimpl IVarChar {\n    pub const fn new() -\u003e Self {\n        Self(String::new())\n    }\n    pub fn with_capacity(cap: usize) -\u003e Self {\n        Self(String::with_capacity(cap))\n    }\n}\npub trait IsValue: Sized {\n    const TY: Ty;\n\n    fn is_null(\u0026self) -\u003e bool {\n        false\n    }\n\n    fn is_primitive(\u0026self) -\u003e bool {\n        std::mem::size_of::\u003cSelf\u003e() == Self::TY.fixed_length()\n    }\n\n    fn as_timestamp(\u0026self) -\u003e i64 {\n        debug_assert!(Self::TY == Ty::Timestamp);\n        unimplemented!()\n    }\n\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        debug_assert!(Self::TY == Ty::VarChar);\n        unimplemented!()\n    }\n\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        debug_assert!(Self::TY == Ty::NChar);\n        unimplemented!()\n    }\n\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8] {\n        debug_assert!(Self::TY == Ty::MediumBlob);\n        unimplemented!()\n    }\n\n    fn as_blob(\u0026self) -\u003e \u0026[u8] {\n        debug_assert!(Self::TY == Ty::Blob);\n        unimplemented!()\n    }\n}\n\nimpl\u003cT\u003e IsValue for Option\u003cT\u003e\nwhere\n    T: IsValue,\n{\n    const TY: Ty = T::TY;\n\n    fn is_null(\u0026self) -\u003e bool {\n        self.is_none()\n    }\n\n    fn is_primitive(\u0026self) -\u003e bool {\n        self.as_ref().unwrap().is_primitive()\n    }\n\n    fn as_timestamp(\u0026self) -\u003e i64 {\n        self.as_ref().unwrap().as_timestamp()\n    }\n\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        self.as_ref().unwrap().as_var_char()\n    }\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        self.as_ref().unwrap().as_nchar()\n    }\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8] {\n        self.as_ref().unwrap().as_medium_blob()\n    }\n    fn as_blob(\u0026self) -\u003e \u0026[u8] {\n        self.as_ref().unwrap().as_blob()\n    }\n}\n\npub trait IValue: Sized {\n    const TY: Ty;\n\n    type Inner: Sized;\n\n    fn is_null(\u0026self) -\u003e bool {\n        false\n    }\n\n    fn into_value(self) -\u003e Value;\n\n    fn into_inner(self) -\u003e Self::Inner;\n}\n\nimpl IValue for INull {\n    const TY: Ty = Ty::Null;\n\n    fn is_null(\u0026self) -\u003e bool {\n        true\n    }\n    fn into_value(self) -\u003e Value {\n        Value::Null\n    }\n\n    type Inner = ();\n\n    fn into_inner(self) -\u003e Self::Inner {\n        ()\n    }\n}\n\n/// Primitive type to TDengine data type.\nmacro_rules! impl_prim {\n    ($($ty:ident = $inner:ty)*) =\u003e {\n        $(paste::paste! {\n            impl IValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n                type Inner = $inner;\n\n                #[inline]\n                fn is_null(\u0026self) -\u003e bool {\n                    false\n                }\n\n                #[inline]\n                fn into_value(self) -\u003e Value {\n                    Value::$ty(self)\n                }\n\n                #[inline]\n                fn into_inner(self) -\u003e Self::Inner {\n                    self\n                }\n            }\n        })*\n    };\n}\n\nimpl_prim!(\n    Bool = bool\n    TinyInt = i8\n    SmallInt =  i16\n    Int = i32\n    BigInt = i64\n    UTinyInt = u8\n    USmallInt = u16\n    UInt = u32\n    UBigInt = u64\n    Float = f32\n    Double = f64\n    Decimal = Decimal\n    Json = Json\n);\n\npub trait IsPrimitive: Copy {\n    const TY: Ty;\n    fn is_primitive(\u0026self) -\u003e bool {\n        std::mem::size_of::\u003cSelf\u003e() == Self::TY.fixed_length()\n    }\n}\n\nmacro_rules! impl_is_primitive {\n    ($($ty:ident) *) =\u003e {\n        $(paste::paste! {\n            impl IsPrimitive for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n            }\n            impl IsValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n            }\n        })*\n    };\n}\n\nimpl_is_primitive!(\n    Bool TinyInt SmallInt Int BigInt\n    UTinyInt USmallInt UInt UBigInt\n    Float Double Decimal\n);\n\nimpl IsValue for ITimestamp {\n    const TY: Ty = Ty::Timestamp;\n\n    #[inline]\n    fn as_timestamp(\u0026self) -\u003e i64 {\n        self.0\n    }\n}\n\nimpl IsValue for IVarChar {\n    const TY: Ty = Ty::VarChar;\n\n    #[inline]\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\nimpl IsValue for INChar {\n    const TY: Ty = Ty::NChar;\n\n    #[inline]\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\npub trait IsVarChar {\n    fn as_var_char(\u0026self) -\u003e \u0026str;\n}\n\nimpl IsVarChar for IVarChar {\n    fn as_var_char(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\npub trait IsNChar {\n    fn as_nchar(\u0026self) -\u003e \u0026str;\n}\n\nimpl IsNChar for INChar {\n    fn as_nchar(\u0026self) -\u003e \u0026str {\n        \u0026self\n    }\n}\n\npub trait IsJson {\n    fn to_json(\u0026self) -\u003e String;\n}\n\nimpl IsJson for IJson {\n    fn to_json(\u0026self) -\u003e String {\n        self.to_string()\n    }\n}\n\npub trait IsMediumBlob {\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8];\n}\n\nimpl IsMediumBlob for IMediumBlob {\n    fn as_medium_blob(\u0026self) -\u003e \u0026[u8] {\n        \u0026self\n    }\n}\n\npub trait IsBlob {\n    fn as_blob(\u0026self) -\u003e \u0026[u8];\n}\n\nimpl IsBlob for IBlob {\n    fn as_blob(\u0026self) -\u003e \u0026[u8] {\n        \u0026self\n    }\n}\n\nimpl IValue for ITimestamp {\n    const TY: Ty = Ty::Timestamp;\n\n    type Inner = i64;\n\n    fn into_value(self) -\u003e Value {\n        todo!()\n    }\n\n    fn into_inner(self) -\u003e Self::Inner {\n        self.0\n    }\n}\n\nmacro_rules! impl_wrapper_struct {\n    ($($ty:ident)*) =\u003e {\n        $(paste::paste! {\n            impl IValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n                #[inline]\n                fn into_value(self) -\u003e Value {\n                    Value::$ty(self.0)\n                }\n            }\n        })*\n    };\n    ($($ty:ident, $inner:ty;)*) =\u003e {\n        $(paste::paste! {\n            #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Deserialize, Serialize)]\n            pub struct [\u003cI $ty\u003e]($inner);\n\n            impl Deref for [\u003cI $ty\u003e] {\n                type Target = $inner;\n\n                #[inline]\n                fn deref(\u0026self) -\u003e \u0026Self::Target {\n                        \u0026self.0\n                }\n            }\n\n            impl IValue for [\u003cI $ty\u003e] {\n                const TY: Ty = Ty::$ty;\n                #[inline]\n                fn into_value(self) -\u003e Value {\n                    Value::$ty(self.0)\n                }\n            }\n        })*\n    };\n}\n","traces":[{"line":47,"address":[2815888],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":48,"address":[2815895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2815952],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":53,"address":[2815975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[2816032],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":59,"address":[2816045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2816096],"length":1,"stats":{"Line":0},"fn_name":"with_capacity"},{"line":62,"address":[2816115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[2392336],"length":1,"stats":{"Line":0},"fn_name":"is_null\u003crust_decimal::decimal::Decimal\u003e"},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2392352],"length":1,"stats":{"Line":0},"fn_name":"is_primitive\u003crust_decimal::decimal::Decimal\u003e"},{"line":73,"address":[2392361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[2470560,2471120,2471232,2470448,2470672,2471456,2471344,2471568,2471680,2470784,2470336,2470896,2471008],"length":1,"stats":{"Line":0},"fn_name":"as_timestamp\u003ci16\u003e"},{"line":77,"address":[2470345,2471129,2471304,2471689,2471577,2471465,2470632,2471416,2471528,2470681,2470793,2470968,2471640,2470457,2470744,2470520,2471752,2471017,2471353,2471080,2471241,2470569,2470408,2470905,2470856,2471192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[2472912,2472016,2472688,2472576,2472240,2472352,2472800,2472128,2472464,2471792,2473024,2471904,2473136],"length":1,"stats":{"Line":0},"fn_name":"as_var_char\u003ci16\u003e"},{"line":82,"address":[2472921,2472984,2472585,2472809,2472536,2473033,2471864,2472473,2471913,2472648,2472249,2472760,2472424,2472137,2473145,2473208,2472312,2472200,2471801,2472088,2471976,2473096,2472697,2472361,2472025,2472872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[2473360,2473584,2474368,2474032,2473808,2473920,2474256,2473248,2474144,2473696,2474592,2474480,2473472],"length":1,"stats":{"Line":0},"fn_name":"as_nchar\u003cu8\u003e"},{"line":87,"address":[2474265,2474440,2473593,2474328,2474489,2473544,2474377,2474664,2474601,2474104,2473481,2473257,2474153,2474041,2473929,2473705,2473817,2473880,2473768,2474552,2474216,2473320,2473992,2473656,2473369,2473432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2475488,2476048,2474928,2475600,2476160,2475712,2475040,2475376,2475264,2475152,2475824,2475936,2474816,2474704],"length":1,"stats":{"Line":0},"fn_name":"as_medium_blob\u003cu8\u003e"},{"line":92,"address":[2392824,2392761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[2392864],"length":1,"stats":{"Line":0},"fn_name":"as_blob\u003crust_decimal::decimal::Decimal\u003e"},{"line":97,"address":[2392936,2392873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2477840],"length":1,"stats":{"Line":0},"fn_name":"is_null\u003ctaos_query::common::itypes::ITimestamp\u003e"},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2816176],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":154,"address":[2816192],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":155,"address":[2816196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2816208],"length":1,"stats":{"Line":0},"fn_name":"into_inner"},{"line":174,"address":[2171264],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":179,"address":[2171280],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":180,"address":[2171287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2171376],"length":1,"stats":{"Line":0},"fn_name":"into_inner"},{"line":185,"address":[2171379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2392976],"length":1,"stats":{"Line":0},"fn_name":"is_primitive\u003crust_decimal::decimal::Decimal\u003e"},{"line":211,"address":[2392985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2816224],"length":1,"stats":{"Line":0},"fn_name":"as_timestamp"},{"line":239,"address":[2816229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2816240],"length":1,"stats":{"Line":0},"fn_name":"as_var_char"},{"line":248,"address":[2816249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2816304],"length":1,"stats":{"Line":0},"fn_name":"as_nchar"},{"line":257,"address":[2816313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2816368],"length":1,"stats":{"Line":0},"fn_name":"as_var_char"},{"line":267,"address":[2816377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2816432],"length":1,"stats":{"Line":0},"fn_name":"as_nchar"},{"line":277,"address":[2816441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[2171216],"length":1,"stats":{"Line":0},"fn_name":"to_json"},{"line":287,"address":[2171233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[2816496],"length":1,"stats":{"Line":0},"fn_name":"as_medium_blob"},{"line":297,"address":[2816505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[2816560],"length":1,"stats":{"Line":0},"fn_name":"as_blob"},{"line":307,"address":[2816569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2816624],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":320,"address":[2816672],"length":1,"stats":{"Line":0},"fn_name":"into_inner"}],"covered":0,"coverable":67},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","mod.rs"],"content":"mod column;\nmod describe;\nmod field;\nmod opts;\nmod precision;\nmod raw;\nmod timestamp;\nmod ty;\nmod value;\n\npub use column::*;\npub use describe::*;\npub use field::*;\npub use opts::*;\npub use precision::*;\npub use raw::*;\npub use timestamp::*;\npub use ty::*;\npub use value::*;\n\npub mod itypes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","opts.rs"],"content":"use std::collections::BTreeMap;\n\nuse mdsn::Dsn;\n// use url::ParseError;\nuse mdsn::DsnError as Error;\n\n#[derive(Debug, Default, PartialEq, Eq)]\npub struct TaosOpts {\n    pub host: Option\u003cString\u003e,\n    pub port: Option\u003cu16\u003e,\n    pub username: Option\u003cString\u003e,\n    pub password: Option\u003cString\u003e,\n    pub database: Option\u003cString\u003e,\n    pub params: BTreeMap\u003cString, String\u003e,\n}\n\nmacro_rules! _build_opt {\n    ($option:ident, $($doc:literal) *) =\u003e {\n        $(#[doc = $doc])*\n        pub fn $option\u003cT: Into\u003cString\u003e\u003e(mut self, $option: T) -\u003e Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n    ($option:ident, $ty:ty, $($doc:literal) *) =\u003e {\n        $(#[doc = $doc])*\n        pub fn $option\u003cT: Into\u003c$ty\u003e\u003e(mut self, $option: T) -\u003e Self {\n            self.$option = Some($option.into());\n            self\n        }\n    };\n}\n\nimpl TaosOpts {\n    /// Default to [Default::default].\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn to_dsn_string(\u0026self) -\u003e String {\n        todo!()\n    }\n\n    /// Parse from a [DSN](https://en.wikipedia.org/wiki/Data_source_name) string.\n    ///\n    /// We use URL-described DSN style like this:\n    ///\n    /// ```text\n    /// \u003cdriver\u003e[+\u003cprotocol\u003e]://\u003cusername\u003e:\u003cpassword\u003e@\u003chost\u003e:\u003cport\u003e[,\u003chost2\u003e:\u003cport2\u003e]/\u003cdatabase\u003e?\u003cparams\u003e\n    /// ```\n    ///\n    /// - **driver**: to distinct from other data source, for TDengine, always use `taos`.\n    /// - **protocol**: additional information for connection, for TDengine, we have a plan to support\n    ///     taosc(the default protocol), http and websocket(with protocol identifier: `ws`).\n    /// - **username**: username for the connection\n    /// - **password**: password for the current user.\n    /// - **host**: host to TDengine server.\n    /// - **port**: port to TDengine server.\n    /// - **database**: default database for the connection, so that you don't need to write with full\n    ///     database name in sql like `select * from database.tb1`.\n    /// - **params**: in-query parameters are key-value pairs, drivers should be aware of the params list\n    ///     to support specific configuration for each driver or protocol.\n    ///\n    pub fn parse(dsn: \u0026str) -\u003e Result\u003cTaosOpts, Error\u003e {\n        if dsn.is_empty() {\n            return Ok(Self::new());\n        }\n        let _ = Dsn::parse(dsn)?;\n\n        Ok(Self::default())\n    }\n\n    _build_opt!(host, \"Set host name or ip address of TDengine server\");\n    _build_opt!(username, \"Set default username for TDengine connection\");\n    _build_opt!(password, \"Set default password for TDengine connection\");\n    _build_opt!(database, \"Set default database name of the connection\");\n    _build_opt!(port, u16, \"Set port to the TDengine server\");\n\n    /// Set other params by k-v pair.\n    pub fn with\u003cK: Into\u003cString\u003e, V: Into\u003cString\u003e\u003e(\n        mut self,\n        iter: impl Iterator\u003cItem = (K, V)\u003e,\n    ) -\u003e Self {\n        for (k, v) in iter {\n            self.set(k, v);\n        }\n        self\n    }\n\n    fn set(\u0026mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e \u0026mut Self {\n        self.params.insert(key.into(), value.into());\n        self\n    }\n}\n\n#[test]\nfn test_options() {\n    let opts = TaosOpts::parse(\"postgresql://root:pass@tcp(host1:123,host2:456)/somedb?target_session_attrs=any\u0026application_name=myapp\");\n    dbg!(opts);\n}\n\n#[test]\nfn test_options_builder_all() {\n    let opts = TaosOpts::new()\n        .host(\"localhost\")\n        .port(6030u16)\n        .username(\"root\")\n        .password(\"taosdata\");\n\n    assert_eq!(\n        opts,\n        TaosOpts {\n            host: Some(\"localhost\".to_string()),\n            port: Some(6030),\n            username: Some(\"root\".to_string()),\n            password: Some(\"taosdata\".to_string()),\n            database: None,\n            params: Default::default(),\n        },\n        \"builder pattern for TaosOpts\"\n    );\n}\n","traces":[{"line":20,"address":[2703013,2702752,2702719,2702464,2703301,2703040],"length":1,"stats":{"Line":3},"fn_name":"host\u003c\u0026str\u003e"},{"line":21,"address":[2703098,2702577,2702865,2702522,2703153,2702810],"length":1,"stats":{"Line":6},"fn_name":null},{"line":22,"address":[2702696,2703278,2702990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[2703460,2703328],"length":1,"stats":{"Line":1},"fn_name":"port\u003cu16\u003e"},{"line":28,"address":[2703410,2703354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2703440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[3281664],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":37,"address":[3281672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[3281696],"length":1,"stats":{"Line":0},"fn_name":"to_dsn_string"},{"line":64,"address":[3281744],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":65,"address":[3281801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[3281845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[3281829,3281904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[3282103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2703488,2703493],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":98,"address":[3284167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[3284225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[2703520,2703525],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":104,"address":[3284839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[3285565,3285683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[3285368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[3284974,3285038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[3285070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[3285161,3285090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[3285261,3285193],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[3285293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[3285305],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":30},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","precision.rs"],"content":"use std::{\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nuse serde::Deserialize;\n\n#[derive(Debug, thiserror::Error)]\npub enum PrecisionError {\n    #[error(\"invalid precision repr: {0}\")]\n    Invalid(String),\n}\n\n/// The precision of a timestamp or a database.\n#[repr(i32)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq, serde_repr::Serialize_repr)]\npub enum Precision {\n    Millisecond = 0,\n    Microsecond,\n    Nanosecond,\n}\n\nimpl PartialEq\u003cstr\u003e for Precision {\n    fn eq(\u0026self, other: \u0026str) -\u003e bool {\n        self.as_str() == other\n    }\n}\n\nimpl PartialEq\u003c\u0026str\u003e for Precision {\n    fn eq(\u0026self, other: \u0026\u0026str) -\u003e bool {\n        self.as_str() == *other\n    }\n}\n\nimpl Precision {\n    pub const fn as_str(\u0026self) -\u003e \u0026'static str {\n        use Precision::*;\n        match self {\n            Millisecond =\u003e \"ms\",\n            Microsecond =\u003e \"us\",\n            Nanosecond =\u003e \"ns\",\n        }\n    }\n\n    pub const fn as_u8(\u0026self) -\u003e u8 {\n        match self {\n            Self::Millisecond =\u003e 0,\n            Self::Microsecond =\u003e 1,\n            Self::Nanosecond =\u003e 2,\n        }\n    }\n    pub const fn from_u8(precision: u8) -\u003e Self {\n        match precision {\n            0 =\u003e Self::Millisecond,\n            1 =\u003e Self::Microsecond,\n            2 =\u003e Self::Nanosecond,\n            _ =\u003e panic!(\"precision integer only allow 0/1/2\"),\n        }\n    }\n}\n\nmacro_rules! _impl_from {\n    ($($ty:ty) *) =\u003e {\n        $(impl From\u003c$ty\u003e for Precision {\n            fn from(v: $ty) -\u003e Self {\n                Self::from_u8(v as _)\n            }\n        })*\n    }\n}\n\n_impl_from!(i8 i16 i32 i64 isize u8 u16 u32 u64 usize);\n\nimpl Display for Precision {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl FromStr for Precision {\n    type Err = PrecisionError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s {\n            \"ms\" =\u003e Ok(Precision::Millisecond),\n            \"us\" =\u003e Ok(Precision::Microsecond),\n            \"ns\" =\u003e Ok(Precision::Nanosecond),\n            s =\u003e Err(PrecisionError::Invalid(s.to_string())),\n        }\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Precision {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: serde::Deserializer\u003c'de\u003e,\n    {\n        struct PrecisionVisitor;\n\n        impl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for PrecisionVisitor {\n            type Value = Precision;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"expect integer 0/1/2 or string ms/us/ns\")\n            }\n\n            fn visit_i8\u003cE\u003e(self, v: i8) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n            fn visit_i16\u003cE\u003e(self, v: i16) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_i32\u003cE\u003e(self, v: i32) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Precision::try_from(v).map_err(\u003cE as serde::de::Error\u003e::custom)\n            }\n\n            fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u16\u003cE\u003e(self, v: u16) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u32\u003cE\u003e(self, v: u32) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                self.visit_i32(v as _)\n            }\n\n            fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Precision::from_str(v).map_err(\u003cE as serde::de::Error\u003e::custom)\n            }\n\n            fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Precision::Millisecond)\n            }\n\n            fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n            where\n                D: serde::Deserializer\u003c'de\u003e,\n            {\n                deserializer.deserialize_any(self)\n            }\n\n            fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Precision::Millisecond)\n            }\n        }\n\n        deserializer.deserialize_any(PrecisionVisitor)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::{\n        de::{\n            value::{I32Deserializer, StrDeserializer, UnitDeserializer},\n            IntoDeserializer,\n        },\n        Deserialize,\n    };\n\n    use super::Precision;\n\n    #[test]\n    fn de() {\n        type SD\u003c'a\u003e = StrDeserializer\u003c'a, serde::de::value::Error\u003e;\n        let precision = Precision::deserialize::\u003cSD\u003e(\"ms\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n        let precision = Precision::deserialize::\u003cSD\u003e(\"us\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Microsecond);\n        let precision = Precision::deserialize::\u003cSD\u003e(\"ns\".into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Nanosecond);\n\n        type I32D = I32Deserializer\u003cserde::de::value::Error\u003e;\n        let precision = Precision::deserialize::\u003cI32D\u003e(0.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n        let precision = Precision::deserialize::\u003cI32D\u003e(1.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Microsecond);\n        let precision = Precision::deserialize::\u003cI32D\u003e(2.into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Nanosecond);\n\n        type UnitD = UnitDeserializer\u003cserde::de::value::Error\u003e;\n        let precision = Precision::deserialize::\u003cUnitD\u003e(().into_deserializer()).unwrap();\n        assert_eq!(precision, Precision::Millisecond);\n\n        let json = serde_json::to_string(\u0026precision).unwrap();\n        assert_eq!(json, \"0\");\n    }\n}\n","traces":[{"line":24,"address":[2833600],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":25,"address":[2833619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2833680],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":31,"address":[2833699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[2833760],"length":1,"stats":{"Line":1},"fn_name":"as_str"},{"line":38,"address":[2833769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2833796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2833819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[2833842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2833888],"length":1,"stats":{"Line":0},"fn_name":"as_u8"},{"line":46,"address":[2833897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2833922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[2833929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2833936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[2833952],"length":1,"stats":{"Line":1},"fn_name":"from_u8"},{"line":53,"address":[2833967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2834029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2834039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2834049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2833993,2834059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[2835280,2835248,2835392,2835584,2835504,2835440,2835312,2835536,2835472,2835344],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":66,"address":[2835289,2835401,2835545,2835481,2835448,2835256,2835593,2835353,2835317,2835509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[2834096],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":76,"address":[2834118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2834256],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":85,"address":[2834378,2834309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2834408,2834350,2834452],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[2834517,2834471,2834424],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[2834540,2834487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2891632,2891664,2891744,2891696],"length":1,"stats":{"Line":3},"fn_name":"deserialize\u003cserde::de::value::UnitDeserializer\u003cserde::de::value::Error\u003e\u003e"},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2834608],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":104,"address":[2834635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[2891824],"length":1,"stats":{"Line":0},"fn_name":"visit_i8\u003cserde::de::value::Error\u003e"},{"line":111,"address":[2891843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2891872],"length":1,"stats":{"Line":0},"fn_name":"visit_i16\u003cserde::de::value::Error\u003e"},{"line":117,"address":[2891892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2891920],"length":1,"stats":{"Line":1},"fn_name":"visit_i32\u003cserde::de::value::Error\u003e"},{"line":124,"address":[2891949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[2891984],"length":1,"stats":{"Line":0},"fn_name":"visit_i64\u003cserde::de::value::Error\u003e"},{"line":131,"address":[2892000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2892016],"length":1,"stats":{"Line":0},"fn_name":"visit_u8\u003cserde::de::value::Error\u003e"},{"line":138,"address":[2892035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2892064],"length":1,"stats":{"Line":0},"fn_name":"visit_u16\u003cserde::de::value::Error\u003e"},{"line":145,"address":[2892084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2892112],"length":1,"stats":{"Line":0},"fn_name":"visit_u32\u003cserde::de::value::Error\u003e"},{"line":152,"address":[2892128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[2892144],"length":1,"stats":{"Line":0},"fn_name":"visit_u64\u003cserde::de::value::Error\u003e"},{"line":159,"address":[2892160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2892176],"length":1,"stats":{"Line":1},"fn_name":"visit_str\u003cserde::de::value::Error\u003e"},{"line":166,"address":[2892199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[2892240],"length":1,"stats":{"Line":0},"fn_name":"visit_none\u003cserde::de::value::Error\u003e"},{"line":173,"address":[2892247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2892288],"length":1,"stats":{"Line":0},"fn_name":"visit_some\u003cserde::__private::de::content::ContentDeserializer\u003cserde::de::value::Error\u003e\u003e"},{"line":180,"address":[2892300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2892368],"length":1,"stats":{"Line":1},"fn_name":"visit_unit\u003cserde::de::value::Error\u003e"},{"line":187,"address":[2892375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[2891755,2891680,2891644,2891717],"length":1,"stats":{"Line":3},"fn_name":null},{"line":208,"address":[2815856,2815861],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":210,"address":[2835639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[2835729,2835885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[2835945,2835833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[2836141,2835985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[2836089,2836201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[2836241,2836368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[2836416,2836342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[2836456,2836574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[2836622,2836548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[2836662,2836780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[2836828,2836754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[2836977,2836868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[2836960,2837021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[2837061,2837186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[2837153,2837230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[2837386,2837266,2837417],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":41,"coverable":76},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","raw","inner.rs"],"content":"use crate::{\n    common::{Column, Field, Precision, Timestamp, Ty, Value},\n    util::{Inlinable, InlinableRead, InlinableWrite},\n    BlockExt,\n};\nuse once_cell::unsync::OnceCell;\n\nuse core::slice;\nuse std::{fmt::Debug, mem::size_of, mem::transmute};\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\n#[repr(packed(2))] // use packed(2) because it's int16_t in raw block.\npub struct ColSchema {\n    ty: Ty,\n    len: u32,\n}\n\n#[test]\nfn col_schema() {\n    let col = ColSchema {\n        ty: Ty::BigInt,\n        len: 1,\n    };\n    let bytes: [u8; 6] = unsafe { std::mem::transmute_copy(\u0026col) };\n    dbg!(\u0026bytes);\n\n    let bytes: [u8; 6] = [4, 0, 1, 0, 0, 0];\n    let col2: ColSchema = unsafe { std::mem::transmute_copy(\u0026bytes) };\n    dbg!(col2);\n}\n#[test]\nfn test_bin() {\n    let v: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let ptr = v.as_ptr();\n\n    let v_u16 = unsafe { *transmute::\u003c*const u8, *const u16\u003e(ptr) };\n    println!(\"{v_u16:#x?}: {:?}\", v_u16.to_le_bytes());\n    #[derive(Debug, Clone, Copy)]\n    #[repr(packed)]\n    #[allow(dead_code)]\n    struct A {\n        a: u16,\n        b: u32,\n    }\n    println!(\"A size: {}\", std::mem::size_of::\u003cA\u003e());\n    let a: \u0026A = unsafe { transmute::\u003c*const u8, *const A\u003e(ptr).as_ref().unwrap() };\n    println!(\"{a:#x?}\");\n}\n\n/// Raw data block format (B for bytes):\n///\n/// ```text,ignore\n/// +-----+----------+---------------+-----------+-----------------------+-----------------+\n/// | len | group id | col_schema... | length... | (bitmap or offsets    | col data)   ... |\n/// | 4B  | 8B       | (2+4)B * cols | 4B * cols | (row+7)/8 or 4 * rows | length[col] ... |\n/// +-----+----------+---------------+-----------+-----------------------+-----------------+\n/// ```\n///\n/// The length of bitmap is decided by number of rows of this data block, and the length of each column data is\n/// recorded in the first segment, next to the struct header\n#[derive(Debug)]\npub struct RawBlock {\n    data: *mut u8,\n    len: usize,\n    cap: usize, // usually same to len.\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: OnceCell\u003cVec\u003c(Ty, isize, isize)\u003e\u003e,\n}\n\nimpl Default for RawBlock {\n    fn default() -\u003e Self {\n        Self {\n            data: std::ptr::null_mut(),\n            len: Default::default(),\n            cap: Default::default(),\n            rows: Default::default(),\n            cols: Default::default(),\n            precision: Precision::Millisecond,\n            offsets: Default::default(),\n        }\n    }\n}\n\nimpl Drop for RawBlock {\n    #[inline]\n    fn drop(\u0026mut self) {\n        unsafe { Vec::from_raw_parts(self.data, self.len, self.cap) };\n    }\n}\n\nimpl Inlinable for RawBlock {\n    /// **NOTE**: raw block bytes is not enough to parse data from.\n    /// You must call [with_rows](#method.with_rows)\n    fn read_inlined\u003cR: std::io::Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        let bytes = reader.read_inlined_bytes::\u003c4\u003e()?;\n        Ok(Self::new(bytes))\n    }\n\n    fn write_inlined\u003cW: std::io::Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_inlined_bytes::\u003c4\u003e(self.as_bytes())\n    }\n}\nimpl RawBlock {\n    #[inline]\n    pub fn new(mut vec: Vec\u003cu8\u003e) -\u003e Self {\n        let data = vec.as_mut_ptr();\n        let len = vec.len();\n        let cap = vec.capacity();\n        assert_eq!(len, cap);\n        std::mem::forget(vec);\n        Self {\n            data,\n            len,\n            cap,\n            rows: Default::default(),\n            cols: Default::default(),\n            precision: Precision::Millisecond,\n            offsets: Default::default(),\n        }\n    }\n\n    #[inline]\n    pub fn with_rows(\u0026mut self, rows: usize) -\u003e \u0026mut Self {\n        self.rows = rows;\n        self\n    }\n\n    #[inline]\n    pub fn with_cols(\u0026mut self, cols: usize) -\u003e \u0026mut Self {\n        self.cols = cols;\n        self\n    }\n\n    #[inline]\n    pub fn with_precision(\u0026mut self, precision: Precision) -\u003e \u0026mut Self {\n        self.precision = precision;\n        self\n    }\n\n    #[inline]\n    /// From raw data block.\n    pub unsafe fn from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -\u003e Self {\n        let len = *transmute::\u003c*const u8, *const u32\u003e(data) as usize;\n        let data = std::slice::from_raw_parts(data.offset(4), len).to_vec();\n        Self::from_bytes(data, rows, cols, precision)\n    }\n\n    #[inline]\n    /// Build inner block from bytes.\n    pub fn from_bytes(mut vec: Vec\u003cu8\u003e, rows: usize, cols: usize, precision: Precision) -\u003e Self {\n        let data = vec.as_mut_ptr();\n        let len = vec.len();\n        let cap = vec.capacity();\n        assert_eq!(len, cap);\n        std::mem::forget(vec);\n        Self {\n            data,\n            len,\n            cap,\n            rows,\n            cols,\n            precision,\n            offsets: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    /// The whole block slice length.\n    pub const fn len(\u0026self) -\u003e usize {\n        self.len\n    }\n\n    #[inline]\n    pub const fn nrows(\u0026self) -\u003e usize {\n        self.rows\n    }\n\n    #[inline]\n    pub const fn ncols(\u0026self) -\u003e usize {\n        self.cols\n    }\n\n    #[inline]\n    /// The group id of the raw block.\n    pub const fn group_id(\u0026self) -\u003e u64 {\n        unsafe { *std::mem::transmute::\u003c*const u8, *const u64\u003e(self.as_ptr()) }\n    }\n\n    /// Inner block as bytes slice.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        unsafe { std::slice::from_raw_parts(self.data, self.len) }\n    }\n\n    #[inline]\n    /// Raw data block bytes.\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        self.as_bytes().to_owned()\n    }\n\n    #[inline]\n    /// Raw data into block bytes.\n    pub fn into_vec(self) -\u003e Vec\u003cu8\u003e {\n        unsafe { Vec::from_raw_parts(self.data, self.len, self.cap) }\n    }\n\n    #[inline]\n    /// Pointer to raw block data slice.\n    const fn as_ptr(\u0026self) -\u003e *const u8 {\n        self.data\n    }\n\n    #[inline]\n    /// Offset to column schema start position.\n    const fn schema_offset(\u0026self) -\u003e isize {\n        // 4 = block data length.\n        // 8 = group id.\n        8\n    }\n\n    #[inline]\n    /// Offset to lengths start position.\n    const fn lengths_offset(\u0026self) -\u003e isize {\n        // 6 == size_of::\u003cColumnSchema\u003e()\n        self.schema_offset() + self.cols as isize * 6\n    }\n\n    #[inline]\n    /// Offset to column data start position.\n    const fn data_offset(\u0026self) -\u003e isize {\n        self.lengths_offset() + self.cols as isize * 4\n    }\n\n    /// Pointer to specific offset.\n    const unsafe fn offset(\u0026self, count: isize) -\u003e *const u8 {\n        self.as_ptr().offset(count)\n    }\n\n    /// Length of each bitmap block.\n    const fn bitmap_len(\u0026self) -\u003e usize {\n        (self.rows + 7) / 8\n    }\n\n    /// A lazy-init-ed index to each column.\n    ///\n    /// For each column, the index is a 3-element tuple:\n    ///\n    /// 0. Column data type represented as [Ty]\n    /// 1. Offset to column data start position relative to the block front.\n    ///   - For var-type, it's a `rows` length `i32` vector contains the offsets to each row.\n    ///   - For non-var-type, it's the is-null bitmap.\n    /// 2. Offset to the start position of real column data.\n    fn column_offsets(\u0026self) -\u003e \u0026[(Ty, isize, isize)] {\n        self.offsets.get_or_init(|| {\n            let lengths = self.lengths();\n            let mut data_offset = self.data_offset();\n            self.schemas()\n                .iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    assert!(data_offset \u003c self.len() as isize);\n                    if col.ty.is_var_type() {\n                        let o = (col.ty, data_offset, data_offset + 4 * self.rows as isize);\n                        data_offset = o.2 + lengths[i] as isize;\n                        o\n                    } else {\n                        let o = (\n                            col.ty,\n                            data_offset,\n                            data_offset + self.bitmap_len() as isize,\n                        );\n                        data_offset = o.2 + lengths[i] as isize;\n\n                        assert!(data_offset \u003c self.len() as isize);\n                        o\n                    }\n                })\n                .collect()\n        })\n    }\n\n    /// Column schema extractor.\n    #[inline]\n    pub const fn schemas(\u0026self) -\u003e \u0026[ColSchema] {\n        unsafe {\n            let ptr = self.offset(self.schema_offset());\n            slice::from_raw_parts(ptr as *mut ColSchema, self.cols)\n        }\n    }\n\n    /// Get column data type.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn get_type_of(\u0026self, col: usize) -\u003e Ty {\n        self.get_schema_of(col).ty\n    }\n\n    /// Get column schema which includes data type and bytes length.\n    #[inline]\n    #[rustversion::attr(nightly, const)]\n    pub fn get_schema_of(\u0026self, col: usize) -\u003e \u0026ColSchema {\n        unsafe { self.schemas().get_unchecked(col) }\n    }\n\n    #[inline]\n    /// Lengths for each column raw data.\n    const fn lengths(\u0026self) -\u003e \u0026[i32] {\n        unsafe {\n            let ptr = self.offset(self.lengths_offset());\n            slice::from_raw_parts(ptr as *mut i32, self.cols)\n        }\n    }\n\n    #[inline]\n    /// Get one value at `(row, col)` of the block.\n    pub unsafe fn get_unchecked(\u0026self, row: usize, col: usize) -\u003e Value {\n        let (ty, o1, o2) = self.column_offsets().get_unchecked(col);\n\n        macro_rules! is_null {\n            ($bm:expr, $row:expr) =\u003e {{\n                (*$bm.offset($row as isize \u003e\u003e 3) \u003e\u003e (7 - ($row \u0026 7)) as u8) \u0026 0x1 == 1\n            }};\n        }\n\n        macro_rules! _primitive_value {\n            ($ty:ident, $native:ty) =\u003e {{\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003c$native\u003e()) as isize)\n                        as *const $native);\n                    Value::$ty(v)\n                }\n            }};\n        }\n\n        match ty {\n            Ty::Null =\u003e Value::Null,\n            Ty::Bool =\u003e _primitive_value!(Bool, bool),\n            Ty::TinyInt =\u003e _primitive_value!(TinyInt, i8),\n            Ty::SmallInt =\u003e _primitive_value!(SmallInt, i16),\n            Ty::Int =\u003e _primitive_value!(Int, i32),\n            Ty::BigInt =\u003e _primitive_value!(BigInt, i64),\n            Ty::Float =\u003e _primitive_value!(Float, f32),\n            Ty::Double =\u003e _primitive_value!(Double, f64),\n            Ty::VarChar =\u003e {\n                //\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    Value::VarChar(\n                        std::str::from_utf8_unchecked(slice::from_raw_parts(\n                            ptr.offset(2),\n                            len as usize,\n                        ))\n                        .to_string(),\n                    )\n                }\n            }\n            Ty::Timestamp =\u003e {\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003ci64\u003e()) as isize) as *const i64);\n                    Value::Timestamp(Timestamp::new(v, self.precision))\n                }\n            }\n            Ty::NChar =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n\n                    Value::NChar(\n                        slice::from_raw_parts(ptr.offset(2) as *mut char, len as usize / 4)\n                            .into_iter()\n                            .collect(),\n                    )\n                }\n            }\n            Ty::UTinyInt =\u003e _primitive_value!(UTinyInt, u8),\n            Ty::USmallInt =\u003e _primitive_value!(USmallInt, u16),\n            Ty::UInt =\u003e _primitive_value!(UInt, u32),\n            Ty::UBigInt =\u003e _primitive_value!(UBigInt, u64),\n            Ty::Json =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    debug_assert!(self.len() as isize \u003e= o1 + row as isize * 4 + len as isize);\n                    let chars_len = len / 4;\n                    let chars_ptr = ptr.offset(2) as *mut char;\n                    let chars = slice::from_raw_parts(chars_ptr, chars_len as usize);\n                    let json: String = chars.into_iter().collect();\n\n                    serde_json::from_str(\u0026json)\n                        .ok()\n                        .map(Value::Json)\n                        .unwrap_or(Value::Null)\n                }\n            }\n            ty =\u003e unreachable!(\"unsupported type: {ty}\"),\n        }\n    }\n}\n\n#[test]\nfn inner_block() {\n    use crate::common::Precision::Millisecond;\n    use crate::common::Timestamp::Milliseconds;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let block = unsafe { RawBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    assert_eq!(block.len(), bytes.len() - 4);\n    assert_eq!(block.as_bytes(), \u0026bytes[4..]);\n    assert_eq!(block.group_id(), 0);\n\n    use Value::*;\n    let values = vec![\n        vec![\n            Timestamp(Milliseconds(1655538138610)),\n            Bool(true),\n            Value::TinyInt(-1),\n            SmallInt(-1),\n            Int(-1),\n            BigInt(-1),\n            UTinyInt(1),\n            USmallInt(1),\n            UInt(1),\n            UBigInt(1),\n            Float(0.0),\n            Double(0.0),\n            VarChar(\"abc\".to_string()),\n            NChar(\"\".to_string()),\n        ],\n        {\n            Some(Timestamp(Milliseconds(1655538139610)))\n                .into_iter()\n                .chain(std::iter::repeat(Value::Null).take(14))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        },\n    ];\n    assert!(block.cols == 14);\n\n    for row in 0..rows {\n        for col in 0..block.cols {\n            let v = unsafe { block.get_unchecked(row, col) };\n            assert_eq!(v, values[row][col]);\n        }\n    }\n\n    let inlined = block.inlined();\n    assert!(inlined == bytes);\n}\n","traces":[{"line":20,"address":[3220304],"length":1,"stats":{"Line":3},"fn_name":"col_schema"},{"line":25,"address":[3220352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[3220408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[3220860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[3220916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[3220972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[3221440],"length":1,"stats":{"Line":3},"fn_name":"test_bin"},{"line":34,"address":[3221447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[3221527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[3221570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[3221607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[3221820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[3221930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[3222001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[3208928],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":77,"address":[3208976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[3208986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[3208996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[3209006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[3209023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[2803424],"length":1,"stats":{"Line":1},"fn_name":"drop"},{"line":90,"address":[2803433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2076435,2076336],"length":1,"stats":{"Line":1},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":103,"address":[2076426,2076371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[3209684,3209715,3209136],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":109,"address":[3209249,3209166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[3209257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3209288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[3209314,3209456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[3209396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[3209526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[3209538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3209569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3209728],"length":1,"stats":{"Line":0},"fn_name":"with_rows"},{"line":127,"address":[3209744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[3209760],"length":1,"stats":{"Line":0},"fn_name":"with_cols"},{"line":133,"address":[3209776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3209792],"length":1,"stats":{"Line":0},"fn_name":"with_precision"},{"line":139,"address":[3209807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[3209824],"length":1,"stats":{"Line":2},"fn_name":"from_ptr"},{"line":151,"address":[3209893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[3209994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[3210051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[3210112,3210690,3210659],"length":1,"stats":{"Line":2},"fn_name":"from_bytes"},{"line":159,"address":[3210264,3210181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[3210272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[3210303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[3210329,3210471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3210411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3210548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[3210704],"length":1,"stats":{"Line":1},"fn_name":"len"},{"line":178,"address":[3210709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[3210720],"length":1,"stats":{"Line":1},"fn_name":"nrows"},{"line":183,"address":[3210725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[3210736],"length":1,"stats":{"Line":1},"fn_name":"ncols"},{"line":188,"address":[3210741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[3210752],"length":1,"stats":{"Line":1},"fn_name":"group_id"},{"line":194,"address":[3210761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[3222960],"length":1,"stats":{"Line":1},"fn_name":"as_bytes"},{"line":201,"address":[3222972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[3210816],"length":1,"stats":{"Line":0},"fn_name":"to_vec"},{"line":207,"address":[3210848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[3210896,3210978],"length":1,"stats":{"Line":0},"fn_name":"into_vec"},{"line":213,"address":[3210916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3211024],"length":1,"stats":{"Line":1},"fn_name":"as_ptr"},{"line":219,"address":[3211029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[3211040],"length":1,"stats":{"Line":1},"fn_name":"schema_offset"},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3211056],"length":1,"stats":{"Line":1},"fn_name":"lengths_offset"},{"line":234,"address":[3211070,3211172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[3211216],"length":1,"stats":{"Line":1},"fn_name":"data_offset"},{"line":240,"address":[3211332,3211230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[3211376],"length":1,"stats":{"Line":1},"fn_name":"offset"},{"line":245,"address":[3211395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[3211456],"length":1,"stats":{"Line":1},"fn_name":"bitmap_len"},{"line":250,"address":[3211465,3211499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[3211536],"length":1,"stats":{"Line":1},"fn_name":"column_offsets"},{"line":263,"address":[2076464],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":264,"address":[2076502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[2076538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[2076666,2076553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[2076783,2076629,2076720],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":270,"address":[2076888,2076807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[2076925,2077799,2076874,2077385],"length":1,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[2077016,2077216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[2077387,2077182,2077267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[2077350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[2077495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[2076947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[2076953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[2076964,2077553,2077449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[2077519,2077705,2077604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[2077679,2077744,2077804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[2077764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[3211616],"length":1,"stats":{"Line":1},"fn_name":"schemas"},{"line":295,"address":[3211630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[3211675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[3223008],"length":1,"stats":{"Line":0},"fn_name":"get_type_of"},{"line":304,"address":[3223022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3223056],"length":1,"stats":{"Line":0},"fn_name":"get_schema_of"},{"line":311,"address":[3223075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3211712],"length":1,"stats":{"Line":1},"fn_name":"lengths"},{"line":318,"address":[3211726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[3211771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[3214002,3211808],"length":1,"stats":{"Line":1},"fn_name":"get_unchecked"},{"line":326,"address":[3211890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[3212021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[3212121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3212145,3219680,3219755],"length":1,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[3219378,3212190,3219303],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[3218974,3212235,3218887],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[3212280,3218462,3218549],"length":1,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[3212325,3218034,3218121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[3212370,3217603,3217690],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[3217259,3217172,3212415],"length":1,"stats":{"Line":3},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[3216708,3212452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[3216838,3217159,3216887],"length":1,"stats":{"Line":3},"fn_name":null},{"line":361,"address":[3216884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[3216858,3216908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[3216937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[3217024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[3217020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[3212501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[3216307,3216687,3216220,3216473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[3216470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[3216478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[3216628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[3215750,3212538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[3216207,3215880,3215929],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[3215926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[3215900,3215950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[3215979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[3216062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[3212587,3215317,3215404],"length":1,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[3214976,3212632,3214889],"length":1,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[3214551,3214464,3212677],"length":1,"stats":{"Line":3},"fn_name":null},{"line":402,"address":[3214123,3212722,3214036],"length":1,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[3213002,3212759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[3213132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[3213178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[3213152,3213213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[3213250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[3213269,3213496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[3213534,3213620,3213481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[3213666,3213618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[3213674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[3213732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[3213792,3213875,3213976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[3213952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[2078256,2078261],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":432,"address":[3223143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[3223166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[3223178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[3223190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[3223201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[3223597,3223275,3223338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[3223558,3223917,3223661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[3223886,3223972,3224113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[3225945,3225716,3224082,3224213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[3224674,3224190,3224567,3225392,3224751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[3224271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[3224331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[3224347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[3224363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[3224381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[3224400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[3224420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[3224436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[3224454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[3224473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[3224493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[3224512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[3224532,3224599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[3224639,3224711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[3225849,3225577,3225912],"length":1,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[3225748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[3225756,3225927,3225888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[3226094,3226012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[3226180,3226030,3226296],"length":1,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[3226317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[3226528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[3226756,3226617,3226540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[3226286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[3226878,3226903,3226819],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":140,"coverable":213},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","raw","mod.rs"],"content":"mod inner;\n\nuse std::io::Write;\n\nuse super::{Column, Field, Precision};\n\nuse crate::util::*;\npub use inner::*;\n\nuse bitflags::bitflags;\nuse once_cell::unsync::OnceCell;\n\nbitflags! {\n    #[derive(Default)]\n    #[repr(transparent)]\n    struct Fx: u8 {\n        /// Has database name in the block.\n        const HAS_DB = 0b00000001;\n        /// Has table name in the block\n        const HAS_TB = 0b00000010;\n        /// Has fields data in the block\n        const HAS_FL = 0b00000100;\n        /// Has precision set.\n        const HAS_PC = 0b00001000;\n        /// Precision set as 'ms'(milliseconds).\n        const IS_MS  = 0b00001000;\n        /// Precision set as 'us'(microseconds).\n        const IS_US  = 0b00011000;\n        /// Precision set as 'ns'(nanoseconds).\n        const IS_NS  = 0b00101000;\n    }\n}\n\npub struct Block {\n    database: Option\u003cString\u003e,\n    table: Option\u003cString\u003e,\n    fields: Option\u003cVec\u003cField\u003e\u003e,\n    raw: OnceCell\u003cRawBlock\u003e,\n    columns: OnceCell\u003cVec\u003cColumn\u003e\u003e,\n}\n\nimpl Inlinable for Block {\n    #[inline]\n    fn read_inlined\u003cR: std::io::Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        let flags = Fx::from_bits(reader.read_u8()?).unwrap();\n        let database = if flags.contains(Fx::HAS_DB) {\n            Some(reader.read_inlined_str::\u003c2\u003e()?)\n        } else {\n            None\n        };\n        let table = if flags.contains(Fx::HAS_DB) {\n            Some(reader.read_inlined_str::\u003c2\u003e()?)\n        } else {\n            None\n        };\n        use itertools::Itertools;\n        let fields = if flags.contains(Fx::HAS_FL) {\n            Some(\n                (0..reader.read_u16()?)\n                    .map(|f| reader.read_inlinable::\u003cField\u003e())\n                    .try_collect()?,\n            )\n        } else {\n            None\n        };\n\n        let precision = if flags.contains(Fx::IS_MS) {\n            Precision::Millisecond\n        } else if flags.contains(Fx::IS_US) {\n            Precision::Microsecond\n        } else if flags.contains(Fx::IS_NS) {\n            Precision::Nanosecond\n        } else {\n            Precision::Millisecond\n        };\n\n        let rows = reader.read_u32()?;\n        let cols = reader.read_u32()?;\n\n        let bytes = reader.read_inlined_bytes::\u003c4\u003e()?;\n        let raw = OnceCell::new();\n        raw.try_insert(RawBlock::from_bytes(\n            bytes,\n            rows as usize,\n            cols as usize,\n            precision,\n        ))\n        .unwrap();\n\n        Ok(Self {\n            database,\n            table,\n            fields,\n            raw,\n            columns: OnceCell::new(),\n        })\n    }\n\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        let mut l = wtr.write_u8(self.flags().bits)?;\n\n        if let Some(name) = self.database.as_ref() {\n            l += wtr.write_inlined_bytes::\u003c2\u003e(name.as_bytes())?;\n        }\n        if let Some(name) = self.table.as_ref() {\n            l += wtr.write_inlined_bytes::\u003c2\u003e(name.as_bytes())?;\n        }\n        if let Some(fields) = self.fields.as_ref() {\n            l += wtr.write_len_with_width::\u003c2\u003e(fields.len())?;\n            for field in fields {\n                l += wtr.write_inlinable(field)?;\n            }\n        }\n        let raw = self.as_raw_block();\n        l += wtr.write_len_with_width::\u003c4\u003e(raw.nrows())?;\n        l += wtr.write_len_with_width::\u003c4\u003e(raw.ncols())?;\n        l += wtr.write_inlined_bytes::\u003c4\u003e(raw.as_bytes())?;\n        Ok(l)\n    }\n}\n\nimpl Block {\n    #[inline]\n    pub fn fields(\u0026self) -\u003e \u0026[Field] {\n        const FIELDS: [Field; 0] = [];\n        if let Some(f) = self.fields.as_ref() {\n            \u0026f\n        } else {\n            \u0026FIELDS\n        }\n    }\n\n    #[inline]\n    pub const fn has_database_name(\u0026self) -\u003e bool {\n        self.database.is_some()\n    }\n    #[inline]\n    pub const fn has_table_name(\u0026self) -\u003e bool {\n        self.table.is_some()\n    }\n\n    #[inline]\n    pub fn with_database_name(\u0026mut self, database: \u0026str) -\u003e \u0026mut Self {\n        self.database = Some(database.to_string());\n        self\n    }\n\n    #[inline]\n    pub fn with_table_name(\u0026mut self, table: \u0026str) -\u003e \u0026mut Self {\n        self.table = Some(table.to_string());\n        self\n    }\n\n    #[inline]\n    pub fn with_fields(\u0026mut self, fields: Vec\u003cField\u003e) -\u003e \u0026mut Self {\n        assert!(fields.len() \u003e 0);\n        self.fields = Some(fields);\n        self\n    }\n\n    #[inline]\n    pub fn from_raw_block(data: RawBlock) -\u003e Self {\n        let raw = OnceCell::new();\n        raw.try_insert(data).unwrap();\n        Self {\n            raw,\n            database: None,\n            table: None,\n            fields: None,\n            columns: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    pub fn from_raw_bytes(bytes: Vec\u003cu8\u003e, rows: usize, cols: usize, precision: Precision) -\u003e Self {\n        let data = RawBlock::from_bytes(bytes, rows, cols, precision);\n        Self::from_raw_block(data)\n    }\n\n    #[inline]\n    pub fn push_column(\u0026mut self, column: impl Into\u003cColumn\u003e) -\u003e \u0026mut Self {\n        if let Some(mut v) = self.columns.take() {\n            v.push(column.into());\n            self.columns.try_insert(v).unwrap();\n        } else {\n            let v = vec![column.into()];\n            self.columns.try_insert(v).unwrap();\n        }\n        self\n    }\n\n    #[inline]\n    pub fn as_raw_block(\u0026self) -\u003e \u0026RawBlock {\n        self.raw.get_or_init(|| todo!())\n    }\n\n    #[inline]\n    pub fn to_raw_vec(\u0026self) -\u003e std::io::Result\u003cVec\u003cu8\u003e\u003e {\n        let mut bytes = Vec::new();\n        bytes.write_inlinable(self)?;\n        Ok(bytes)\n    }\n\n    #[inline]\n    pub fn nrows(\u0026self) -\u003e usize {\n        self.as_raw_block().nrows()\n    }\n\n    #[inline]\n    pub fn ncols(\u0026self) -\u003e usize {\n        self.as_raw_block().ncols()\n    }\n\n    fn flags(\u0026self) -\u003e Fx {\n        let mut flags = Fx::default();\n        if self.has_database_name() {\n            flags |= Fx::HAS_DB;\n        }\n        if self.has_table_name() {\n            flags |= Fx::HAS_TB;\n        }\n        if self.fields.is_some() {\n            flags |= Fx::HAS_FL;\n        }\n        flags\n    }\n}\n\n#[test]\nfn inner_block() -\u003e anyhow::Result\u003c()\u003e {\n    use crate::common::Precision::Millisecond;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let raw = unsafe { RawBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    let mut block = Block::from_raw_block(raw);\n    block.with_database_name(\"abc\").with_table_name(\"n1\");\n\n    let a = block.printable_inlined();\n\n    let inlined = block.inlined();\n\n    anyhow::ensure!(\n        \u0026inlined[0..18] == b\"\\x03\\x03\\x00abc\\x02\\x00n1\\x02\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\"\n    );\n    assert!(\u0026inlined[18..] == bytes);\n\n    let block = Block::read_inlined(inlined.as_slice())?;\n    let b = block.printable_inlined();\n\n    assert_eq!(a, b);\n    Ok(())\n}\n","traces":[{"line":13,"address":[1929277,1928893,1929213,1928957,1929021,1929085,1929149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[1925086,1925072],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":44,"address":[2707655,2707821,2704464],"length":1,"stats":{"Line":1},"fn_name":"read_inlined\u003c\u0026[u8]\u003e"},{"line":45,"address":[2704585,2704708,2704491],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[2704753,2704791,2704998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2704809,2705005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2704774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2705169,2705391,2705143,2705087],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[2705398,2705187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2705149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[2705576,2706018,2705550,2705494],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[2705594,2705814,2705690,2705791,2706041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2707864,2705682,2707840],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c\u0026[u8]\u003e"},{"line":61,"address":[2706025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2705556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[2706127,2706183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2706210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[2706245,2706199,2706283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2706272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[2706319,2706289,2706261,2706306],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[2706308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2706295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[2706412,2706337,2706234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2706505,2706400,2706580],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2706568,2706658,2706779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2706764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2706911,2707063,2706991],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[2706919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[2706959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[2706963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2706967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[2707349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[2707092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[2707126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2707166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[2707206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[2707302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[2707888,2710428],"length":1,"stats":{"Line":1},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":101,"address":[2707946,2707994,2708125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[2708201,2708524,2708098],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[2708529,2708340,2708516,2708251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[2708282,2708888,2708569],"length":1,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[2708880,2708704,2708619,2708893],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2708650,2708934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2708989,2709220,2709245,2709045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2709288,2709228,2709576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[2709398,2709581,2709568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2709619,2709009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[2709627,2709855,2709835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2710084,2709909,2709843,2710109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[2710092,2710168,2710366,2710395],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[2710374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[1922608],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":127,"address":[1922740,1922617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[1922664,1922730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[1922685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1922752],"length":1,"stats":{"Line":1},"fn_name":"has_database_name"},{"line":136,"address":[1922761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[1922800],"length":1,"stats":{"Line":1},"fn_name":"has_table_name"},{"line":140,"address":[1922809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[1922940,1922848],"length":1,"stats":{"Line":1},"fn_name":"with_database_name"},{"line":145,"address":[1922973,1922872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[1923008,1923105],"length":1,"stats":{"Line":1},"fn_name":"with_table_name"},{"line":151,"address":[1923032,1923138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[1923471,1923184,1923495],"length":1,"stats":{"Line":0},"fn_name":"with_fields"},{"line":157,"address":[1923273,1923224,1923349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[1923386,1923296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[1923214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[1924153,1924235,1923520],"length":1,"stats":{"Line":1},"fn_name":"from_raw_block"},{"line":164,"address":[1923542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[1923624,1923765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[1923901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[1924272],"length":1,"stats":{"Line":0},"fn_name":"from_raw_bytes"},{"line":177,"address":[1924313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[1924354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[1924416],"length":1,"stats":{"Line":1},"fn_name":"as_raw_block"},{"line":195,"address":[1924425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1924756,1924464],"length":1,"stats":{"Line":0},"fn_name":"to_raw_vec"},{"line":200,"address":[1924491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[1924688,1924562,1924517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[1924617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[1924800],"length":1,"stats":{"Line":0},"fn_name":"nrows"},{"line":207,"address":[1924809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[1924848],"length":1,"stats":{"Line":0},"fn_name":"ncols"},{"line":212,"address":[1924857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[1924896],"length":1,"stats":{"Line":1},"fn_name":"flags"},{"line":216,"address":[1924910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[1924924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[1924959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[1924948,1924980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1925006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[1924991,1925027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[1925042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1929328,1930779,1930861],"length":1,"stats":{"Line":3},"fn_name":"inner_block"},{"line":233,"address":[1929335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[1929350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[1929362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[1929374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[1929385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[1929451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[1929498,1929581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[1929616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[1929639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[1929714,1929822,1929994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[1929690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1929938,1930189,1930111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[1930386,1930239,1930172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[1930376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[1930732,1930686,1930562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[1930692],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":78,"coverable":119},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","timestamp.rs"],"content":"use std::fmt::{self, Debug, Display};\n\nuse serde::{Deserialize, Serialize};\n\nuse super::Precision;\n\n#[derive(Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\npub enum Timestamp {\n    Milliseconds(i64),\n    Microseconds(i64),\n    Nanoseconds(i64),\n}\n\nimpl Debug for Timestamp {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        if f.alternate() {\n            match self {\n                Self::Milliseconds(arg0) =\u003e f.debug_tuple(\"Milliseconds\").field(arg0).finish(),\n                Self::Microseconds(arg0) =\u003e f.debug_tuple(\"Microseconds\").field(arg0).finish(),\n                Self::Nanoseconds(arg0) =\u003e f.debug_tuple(\"Nanoseconds\").field(arg0).finish(),\n            }\n        } else {\n            Debug::fmt(\u0026self.to_naive_datetime(), f)\n        }\n    }\n}\n\nimpl Display for Timestamp {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        Display::fmt(\u0026self.to_naive_datetime(), f)\n    }\n}\n\nimpl Timestamp {\n    pub fn new(raw: i64, precision: Precision) -\u003e Self {\n        match precision {\n            Precision::Millisecond =\u003e Timestamp::Milliseconds(raw),\n            Precision::Microsecond =\u003e Timestamp::Microseconds(raw),\n            Precision::Nanosecond =\u003e Timestamp::Nanoseconds(raw),\n        }\n    }\n    pub fn as_raw_i64(\u0026self) -\u003e i64 {\n        match self {\n            Timestamp::Milliseconds(raw)\n            | Timestamp::Microseconds(raw)\n            | Timestamp::Nanoseconds(raw) =\u003e *raw,\n        }\n    }\n    pub fn to_naive_datetime(\u0026self) -\u003e chrono::NaiveDateTime {\n        let duration = match self {\n            Timestamp::Milliseconds(raw) =\u003e chrono::Duration::milliseconds(*raw),\n            Timestamp::Microseconds(raw) =\u003e chrono::Duration::microseconds(*raw),\n            Timestamp::Nanoseconds(raw) =\u003e chrono::Duration::nanoseconds(*raw),\n        };\n        chrono::NaiveDateTime::from_timestamp(0, 0)\n            .checked_add_signed(duration)\n            .unwrap()\n    }\n\n    // todo: support to tz.\n    pub fn to_datetime_with_tz(\u0026self) {}\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ts_new() {\n        use Precision::*;\n        for prec in [Millisecond, Microsecond, Nanosecond] {\n            let ts = Timestamp::new(0, prec);\n            assert!(ts.as_raw_i64() == 0);\n            assert!(ts.to_naive_datetime() == chrono::NaiveDateTime::from_timestamp(0, 0));\n        }\n    }\n\n    #[test]\n    fn ts_debug() {\n        let ts = Timestamp::new(0, Precision::Millisecond);\n        assert_eq!(format!(\"{:?}\", ts), \"1970-01-01T00:00:00\");\n        assert_eq!(format!(\"{:#?}\", ts), \"Milliseconds(\\n    0,\\n)\");\n        assert_eq!(format!(\"{}\", ts), \"1970-01-01 00:00:00\");\n    }\n}\n","traces":[{"line":15,"address":[2699936],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":16,"address":[8227662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[2700030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[2700072,2700339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[2700292,2700127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[2700179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[2700007,2700384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[2700416],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":30,"address":[2700441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2700496],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":36,"address":[2700513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2700546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[2700566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[2700586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2700624],"length":1,"stats":{"Line":1},"fn_name":"as_raw_i64"},{"line":43,"address":[2700637,2700682,2700697],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[2700703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[2700736],"length":1,"stats":{"Line":1},"fn_name":"to_naive_datetime"},{"line":50,"address":[2700760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2700797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2700834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2700871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2700926,2700901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[2700917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[2700981,2700976],"length":1,"stats":{"Line":0},"fn_name":"to_datetime_with_tz"},{"line":69,"address":[2458272,2458733],"length":1,"stats":{"Line":3},"fn_name":"ts_new"},{"line":71,"address":[2458279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[2458506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2458610,2458557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2458654,2458603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2458768,2459170],"length":1,"stats":{"Line":3},"fn_name":"ts_debug"},{"line":80,"address":[2458775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[2458818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2459196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2459571],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":35},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","ty.rs"],"content":"use std::{\n    fmt::{self, Display},\n    str::FromStr,\n};\n\nuse serde::de::Visitor;\n\n// todo: useful?\n// pub const TY_NULL: Ty = Ty::Null; // 1 bytes\n// pub const TY_BOOL: Ty = Ty::Bool; // 1 bytes\n// pub const TY_TINY_INT: Ty = Ty::TinyInt; // 1 byte\n// pub const TY_SMALL_INT: Ty = Ty::SmallInt; // 2 bytes\n// pub const TY_INT: Ty = Ty::Int; // 4 bytes\n// pub const TY_BIGINT: Ty = Ty::BigInt; // 8 bytes\n// pub const TY_FLOAT: Ty = Ty::Float; // 4 bytes\n// pub const TY_DOUBLE: Ty = Ty::Double; // 8 bytes\n// pub const TY_BINARY: Ty = Ty::VarChar; // string, alias for varchar\n// pub const TY_TIMESTAMP: Ty = Ty::Timestamp; // 8 bytes\n// pub const TY_NCHAR: Ty = Ty::NChar; // unicode string\n// pub const TY_U_TINY_INT: Ty = Ty::UTinyInt; // 1 byte\n// pub const TY_U_SMALL_INT: Ty = Ty::USmallInt; // 2 bytes\n// pub const TY_UINT: Ty = Ty::UInt; // 4 bytes\n// pub const TY_UBIGINT: Ty = Ty::UBigInt; // 8 bytes\n// pub const TY_JSON: Ty = Ty::Json; // json\n// pub const TY_VARCHAR: Ty = Ty::VarChar; // string\n// pub const TY_VAR_BINARY: Ty = Ty::VarBinary; // binary\n// pub const TY_DECIMAL: Ty = Ty::Decimal; // decimal\n// pub const TY_BLOB: Ty = Ty::Blob; // binary\n// pub const TY_MEDIUM_BLOB: Ty = Ty::MediumBlob; // binary\n\n/// TDengine data type enumeration.\n///\n/// | enum       | int | sql name         | rust type |\n/// | ----       |:---:| --------         |:---------:|\n/// | Null       | 0   | NULL             | None      |\n/// | Bool       | 1   | BOOL             | bool      |\n/// | TinyInt    | 2   | TINYINT          | i8        |\n/// | SmallInt   | 3   | SMALLINT         | i16       |\n/// | Int        | 4   | INT              | i32       |\n/// | BitInt     | 5   | BIGINT           | i64       |\n/// | Float      | 6   | FLOAT            | f32       |\n/// | Double     | 7   | DOUBLE           | f64       |\n/// | VarChar    | 8   | BINARY/VARCHAR   | str/String        |\n/// | Timestamp  | 9   | TIMESTAMP        | i64               |\n/// | NChar      | 10  | NCHAR            | str/String        |\n/// | UTinyInt   | 11  | TINYINT UNSIGNED | u8                |\n/// | USmallInt  | 12  | SMALLINT UNSIGNED| u16               |\n/// | UInt       | 13  | INT UNSIGNED     | u32               |\n/// | UBigInt    | 14  | BIGINT UNSIGNED  | u64               |\n/// | Json       | 15  | JSON             | serde_json::Value |\n/// | VarBinary  | 16  | VARBINARY        | Vec\u003cu8\u003e           |\n/// | Decimal    | 17  | DECIMAL          | ?                 |\n/// | Blob       | 18  | BLOB             | ?                 |\n/// | MediumBlob | 19  | MEDIUMBLOB       | ?                 |\n///\n/// Note:\n/// - VarChar sql name is BINARY in v2, and VARCHAR in v3.\n/// - Decimal/Blob/MediumBlob is not supported in 2.0/3.0 .\n#[derive(Debug, Clone, Copy, PartialEq, Eq, serde_repr::Serialize_repr)]\n#[repr(u8)]\n#[non_exhaustive]\npub enum Ty {\n    /// 0: Null is only a value, not a *real* type, a nullable data type could be represented as [Option\u003cT\u003e] in Rust.\n    Null = 0,\n    /// 1: Bool, `bool` type in sql, will be represented as [bool] in Rust.\n    Bool, // 1\n    /// 2: TinyInt, `tinyint` type in sql, will be represented in Rust as [i8].\n    TinyInt, // 2\n    /// 3: SmallInt, `smallint` type in sql, will be represented in Rust as [i16].\n    SmallInt, // 3\n    /// 4: Int, `int` type in sql, will be represented in Rust as [i32].\n    Int, // 4\n    /// 5: BigInt, `bigint` type in sql, will be represented in Rust as [i64].\n    BigInt, // 5\n    /// 6: Float, `float` type in sql, will be represented in Rust as [f32].\n    Float, // 6\n    /// 7: Double, `tinyint` type in sql, will be represented in Rust as [f64].\n    Double, // 7\n    /// 8: VarChar, `binary` type in sql for TDengine 2.x, `varchar` for TDengine 3.x,\n    ///  will be represented in Rust as [\u0026str] or [String]. This type of data be deserialized to [Vec\u003cu8\u003e].\n    VarChar,\n    /// 9: Timestamp, `timestamp` type in sql, will be represented as [i64] in Rust.\n    /// But can be deserialized to [chrono::naive::NaiveDateTime] or [String].\n    Timestamp, // 9\n    /// 10: NChar, `nchar` type in sql, the recommended way in TDengine to store utf-8 [String].\n    NChar, // 10\n    /// 11: UTinyInt, `tinyint unsigned` in sql, [u8] in Rust.\n    UTinyInt, // 11\n    /// 12: USmallInt, `smallint unsigned` in sql, [u16] in Rust.\n    USmallInt, // 12\n    /// 13: UInt, `int unsigned` in sql, [u32] in Rust.\n    UInt, // 13\n    /// 14: UBigInt, `bigint unsigned` in sql, [u64] in Rust.\n    UBigInt, // 14\n    /// 15: Json, `json` tag in sql, will be represented as [serde_json::value::Value] in Rust.\n    Json, // 15\n    /// 16, VarBinary, `varbinary` in sql, [Vec\u003cu8\u003e] in Rust, which is supported since TDengine 3.0.\n    VarBinary, // 16\n    /// 17, Not supported now.\n    Decimal, // 17\n    /// 18, Not supported now.\n    Blob, // 18\n    /// 19, Not supported now.\n    MediumBlob, // 19\n}\n\nimpl\u003c'de\u003e serde::Deserialize\u003c'de\u003e for Ty {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: serde::Deserializer\u003c'de\u003e,\n    {\n        struct TyVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for TyVisitor {\n            type Value = Ty;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"invalid TDengine type\")\n            }\n            fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v as u8))\n            }\n\n            fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v))\n            }\n\n            fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::from_u8(v as u8))\n            }\n\n            fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ty::from_str(v).map_err(\u003cE as serde::de::Error\u003e::custom)\n            }\n\n            fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::Null)\n            }\n\n            fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n            where\n                D: serde::Deserializer\u003c'de\u003e,\n            {\n                deserializer.deserialize_any(self)\n            }\n\n            fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n            where\n                E: serde::de::Error,\n            {\n                Ok(Ty::Null)\n            }\n        }\n\n        deserializer.deserialize_any(TyVisitor)\n    }\n}\n\n// todo: decimal/blob\nimpl FromStr for Ty {\n    type Err = \u0026'static str;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"timestamp\" =\u003e Ok(Ty::Timestamp),\n            \"bool\" =\u003e Ok(Ty::Bool),\n            \"tinyint\" =\u003e Ok(Ty::TinyInt),\n            \"smallint\" =\u003e Ok(Ty::SmallInt),\n            \"int\" =\u003e Ok(Ty::Int),\n            \"bigint\" =\u003e Ok(Ty::BigInt),\n            \"tinyint unsigned\" =\u003e Ok(Ty::UTinyInt),\n            \"smallint unsigned\" =\u003e Ok(Ty::USmallInt),\n            \"int unsigned\" =\u003e Ok(Ty::UInt),\n            \"bigint unsigned\" =\u003e Ok(Ty::UBigInt),\n            \"float\" =\u003e Ok(Ty::Float),\n            \"double\" =\u003e Ok(Ty::Double),\n            \"binary\" | \"varchar\" =\u003e Ok(Ty::VarChar),\n            \"nchar\" =\u003e Ok(Ty::NChar),\n            \"json\" =\u003e Ok(Ty::Json),\n            \"varbinary\" =\u003e Ok(Ty::VarBinary),\n            \"decimal\" =\u003e Ok(Ty::Decimal),\n            \"blob\" =\u003e Ok(Ty::Blob),\n            \"mediumblob\" =\u003e Ok(Ty::MediumBlob),\n            _ =\u003e Err(\"not a valid data type string\"),\n        }\n    }\n}\n\nimpl Ty {\n    /// Check if the data type is null or not.\n    pub const fn is_null(\u0026self) -\u003e bool {\n        matches!(self, Ty::Null)\n    }\n\n    /// Var type which is one of [Ty::VarChar], [Ty::VarBinary] or [Ty::NChar].\n    pub const fn is_var_type(\u0026self) -\u003e bool {\n        use Ty::*;\n        matches!(self, VarChar | VarBinary | NChar)\n    }\n\n    pub const fn is_primitive(\u0026self) -\u003e bool {\n        use Ty::*;\n        matches!(\n            self,\n            Bool | TinyInt\n                | SmallInt\n                | Int\n                | BigInt\n                | UTinyInt\n                | USmallInt\n                | UInt\n                | UBigInt\n                | Float\n                | Double\n                | Decimal\n        )\n    }\n\n    /// Fixed length if the type is primitive.\n    pub const fn fixed_length(\u0026self) -\u003e usize {\n        use Ty::*;\n        match self {\n            Bool =\u003e 1,\n            TinyInt =\u003e 1,\n            SmallInt =\u003e 2,\n            Int =\u003e 4,\n            BigInt =\u003e 8,\n            Float =\u003e 4,\n            Double =\u003e 8,\n            Timestamp =\u003e 8,\n            UTinyInt =\u003e 1,\n            USmallInt =\u003e 2,\n            UInt =\u003e 4,\n            UBigInt =\u003e 8,\n            Decimal =\u003e 16,\n            _ =\u003e panic!(\"not a fixed length type\"),\n        }\n    }\n\n    /// The sql name of type.\n    pub const fn name(\u0026self) -\u003e \u0026'static str {\n        use Ty::*;\n        match self {\n            Null =\u003e \"NULL\",\n            Bool =\u003e \"BOOL\",\n            TinyInt =\u003e \"TINYINT\",\n            SmallInt =\u003e \"SMALLINT\",\n            Int =\u003e \"INT\",\n            BigInt =\u003e \"BIGINT\",\n            Float =\u003e \"FLOAT\",\n            Double =\u003e \"DOUBLE\",\n            VarChar =\u003e \"BINARY\",\n            Timestamp =\u003e \"TIMESTAMP\",\n            NChar =\u003e \"NCHAR\",\n            UTinyInt =\u003e \"TINYINT UNSIGNED\",\n            USmallInt =\u003e \"SMALLINT UNSIGNED\",\n            UInt =\u003e \"INT UNSIGNED\",\n            UBigInt =\u003e \"BIGINT UNSIGNED\",\n            Json =\u003e \"JSON\",\n            VarBinary =\u003e \"VARBINARY\",\n            Decimal =\u003e \"DECIMAL\",\n            Blob =\u003e \"BLOB\",\n            MediumBlob =\u003e \"MEDIUMBLOB\",\n        }\n    }\n\n    /// The enum constants directly to str.\n    pub const fn as_variant_str(\u0026self) -\u003e \u0026'static str {\n        use Ty::*;\n        macro_rules! _var_str {\n          ($($v:ident) *) =\u003e {\n              match self {\n                $($v =\u003e stringify!($v),) *\n              }\n          }\n        }\n        return _var_str!(\n            Null Bool TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt\n            Float Double VarChar NChar Timestamp Json VarBinary Decimal Blob MediumBlob\n        );\n    }\n\n    pub fn from_u8(v: u8) -\u003e Self {\n        use Ty::*;\n        match v {\n            0 =\u003e Null,\n            1 =\u003e Bool,\n            2 =\u003e TinyInt,\n            3 =\u003e SmallInt,\n            4 =\u003e Int,\n            5 =\u003e BigInt,\n            6 =\u003e Float,\n            7 =\u003e Double,\n            8 =\u003e VarChar,\n            9 =\u003e Timestamp,\n            10 =\u003e NChar,\n            11 =\u003e UTinyInt,\n            12 =\u003e USmallInt,\n            13 =\u003e UInt,\n            14 =\u003e UBigInt,\n            15 =\u003e Json,\n            16 =\u003e VarBinary,\n            17 =\u003e Decimal,\n            18 =\u003e Blob,\n            19 =\u003e MediumBlob,\n            _ =\u003e unreachable!(\"unknown data type\"),\n        }\n    }\n}\nimpl From\u003cu8\u003e for Ty {\n    fn from(v: u8) -\u003e Self {\n        unsafe { std::mem::transmute(v) }\n    }\n}\n\nimpl Display for Ty {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.name())\n    }\n}\nmacro_rules! _impl_from_primitive {\n    ($($ty:ty) *) =\u003e {\n      $(\n         impl From\u003c$ty\u003e for Ty {\n           fn from(v: $ty) -\u003e Self {\n             Self::from_u8(v as _)\n           }\n         }\n      )*\n    }\n}\n\n_impl_from_primitive!(i8 i16 i32 i64 u16 u32 u64);\n","traces":[{"line":108,"address":[2638848,2638816],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003c\u0026mut serde_json::de::Deserializer\u003cserde_json::read::StrRead\u003e\u003e"},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[2280560],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":118,"address":[2280587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2638976,2638912],"length":1,"stats":{"Line":0},"fn_name":"visit_i64\u003cserde::de::value::Error\u003e"},{"line":124,"address":[2638930,2638994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[2639040],"length":1,"stats":{"Line":0},"fn_name":"visit_u8\u003cserde::de::value::Error\u003e"},{"line":131,"address":[2639061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2639168,2639104],"length":1,"stats":{"Line":1},"fn_name":"visit_u64\u003cserde_json::error::Error\u003e"},{"line":138,"address":[2639122,2639186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[2639232,2639296],"length":1,"stats":{"Line":0},"fn_name":"visit_str\u003cserde::de::value::Error\u003e"},{"line":145,"address":[2639256,2639320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2639360],"length":1,"stats":{"Line":0},"fn_name":"visit_none\u003cserde::de::value::Error\u003e"},{"line":152,"address":[2639367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[2639392],"length":1,"stats":{"Line":0},"fn_name":"visit_unit\u003cserde_json::error::Error\u003e"},{"line":166,"address":[2639399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2638833,2638861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[2280624,2281912],"length":1,"stats":{"Line":0},"fn_name":"from_str"},{"line":178,"address":[2280651,2280732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2280819,2280748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[2280791,2280890,2280846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2280903,2280862,2280947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2280963,2280919,2281007],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2281023,2280979,2281067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2281083,2281039,2281127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2281143,2281187,2281099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2281159,2281203,2281247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2281219,2281263,2281307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[2281279,2281367,2281323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2281339,2281383,2281427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[2281399,2281487,2281443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[2281503,2281459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[2281650,2281579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[2281710,2281622,2281666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2281770,2281726,2281682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2281742,2281830,2281786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2281846,2281802,2281890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2281862,2281972,2281906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[2281940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[2282000],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":206,"address":[2282009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2282048],"length":1,"stats":{"Line":1},"fn_name":"is_var_type"},{"line":212,"address":[2282057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[2282128],"length":1,"stats":{"Line":0},"fn_name":"is_primitive"},{"line":217,"address":[2282143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[2282137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2282208],"length":1,"stats":{"Line":0},"fn_name":"fixed_length"},{"line":236,"address":[2282217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[2282291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[2282305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[2282319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[2282333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[2282344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[2282355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[2282366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2282377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[2282388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[2282399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2282410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[2282421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[2282432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[2282252,2282443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2282480],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":257,"address":[2282489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[2282518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[2282544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2282570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[2282596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[2282622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2282648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[2282674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[2282700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[2282726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[2282752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2282778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[2282804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[2282830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[2282856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[2282882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2282905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[2282928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[2282951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[2282974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[2282997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[2283040],"length":1,"stats":{"Line":1},"fn_name":"as_variant_str"},{"line":291,"address":[2283049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[2283600],"length":1,"stats":{"Line":1},"fn_name":"from_u8"},{"line":299,"address":[2283617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[2283689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[2283699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[2283709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[2283719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[2283729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[2283739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[2283749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[2283759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[2283769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[2283779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[2283789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[2283799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[2283809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[2283819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[2283829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[2283839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[2283846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[2283853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[2283860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[2283867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[2283984],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":326,"address":[2283995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[2284016],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":332,"address":[2284038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[2285200,2285232,2285056,2285088,2285168,2285120,2285024],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":340,"address":[2285065,2285205,2285129,2285241,2285032,2285093,2285177],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":117},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","borrowed.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl\u003c'b, 'de: 'b\u003e serde::de::EnumAccess\u003c'de\u003e for BorrowedValue\u003c'b\u003e {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let d = self.strict_as_str().into_deserializer();\n        seed.deserialize(d).map(|v| (v, UnitOnly))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer\u003c'b\u003e {\n    value: BorrowedValue\u003c'b\u003e,\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer\u003c'b\u003e {\n    value: BorrowedValue\u003c'b\u003e,\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumValueDeserializer\u003c'b\u003e {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        return seed\n            .deserialize(self.value.ty().as_variant_str().into_deserializer())\n            .map(|v| (v, self));\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e de::VariantAccess\u003c'de\u003e for EnumValueDeserializer\u003c'b\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nimpl\u003c'b, 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumTimestampDeserializer\u003c'b\u003e {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n\n        match \u0026self.value {\n            BorrowedValue::Timestamp(Timestamp::Microseconds(v)) =\u003e Ok((\n                seed.deserialize(\"Microseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            BorrowedValue::Timestamp(Timestamp::Milliseconds(v)) =\u003e Ok((\n                seed.deserialize(\"Milliseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            BorrowedValue::Timestamp(Timestamp::Nanoseconds(v)) =\u003e Ok((\n                seed.deserialize(\"Nanoseconds\".into_deserializer())?,\n                VariantTimestampDeserializer { value: *v },\n            )),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::Deserializer\u003c'de\u003e for BorrowedValue\u003c'de\u003e {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use BorrowedValue::*;\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            VarChar(v) =\u003e visitor.visit_borrowed_str(v),\n            NChar(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e visitor.visit_borrowed_str(v),\n                Cow::Owned(v) =\u003e visitor.visit_string(v),\n            },\n            Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_any(visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_any(visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e visitor.visit_borrowed_bytes(v),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple identifier ignored_any\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str: {self:?}\");\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e visitor.visit_borrowed_str(\"\"), // todo: empty string or error?\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e std::str::from_utf8(v)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                    .and_then(|s| visitor.visit_borrowed_str(s)),\n                Cow::Owned(v) =\u003e String::from_utf8(v)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                    .and_then(|s| visitor.visit_string(s)),\n            },\n            VarChar(v) =\u003e visitor.visit_borrowed_str(v),\n            NChar(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e visitor.visit_borrowed_str(v),\n                Cow::Owned(v) =\u003e visitor.visit_str(\u0026v),\n            },\n            Timestamp(v) =\u003e visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"unsupported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use BorrowedValue::*;\n        macro_rules! _v_ {\n            ($v:expr) =\u003e {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e _v_!(v),\n            TinyInt(v) =\u003e _v_!(v),\n            SmallInt(v) =\u003e _v_!(v),\n            Int(v) =\u003e _v_!(v),\n            BigInt(v) =\u003e _v_!(v),\n            UTinyInt(v) =\u003e _v_!(v),\n            USmallInt(v) =\u003e _v_!(v),\n            UInt(v) =\u003e _v_!(v),\n            UBigInt(v) =\u003e _v_!(v),\n            Float(v) =\u003e _v_!(v),\n            Double(v) =\u003e _v_!(v),\n            VarChar(v) =\u003e _v_!(v),\n            NChar(v) =\u003e _v_!(v),\n            Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_newtype_struct(_name, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_newtype_struct(_name, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e visitor.visit_borrowed_bytes(v),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Vec::\u003cu8\u003e::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) =\u003e v.to_vec().into_deserializer().deserialize_seq(visitor),\n            Timestamp(_) =\u003e todo!(),\n            VarChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            NChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.to_vec().into_deserializer().deserialize_seq(visitor)\n            }\n            _ =\u003e todo!(),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize enum with name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" \u0026\u0026 variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" \u0026\u0026 variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            BorrowedValue::Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_struct(name, fields, visitor)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_struct(name, fields, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            BorrowedValue::Json(v) =\u003e match v {\n                Cow::Borrowed(v) =\u003e serde_json::Deserializer::from_slice(v)\n                    .deserialize_tuple_struct(name, len, visitor)\n                    .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n                Cow::Owned(v) =\u003e serde_json::from_slice::\u003cserde_json::Value\u003e(\u0026v)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom)?\n                    .into_deserializer()\n                    .deserialize_tuple_struct(name, len, visitor)\n                    .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            },\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl\u003c'de\u003e serde::de::IntoDeserializer\u003c'de, Error\u003e for BorrowedValue\u003c'de\u003e {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn de_value_as_inner() {\n        use BorrowedValue::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) =\u003e {\n                $(\n                    {\n                        let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option\u003cu8\u003e, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\"), String, \"\".to_string()\n            NChar(\"\".into()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(\u0026[0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            Blob(\u0026[0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            MediumBlob(\u0026[0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_borrowed_str() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            Json(json!({ \"name\": \"abc\"}).to_string().into_bytes().into()), is_err\n            Json(json!(1).to_string().into_bytes().into()), is_err\n            Json(json!(null).to_string().into_bytes().into()), is_err\n            Json(json!(\"abc\").to_string().into_bytes().into()), is_err\n            Timestamp(crate::Timestamp::Milliseconds(0)), is_err\n            ;\n            Null, \"\"\n            VarChar(\"String\"), \"String\"\n            VarChar(\"\"), \"\"\n        };\n    }\n    #[test]\n    fn de_string() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(String::deserialize(($v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(String::deserialize(($v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $tv:expr) *) =\u003e {\n                $(_de_str!($v, $tv);)*\n            };\n            ($($v2:expr, is_err) *; $($v:expr, $tv:expr) * ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\"), \"String\"\n            VarChar(\"\"), \"\"\n            Json(json!(\"abc\").to_string().into_bytes().into()), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"}).to_string().into_bytes().into()), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1).to_string().into_bytes().into()), json!(1).to_string()\n            Json(json!(null).to_string().into_bytes().into()), json!(null).to_string()\n        };\n    }\n\n    #[test]\n    fn de_json() {\n        use serde_json::json;\n        use BorrowedValue::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize(\n                    Json($v.to_string().into_bytes().into()).into_deserializer(),\n                )\n                .expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(json!(\"string\"), String, json!(\"string\").to_string());\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_json!(json!(\"string\"), JsonStr, JsonStr(\"string\".to_string()));\n    }\n\n    #[test]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use BorrowedValue::*;\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\").to_string().into_bytes().into()),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi\u003cT\u003e(T);\n        _de_ty!(\n            Json(json!(1).to_string().into_bytes().into()),\n            Primi\u003ci32\u003e,\n            Primi(1)\n        );\n        _de_ty!(TinyInt(1), Primi\u003ci8\u003e, Primi(1));\n        _de_ty!(SmallInt(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(Int(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(BigInt(1), Primi\u003ci64\u003e, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) =\u003e {\n                println!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::\u003c$ty\u003e()\n                );\n                _de_ty!($v($inner), Primi\u003c$ty\u003e, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) =\u003e {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) =\u003e {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () =\u003e {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[2952592,2952792],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":17,"address":[2952622,2952688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[2641200,2641211],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":37,"address":[2641232,2641583,2641556],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":41,"address":[2641262,2641415,2641500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2641294,2641445,2641519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[2641600,2641453,2641624],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":50,"address":[2074704],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":51,"address":[2074708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[2641680],"length":1,"stats":{"Line":0},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003ci64\u003e\u003e"},{"line":58,"address":[2641694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2643081,2641744],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":92,"address":[2641766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[2642640,2642020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2642481,2642690,2642037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[2642629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2642927,2641946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[2641963,2642989,2642768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[2642916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2642317,2642094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[2642376,2642110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[2642306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2960992,2983808,2954868,2983653,2960310,2991223,2970080,2958272,2969398,2972084,2989184,2988504,2972768,2983100,2978240,2960844,2955552,2980316,2978090,2958126,2991757,2980869,2969928,2952832,2986496,2963680,2981024,2963526,2994441,2993911,2957592,2975397,2977560,2966124,2989034,2974844,2962996,2967392,2986345,2991904,2985815,2972614,2955402,2975552,2967221],"length":1,"stats":{"Line":10},"fn_name":"deserialize_any\u003cserde::de::impls::{impl#53}::deserialize::PrimitiveVisitor\u003e"},{"line":117,"address":[2986852,2972935,2961014,2975574,2961241,2955719,2967641,2970102,2978407,2989206,2953081,2981380,2992071,2989351,2983830,2978262,2970329,2967414,2975908,2955908,2967748,2970436,2961159,2984057,2992153,2963937,2983975,2973124,2952854,2978489,2955574,2991926,2964062,2963840,2967559,2975801,2958521,2986663,2984164,2986745,2986518,2953188,2958628,2952999,2961348,2981273,2973017,2989540,2981046,2989433,2970247,2992260,2978596,2975719,2958294,2963695,2958439,2955801,2981191,2972790],"length":1,"stats":{"Line":30},"fn_name":null},{"line":120,"address":[2968712,2987847,2993255,2981336,2961304,2985159,2978552,2974140,2970392,2964009,2989496,2954215,2956873,2979612,2976872,2956935,2965293,2975864,2959655,2967704,2962312,2982396,2959593,2968681,2979581,2986808,2976841,2993193,2959624,2982427,2985128,2962343,2982365,2990536,2968743,2979643,2990505,2984120,2993224,2992216,2954153,2974109,2965327,2971431,2953144,2955864,2987816,2990567,2958584,2956904,2971400,2985097,2962281,2954184,2974171,2976903,2973080,2971369,2987785,2965259],"length":1,"stats":{"Line":10},"fn_name":null},{"line":121,"address":[2963448,2955324,2994363,2976098,2986267,2953378,2958818,2975319,2972536,2967938,2973314,2978012,2978786,2987042,2961538,2956098,2989730,2991679,2984354,2958048,2964265,2980791,2981570,2969850,2970626,2988956,2967121,2992450,2983575,2960766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2978007,2967966,2992478,2989758,2964311,2960761,2970654,2984382,2994358,2986262,2987070,2991674,2980786,2955319,2956126,2958043,2978818,2975314,2983570,2953406,2969845,2958846,2988951,2972531,2976126,2961566,2973346,2963443,2981602,2967084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[2975309,2963438,2989802,2972526,2953450,2960756,2955314,2984426,2976170,2992522,2983565,2968010,2980781,2986257,2991669,2964373,2988946,2973394,2967047,2981650,2987114,2994353,2958890,2978866,2956170,2970698,2969840,2978002,2961610,2958038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[2989848,2972521,2958033,2991664,2958936,2988941,2969835,2981696,2984468,2961652,2968052,2975304,2973440,2967010,2986252,2953496,2978912,2983560,2976212,2960751,2994348,2970740,2964433,2956216,2980776,2955309,2963433,2977997,2987156,2992564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[2955304,2978959,2956263,2984511,2961695,2966973,2972516,2991659,2960746,2977992,2964494,2980771,2963428,2958028,2976255,2968095,2969830,2987199,2994343,2975299,2958983,2992607,2953543,2988936,2989895,2986247,2970783,2973487,2983555,2981743],"length":1,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[2992645,2959025,2953585,2979001,2972511,2988931,2969825,2964550,2963423,2960741,2984549,2976293,2991654,2994338,2970821,2961733,2955299,2975294,2956305,2973529,2958023,2981785,2986242,2989937,2966936,2980766,2977987,2983550,2968133,2987237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2959334,2991368,2983253,2985960,2994056,2987542,2955013,2960455,2957737,2964936,2976598,2982106,2956614,2969543,2966417,2990246,2973850,2979322,2974997,2988649,2972229,2984854,2977705,2963141,2953894,2968438,2992950,2971126,2980469,2962038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[2962080,2963136,2968480,2971168,2991363,2979368,2992992,2985955,2973896,2987584,2976640,2974992,2959380,2955008,2964996,2983248,2972224,2990292,2980464,2953940,2966380,2982152,2984896,2969538,2988644,2977700,2957732,2956660,2994051,2960450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[2990339,2955003,2980459,2960445,2994046,2984939,2968523,2959427,2965057,2969533,2974987,2962123,2957727,2963131,2993035,2953987,2973943,2983243,2982199,2988639,2971211,2972219,2966343,2976683,2979415,2977695,2991358,2956707,2987627,2985950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[2966306,2976721,2984977,2991353,2956749,2954029,2987665,2965113,2983238,2971249,2990381,2979457,2957722,2988634,2982241,2973985,2977690,2994041,2974982,2972214,2959469,2962161,2980454,2969528,2993073,2963126,2968561,2954998,2985945,2960440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[2980761,2961773,2958018,2955294,2975289,2983545,2991649,2970861,2969820,2964608,2953629,2976333,2986237,2968173,2966899,2988926,2981829,2977982,2972506,2979045,2960736,2984589,2989981,2959069,2994333,2987277,2992685,2963418,2973573,2956349],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[2992727,2959111,2961815,2953671,2994328,2979091,2966862,2956391,2986232,2976375,2977977,2990023,2975284,2970903,2968215,2972501,2980756,2983540,2984631,2958013,2973619,2963413,2991644,2988921,2987319,2981875,2955289,2960731,2964668,2969815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[2983535,2959153,2970945,2977972,2960726,2969810,2956433,2961857,2981921,2968257,2988916,2973665,2958008,2972496,2975279,2963408,2986227,2987361,2953713,2955284,2980751,2979137,2966825,2994323,2984673,2964728,2976417,2991639,2992769,2990065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2971060,2972234,2973784,2966438,2976532,2957742,2980474,2984788,2985965,2982040,2961972,2963146,2969548,2968372,2977710,2959268,2953828,2990180,2992884,2983258,2960460,2956548,2964872,2975002,2987476,2994061,2979256,2991373,2988654,2955018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[2963153,2985972,2991380,2955025,2957749,2991553,2972414,2969555,2966440,2969728,2977890,2960467,2983449,2988834,2994068,2975193,2994241,2988661,2975009,2960640,2966673,2972241,2977717,2986145,2963326,2957922,2980481,2955198,2980665,2983265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2969721,2966642,2955077,2977769,2991432,2991546,2957801,2988827,2960633,2957915,2955191,2960519,2963205,2980540,2994120,2975068,2966504,2988713,2994234,2983324,2972293,2986138,2972407,2986024,2983442,2980658,2977883,2975186,2963319,2969607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2962196,2954300,2971284,2985012,2956788,2979736,2971516,2976756,2974264,2957024,2959508,2959742,2979496,2976992,2990655,2982520,2965171,2965465,2993108,2993343,2974024,2954068,2985247,2962428,2968830,2987700,2982280,2987936,2990420,2968596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2985919,2993345,2980416,2972124,2977600,2954972,2974944,2980340,2994015,2960350,2968832,2969502,2972188,2983124,2957632,2962430,2983200,2976994,2957026,2991327,2990657,2959744,2987938,2954908,2971518,2960414,2991263,2965467,2974868,2985249,2969438,2954302,2985855,2974266,2988544,2966148,2977664,2963036,2966221,2982522,2963100,2957696,2993951,2988608,2979738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2969414,2985831,2983116,2977576,2954884,2974860,2988520,2960326,2966140,2993927,2972100,2991239,2963012,2980332,2957608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[2974895,2972131,2954979,2969445,2980367,2954915,2977671,2960357,2969509,2988551,2993958,2966172,2957703,2985862,2991334,2974963,2980435,2985926,2977607,2972195,2994022,2960421,2983219,2983151,2988615,2963107,2957639,2963043,2966268,2991270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2980246,2971572,2965866,2982914,2993737,2982691,2962822,2957080,2977048,2957195,2985303,2979792,2968886,2969224,2991177,2974435,2988330,2993865,2957546,2965931,2985418,2965648,2954471,2962484,2991049,2990711,2966029,2971687,2993514,2977163,2954694,2962599,2987992,2960264,2969352,2985641,2988458,2985769,2974320,2960136,2962950,2979907,2974774,2988107,2977386,2977514,2974658,2982576,2954822,2993399,2983030,2980130,2972038,2965521,2959798,2959913,2969001,2957418,2954356,2990826,2971910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[2985609,2991017,2965834,2993705,2962790,2988298,2957386,2982882,2960104,2971878,2974626,2954662,2977354,2969192,2980098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2983022,2985745,2974766,2954798,2966021,2980238,2977490,2988434,2969328,2960240,2991153,2962926,2993841,2957522,2972014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[2954849,2988485,2980297,2959859,2954708,2985655,2985796,2993892,2962977,2993460,2974676,2982932,2965894,2960150,2979853,2977109,2977541,2971633,2991204,2954417,2977400,2965947,2966105,2974381,2972065,2982637,2960291,2957573,2962836,2988344,2969379,2988053,2980148,2974825,2957141,2991063,2969238,2957432,2993751,2985364,2990772,2971924,2962545,2983081,2968947,2965588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[2966691,2975195,2991555,2987408,2955200,2969730,2981972,2953760,2984720,2960642,2992816,2968304,2988836,2973716,2956480,2977892,2990112,2976464,2964798,2963328,2957924,2970992,2980667,2986147,2979188,2994243,2983451,2961904,2959200,2972416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[2982403,2987792,2971376,2979557,2954129,2990481,2959569,2982341,2962288,2959600,2976879,2987903,2968688,2982372,2987761,2979619,2974085,2965235,2965303,2959709,2982483,2968797,2993200,2974147,2993169,2968657,2985135,2990543,2971407,2965380,2985214,2956849,2985104,2956991,2990512,2956911,2976959,2971345,2954160,2971483,2956880,2993231,2954191,2974227,2962319,2962257,2965269,2974116,2979588,2962395,2968719,2987823,2959631,2976848,2990622,2993310,2954267,2985073,2976817,2979699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[2973273,2971448,2962360,2976920,2987864,2990584,2958777,2974188,2987001,2959672,2984313,2979660,2989689,2978745,2964223,2956057,2993272,2956952,2953337,2992409,2985176,2954232,2981529,2968760,2970585,2961497,2965345,2967897,2982444,2976057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[3001766,2994592,2996901,2999366,2998991,2996526,2997056,2999520,3001395],"length":1,"stats":{"Line":3},"fn_name":"deserialize_str\u003cchrono::naive::datetime::serde::NaiveDateTimeVisitor\u003e"},{"line":168,"address":[2999695,2997420,2994956,2999884,2994849,2997313,2997231,2999542,2997078,2994767,2994614,2999777],"length":1,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[2994912,2999840,2997376],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[3000074,2997610,3001689,2995146,2999289,2996824],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[3000113,2997653,2999284,3001684,2995189,2996819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3000157,3001679,2995237,2999279,2997701,2996814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[2999274,3001674,2997747,2996809,3000199,2995283],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[3000242,2995330,2996804,3001669,2997794,2999269],"length":1,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[2997836,3001664,2996799,2995372,3000280,2999264],"length":1,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[2995696,3001148,2996271,2998160,2998736,3000588],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[3000630,2996266,2998731,2995742,3001143,2998206],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[2998726,2995789,3001138,2998253,3000673,2996261],"length":1,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[2998295,2995831,2998721,3000711,3001133,2996256],"length":1,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[2997880,2996794,2995416,3000320,3001659,2999259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2999254,2995462,2997926,3001654,3000362,2996789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[2998432,3000746,2995870,2998334,2995967,3000844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[3000846,2996199,2996247,3001124,2998712,3001076,2998434,2995969,2998664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2643190,2643142,2643238,2643120,2643216,2643168],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cchrono::naive::datetime::serde::NaiveDateTimeVisitor\u003e"},{"line":187,"address":[3001062,2996185,2998650,3000900,3001014,2996023,2996137,2998602,2998488],"length":1,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2643275,2643403,2643392,2643339,2643328,2643264],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}\u003cserde::de::impls::StringVisitor\u003e"},{"line":191,"address":[2999249,3000404,2995508,3001649,2996784,2997972],"length":1,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[3001153,2998094,3000522,2996276,2995630,2998741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[2996569,2998748,3001160,3001438,2996283,2999034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[3001210,2996337,2998802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2998023,2996720,2999185,3000451,2995559,3001589],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[3001481,3000507,2995615,2996612,2999077,2998079],"length":1,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3000033,2995105,2998398,3000810,2997569,2995934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[3002400,3001920,3002373],"length":1,"stats":{"Line":2},"fn_name":"deserialize_string\u003cserde::de::impls::StringVisitor\u003e"},{"line":211,"address":[3001942,3002051,3002249,3002130],"length":1,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[3002183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[3003495,3004071,3004098,3004647,3002416,3004144,3002992,3004674,3002946,3003568,3003522,3002919],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option\u003cserde::de::impls::OptionVisitor\u003cchrono::naive::datetime::NaiveDateTime\u003e\u003e"},{"line":219,"address":[3002438,3002626,3003590,3004166,3004275,3003778,3002685,3003699,3003123,3003014,3004354,3003261,3003837,3004413,3003202,3002547],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[3003359,3002783,3004511,3003935,3003826,3002674,3004402,3003250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[3002870,3003446,3004598,3004022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[3003375,3002799,3004631,3004055,3002903,3004527,3003951,3003479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[3043140,3028557,3016559,3011136,3008559,3040560,3024720,3020561,3004720,3007138,3020720,3027136,3028720,3024560,3019140,3032720,3015138,3012720,3012557,3036561,3035140,3039139,3016720,3031140,3044561,3036720,3032561,3008720,3040720,3023139],"length":1,"stats":{"Line":10},"fn_name":"deserialize_newtype_struct\u003ctaos_query::common::value::de::borrowed::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor\u003cu16\u003e\u003e"},{"line":235,"address":[3025016,3021016,3012767,3016767,3005230,3041016,3004767,3013113,3017016,3036767,3041230,3033016,3024767,3040767,3028767,3008767,3037016,3013016,3041113,3017230,3037230,3009113,3029016,3013230,3037113,3025230,3033230,3025113,3005016,3009230,3029230,3020767,3032767,3017113,3021113,3029113,3005113,3021230,3009016,3033113],"length":1,"stats":{"Line":30},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[3038452,3037185,3038384,3041185,3042384,3030452,3013185,3026452,3029185,3006384,3025185,3033185,3017185,3034418,3038418,3021185,3022418,3042418,3018452,3030384,3042452,3014452,3010384,3014418,3034384,3006452,3010452,3009185,3026384,3014384,3022452,3034452,3018418,3005185,3018384,3030418,3026418,3022384,3010418,3006418],"length":1,"stats":{"Line":10},"fn_name":null},{"line":244,"address":[3005441,3041441,3025441,3044477,3008475,3040476,3028473,3012473,3013441,3032477,3017441,3037441,3020477,3029441,3021441,3009441,3016475,3033441,3024476,3036477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[3033467,3020389,3037467,3032389,3013467,3036389,3016387,3021467,3025467,3008387,3009467,3017467,3044389,3005467,3041467,3029467,3028385,3024388,3040388,3012385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[3032304,3036304,3044304,3041521,3016302,3025521,3017521,3013521,3028300,3021521,3020304,3005521,3008302,3033521,3040303,3037521,3009521,3029521,3024303,3012300],"length":1,"stats":{"Line":8},"fn_name":null},{"line":247,"address":[3005573,3013573,3020218,3033573,3021573,3024217,3044218,3008216,3028214,3041573,3017573,3037573,3036218,3012214,3032218,3016216,3029573,3040217,3025573,3009573],"length":1,"stats":{"Line":8},"fn_name":null},{"line":248,"address":[3016134,3013627,3033627,3032136,3020136,3025627,3028132,3008134,3012132,3017627,3037627,3005627,3041627,3009627,3040135,3021627,3036136,3024135,3029627,3044136],"length":1,"stats":{"Line":8},"fn_name":null},{"line":249,"address":[3008051,3012049,3028049,3021675,3033675,3040052,3016051,3029675,3005675,3044053,3020053,3024052,3032053,3013675,3037675,3009675,3017675,3036053,3025675,3041675],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[3035543,3039542,3006091,3026091,3014091,3007541,3030091,3027539,3031543,3018091,3043543,3022091,3010091,3015541,3019543,3034091,3011539,3042091,3038091,3023542],"length":1,"stats":{"Line":8},"fn_name":null},{"line":251,"address":[3019457,3034143,3011453,3006143,3018143,3015455,3031457,3042143,3027453,3007455,3026143,3030143,3022143,3010143,3023456,3043457,3039456,3035457,3038143,3014143],"length":1,"stats":{"Line":8},"fn_name":null},{"line":252,"address":[3034197,3018197,3038197,3030197,3006197,3007373,3039374,3043375,3011371,3022197,3026197,3015373,3010197,3035375,3014197,3042197,3019375,3027371,3031375,3023374],"length":1,"stats":{"Line":8},"fn_name":null},{"line":253,"address":[3039291,3035292,3019292,3038245,3030245,3014245,3015290,3043292,3018245,3042245,3026245,3007290,3027288,3034245,3006245,3011288,3022245,3023291,3010245,3031292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":254,"address":[3027965,3023968,3025726,3009726,3035969,3039968,3013726,3017726,3011965,3033726,3021726,3041726,3007967,3037726,3029726,3015967,3005726,3019969,3031969,3043969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3011881,3019885,3037780,3035885,3031885,3039884,3005780,3029780,3033780,3041780,3007883,3027881,3015883,3021780,3017780,3043885,3013780,3025780,3023884,3009780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[3039796,3025834,3017834,3031797,3033834,3041834,3023796,3007795,3011793,3021834,3009834,3037834,3029834,3015795,3035797,3005834,3019797,3043797,3013834,3027793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[3043628,3023627,3005977,3021977,3027624,3039627,3029977,3017977,3037977,3013977,3015626,3035628,3041977,3031628,3025977,3007626,3009977,3033977,3011624,3019628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[3014545,3018547,3014296,3010296,3006296,3006545,3034296,3026543,3030296,3022546,3038546,3018296,3022296,3042296,3030547,3042547,3034547,3038296,3026296,3010543],"length":1,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[3031263,3011259,3027259,3039195,3026545,3039262,3011192,3030549,3035196,3019263,3027192,3023262,3019196,3018549,3042549,3014547,3043196,3007261,3022548,3038548,3015194,3034549,3031196,3043263,3007194,3023195,3015261,3006547,3010545,3035263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[3031156,3035156,3011152,3043156,3027152,3007154,3015154,3019156,3023155,3039155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[3043203,3007201,3011266,3015201,3019203,3039269,3039202,3031203,3007268,3035270,3027199,3019270,3031270,3023269,3011199,3043270,3015268,3035203,3023202,3027266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[3039090,3010940,3030944,3023090,3034944,3043091,3022943,3007089,3019091,3014601,3038717,3042944,3042603,3014942,3006601,3042718,3014716,3010599,3006716,3034603,3030603,3035091,3026714,3026599,3010714,3030718,3038602,3018944,3006942,3011087,3022602,3031091,3018718,3015089,3038943,3034718,3027087,3022717,3026940,3018603],"length":1,"stats":{"Line":9},"fn_name":null},{"line":263,"address":[3006910,3030912,3010908,3014910,3038911,3042912,3026908,3022911,3034912,3018912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3015049,3027047,3035051,3019051,3039050,3031051,3007049,3011047,3043051,3023050],"length":1,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[3018664,3030664,3027117,3006956,3015119,3023120,3019121,3034664,3014956,3011117,3035121,3010660,3022663,3034958,3042664,3026954,3010954,3038663,3018958,3031121,3038957,3039120,3007119,3006662,3026660,3022957,3014662,3030958,3042958,3043121],"length":1,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[3043714,3007712,3021906,3035714,3017906,3031714,3005906,3013906,3011710,3009906,3023713,3033906,3015712,3041906,3039713,3029906,3037906,3019714,3027710,3025906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3026428,3014428,3034514,3006512,3010428,3022513,3014512,3018514,3030428,3018428,3038360,3026360,3010360,3030514,3022428,3022360,3030394,3022394,3034394,3042394,3010394,3014394,3042514,3030360,3010510,3038513,3026510,3034360,3034428,3018394,3042360,3038394,3006360,3006428,3006394,3038428,3026394,3042428,3018360,3014360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3005397,3009397,3006472,3014472,3010472,3034472,3041397,3021397,3030472,3029397,3013397,3037397,3017397,3042472,3022472,3018472,3033397,3025397,3026472,3038472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3046225,3044720,3045825],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq\u003cserde::de::impls::{impl#19}::deserialize::VecVisitor\u003cu8\u003e\u003e"},{"line":288,"address":[3044879,3044742,3045059,3044961],"length":1,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[3045024,3045512,3045543,3045574],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[3045198,3046151,3046179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[3046163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3045679,3045419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3046060,3045225,3046123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[3046107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[3046021,3045350,3045958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[3046028,3045836,3046005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[3045550,3045519,3045488],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[3045578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[3047412,3047439,3046304],"length":1,"stats":{"Line":1},"fn_name":"deserialize_enum\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":322,"address":[3046467,3046352,3046637,3046549],"length":1,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[3046607,3046874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[3046983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[3047116,3046943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[3047274,3047325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[3047282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[3047195,3047393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[3048363,3048524,3047456],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct\u003ctaos_query::common::value::de::borrowed::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":346,"address":[3047530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[3047753,3047576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[3048481,3047755,3048420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3048399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[3048488,3048427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[3048135,3047803,3047912,3048317],"length":1,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[3048103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3048293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[3048344,3048149,3047858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[3047732,3047625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[1945264],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":390,"address":[1945272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[2411792,2411801],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":402,"address":[2892768,2896087,2896060],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":415,"address":[2896199,2897128,2895784,2894782,2896071,2893753,2893496,2897946,2892783,2895327,2897036,2898038,2896661,2897843,2892991,2894525,2894012,2897491,2897583,2896877,2893242,2894267,2897388,2895615,2895046,2896306],"length":1,"stats":{"Line":21},"fn_name":null},{"line":416,"address":[2892775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[2892975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[2893224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[2893477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[2893732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[2893996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[2894249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[2894506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[2894762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[2895021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[2895302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2895580,2895758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[2896102,2896280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[2896597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2897024,2897085,2896842],"length":1,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[2897540,2897479,2897353],"length":1,"stats":{"Line":3},"fn_name":null},{"line":432,"address":[2897808,2897934,2897995],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[2411849,2411840],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":437,"address":[2898558,2898416],"length":1,"stats":{"Line":1},"fn_name":"de_borrowed_str"},{"line":464,"address":[2898423,2901541,2901391,2899349,2898983,2900299,2898588,2902441,2901917,2899720,2898447,2902698,2898797,2899534,2900449,2899165,2899901,2901306,2901150,2901005,2900609,2902167,2901743,2898612,2900844,2900694],"length":1,"stats":{"Line":18},"fn_name":null},{"line":465,"address":[2898431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[2898594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[2898778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[2898963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[2899149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[2899331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[2899515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[2899700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[2900359,2899931,2899886],"length":1,"stats":{"Line":3},"fn_name":null},{"line":474,"address":[2900639,2900754,2900587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[2901035,2900982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[2901451,2901284,2901336],"length":1,"stats":{"Line":3},"fn_name":null},{"line":477,"address":[2901679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[2901909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2902132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[2902406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[2411888,2411897],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":485,"address":[2902896,2903067],"length":1,"stats":{"Line":1},"fn_name":"de_string"},{"line":508,"address":[2904304,2903713,2902935,2906295,2906984,2905950,2908805,2902903,2908260,2903124,2904896,2906100,2908016,2907221,2903909,2908361,2908913,2903321,2903519,2907630,2904106,2908166,2906194,2904490,2905582,2903100,2907134,2905242],"length":1,"stats":{"Line":18},"fn_name":null},{"line":510,"address":[2902919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[2903106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[2903302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[2903499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[2903697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[2903891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[2904087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[2904284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2904482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2904832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[2905207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[2905547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[2906172,2906010,2906238,2905875],"length":1,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[2907044,2907214,2906603,2907265],"length":1,"stats":{"Line":4},"fn_name":null},{"line":526,"address":[2908304,2908076,2907941,2908238],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[2908669,2908887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":531,"address":[2411936,2411945],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":532,"address":[2909666,2909344],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":546,"address":[2909692,2909351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[2910823,2910448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[2910094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[2910783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[2910756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[2911035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[2420752,2420761],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":566,"address":[2912512,2912841],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":577,"address":[2912971,2912600,2912875,2912750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[2912660,2912525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":580,"address":[2912904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[2913275,2913425,2913683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[2913335,2913200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":590,"address":[2913727,2913948,2913628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[2914215,2913891,2913992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":592,"address":[2914259,2914157,2914483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[2914424,2914527,2914739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":621,"address":[2914692,2944490,2914783],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":156,"coverable":248},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","mod.rs"],"content":"//! Value de-serialization.\n//!\n//! All values queried from TDengine sql could be deserialized to a Rust type.\n//! Commonly, you can deserialize a value directly into a [crate::common::Value].\n//!\nuse serde::de::value::Error;\nuse serde::{de, forward_to_deserialize_any};\n\nconst TIMESTAMP_VARIANTS: [\u0026str; 3] = [\"Milliseconds\", \"Microseconds\", \"Nanoseconds\"];\nconst VALUE_VARIANTS: [\u0026str; 20] = [\n    \"Null\",\n    \"Bool\",\n    \"TinyInt\",\n    \"SmallInt\",\n    \"Int\",\n    \"BigInt\",\n    \"Float\",\n    \"Double\",\n    \"VarChar\",\n    \"Timestamp\",\n    \"NChar\",\n    \"UTinyInt\",\n    \"USmallInt\",\n    \"UInt\",\n    \"UBigInt\",\n    \"Json\",\n    \"VarBinary\",\n    \"Decimal\",\n    \"Blob\",\n    \"MediumBlob\",\n];\n\npub struct UnitOnly;\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for UnitOnly {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            \u0026\"newtype variant\",\n        ))\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            \u0026\"tuple variant\",\n        ))\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        Err(de::Error::invalid_type(\n            de::Unexpected::UnitVariant,\n            \u0026\"struct variant\",\n        ))\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct VariantTimestampDeserializer {\n    value: i64,\n}\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for VariantTimestampDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_i64(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de\u003e de::VariantAccess\u003c'de\u003e for VariantTimestampDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nmod borrowed;\nmod ref_value;\n\nmod value;\n","traces":[{"line":38,"address":[2770144],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":39,"address":[2770148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[2396032,2396135,2396304,2396160,2395232,2395760,2396811,2397120,2396010,2396535,2395904,2396704,2397355,2397083,2395723,2395591,2395867,2395360,2397225,2396848,2395465,2396667,2396560,2396976,2395338,2395488,2396432,2396410,2397248,2396954,2396267,2395616],"length":1,"stats":{"Line":0},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003cu32\u003e\u003e"},{"line":46,"address":[2396122,2395250,2395450,2395578,2396794,2395634,2395922,2396578,2395378,2397338,2396178,2396650,2396050,2397138,2396722,2395778,2397266,2396994,2397066,2395850,2397210,2395706,2396938,2395506,2396250,2396866,2396522,2396322,2396450,2395322,2395994,2396394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2396861,2395917,2395373,2396173,2395245,2396445,2397261,2395773,2397133,2396573,2396717,2395501,2395629,2396045,2396317,2396989],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2397744,2397872,2397552,2397584,2397456,2397776,2397712,2397392,2397520,2397488,2397680,2397808,2397840,2397424,2397648,2397616],"length":1,"stats":{"Line":1},"fn_name":"deserialize_any\u003cserde::de::impls::BoolVisitor\u003e"},{"line":88,"address":[2397760,2397536,2397856,2397600,2397664,2397728,2397792,2397696,2397632,2397440,2397568,2397824,2397408,2397888,2397504,2397472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2770176],"length":1,"stats":{"Line":0},"fn_name":"unit_variant"},{"line":102,"address":[2770185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2398352,2398128,2398000,2398160,2398288,2398064,2398032,2397968,2398320,2397936,2398096,2397904,2398192,2398256,2398384,2398224],"length":1,"stats":{"Line":1},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003cu64\u003e\u003e"},{"line":109,"address":[2398400,2398112,2398016,2398272,2398240,2398176,2398048,2398080,2397920,2398208,2398336,2398368,2398304,2398144,2397984,2397952],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":18},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","ref_value.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl\u003c'de, 'v\u003e serde::de::EnumAccess\u003c'de\u003e for \u0026'v Value {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let s = self.strict_as_str();\n        return Ok((\n            seed.deserialize(StringDeserializer {\n                input: s.to_string(),\n            })?,\n            UnitOnly,\n        ));\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer\u003c'v\u003e {\n    value: \u0026'v Value,\n}\n\nimpl\u003c'v, 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumTimestampDeserializer\u003c'v\u003e {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n        match self.value {\n            Value::Timestamp(Timestamp::Microseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Microseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            Value::Timestamp(Timestamp::Milliseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Milliseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            Value::Timestamp(Timestamp::Nanoseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Nanoseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: *v },\n            )),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer\u003c'v\u003e {\n    value: \u0026'v Value,\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\nimpl\u003c'de, 'v: 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumValueDeserializer\u003c'v\u003e {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let variant = self.value.ty().as_variant_str();\n\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: variant.to_string(),\n            })\n            .expect(\"\"),\n            self,\n        ))\n    }\n}\n\nimpl\u003c'de, 'v: 'de\u003e de::VariantAccess\u003c'de\u003e for EnumValueDeserializer\u003c'v\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nimpl\u003c'de, 'v: 'de\u003e serde::de::Deserializer\u003c'de\u003e for \u0026'v Value {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use Value::*;\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e visitor.visit_bool(*v),\n            TinyInt(v) =\u003e visitor.visit_i8(*v),\n            SmallInt(v) =\u003e visitor.visit_i16(*v),\n            Int(v) =\u003e visitor.visit_i32(*v),\n            BigInt(v) =\u003e visitor.visit_i64(*v),\n            UTinyInt(v) =\u003e visitor.visit_u8(*v),\n            USmallInt(v) =\u003e visitor.visit_u16(*v),\n            UInt(v) =\u003e visitor.visit_u32(*v),\n            UBigInt(v) =\u003e visitor.visit_u64(*v),\n            Float(v) =\u003e visitor.visit_f32(*v),\n            Double(v) =\u003e visitor.visit_f64(*v),\n            VarChar(v) =\u003e visitor.visit_borrowed_str(v),\n            NChar(v) =\u003e visitor.visit_borrowed_str(v),\n            Json(v) =\u003e v\n                .clone()\n                .into_deserializer()\n                .deserialize_any(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e visitor.visit_borrowed_bytes(v),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    serde::forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple_struct tuple identifier ignored_any\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str\");\n        use Value::*;\n        match self {\n            Null =\u003e visitor.visit_borrowed_str(\"\"), // todo: empty string or error?\n            Bool(v) =\u003e visitor.visit_bool(*v),\n            TinyInt(v) =\u003e visitor.visit_i8(*v),\n            SmallInt(v) =\u003e visitor.visit_i16(*v),\n            Int(v) =\u003e visitor.visit_i32(*v),\n            BigInt(v) =\u003e visitor.visit_i64(*v),\n            UTinyInt(v) =\u003e visitor.visit_u8(*v),\n            USmallInt(v) =\u003e visitor.visit_u16(*v),\n            UInt(v) =\u003e visitor.visit_u32(*v),\n            UBigInt(v) =\u003e visitor.visit_u64(*v),\n            Float(v) =\u003e visitor.visit_f32(*v),\n            Double(v) =\u003e visitor.visit_f64(*v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_borrowed_str(v),\n            Json(v) =\u003e visitor.visit_string(v.to_string()),\n            Timestamp(v) =\u003e visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use Value::*;\n        macro_rules! _v_ {\n            ($v:expr) =\u003e {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e _v_!(v),\n            TinyInt(v) =\u003e _v_!(v),\n            SmallInt(v) =\u003e _v_!(v),\n            Int(v) =\u003e _v_!(v),\n            BigInt(v) =\u003e _v_!(v),\n            UTinyInt(v) =\u003e _v_!(v),\n            USmallInt(v) =\u003e _v_!(v),\n            UInt(v) =\u003e _v_!(v),\n            UBigInt(v) =\u003e _v_!(v),\n            Float(v) =\u003e _v_!(v),\n            Double(v) =\u003e _v_!(v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_newtype_struct(v.as_str().into_deserializer()),\n            Json(v) =\u003e visitor\n                .visit_newtype_struct(v.clone().into_deserializer())\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e _v_!(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                visitor.visit_newtype_struct(v.as_slice().into_deserializer())\n            }\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use Value::*;\n        match self {\n            Null =\u003e Vec::\u003cu8\u003e::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) =\u003e v\n                .clone()\n                .into_deserializer()\n                .deserialize_seq(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            VarChar(v) | NChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.clone().into_deserializer().deserialize_any(visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" \u0026\u0026 variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" \u0026\u0026 variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            Value::Json(json) =\u003e json\n                .clone()\n                .into_deserializer()\n                .deserialize_struct(name, fields, visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::IntoDeserializer\u003c'de, Error\u003e for \u0026'b Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn value_de_value_ref() {\n        use std::cmp::PartialEq;\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr) *) =\u003e {\n                $(\n                    {\n                        let v = \u0026$v;\n                        let d = Value::deserialize(v.into_deserializer()).expect(\"\");\n                        assert!(dbg!(d).eq(\u0026$v));\n                    }\n                )*\n            }\n        }\n        _de_value!(\n            Null Bool(true) TinyInt(0xf) SmallInt(0xfff) Int(0xffff) BigInt(-1) Float(1.0) Double(1.0)\n            UTinyInt(0xf) USmallInt(0xfff) UInt(0xffff) UBigInt(0xffffffff)\n            Timestamp(crate::common::timestamp::Timestamp::Milliseconds(0)) VarChar(\"anything\".to_string())\n            NChar(\"\".to_string()) VarBinary(vec![1,2,3]) Blob(vec![1,2, 3]) MediumBlob(vec![1,2,3])\n            Json(serde_json::json!({\"name\": \"ABC\"}))\n        );\n    }\n\n    #[test]\n    fn de_value_as_inner() {\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) =\u003e {\n                $(\n                    {\n                        let v = \u0026$v;\n                        let d = \u003c$ty\u003e::deserialize(v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option\u003cu8\u003e, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\".to_string()), String, \"\".to_string()\n            NChar(\"\".to_string()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            Blob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            MediumBlob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_borrowed_str() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(\u003c\u0026str\u003e::deserialize((\u0026$v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(\u003c\u0026str\u003e::deserialize((\u0026$v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(\u003c\u0026str\u003e::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            Json(json!({ \"name\": \"abc\"})), is_err\n            Json(json!(1)), is_err\n            Json(json!(null)), is_err\n            Json(json!(\"abc\")), is_err\n            Timestamp(crate::Timestamp::Milliseconds(0)), is_err\n            ;\n            Null, \"\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"\".to_string()), \"\"\n        };\n    }\n    #[test]\n    fn de_string() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(String::deserialize((\u0026$v).into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(String::deserialize((\u0026$v).into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(String::deserialize(($v).into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"\".to_string()), \"\"\n            Json(json!(\"abc\")), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"})), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1)), json!(1).to_string()\n            Json(json!(null)), json!(null).to_string()\n        };\n    }\n\n    #[test(log_level = \"trace\")]\n    fn de_json() {\n        use Value::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let v = \u0026Json($v);\n                let d = \u003c$ty\u003e::deserialize(v.into_deserializer()).expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(\n            serde_json::json!(\"string\"),\n            String,\n            \"\\\"string\\\"\".to_string()\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            serde_json::json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n    }\n\n    #[test(log_level = \"trace\")]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize((\u0026$v).into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\")),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi\u003cT\u003e(T);\n        _de_ty!(Json(json!(1)), Primi\u003ci32\u003e, Primi(1));\n        _de_ty!(TinyInt(1), Primi\u003ci8\u003e, Primi(1));\n        _de_ty!(SmallInt(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(Int(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(BigInt(1), Primi\u003ci64\u003e, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) =\u003e {\n                log::info!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::\u003c$ty\u003e()\n                );\n                _de_ty!($v($inner), Primi\u003c$ty\u003e, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) =\u003e {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) =\u003e {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () =\u003e {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[3049019,3048608,3049056,3049467],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::value::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":17,"address":[3048736,3049092,3048644,3049184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3049377,3048929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3048898,3049346,3049265,3049424,3049334,3049465,3049017,3048976,3048817,3049200,3048886,3048752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3048776,3049224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2733444,2734564,2733472,2732352],"length":1,"stats":{"Line":2},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":43,"address":[2732382,2733502],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[2734283,2733163,2732588,2733708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2733037,2732605,2734157,2733099,2734219,2733725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[2733741,2732621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2733152,2734272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[2733387,2734507,2733640,2732520],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2733320,2734440,2734369,2732537,2733657,2733249],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[2733673,2732553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[2734496,2733376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2734055,2733776,2732935,2732656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2733793,2732797,2733917,2732673,2733988,2732868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[2733809,2732689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[2734044,2732924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[2734656,2734592],"length":1,"stats":{"Line":3},"fn_name":"deserialize_any\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__FieldVisitor\u003e"},{"line":87,"address":[2734667,2734603],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[2735136,2735529,2735113,2734720],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::value::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":105,"address":[2735174,2735254,2734838,2734758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[2735070,2735486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[2735427,2734890,2734955,2735371,2735306,2735011],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2734911,2735327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2833104],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":121,"address":[2833113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[2735616,2735968,2735552,2735648,2735840,2735936,2735680,2735904,2735584,2735872,2735808,2735776,2735744,2736000,2735712,2736032],"length":1,"stats":{"Line":15},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003ci8\u003e\u003e"},{"line":128,"address":[2735728,2735696,2736016,2735600,2735632,2735824,2735664,2735568,2735984,2735760,2735856,2735792,2735888,2735952,2736048,2735920],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[3080402,3076288,3072096,3055629,3055664,3061730,3074142,3065952,3053581,3057674,3063824,3070096,3049504,3051518,3078352,3059726,3059776,3068000,3076240,3057712,3074192,3072055,3065910,3053616,3063786,3051568,3070049,3067964,3078302,3061776],"length":1,"stats":{"Line":12},"fn_name":"deserialize_any\u003ctaos_query::common::value::de::ref_value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":157,"address":[3056027,3053784,3053647,3068363,3053866,3051931,3057962,3065983,3078520,3076651,3049672,3051736,3051818,3078715,3066120,3063855,3064074,3076456,3055832,3049535,3068250,3063992,3070124,3064187,3068168,3060023,3049867,3066202,3074223,3068031,3078602,3057743,3070343,3072127,3072459,3055695,3078383,3060136,3062026,3061944,3076538,3055914,3059804,3061807,3074555,3066315,3072346,3062139,3070261,3051599,3053979,3076319,3057880,3074442,3074360,3049754,3072264,3070456,3058075,3059941],"length":1,"stats":{"Line":38},"fn_name":null},{"line":160,"address":[3059112,3057086,3073506,3079762,3053924,3050904,3052946,3079806,3069432,3055038,3054994,3061115,3059134,3049812,3055972,3058020,3062084,3050926,3055016,3077710,3067352,3063154,3077666,3068308,3069410,3078660,3057064,3077688,3052968,3072404,3079784,3065250,3075646,3061137,3075602,3063176,3067374,3067330,3071457,3073528,3064132,3069454,3065294,3076596,3060081,3057042,3063198,3051876,3070401,3071435,3065272,3074500,3059090,3061159,3066260,3075624,3073550,3050882,3071479,3052990],"length":1,"stats":{"Line":14},"fn_name":null},{"line":161,"address":[3059721,3067959,3064380,3054172,3078297,3068556,3050060,3057669,3066508,3060326,3078908,3063781,3053576,3072652,3061725,3072050,3074137,3074748,3070646,3076844,3056220,3058268,3070044,3062332,3055624,3080397,3065905,3076235,3051513,3052124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3061720,3072678,3065900,3076870,3072045,3054198,3078934,3068582,3067954,3052150,3055619,3076230,3050086,3060349,3057664,3058294,3059716,3078292,3063776,3074132,3080392,3070669,3074774,3066534,3053571,3070039,3064410,3051508,3062358,3056246],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3068635,3072040,3063771,3076225,3060399,3074127,3076923,3052203,3065895,3080387,3057659,3056299,3053566,3078987,3059711,3070719,3051503,3054251,3058347,3066587,3078287,3072731,3067949,3074827,3062411,3064467,3055614,3061715,3050139,3070034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3066640,3072035,3058400,3080382,3074122,3060449,3074884,3065890,3079044,3070769,3053561,3062464,3072788,3055609,3061710,3050192,3051498,3052256,3059706,3063766,3054304,3076976,3070029,3068692,3067944,3057654,3056352,3076220,3078282,3064524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3055604,3067939,3054357,3058453,3051493,3072030,3074117,3050245,3053556,3080377,3065885,3062517,3076215,3052309,3061705,3078277,3066693,3056405,3068749,3063761,3070819,3077029,3070024,3064581,3079101,3072845,3074941,3057649,3059701,3060499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[3053551,3063756,3078272,3059696,3076210,3057644,3070868,3056457,3061700,3065880,3058505,3050297,3077081,3062569,3074997,3072901,3051488,3055599,3079157,3070019,3060548,3074112,3072025,3068805,3052361,3066745,3064637,3054409,3067934,3080372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[3053277,3077405,3073229,3059422,3052685,3061435,3056781,3075325,3069741,3077998,3067660,3079485,3050621,3065594,3073834,3071760,3055325,3051214,3063482,3069133,3071183,3064973,3080094,3060863,3067069,3058829,3062893,3075932,3057370,3054733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3057365,3067655,3058882,3059417,3071755,3077993,3080089,3053272,3063477,3075927,3055320,3067122,3075382,3050674,3073286,3069736,3052738,3069190,3073829,3065589,3065030,3077458,3060913,3054786,3071233,3061430,3051209,3062946,3079542,3056834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[3054839,3057360,3069247,3065087,3071750,3059412,3067175,3053267,3051204,3077511,3073824,3061425,3069731,3071283,3063472,3055315,3067650,3079599,3073343,3060963,3056887,3080084,3050727,3065584,3075439,3058935,3075922,3062999,3052791,3077988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[3075495,3063467,3079655,3080079,3073399,3067645,3061012,3052843,3059407,3061420,3077563,3056939,3069726,3067227,3065579,3069303,3063051,3051199,3075917,3057355,3054891,3053262,3058987,3071332,3077983,3073819,3050779,3065143,3055310,3071745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3077134,3068862,3057639,3070014,3050350,3053546,3074107,3063751,3055594,3076205,3061695,3062622,3067929,3078267,3070918,3054462,3056510,3052414,3059691,3065875,3051483,3079214,3072958,3064694,3066798,3080367,3072020,3058558,3075054,3060598],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[3079268,3064752,3061690,3070969,3075108,3067924,3068916,3072015,3051478,3078262,3053541,3062676,3056564,3054516,3059686,3052468,3076200,3058612,3055589,3070009,3077188,3050404,3074102,3080362,3063746,3065870,3073012,3066852,3057634,3060649],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[3063658,3065778,3061605,3075154,3069921,3071015,3051390,3074014,3067836,3079314,3073058,3050450,3080274,3057546,3068962,3055501,3052514,3062722,3053453,3071930,3077234,3066898,3076112,3078174,3059598,3064802,3054562,3056610,3058658,3060695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3061440,3078003,3055330,3060802,3080099,3058765,3051219,3053282,3067005,3079421,3064909,3057375,3067665,3069746,3071122,3065599,3062829,3075937,3056717,3073165,3069069,3054669,3059427,3075261,3071765,3052621,3073839,3077341,3063487,3050557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[3053227,3053176,3055224,3054936,3055275,3075831,3052888,3073784,3077897,3063381,3065520,3051164,3057320,3077608,3061337,3059032,3061388,3051113,3079993,3056984,3065192,3057269,3080044,3059372,3050824,3069352,3069691,3059321,3073448,3067272,3079704,3061057,3071377,3073733,3075544,3075882,3071709,3067559,3063432,3065485,3063096,3077948,3071658,3069640,3067610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[3077924,3057296,3053203,3065512,3069667,3051140,3075858,3073760,3061364,3071685,3063408,3067586,3059348,3080020,3055251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3069834,3073927,3060751,3076025,3058714,3067753,3065691,3051307,3064858,3052570,3071850,3063575,3071071,3075210,3053370,3056666,3066954,3054618,3078091,3061525,3069018,3050506,3059515,3079370,3077290,3080187,3055418,3062778,3057463,3073114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3077646,3061095,3054996,3065230,3052948,3057066,3065274,3057022,3054974,3059092,3063156,3055091,3071415,3063178,3077690,3050980,3069434,3067426,3059070,3050862,3075604,3073600,3071437,3059114,3075626,3069412,3077764,3057136,3065252,3067310,3061209,3069390,3079860,3073486,3079764,3065348,3050906,3067354,3079786,3071530,3061117,3073530,3057044,3052926,3063134,3071459,3055018,3067332,3075698,3075582,3073508,3050884,3079742,3061139,3059188,3077668,3053043,3069507,3052970,3063248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[3058224,3077730,3059154,3066464,3075666,3070605,3072608,3079826,3071496,3055058,3054128,3061176,3068512,3057106,3050946,3053010,3060285,3067394,3073570,3069474,3062288,3052080,3056176,3074704,3076800,3078864,3064336,3050016,3065314,3063218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[3083892,3082160,3082120,3083734,3080448,3081966],"length":1,"stats":{"Line":2},"fn_name":"deserialize_str\u003cserde::de::impls::StrVisitor\u003e"},{"line":200,"address":[3080674,3080595,3080478,3082190,3082386,3080757,3082469,3082307],"length":1,"stats":{"Line":6},"fn_name":null},{"line":202,"address":[3082434,3080722,3081350,3083094,3081277,3083021],"length":1,"stats":{"Line":5},"fn_name":null},{"line":203,"address":[3082613,3082115,3080901,3083887],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[3080940,3082110,3082656,3083882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[3082707,3083877,3080987,3082105],"length":1,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[3082758,3081034,3082100,3083872],"length":1,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[3082095,3082809,3081081,3083867],"length":1,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[3083862,3081127,3082859,3082090],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[3081365,3083109,3081729,3083493],"length":1,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[3083160,3081412,3083491,3081727],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[3083489,3081459,3081725,3083211],"length":1,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[3083261,3083487,3081505,3081723],"length":1,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[3083857,3081174,3082910,3082085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3082962,3083852,3082080,3081222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[3081995,3083009,3081731,3081265,3083495,3083763,3083082,3081338],"length":1,"stats":{"Line":5},"fn_name":null},{"line":216,"address":[3081643,3081547,3083403,3083307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[3083688,3081924,3081287,3083031],"length":1,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[3083067,3083580,3081816,3081323],"length":1,"stats":{"Line":4},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[3081609,3082572,3083369,3080860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3083936,3084313],"length":1,"stats":{"Line":1},"fn_name":"deserialize_string\u003cserde::de::impls::StringVisitor\u003e"},{"line":232,"address":[3084206,3084138,3084059,3083966],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[3084191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[3084767,3084336],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option\u003cserde::de::impls::OptionVisitor\u003cu8\u003e\u003e"},{"line":240,"address":[3084597,3084459,3084366,3084538],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[3084586,3084695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[3084731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[3084765,3084711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[3087984,3103945,3110384,3091141,3107145,3084784,3113543,3087943,3110344,3107184,3091184,3100744,3094341,3097545,3103984,3100784,3097584,3094384],"length":1,"stats":{"Line":9},"fn_name":"deserialize_newtype_struct\u003ctaos_query::common::value::de::ref_value::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor\u003cu16\u003e\u003e"},{"line":256,"address":[3104478,3107561,3091239,3110439,3091464,3094761,3088039,3110664,3091678,3110878,3107678,3110761,3098078,3091561,3084839,3104264,3107239,3107464,3104361,3104039,3097639,3101064,3100839,3085161,3097961,3101278,3088361,3094664,3085064,3085278,3094439,3101161,3094878,3088264,3097864,3088478],"length":1,"stats":{"Line":27},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3092763,3092785,3086363,3101233,3111941,3098833,3099141,3098757,3089541,3086341,3095633,3102363,3091633,3095985,3086385,3108433,3095963,3088433,3105233,3092357,3102033,3105563,3095941,3098033,3099163,3094833,3095557,3108763,3089233,3085233,3085957,3099185,3111633,3111963,3105541,3111557,3104433,3089585,3107633,3108785,3108357,3092433,3105157,3089157,3108741,3102341,3092741,3110833,3105585,3111985,3101957,3089563,3086033,3102385],"length":1,"stats":{"Line":9},"fn_name":null},{"line":264,"address":[3088701,3111101,3107140,3095101,3101501,3091901,3097540,3091136,3085501,3098301,3100739,3104701,3087938,3107901,3103940,3094336,3110339,3113538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[3087847,3088727,3091045,3094245,3101527,3113447,3104727,3085527,3097449,3107049,3111127,3100648,3091927,3095127,3103849,3098327,3107927,3110248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[3104787,3088787,3097361,3091987,3111187,3101587,3087759,3103761,3098387,3110160,3113359,3106961,3107987,3094157,3090957,3095187,3085587,3100560],"length":1,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[3101647,3108047,3088847,3104847,3095247,3100471,3085647,3090868,3098447,3092047,3103672,3110071,3113270,3094068,3111247,3087670,3106872,3097272],"length":1,"stats":{"Line":8},"fn_name":null},{"line":268,"address":[3088908,3106787,3109986,3085708,3093983,3097187,3100386,3092108,3111308,3098508,3113185,3101708,3103587,3104908,3090783,3087585,3108108,3095308],"length":1,"stats":{"Line":8},"fn_name":null},{"line":269,"address":[3106704,3100303,3095367,3088967,3093900,3097104,3103504,3113102,3109903,3087502,3092167,3108167,3090700,3098567,3101767,3085767,3104967,3111367],"length":1,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[3111646,3105246,3098846,3109387,3093384,3086986,3096588,3108446,3106188,3092446,3112586,3086046,3089246,3095646,3102988,3099787,3090184,3102046],"length":1,"stats":{"Line":8},"fn_name":null},{"line":271,"address":[3098903,3086900,3108503,3096502,3102103,3111703,3106102,3086103,3095703,3099701,3092503,3090098,3093298,3105303,3109301,3102902,3112500,3089303],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[3102820,3086818,3086161,3090016,3096420,3098961,3105361,3092561,3111761,3095761,3106020,3093216,3112418,3109219,3099619,3089361,3108561,3102161],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[3105417,3093133,3086217,3086735,3109136,3089417,3089933,3111817,3092617,3095817,3102217,3105937,3102737,3099017,3096337,3112335,3099536,3108617],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[3095425,3111425,3106620,3098625,3103420,3097020,3090616,3089025,3100219,3085825,3113018,3108225,3087418,3092225,3093816,3109819,3105025,3101825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[3093732,3101885,3095485,3112934,3092285,3103336,3090532,3108285,3106536,3105085,3111485,3089085,3087334,3085885,3096936,3098685,3100135,3109735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[3087215,3089145,3105145,3090269,3093613,3098821,3085945,3109472,3087071,3101945,3098745,3105221,3096673,3100016,3108345,3095621,3086021,3106273,3092421,3111621,3099872,3089221,3092345,3111545,3106417,3102021,3103073,3096817,3109616,3093469,3112671,3090413,3095545,3108421,3112815,3103217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[3099464,3099531,3089916,3086663,3102275,3112330,3089861,3093116,3096320,3102720,3086718,3099519,3108675,3096265,3105865,3112263,3092675,3093128,3089928,3105932,3112318,3111875,3109064,3086730,3099075,3105475,3093061,3086275,3102665,3102732,3109119,3089475,3096332,3109131,3105920,3095875],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[3086311,3093100,3112302,3105511,3096327,3092997,3096304,3089900,3105927,3102601,3086599,3089797,3095911,3111911,3109000,3105904,3092711,3108711,3099526,3099503,3086702,3086725,3102704,3102311,3109103,3099400,3109126,3089923,3096201,3093123,3089511,3112325,3102727,3112199,3105801,3099111],"length":1,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3101970,3093513,3096717,3106317,3099916,3089170,3105170,3108370,3092370,3112715,3103117,3111570,3085970,3098770,3087115,3095570,3090313,3109516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3111929,3086373,3108773,3086329,3089551,3105529,3111973,3102329,3089573,3092729,3099129,3092751,3105573,3095973,3108751,3105551,3086351,3089529,3111951,3108729,3099151,3099173,3102373,3095929,3095951,3092773,3102351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[3096196,3112043,3099395,3099244,3089641,3108844,3092841,3096045,3102596,3089792,3112194,3086443,3092992,3086594,3108995,3102445,3105796,3105645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3105611,3098251,3111051,3101451,3107851,3096011,3091851,3112011,3104651,3102411,3086411,3088651,3089611,3095051,3085451,3092811,3108811,3099211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[3114494,3113584],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq\u003cserde::de::impls::{impl#19}::deserialize::VecVisitor\u003cu8\u003e\u003e"},{"line":302,"address":[3113786,3113707,3113869,3113614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[3114033,3113834,3114131,3114055,3114150,3114112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[3114454,3113994,3114482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[3114466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[3114298,3114065,3114247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3114274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3114426,3114043,3114021,3114330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[3114410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[3114100,3114138,3114119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[3114167],"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[3114152,3113976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[3115378,3116274,3114512,3115408],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":334,"address":[3114840,3115736,3115467,3114571,3115566,3114670,3115648,3114752],"length":1,"stats":{"Line":6},"fn_name":null},{"line":336,"address":[3115077,3115706,3115973,3114810],"length":1,"stats":{"Line":5},"fn_name":null},{"line":337,"address":[3116079,3115183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[3115146,3116042,3116129,3115233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[3115337,3116233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[3116208,3115312,3116269,3115373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[3116601,3116304],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct\u003ctaos_query::common::value::de::ref_value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":358,"address":[3116385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[3116517,3116575,3116415],"length":1,"stats":{"Line":3},"fn_name":null},{"line":362,"address":[3116557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[3116449,3116502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[1945296],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[2545140,2545136],"length":1,"stats":{"Line":4},"fn_name":"value_de_value_ref"},{"line":385,"address":[2546131,2545280],"length":1,"stats":{"Line":1},"fn_name":"value_de_value_ref"},{"line":399,"address":[2561231,2564815,2563351,2546165,2562220,2559969,2563482,2557573,2557495,2559611,2564045,2560827,2558433,2559699,2545293,2565241,2560958,2562089,2558521,2558751,2562493],"length":1,"stats":{"Line":13},"fn_name":null},{"line":402,"address":[2557468,2558465,2558398,2557525],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[2562066,2559643,2561119,2559576,2560804,2563328,2559857,2560867,2558678,2562381,2563391,2562129],"length":1,"stats":{"Line":12},"fn_name":null},{"line":404,"address":[2564847,2563643,2564800],"length":1,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[2565408,2565412],"length":1,"stats":{"Line":4},"fn_name":"de_value_as_inner"},{"line":409,"address":[2565552,2568876,2568921],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":423,"address":[2568600,2568887,2571165,2570581,2571257,2569008,2569848,2568355,2571022,2570673,2568447,2569158,2569715,2569997,2570438,2570089,2565559],"length":1,"stats":{"Line":10},"fn_name":null},{"line":435,"address":[2568574,2568313,2568399],"length":1,"stats":{"Line":3},"fn_name":null},{"line":436,"address":[2569132,2568936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[2570046,2569985,2569674,2569767],"length":1,"stats":{"Line":4},"fn_name":null},{"line":439,"address":[2570569,2570630,2570332],"length":1,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[2571214,2571153,2570916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":444,"address":[2571520,2571524],"length":1,"stats":{"Line":4},"fn_name":"de_borrowed_str"},{"line":445,"address":[2571664,2571810],"length":1,"stats":{"Line":1},"fn_name":"de_borrowed_str"},{"line":472,"address":[2574237,2573844,2573103,2573522,2575051,2574343,2573738,2575435,2574959,2571843,2571671],"length":1,"stats":{"Line":7},"fn_name":null},{"line":481,"address":[2573133,2573088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[2573716,2573768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":484,"address":[2574215,2574267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[2574922,2575003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[2575362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":492,"address":[2575760,2575764],"length":1,"stats":{"Line":4},"fn_name":"de_string"},{"line":493,"address":[2575904,2576058],"length":1,"stats":{"Line":1},"fn_name":"de_string"},{"line":520,"address":[2580034,2580985,2575911,2578060,2579095,2579905,2578959,2578498,2580849,2579196,2581086,2581494,2580443,2576091],"length":1,"stats":{"Line":7},"fn_name":null},{"line":534,"address":[2577987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[2578425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[2578863,2579073,2579139],"length":1,"stats":{"Line":3},"fn_name":null},{"line":537,"address":[2580078,2580027,2579503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[2580753,2581029,2580963],"length":1,"stats":{"Line":3},"fn_name":null},{"line":539,"address":[2581468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[2581776,2581780],"length":1,"stats":{"Line":4},"fn_name":"de_json"},{"line":544,"address":[2582430,2581936,2582472],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":555,"address":[2581943,2582441,2581996,2582172],"length":1,"stats":{"Line":3},"fn_name":null},{"line":556,"address":[2581951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[2582145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[2583043,2583115,2582838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":566,"address":[2582487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[2583075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[2583008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[2583748,2583744],"length":1,"stats":{"Line":4},"fn_name":"de_newtype_struct"},{"line":575,"address":[2584145,2583904],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":587,"address":[2584275,2584179,2584013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":588,"address":[2583917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[2584208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[2584504,2584888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[2584940,2584850,2585134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":597,"address":[2585186,2585381,2585096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":598,"address":[2585433,2585628,2585343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":599,"address":[2585680,2585590,2585894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":627,"address":[2588669,2611995,2596002,2589335,2588003,2586005,2620661,2595335,2621327,2598667,2625993,2627327,2623992,2586671,2616663,2624659,2604665,2608665,2605332,2609997,2590001,2621993,2594001,2591333,2592667,2592000,2607999,2587337,2615329,2603331,2615996,2599333,2594668,2613995,2602664,2619995,2585837,2614662,2622659,2623325,2617330,2618663,2605999,2590667,2609331,2613328,2597335,2625326,2607333,2619329,2585945,2610663,2596669,2627952,2603998,2612661,2628421,2626660,2599999,2600665,2601997,2611329,2593334,2601331,2617997,2606666,2598001],"length":1,"stats":{"Line":66},"fn_name":null}],"covered":136,"coverable":200},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value","de","value.rs"],"content":"use super::super::*;\nuse super::*;\nuse serde::{\n    de::{self, value::Error, DeserializeSeed, IntoDeserializer, Visitor},\n    forward_to_deserialize_any,\n};\n\nimpl\u003c'de, 'b\u003e serde::de::EnumAccess\u003c'de\u003e for Value {\n    type Error = Error;\n\n    type Variant = UnitOnly;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let s = self.strict_as_str();\n        return Ok((\n            seed.deserialize(StringDeserializer {\n                input: s.to_string(),\n            })?,\n            UnitOnly,\n        ));\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumTimestampDeserializer {\n    value: Value,\n}\n\nimpl\u003c'b, 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumTimestampDeserializer {\n    type Error = Error;\n\n    type Variant = VariantTimestampDeserializer;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        // let variant = self.value.ty().as_variant_str();\n        // use BorrowedValue::*;\n        match self.value {\n            Value::Timestamp(Timestamp::Microseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Microseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            Value::Timestamp(Timestamp::Milliseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Milliseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            Value::Timestamp(Timestamp::Nanoseconds(v)) =\u003e Ok((\n                seed.deserialize(StringDeserializer {\n                    input: \"Nanoseconds\".to_string(),\n                })\n                .expect(\"\"),\n                VariantTimestampDeserializer { value: v },\n            )),\n            _ =\u003e todo!(),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\nstruct EnumValueDeserializer {\n    value: Value,\n}\n\n#[derive(Clone)]\nstruct StringDeserializer {\n    input: String,\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for StringDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.input)\n    }\n\n    forward_to_deserialize_any! {\n        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n        seq bytes byte_buf map unit_struct newtype_struct\n        tuple_struct struct tuple enum identifier ignored_any\n    }\n}\nimpl\u003c'de, 'b: 'de\u003e serde::de::EnumAccess\u003c'de\u003e for EnumValueDeserializer {\n    type Error = Error;\n\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let variant = self.value.ty().as_variant_str();\n\n        Ok((\n            seed.deserialize(StringDeserializer {\n                input: variant.to_string(),\n            })\n            .expect(\"\"),\n            self,\n        ))\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e de::VariantAccess\u003c'de\u003e for EnumValueDeserializer {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self.value)\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        _visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        todo!()\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::Deserializer\u003c'de\u003e for Value {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_any: {self:?}\");\n        use Value::*;\n        // todo!()\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            VarChar(v) =\u003e visitor.visit_string(v),\n            NChar(v) =\u003e visitor.visit_string(v),\n            Json(v) =\u003e v\n                .into_deserializer()\n                .deserialize_any(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e visitor.visit_i64(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.into_deserializer().deserialize_any(visitor)\n            }\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {bool i8 u8 i16 u16 i32 u32 i64 u64 f32 f64 char}\n\n    serde::forward_to_deserialize_any! {\n        unit\n        bytes byte_buf unit_struct\n        tuple_struct tuple identifier ignored_any\n    }\n\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str\");\n        use Value::*;\n        match self {\n            Null =\u003e visitor.visit_str(\"\"), // todo: empty string or error?\n            // Null =\u003e Err(Self::Error::from_string(\n            // \"expect non-optional String, but value is null\",\n            // )),\n            Bool(v) =\u003e visitor.visit_bool(v),\n            TinyInt(v) =\u003e visitor.visit_i8(v),\n            SmallInt(v) =\u003e visitor.visit_i16(v),\n            Int(v) =\u003e visitor.visit_i32(v),\n            BigInt(v) =\u003e visitor.visit_i64(v),\n            UTinyInt(v) =\u003e visitor.visit_u8(v),\n            USmallInt(v) =\u003e visitor.visit_u16(v),\n            UInt(v) =\u003e visitor.visit_u32(v),\n            UBigInt(v) =\u003e visitor.visit_u64(v),\n            Float(v) =\u003e visitor.visit_f32(v),\n            Double(v) =\u003e visitor.visit_f64(v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_string(v),\n            Json(v) =\u003e visitor.visit_string(v.to_string()),\n            Timestamp(v) =\u003e visitor.visit_string(\n                v.to_naive_datetime()\n                    .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                    .to_string(),\n            ),\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_string\");\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_option\");\n        if self.is_null() {\n            visitor.visit_none()\n        } else {\n            visitor.visit_some(self)\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"deserialize_newtype_struct: {_name}\");\n        use Value::*;\n        macro_rules! _v_ {\n            ($v:expr) =\u003e {\n                visitor.visit_newtype_struct($v.into_deserializer())\n            };\n        }\n        match self {\n            Null =\u003e visitor.visit_none(),\n            Bool(v) =\u003e _v_!(v),\n            TinyInt(v) =\u003e _v_!(v),\n            SmallInt(v) =\u003e _v_!(v),\n            Int(v) =\u003e _v_!(v),\n            BigInt(v) =\u003e _v_!(v),\n            UTinyInt(v) =\u003e _v_!(v),\n            USmallInt(v) =\u003e _v_!(v),\n            UInt(v) =\u003e _v_!(v),\n            UBigInt(v) =\u003e _v_!(v),\n            Float(v) =\u003e _v_!(v),\n            Double(v) =\u003e _v_!(v),\n            VarChar(v) | NChar(v) =\u003e visitor.visit_newtype_struct(v.as_str().into_deserializer()),\n            Json(v) =\u003e visitor\n                .visit_newtype_struct(v.into_deserializer())\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            Timestamp(v) =\u003e _v_!(v.as_raw_i64()),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                visitor.visit_newtype_struct(v.as_slice().into_deserializer())\n            }\n            _ =\u003e Err(\u003cSelf::Error as de::Error\u003e::custom(\n                \"un supported type to deserialize\",\n            )),\n        }\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_map\");\n        self.deserialize_any(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: serde::de::Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize seq by value\");\n        use Value::*;\n        match self {\n            Null =\u003e Vec::\u003cu8\u003e::new()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            Json(v) =\u003e v\n                .into_deserializer()\n                .deserialize_seq(visitor)\n                .map_err(\u003cSelf::Error as de::Error\u003e::custom),\n            VarChar(v) | NChar(v) =\u003e v\n                .as_bytes()\n                .to_vec()\n                .into_deserializer()\n                .deserialize_seq(visitor),\n            VarBinary(v) | Blob(v) | MediumBlob(v) =\u003e {\n                v.into_deserializer().deserialize_seq(visitor)\n            }\n            _ =\u003e todo!(),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"name: {name}, variants: {variants:?}\");\n\n        if name == \"Timestamp\" \u0026\u0026 variants == TIMESTAMP_VARIANTS {\n            return visitor.visit_enum(EnumTimestampDeserializer { value: self });\n        }\n        if name == \"Value\" \u0026\u0026 variants == VALUE_VARIANTS {\n            return visitor.visit_enum(EnumValueDeserializer {\n                // variants,\n                value: self,\n            });\n        }\n\n        visitor.visit_enum(self)\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self {\n            Value::Json(json) =\u003e json\n                .into_deserializer()\n                .deserialize_struct(name, fields, visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de\u003e serde::de::IntoDeserializer\u003c'de, Error\u003e for Value {\n    type Deserializer = Self;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use serde_json::json;\n    use taos_macros::test;\n\n    #[test]\n    fn value_de_value() {\n        use std::cmp::PartialEq;\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr) *) =\u003e {\n                $(\n                    {\n                        let v = $v;\n                        let d = Value::deserialize(v.clone().into_deserializer()).expect(\"\");\n                        assert!(v.eq(\u0026d));\n                    }\n                )*\n            }\n        }\n        _de_value!(\n                Null Bool(true) TinyInt(0xf) SmallInt(0xfff) Int(0xffff) BigInt(-1) Float(1.0) Double(1.0)\n                UTinyInt(0xf) USmallInt(0xfff) UInt(0xffff) UBigInt(0xffffffff)\n                Timestamp(crate::common::timestamp::Timestamp::Milliseconds(0)) VarChar(\"anything\".to_string())\n                NChar(\"\".to_string()) VarBinary(vec![1,2,3]) Blob(vec![1,2, 3]) MediumBlob(vec![1,2,3])\n                Json(serde_json::json!({\"name\": \"ABC\"}))\n        );\n    }\n\n    #[test]\n    fn de_value_as_inner() {\n        use Value::*;\n        macro_rules! _de_value {\n            ($($v:expr, $ty:ty, $tv:expr) *) =\u003e {\n                $(\n                    {\n                        let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"\");\n                        assert_eq!(d, $tv);\n                    }\n                )*\n            }\n        }\n\n        _de_value!(\n            Null, Option\u003cu8\u003e, None\n            TinyInt(-1), i8, -1\n            SmallInt(-1), i16, -1\n            Int(0x0fff_ffff), i32, 0x0fff_ffff\n            BigInt(0xffffffff), i64, 0xffffffff\n            UTinyInt(0xff), u8, 0xff\n            USmallInt(0xffff), u16, 0xffff\n            UInt(0x_ffff_ffff), u32, 0x_ffff_ffff\n            UBigInt(0x_ffff_ffff_ffff_ffff), u64, 0x_ffff_ffff_ffff_ffff\n            Float(1.0), f32, 1.0\n            Double(f64::MAX), f64, f64::MAX\n            VarChar(\"\".to_string()), String, \"\".to_string()\n            NChar(\"\".to_string()), String, \"\".to_string()\n            Timestamp(crate::Timestamp::Milliseconds(1)), crate::Timestamp, crate::Timestamp::Milliseconds(1)\n            VarBinary(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            Blob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n            MediumBlob(vec![0, 1,2]), Vec\u003cu8\u003e, vec![0, 1, 2]\n        );\n    }\n\n    #[test]\n    fn de_str() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_str {\n            ($v:expr, is_err) =\u003e {\n                assert!(String::deserialize($v.into_deserializer()).is_err());\n            };\n            ($v:expr, $tv:expr) =\u003e {\n                assert_eq!(String::deserialize($v.into_deserializer()).expect(\"str\"), $tv);\n            };\n            ($($v:expr, $c:ident) *) =\u003e {\n                $(\n                    {\n                        assert!(String::deserialize($v.into_deserializer()).$c());\n                    }\n                )*\n            };\n            ($($v2:expr, is_err) +; $($v:expr, $tv:expr) + ) =\u003e {\n                $(\n                    _de_str!($v2, is_err);\n                )*\n                $(\n                    _de_str!($v, $tv);\n                )*\n            }\n        }\n        _de_str! {\n            TinyInt(-1), is_err\n            SmallInt(-1), is_err\n            Int(-1), is_err\n            BigInt(-1), is_err\n            UTinyInt(1), is_err\n            USmallInt(1), is_err\n            UInt(1), is_err\n            UBigInt(1), is_err\n            ;\n\n            Null, \"\"\n            Timestamp(crate::Timestamp::Milliseconds(0)), \"1970-01-01T00:00:00\"\n            VarChar(\"String\".to_string()), \"String\"\n            VarChar(\"\".to_string()), \"\"\n            Json(json!(\"abc\")), json!(\"abc\").to_string()\n            Json(json!({ \"name\": \"abc\"})), json!({ \"name\": \"abc\"}).to_string()\n            Json(json!(1)), json!(1).to_string()\n            Json(json!(null)), json!(null).to_string()\n        };\n    }\n\n    #[test]\n    fn de_json() {\n        use Value::*;\n\n        macro_rules! _de_json {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let v = Json($v);\n                let d = \u003c$ty\u003e::deserialize(v.clone().into_deserializer()).expect(\"de json\");\n                assert_eq!(d, $tv);\n            }};\n        }\n\n        _de_json!(\n            serde_json::json!(\"string\"),\n            String,\n            \"\\\"string\\\"\".to_string()\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Obj {\n            name: String,\n        }\n        _de_json!(\n            serde_json::json!({ \"name\": \"string\" }),\n            Obj,\n            Obj {\n                name: \"string\".to_string()\n            }\n        );\n    }\n\n    #[test]\n    fn de_newtype_struct() {\n        use serde_json::json;\n        use Value::*;\n\n        macro_rules! _de_ty {\n            ($v:expr, $ty:ty, $tv:expr) =\u003e {{\n                let d = \u003c$ty\u003e::deserialize($v.into_deserializer()).expect(\"de type\");\n                assert_eq!(d, $tv);\n            }};\n        }\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct JsonStr(String);\n        _de_ty!(\n            Json(json!(\"string\")),\n            JsonStr,\n            JsonStr(\"string\".to_string())\n        );\n\n        #[derive(Debug, PartialEq, Eq, Deserialize)]\n        struct Primi\u003cT\u003e(T);\n        _de_ty!(Json(json!(1)), Primi\u003ci32\u003e, Primi(1));\n        _de_ty!(TinyInt(1), Primi\u003ci8\u003e, Primi(1));\n        _de_ty!(SmallInt(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(Int(1), Primi\u003ci64\u003e, Primi(1));\n        _de_ty!(BigInt(1), Primi\u003ci64\u003e, Primi(1));\n\n        macro_rules! _de_prim {\n            ($v:ident, $ty:ty, $inner:literal) =\u003e {\n                log::debug!(\n                    \"ty: {}, prim: {}\",\n                    stringify!($v),\n                    std::any::type_name::\u003c$ty\u003e()\n                );\n                _de_ty!($v($inner), Primi\u003c$ty\u003e, Primi($inner));\n            };\n        }\n\n        macro_rules! _de_prim_cross {\n            ($($vty:ident) +, $tt:ty) =\u003e {\n                $(\n                  _de_prim!($vty, $tt, 1);\n                )*\n            };\n            ($($ty:ty) +) =\u003e {\n                $(\n                    _de_prim_cross!(TinyInt SmallInt Int BigInt UTinyInt USmallInt UInt UBigInt, $ty);\n                )*\n            };\n            () =\u003e {\n                _de_prim_cross!(i8 i16 i32 i64 u8 u16 u32 u64);\n            };\n        }\n        _de_prim_cross!();\n    }\n}\n","traces":[{"line":13,"address":[3116624,3117498,3117034,3117088],"length":1,"stats":{"Line":0},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":17,"address":[3116744,3116652,3117208,3117116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3117395,3116931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[3116760,3117352,3117364,3116978,3117286,3116888,3116900,3117483,3116822,3117224,3117442,3117019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3117245,3116781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1960672,1961808,1962893,1961757],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":43,"address":[1960694,1961830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[1961465,1960934,1962070,1962601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1962478,1961342,1960951,1961404,1962087,1962540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1960967,1962103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1961457,1962593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1961686,1962002,1960866,1962822],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[1960883,1962758,1961551,1962019,1961622,1962687],"length":1,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[1962035,1960899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1962814,1961678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1961238,1962374,1962138,1961002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[1961019,1962310,1962155,1961174,1961103,1962239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1962171,1961035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[1962366,1961230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1962944,1963008],"length":1,"stats":{"Line":3},"fn_name":"deserialize_any\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__FieldVisitor\u003e"},{"line":87,"address":[1962955,1963019],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[1963568,1964030,1963072,1963534],"length":1,"stats":{"Line":1},"fn_name":"variant_seed\u003ccore::marker::PhantomData\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Field\u003e\u003e"},{"line":105,"address":[1963598,1963182,1963102,1963678],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[1963936,1963440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[1963374,1963802,1963870,1963234,1963306,1963730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[1963258,1963754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1963418,1963914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[2711072],"length":1,"stats":{"Line":1},"fn_name":"unit_variant"},{"line":121,"address":[2711076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[1964320,1964512,1964384,1964704,1964832,1964576,1964064,1964640,1964768,1964256,1964896,1965024,1964960,1964128,1964448,1964192],"length":1,"stats":{"Line":15},"fn_name":"newtype_variant_seed\u003ccore::marker::PhantomData\u003cu64\u003e\u003e"},{"line":128,"address":[1964590,1964526,1964718,1964142,1965038,1964398,1964846,1964334,1964910,1964270,1964782,1964974,1964462,1964206,1964078,1964654],"length":1,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[3146873,3134912,3134581,3122229,3127154,3144403,3124693,3146986,3151954,3142042,3149496,3132118,3119754,3139872,3132005,3137046,3139545,3147328,3125024,3151841,3142384,3137376,3119641,3117552,3120096,3144848,3141929,3129622,3124580,3129952,3149383,3127041,3127488,3132448,3139432,3122116,3122560,3134468,3136933,3144516,3149824,3129509],"length":1,"stats":{"Line":12},"fn_name":"deserialize_any\u003cserde::de::impls::{impl#49}::deserialize::PrimitiveVisitor\u003e"},{"line":157,"address":[3134934,3147629,3127893,3130171,3142685,3117957,3127707,3132667,3135317,3125046,3120397,3139894,3147350,3145149,3145067,3140091,3125243,3120118,3150043,3127789,3127510,3117771,3132749,3147547,3150125,3125429,3147733,3137595,3117853,3122965,3137398,3140277,3149846,3142603,3137677,3122779,3129974,3145253,3120315,3135131,3125325,3142406,3130357,3144870,3122582,3117574,3142789,3130253,3122861,3140173,3135213,3120501,3150229,3137781,3132853,3132470],"length":1,"stats":{"Line":37},"fn_name":null},{"line":160,"address":[3146328,3126609,3131518,3120457,3126504,3117913,3141489,3143864,3140233,3122921,3141384,3133928,3127849,3129022,3124145,3128968,3150185,3136497,3119088,3119142,3145209,3124094,3151409,3148945,3130313,3138888,3121576,3132809,3134033,3119193,3129073,3138993,3135273,3125385,3131464,3143918,3138942,3143969,3141438,3136392,3131569,3147689,3148840,3148894,3142745,3151304,3121630,3121681,3151358,3136446,3126558,3146433,3146382,3137737,3124040,3133982],"length":1,"stats":{"Line":13},"fn_name":null},{"line":161,"address":[3120688,3133040,3149284,3130544,3145440,3119542,3124481,3146774,3122017,3125616,3137968,3118144,3126942,3141830,3150416,3134369,3144304,3151742,3131906,3140464,3123152,3142976,3147920,3139333,3136834,3128080,3129410,3135504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[3118176,3151737,3135532,3137996,3145468,3120716,3124476,3146769,3130572,3129405,3134364,3139328,3136829,3143004,3141825,3150444,3119537,3128108,3144299,3126937,3140492,3133068,3122012,3149279,3125644,3147948,3131901,3123180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[3135576,3147992,3151732,3120760,3133112,3146764,3129400,3144294,3143048,3130616,3134359,3119532,3125688,3131896,3136824,3149274,3145512,3122007,3124471,3126932,3139323,3123224,3140536,3138040,3141820,3128152,3118224,3150488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[3133154,3151727,3139318,3149269,3141815,3150530,3135618,3138086,3120802,3143090,3118270,3131891,3123266,3136819,3128194,3148038,3134354,3126927,3119527,3129395,3122002,3125730,3124466,3144289,3145554,3130662,3146759,3140582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3133197,3129390,3128237,3131886,3144284,3140629,3120845,3123309,3143133,3136814,3119522,3149264,3125773,3121997,3135661,3138133,3146754,3150573,3126922,3148085,3145597,3134349,3124461,3118317,3141810,3151722,3130709,3139313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[3121992,3123347,3130751,3131881,3148127,3139308,3126917,3146749,3141805,3128275,3120883,3140671,3129385,3135699,3143171,3151717,3150611,3124456,3119517,3133235,3149259,3145635,3118359,3125811,3136809,3144279,3138175,3134344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[3136704,3149150,3131147,3151612,3146644,3121887,3133627,3134239,3121275,3151003,3123739,3129280,3126812,3126203,3138571,3143563,3144174,3139199,3148523,3124351,3118771,3131772,3128667,3136091,3141067,3119408,3141696,3146027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[3131767,3143605,3133669,3118817,3123781,3128709,3139194,3121317,3141691,3121882,3144169,3134234,3131193,3148569,3151607,3136133,3146639,3129275,3136699,3146069,3126245,3124346,3151045,3141113,3138617,3119403,3149145,3126807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[3131762,3121360,3118864,3143648,3126288,3134229,3136694,3139189,3149140,3151602,3138664,3148616,3124341,3141160,3123824,3119398,3131240,3144164,3146634,3126802,3151088,3141686,3121877,3146112,3128752,3133712,3129270,3136176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[3134224,3151126,3141202,3139184,3136689,3146150,3143686,3144159,3148658,3129265,3131757,3121398,3126326,3138706,3136214,3149135,3118906,3133750,3119393,3121872,3146629,3141681,3151597,3123862,3126797,3131282,3128790,3124336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[3133275,3131876,3149254,3141800,3125851,3121987,3134339,3118403,3135739,3139303,3145675,3136804,3138219,3144274,3129380,3148171,3151712,3128315,3146744,3130795,3150651,3123387,3120923,3119512,3126912,3124451,3140715,3143211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[3119507,3135781,3118449,3143253,3131871,3146739,3139298,3144269,3123429,3136799,3130837,3120965,3150693,3141795,3149249,3124446,3133317,3151707,3125893,3134334,3145717,3121982,3140757,3148213,3126907,3128357,3138261,3129375],"length":1,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[3126902,3148255,3143295,3150735,3123471,3136794,3118495,3121977,3144264,3140799,3125935,3139293,3124441,3128399,3130879,3119502,3145759,3146734,3151702,3121007,3149244,3138303,3129370,3133359,3134329,3141790,3131866,3135823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[3134244,3148423,3141701,3149155,3128567,3121892,3140967,3136709,3138471,3133527,3139204,3150903,3119413,3146649,3123639,3135991,3151617,3144179,3118667,3121175,3131777,3143463,3124356,3126103,3126817,3145927,3131047,3129285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[3131321,3121840,3126765,3121433,3136249,3151161,3123897,3138745,3118945,3124304,3129233,3134192,3151565,3139152,3141241,3146593,3143721,3144127,3131725,3119337,3133785,3136657,3148697,3146185,3141649,3149103,3128825,3126361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[3149079,3151541,3139128,3124280,3136633,3126741,3119329,3121816,3129209,3141625,3146569,3131701,3144103,3134168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[3135918,3146654,3149160,3134249,3126030,3118594,3138398,3148350,3129290,3143390,3121897,3131782,3139209,3144184,3141706,3128494,3151622,3124361,3145854,3133454,3126822,3140894,3136714,3121102,3123566,3119418,3130974,3150830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3119098,3121586,3133938,3133884,3136453,3126460,3138898,3141340,3133989,3146389,3121637,3126514,3119044,3128978,3131420,3151260,3128924,3124101,3146338,3136402,3146284,3123996,3129029,3151314,3148796,3138844,3131474,3148850,3119149,3121532,3131525,3148901,3143874,3143820,3124050,3136348,3138949,3141445,3141394,3151365,3143925,3126565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[3129124,3119244,3148994,3131616,3134083,3121731,3136548,3146484,3139043,3141540,3144018,3151456,3126656,3124195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[3125575,3147879,3130503,3126626,3120647,3139010,3145399,3128039,3150375,3129090,3148962,3131586,3136514,3134050,3132999,3119210,3140423,3141506,3142935,3135463,3118103,3146450,3121698,3124162,3151426,3143986,3123111,3137927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[3154232,3153723,3152288],"length":1,"stats":{"Line":1},"fn_name":"deserialize_str\u003cserde::de::impls::StringVisitor\u003e"},{"line":201,"address":[3152467,3152546,3152629,3152310],"length":1,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[3152594,3153293,3153168],"length":1,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[3152767,3154074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[3152810,3154069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[3152858,3154064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[3152904,3154059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[3152951,3154054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[3154049,3152993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[3153308,3153749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[3153744,3153354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[3153401,3153739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[3153734,3153443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[3154044,3153037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[3154039,3153083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[3153759,3154034,3153124,3153249],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[3153606,3153482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[3153178,3153970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[3153862,3153234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[3153572,3152726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[3154912,3154432,3154885],"length":1,"stats":{"Line":1},"fn_name":"deserialize_string\u003cserde::de::impls::StringVisitor\u003e"},{"line":236,"address":[3154761,3154454,3154642,3154563],"length":1,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[3154695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[3154928,3155431,3155458],"length":1,"stats":{"Line":1},"fn_name":"deserialize_option\u003cserde::de::impls::OptionVisitor\u003cu8\u003e\u003e"},{"line":244,"address":[3154950,3155197,3155138,3155059],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[3155186,3155295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[3155382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[3155311,3155415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[3161712,3178031,3167261,3175904,3165793,3183577,3186192,3187660,3159584,3169873,3163180,3171824,3175421,3171341,3179984,3184064,3188144,3159099,3190269,3173953,3182109,3163664,3191737,3167744,3179499,3155504,3157631],"length":1,"stats":{"Line":9},"fn_name":"deserialize_newtype_struct\u003ctaos_query::common::value::de::value::tests::de_newtype_struct::de_newtype_struct::_::{impl#0}::deserialize::__Visitor\u003ci16\u003e\u003e"},{"line":260,"address":[3176369,3163711,3184529,3188726,3184432,3180352,3159631,3156086,3180566,3167791,3184111,3180031,3155551,3172289,3188191,3164129,3168209,3164246,3159952,3180449,3172406,3188609,3175951,3155969,3160049,3168112,3188512,3168326,3171871,3176486,3172192,3184646,3160166,3176272,3164032,3155872],"length":1,"stats":{"Line":27},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[3189401,3157269,3165049,3177726,3188681,3172361,3165429,3160121,3185321,3164201,3173700,3156041,3185886,3156889,3161406,3165486,3169509,3177161,3190020,3184601,3177780,3157326,3189909,3181860,3181749,3169001,3181369,3173646,3161349,3177669,3160969,3177289,3185449,3157380,3180521,3169129,3185940,3181806,3189966,3189529,3168281,3185829,3160841,3161460,3173589,3165540,3169620,3176441,3181241,3156761,3169566,3164921,3173209,3173081],"length":1,"stats":{"Line":9},"fn_name":null},{"line":268,"address":[3163075,3168549,3164469,3156309,3184869,3191632,3171236,3175316,3176709,3158994,3188949,3180789,3179394,3160389,3187555,3183472,3167156,3172629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[3156335,3175225,3191541,3171145,3180815,3168575,3179303,3183381,3158903,3162984,3176735,3188975,3164495,3172655,3187464,3160415,3184895,3167065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3160472,3158815,3183293,3187376,3189032,3180872,3191453,3166977,3176792,3168632,3162896,3175137,3164552,3184952,3172712,3156392,3171057,3179215],"length":1,"stats":{"Line":8},"fn_name":null},{"line":271,"address":[3179126,3160527,3189087,3172767,3180927,3164607,3156447,3168687,3166888,3170968,3176847,3158726,3185007,3162807,3187287,3175048,3191364,3183204],"length":1,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[3166803,3179041,3156504,3160584,3187202,3180984,3174963,3164664,3191279,3158641,3168744,3183119,3185064,3170883,3176904,3189144,3162722,3172824],"length":1,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[3170797,3174877,3187116,3162636,3164715,3189195,3181035,3166717,3191193,3178955,3160635,3176955,3172875,3185115,3183033,3158555,3156555,3168795],"length":1,"stats":{"Line":8},"fn_name":null},{"line":274,"address":[3186563,3162083,3160982,3178402,3185462,3166164,3173222,3182480,3169142,3158002,3181382,3170244,3189542,3190640,3177302,3165062,3156902,3174324],"length":1,"stats":{"Line":8},"fn_name":null},{"line":275,"address":[3178316,3185514,3189594,3190554,3170158,3186477,3165114,3181434,3169194,3156954,3182394,3166078,3177354,3157916,3174238,3173274,3161034,3161997],"length":1,"stats":{"Line":8},"fn_name":null},{"line":276,"address":[3178234,3182312,3165168,3157834,3161915,3169248,3189648,3161088,3190472,3185568,3181488,3170076,3157008,3177408,3174156,3165996,3173328,3186395],"length":1,"stats":{"Line":8},"fn_name":null},{"line":277,"address":[3177456,3161832,3186312,3157056,3182229,3161136,3181536,3189696,3174073,3165913,3169993,3173376,3190389,3185616,3165216,3157751,3178151,3169296],"length":1,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[3191109,3189249,3174793,3178871,3185169,3187032,3172929,3162552,3156609,3160689,3158471,3181089,3170713,3166633,3177009,3168849,3164769,3182949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[3178787,3166549,3158387,3181143,3186948,3191025,3168903,3182865,3174709,3164823,3156663,3172983,3185223,3170629,3162468,3160743,3189303,3177063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[3164877,3173037,3190869,3160797,3160925,3182709,3166393,3189357,3190725,3177245,3185277,3185405,3158231,3165005,3158087,3173165,3182565,3174553,3156845,3156717,3166249,3170329,3181197,3174409,3170473,3177117,3186648,3168957,3169085,3178487,3186792,3162168,3181325,3162312,3189485,3178631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3169921,3177507,3190317,3157746,3169347,3186240,3173427,3165896,3178146,3161815,3169976,3165267,3182157,3174056,3186307,3182212,3174001,3186295,3157734,3185667,3161760,3178079,3190384,3165841,3161827,3165908,3182224,3174068,3190372,3157679,3169988,3189747,3161187,3178134,3181587,3157107],"length":1,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[3165804,3169395,3157718,3161822,3185715,3190379,3157741,3161235,3161723,3165903,3178118,3165880,3174063,3169884,3186203,3174040,3190356,3178141,3161799,3181635,3157155,3157642,3173964,3169983,3182120,3173475,3186279,3177555,3178042,3165315,3169960,3182219,3190280,3182196,3186302,3189795],"length":1,"stats":{"Line":4},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[3190769,3177174,3158131,3182609,3181254,3160854,3164934,3174453,3169014,3170373,3189414,3186692,3173094,3178531,3162212,3156774,3166293,3185334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3189976,3157282,3165496,3169465,3157225,3169522,3189865,3161305,3157336,3173602,3165385,3177625,3185842,3181816,3181705,3161416,3181762,3165442,3177736,3173545,3185785,3189922,3173656,3177682,3185896,3161362,3169576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3165791,3186190,3169871,3157438,3178029,3177838,3161519,3185999,3173760,3182107,3173951,3165600,3181916,3190076,3190267,3161710,3157629,3169680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[3172579,3168499,3157406,3181886,3173726,3185966,3165566,3190046,3161486,3177806,3156259,3176659,3169646,3180739,3164419,3160339,3184819,3188899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[3193433,3193544,3192224],"length":1,"stats":{"Line":1},"fn_name":"deserialize_seq\u003cserde::de::impls::{impl#19}::deserialize::VecVisitor\u003cu8\u003e\u003e"},{"line":306,"address":[3192514,3192597,3192435,3192246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[3192562,3193056,3193107,3192852,3192798,3193005],"length":1,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[3193488,3192727,3193460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3193472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[3193233,3192862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[3193209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3193270,3192808,3193404,3193341,3192754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[3193388,3193411,3193287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[3193012,3193063,3192961],"length":1,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[3193111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[3196063,3196036,3194884,3193776,3194911,3194928],"length":1,"stats":{"Line":2},"fn_name":"deserialize_enum\u003ctaos_query::common::timestamp::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":337,"address":[3193939,3195173,3194976,3194021,3193824,3194109,3195091,3195261],"length":1,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[3194079,3195231,3195498,3194346],"length":1,"stats":{"Line":4},"fn_name":null},{"line":340,"address":[3194455,3195607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[3195567,3195740,3194588,3194415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[3195949,3194797,3194746,3195898],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[3195906,3194754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[3194667,3195819,3196017,3194865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[3196486,3196080,3196527],"length":1,"stats":{"Line":1},"fn_name":"deserialize_struct\u003ctaos_query::common::value::de::value::tests::de_json::de_json::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":361,"address":[3196154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[3196446,3196200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[3196425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[3196284,3196384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[1945312],"length":1,"stats":{"Line":1},"fn_name":"into_deserializer"},{"line":375,"address":[1945320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[2102516,2102512],"length":1,"stats":{"Line":4},"fn_name":"value_de_value"},{"line":387,"address":[2102656,2102935,2102958],"length":1,"stats":{"Line":1},"fn_name":"value_de_value"},{"line":401,"address":[2104534,2106426,2103612,2104848,2102669,2103005,2105152,2108290,2108972,2107132,2107518,2103919,2103306,2102946,2105458,2106779,2106074,2105765,2102695,2107904,2104227],"length":1,"stats":{"Line":21},"fn_name":null},{"line":402,"address":[2103884,2102973,2104816,2104191,2102677,2103274,2104499,2103578],"length":1,"stats":{"Line":8},"fn_name":null},{"line":403,"address":[2105730,2106042,2105120,2105424],"length":1,"stats":{"Line":4},"fn_name":null},{"line":404,"address":[2106346,2106698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":405,"address":[2107051,2108176,2107404,2107790],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[2108562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[2109268,2109264],"length":1,"stats":{"Line":4},"fn_name":"de_value_as_inner"},{"line":411,"address":[2112751,2112778,2109408],"length":1,"stats":{"Line":1},"fn_name":"de_value_as_inner"},{"line":424,"address":[2113566,2110142,2113704,2112980,2113807,2113335,2114967,2109429,2114238,2110658,2114772,2112762,2110913,2114875,2111171,2110399,2112368,2111692,2112873,2111973,2109637,2112475,2112268,2114341,2114433,2109888,2113899,2111428],"length":1,"stats":{"Line":21},"fn_name":null},{"line":425,"address":[2109421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[2109621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[2109870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[2110123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[2110378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[2110642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[2110895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[2111152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[2111408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[2111667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[2111948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[2112449,2112226,2112312],"length":1,"stats":{"Line":3},"fn_name":null},{"line":437,"address":[2112954,2112793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[2113271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[2113615,2113856,2113528,2113795],"length":1,"stats":{"Line":4},"fn_name":null},{"line":440,"address":[2114390,2114329,2114124],"length":1,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[2114924,2114658,2114863],"length":1,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[2115200,2115204],"length":1,"stats":{"Line":4},"fn_name":"de_str"},{"line":446,"address":[2115515,2115344],"length":1,"stats":{"Line":1},"fn_name":"de_str"},{"line":473,"address":[2115769,2117344,2120411,2116554,2120985,2119493,2118746,2118541,2118645,2115351,2120616,2121093,2118128,2116161,2115572,2117736,2116357,2115548,2116752,2115383,2120515,2115967,2116938,2119999,2119590],"length":1,"stats":{"Line":18},"fn_name":null},{"line":474,"address":[2115367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[2115554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[2115750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[2115947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[2116145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[2116339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[2116535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[2116732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[2116930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[2117280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[2117655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[2118047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[2118623,2118689,2118421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[2119035,2119583,2119634],"length":1,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[2120559,2120493,2120291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[2121067,2120905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[2121376,2121380],"length":1,"stats":{"Line":4},"fn_name":"de_json"},{"line":496,"address":[2121520,2122029,2122071],"length":1,"stats":{"Line":1},"fn_name":"de_json"},{"line":507,"address":[2122040,2121527,2121574,2121771],"length":1,"stats":{"Line":3},"fn_name":null},{"line":508,"address":[2121535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[2121744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[2122663,2122437,2122735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[2122086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[2122695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[2122628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[2123364,2123360],"length":1,"stats":{"Line":4},"fn_name":"de_newtype_struct"},{"line":527,"address":[2124068,2124042,2123504],"length":1,"stats":{"Line":1},"fn_name":"de_newtype_struct"},{"line":539,"address":[2123826,2124053,2123637,2123754],"length":1,"stats":{"Line":3},"fn_name":null},{"line":540,"address":[2123517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[2123786,2123719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[2124083,2124443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[2124708,2124487,2124388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[2124975,2124651,2124752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":550,"address":[2125243,2124917,2125019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[2125287,2125184,2125509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[2146876,2141387,2139333,2135217,2160590,2134531,2169254,2126988,2148932,2168760,2150305,2137275,2129729,2157161,2129044,2140016,2163331,2131102,2135904,2158536,2126303,2130415,2161277,2138646,2153046,2150988,2164702,2165388,2136592,2153730,2166075,2142074,2144819,2147564,2167447,2162645,2137960,2156475,2128361,2140701,2133159,2159904,2133847,2164018,2157848,2145503,2146189,2142758,2131786,2148247,2125452,2144131,2125620,2155791,2143444,2168127,2125560,2154416,2161960,2152359,2151673,2166763,2159219,2155103,2127674,2132472,2149618],"length":1,"stats":{"Line":66},"fn_name":null}],"covered":155,"coverable":216},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","common","value.rs"],"content":"use std::{borrow::Cow, fmt::Display, str::Utf8Error};\n\nuse rust_decimal::prelude::*;\nuse serde::{Deserialize, Serialize};\n\nuse super::{Timestamp, Ty};\n\n#[derive(Debug, Clone)]\npub enum BorrowedValue\u003c'b\u003e {\n    Null,        // 0\n    Bool(bool),  // 1\n    TinyInt(i8), // 2\n    SmallInt(i16),\n    Int(i32),\n    BigInt(i64),\n    Float(f32),\n    Double(f64),\n    VarChar(\u0026'b str),\n    Timestamp(Timestamp),\n    NChar(Cow\u003c'b, str\u003e),\n    UTinyInt(u8),\n    USmallInt(u16),\n    UInt(u32),\n    UBigInt(u64), // 14\n    Json(Cow\u003c'b, [u8]\u003e),\n    VarBinary(\u0026'b [u8]),\n    Decimal(Decimal),\n    Blob(\u0026'b [u8]),\n    MediumBlob(\u0026'b [u8]),\n}\n\nimpl\u003c'b\u003e BorrowedValue\u003c'b\u003e {\n    /// The data type of this value.\n    pub const fn ty(\u0026self) -\u003e Ty {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Ty::Null,\n            Bool(_) =\u003e Ty::Bool,\n            TinyInt(_) =\u003e Ty::TinyInt,\n            SmallInt(_) =\u003e Ty::SmallInt,\n            Int(_) =\u003e Ty::Int,\n            BigInt(_) =\u003e Ty::BigInt,\n            UTinyInt(_) =\u003e Ty::UTinyInt,\n            USmallInt(_) =\u003e Ty::USmallInt,\n            UInt(_) =\u003e Ty::UInt,\n            UBigInt(_) =\u003e Ty::UBigInt,\n            Float(_) =\u003e Ty::Float,\n            Double(_) =\u003e Ty::Double,\n            VarChar(_) =\u003e Ty::VarChar,\n            Timestamp(_) =\u003e Ty::Timestamp,\n            Json(_) =\u003e Ty::Json,\n            NChar(_) =\u003e Ty::NChar,\n            VarBinary(_) =\u003e Ty::VarBinary,\n            Decimal(_) =\u003e Ty::Decimal,\n            Blob(_) =\u003e Ty::Blob,\n            MediumBlob(_) =\u003e Ty::MediumBlob,\n        }\n    }\n\n    /// Check if the value is null.\n    pub const fn is_null(\u0026self) -\u003e bool {\n        matches!(self, BorrowedValue::Null)\n    }\n    /// Only VarChar, NChar, Json could be treated as [\u0026str].\n    fn strict_as_str(\u0026self) -\u003e \u0026str {\n        use BorrowedValue::*;\n        match self {\n            VarChar(v) =\u003e *v,\n            NChar(v) =\u003e \u0026v,\n            Null =\u003e panic!(\"expect str but value is null\"),\n            Timestamp(_) =\u003e panic!(\"expect str but value is timestamp\"),\n            _ =\u003e panic!(\"expect str but only varchar/binary/nchar is supported\"),\n        }\n    }\n    pub fn to_string(\u0026self) -\u003e Result\u003cString, Utf8Error\u003e {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Ok(String::new()),\n            VarChar(v) =\u003e Ok(v.to_string()),\n            Json(v) =\u003e Ok(unsafe { std::str::from_utf8_unchecked(v) }.to_string()),\n            NChar(v) =\u003e Ok(v.to_string()),\n            TinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            SmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            Int(v) =\u003e Ok(format!(\"{v}\")),\n            BigInt(v) =\u003e Ok(format!(\"{v}\")),\n            UTinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            USmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            UInt(v) =\u003e Ok(format!(\"{v}\")),\n            UBigInt(v) =\u003e Ok(format!(\"{v}\")),\n            Float(v) =\u003e Ok(format!(\"{v}\")),\n            Double(v) =\u003e Ok(format!(\"{v}\")),\n            Timestamp(v) =\u003e Ok(v\n                .to_naive_datetime()\n                .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                .to_string()),\n            _ =\u003e unreachable!(\"un supported type to string\"),\n        }\n    }\n\n    pub fn to_value(\u0026self) -\u003e Value {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Value::Null,\n            Bool(v) =\u003e Value::Bool(*v),\n            TinyInt(v) =\u003e Value::TinyInt(*v),\n            SmallInt(v) =\u003e Value::SmallInt(*v),\n            Int(v) =\u003e Value::Int(*v),\n            BigInt(v) =\u003e Value::BigInt(*v),\n            UTinyInt(v) =\u003e Value::UTinyInt(*v),\n            USmallInt(v) =\u003e Value::USmallInt(*v),\n            UInt(v) =\u003e Value::UInt(*v),\n            UBigInt(v) =\u003e Value::UBigInt(*v),\n            Float(v) =\u003e Value::Float(*v),\n            Double(v) =\u003e Value::Double(*v),\n            VarChar(v) =\u003e Value::VarChar(v.to_string()),\n            Timestamp(v) =\u003e Value::Timestamp(*v),\n            Json(v) =\u003e {\n                Value::Json(serde_json::from_slice(v).expect(\"json should always be deserialized\"))\n            }\n            NChar(str) =\u003e Value::NChar(str.to_string()),\n            VarBinary(_) =\u003e todo!(),\n            Decimal(_) =\u003e todo!(),\n            Blob(_) =\u003e todo!(),\n            MediumBlob(_) =\u003e todo!(),\n        }\n    }\n\n    #[inline]\n    pub fn into_value(self) -\u003e Value {\n        use BorrowedValue::*;\n        match self {\n            Null =\u003e Value::Null,\n            Bool(v) =\u003e Value::Bool(v),\n            TinyInt(v) =\u003e Value::TinyInt(v),\n            SmallInt(v) =\u003e Value::SmallInt(v),\n            Int(v) =\u003e Value::Int(v),\n            BigInt(v) =\u003e Value::BigInt(v),\n            UTinyInt(v) =\u003e Value::UTinyInt(v),\n            USmallInt(v) =\u003e Value::USmallInt(v),\n            UInt(v) =\u003e Value::UInt(v),\n            UBigInt(v) =\u003e Value::UBigInt(v),\n            Float(v) =\u003e Value::Float(v),\n            Double(v) =\u003e Value::Double(v),\n            VarChar(v) =\u003e Value::VarChar(v.to_string()),\n            Timestamp(v) =\u003e Value::Timestamp(v),\n            Json(v) =\u003e {\n                Value::Json(serde_json::from_slice(\u0026v).expect(\"json should always be deserialized\"))\n            }\n            NChar(str) =\u003e Value::NChar(str.to_string()),\n            VarBinary(_) =\u003e todo!(),\n            Decimal(_) =\u003e todo!(),\n            Blob(_) =\u003e todo!(),\n            MediumBlob(_) =\u003e todo!(),\n        }\n    }\n}\n\nunsafe impl\u003c'b\u003e Send for BorrowedValue\u003c'b\u003e {}\n\n// #[derive(Debug, Clone)]\n#[derive(Debug, Clone, Deserialize, Serialize, PartialEq)]\npub enum Value {\n    Null,        // 0\n    Bool(bool),  // 1\n    TinyInt(i8), // 2\n    SmallInt(i16),\n    Int(i32),\n    BigInt(i64),\n    Float(f32),\n    Double(f64),\n    VarChar(String),\n    Timestamp(Timestamp),\n    NChar(String),\n    UTinyInt(u8),\n    USmallInt(u16),\n    UInt(u32),\n    UBigInt(u64), // 14\n    Json(serde_json::Value),\n    VarBinary(Vec\u003cu8\u003e),\n    Decimal(Decimal),\n    Blob(Vec\u003cu8\u003e),\n    MediumBlob(Vec\u003cu8\u003e),\n}\n\nimpl Display for Value {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        todo!()\n    }\n}\n\nimpl Value {\n    /// The data type of this value.\n    pub const fn ty(\u0026self) -\u003e Ty {\n        use Value::*;\n        match self {\n            Null =\u003e Ty::Null,\n            Bool(_) =\u003e Ty::Bool,\n            TinyInt(_) =\u003e Ty::TinyInt,\n            SmallInt(_) =\u003e Ty::SmallInt,\n            Int(_) =\u003e Ty::Int,\n            BigInt(_) =\u003e Ty::BigInt,\n            UTinyInt(_) =\u003e Ty::UTinyInt,\n            USmallInt(_) =\u003e Ty::USmallInt,\n            UInt(_) =\u003e Ty::UInt,\n            UBigInt(_) =\u003e Ty::UBigInt,\n            Float(_) =\u003e Ty::Float,\n            Double(_) =\u003e Ty::Double,\n            VarChar(_) =\u003e Ty::VarChar,\n            Timestamp(_) =\u003e Ty::Timestamp,\n            Json(_) =\u003e Ty::Json,\n            NChar(_) =\u003e Ty::NChar,\n            VarBinary(_) =\u003e Ty::VarBinary,\n            Decimal(_) =\u003e Ty::Decimal,\n            Blob(_) =\u003e Ty::Blob,\n            MediumBlob(_) =\u003e Ty::MediumBlob,\n        }\n    }\n\n    pub fn to_borrowed_value(\u0026self) -\u003e BorrowedValue {\n        use Value::*;\n        match self {\n            Null =\u003e BorrowedValue::Null,\n            Bool(v) =\u003e BorrowedValue::Bool(*v),\n            TinyInt(v) =\u003e BorrowedValue::TinyInt(*v),\n            SmallInt(v) =\u003e BorrowedValue::SmallInt(*v),\n            Int(v) =\u003e BorrowedValue::Int(*v),\n            BigInt(v) =\u003e BorrowedValue::BigInt(*v),\n            UTinyInt(v) =\u003e BorrowedValue::UTinyInt(*v),\n            USmallInt(v) =\u003e BorrowedValue::USmallInt(*v),\n            UInt(v) =\u003e BorrowedValue::UInt(*v),\n            UBigInt(v) =\u003e BorrowedValue::UBigInt(*v),\n            Float(v) =\u003e BorrowedValue::Float(*v),\n            Double(v) =\u003e BorrowedValue::Double(*v),\n            VarChar(v) =\u003e BorrowedValue::VarChar(v),\n            Timestamp(v) =\u003e BorrowedValue::Timestamp(*v),\n            Json(j) =\u003e BorrowedValue::Json(j.to_string().into_bytes().into()),\n            NChar(v) =\u003e BorrowedValue::NChar(v.as_str().into()),\n            VarBinary(v) =\u003e BorrowedValue::VarBinary(v),\n            Decimal(v) =\u003e BorrowedValue::Decimal(*v),\n            Blob(v) =\u003e BorrowedValue::Blob(v),\n            MediumBlob(v) =\u003e BorrowedValue::MediumBlob(v),\n        }\n    }\n\n    /// Check if the value is null.\n    pub const fn is_null(\u0026self) -\u003e bool {\n        matches!(self, Value::Null)\n    }\n    /// Only VarChar, NChar, Json could be treated as [\u0026str].\n    pub fn strict_as_str(\u0026self) -\u003e \u0026str {\n        use Value::*;\n        match self {\n            VarChar(v) =\u003e v.as_str(),\n            NChar(v) =\u003e v.as_str(),\n            Json(v) =\u003e v.as_str().expect(\"invalid str type\"),\n            Null =\u003e \"Null\",\n            Timestamp(_) =\u003e panic!(\"expect str but value is timestamp\"),\n            _ =\u003e panic!(\"expect str but only varchar/binary/json/nchar is supported\"),\n        }\n    }\n\n    pub fn to_sql_value(\u0026self) -\u003e String {\n        use Value::*;\n        match self {\n            Null =\u003e \"NULL\".to_string(),\n            Bool(v) =\u003e format!(\"{v}\"),\n            TinyInt(v) =\u003e format!(\"{v}\"),\n            SmallInt(v) =\u003e format!(\"{v}\"),\n            Int(v) =\u003e format!(\"{v}\"),\n            BigInt(v) =\u003e format!(\"{v}\"),\n            Float(v) =\u003e format!(\"{v}\"),\n            Double(v) =\u003e format!(\"{v}\"),\n            VarChar(v) =\u003e format!(\"\\\"{}\\\"\", v.escape_debug()),\n            Timestamp(v) =\u003e format!(\"{}\", v.as_raw_i64()),\n            NChar(v) =\u003e format!(\"\\\"{}\\\"\", v.escape_debug()),\n            UTinyInt(v) =\u003e format!(\"{v}\"),\n            USmallInt(v) =\u003e format!(\"{v}\"),\n            UInt(v) =\u003e format!(\"{v}\"),\n            UBigInt(v) =\u003e format!(\"{v}\"),\n            Json(v) =\u003e format!(\"\\\"{}\\\"\", v),\n            VarBinary(_) =\u003e todo!(),\n            Decimal(_) =\u003e todo!(),\n            Blob(_) =\u003e todo!(),\n            MediumBlob(_) =\u003e todo!(),\n        }\n    }\n\n    pub fn to_string(\u0026self) -\u003e Result\u003cString, Utf8Error\u003e {\n        use Value::*;\n        match self {\n            Null =\u003e Ok(String::new()),\n            VarChar(v) =\u003e Ok(v.to_string()),\n            Json(v) =\u003e Ok(v.to_string()),\n            NChar(v) =\u003e Ok(v.to_string()),\n            TinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            SmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            Int(v) =\u003e Ok(format!(\"{v}\")),\n            BigInt(v) =\u003e Ok(format!(\"{v}\")),\n            UTinyInt(v) =\u003e Ok(format!(\"{v}\")),\n            USmallInt(v) =\u003e Ok(format!(\"{v}\")),\n            UInt(v) =\u003e Ok(format!(\"{v}\")),\n            UBigInt(v) =\u003e Ok(format!(\"{v}\")),\n            Float(v) =\u003e Ok(format!(\"{v}\")),\n            Double(v) =\u003e Ok(format!(\"{v}\")),\n            Timestamp(v) =\u003e Ok(v\n                .to_naive_datetime()\n                .format(\"%Y-%m-%dT%H:%M:%S%.f\")\n                .to_string()),\n            _ =\u003e unreachable!(\"un supported type to string\"),\n        }\n    }\n}\n\nmod de;\n","traces":[{"line":34,"address":[1930880],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":36,"address":[1930889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[1930918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1930928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[1930935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[1930942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[1930949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[1930956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1930998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[1931005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1931012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[1931019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[1930963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[1930970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[1930977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1930984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[1931026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[1930991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1931033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[1931040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[1931047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1931054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[1931072],"length":1,"stats":{"Line":1},"fn_name":"is_null"},{"line":62,"address":[1931081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1931120],"length":1,"stats":{"Line":0},"fn_name":"strict_as_str"},{"line":67,"address":[1931351,1931140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[1931261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[1931337,1931403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1931454,1931217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1931296,1931431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[1931368,1931175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1931488,1933506],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":77,"address":[1931527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1934754,1931610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[1933540,1931960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[1932271,1932424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[1932037,1933287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[1934568,1931636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1934374,1931691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[1931746,1934180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[1931801,1933986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[1932075,1933101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[1932124,1932913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[1932173,1932725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[1932222,1932537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[1931856,1933792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[1931911,1933598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[1933335,1933444,1931999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[1933395,1933487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[1934816],"length":1,"stats":{"Line":0},"fn_name":"to_value"},{"line":102,"address":[1934846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[1934882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[1934900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[1934942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[1934981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[1935022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[1935061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[1935305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[1935344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[1935385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[1935424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[1935102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[1935145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[1935772,1935183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[1935221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[1935460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[1935618,1935472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[1935265,1935726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[1936747,1935808],"length":1,"stats":{"Line":0},"fn_name":"into_value"},{"line":131,"address":[1935830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[1935866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[1935884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[1935923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[1935954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[1935988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[1936019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[1936276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[1936307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[1936341],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[1936372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[1936053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[1936090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[1936892,1936122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[1936171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[1936401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[1936619,1936419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[1936786,1936216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1936928],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":193,"address":[1936976],"length":1,"stats":{"Line":1},"fn_name":"ty"},{"line":195,"address":[1936985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[1937014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[1937024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[1937031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[1937038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[1937045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[1937052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[1937094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[1937101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[1937108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[1937115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[1937059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[1937066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[1937073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[1937080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[1937122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[1937087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[1937129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1937136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[1937143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[1937150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[1937168],"length":1,"stats":{"Line":0},"fn_name":"to_borrowed_value"},{"line":221,"address":[1937198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[1937234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[1937252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[1937294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[1937333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[1937374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[1937413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[1937663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[1937702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[1937743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[1937782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[1937454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[1937497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[1938326,1937535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[1937577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[1938128,1937818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[1938236,1937621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[1937854,1938115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[1937897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[1938087,1937970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[1938005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[1938352],"length":1,"stats":{"Line":1},"fn_name":"is_null"},{"line":247,"address":[1938361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[1938400],"length":1,"stats":{"Line":0},"fn_name":"strict_as_str"},{"line":252,"address":[1938420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[1938528,1938835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[1938604,1938790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[1938641,1938707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[1938497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[1938560,1938802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[1938455,1938671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[1938848],"length":1,"stats":{"Line":0},"fn_name":"to_sql_value"},{"line":264,"address":[1938887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[1938932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[1938962,1941886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[1941748,1939017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[1941610,1939072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[1939127,1941472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[1941334,1939182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[1941196,1939237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[1939292,1941058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[1939347,1940870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[1939393,1940698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[1939431,1940526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[1939477,1940388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[1940253,1939529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[1940121,1939578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[1939989,1939627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[1939844,1939676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[1943971,1942016],"length":1,"stats":{"Line":0},"fn_name":"to_string"},{"line":290,"address":[1942055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[1945207,1942138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[1944005,1942476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[1942933,1942786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[1943752,1942552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[1945021,1942164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[1944827,1942219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[1942274,1944633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[1942329,1944439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[1942590,1943566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[1943378,1942639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[1943190,1942688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[1942737,1943002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[1942378,1944251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[1942427,1944063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[1943800,1943909,1942514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[1943860,1943952],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":25,"coverable":180},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","de","mod.rs"],"content":"use std::any::type_name;\nuse std::marker::PhantomData;\n\nuse serde::de::{DeserializeSeed, IntoDeserializer, MapAccess, SeqAccess, Visitor};\nuse serde::Deserializer;\n\nuse serde::de::value::Error;\n\nuse crate::common::BorrowedValue;\nuse crate::Field;\n\n/// Row-based deserializer helper.\n///\n/// 'b: field lifetime may go across the whole query.\npub(crate) struct RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    inner: \u003cR as IntoIterator\u003e::IntoIter,\n    value: Option\u003cBorrowedValue\u003c'b\u003e\u003e,\n    _marker: PhantomData\u003c\u0026'b u8\u003e,\n}\n\nimpl\u003c'b, R\u003e From\u003cR\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    fn from(input: R) -\u003e Self {\n        Self {\n            inner: input.into_iter(),\n            value: None,\n            _marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'b, R\u003e RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    fn next_value(\u0026mut self) -\u003e Option\u003cBorrowedValue\u003c'b\u003e\u003e {\n        self.inner.next().map(|(_, v)| v)\n    }\n}\n\nimpl\u003c'de, 'b: 'de, R\u003e MapAccess\u003c'de\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.inner.next() {\n            Some((field, value)) =\u003e {\n                self.value = Some(value);\n                let field = \u0026*field;\n                seed.deserialize(field.name().into_deserializer()).map(Some)\n            }\n            _ =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let value = self.value.take().unwrap(); // always be here, so it's safe to unwrap\n\n        log::trace!(\"target value: {:?}\", type_name::\u003cV::Value\u003e());\n        seed.deserialize(value)\n            .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n    }\n}\n\nimpl\u003c'de, 'b: 'de, R\u003e SeqAccess\u003c'de\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    type Error = Error;\n\n    fn next_element_seed\u003cS\u003e(\u0026mut self, seed: S) -\u003e Result\u003cOption\u003cS::Value\u003e, Self::Error\u003e\n    where\n        S: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.inner.next() {\n            Some((_, v)) =\u003e seed\n                .deserialize(v)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                .map(Some),\n            None =\u003e Ok(None),\n        }\n    }\n}\n\nimpl\u003c'de, 'b: 'de, R\u003e Deserializer\u003c'de\u003e for RecordDeserializer\u003c'b, R\u003e\nwhere\n    R: IntoIterator\u003cItem = (\u0026'b Field, BorrowedValue\u003c'b\u003e)\u003e,\n{\n    type Error = Error;\n\n    // Look at the input data to decide what Serde data model type to\n    // deserialize as. Not all data formats are able to support this operation.\n    // Formats that support `deserialize_any` are known as self-describing.\n    fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize any for \u003c{}\u003e\", type_name::\u003cV\u003e());\n        match self.next_value() {\n            Some(v) =\u003e v\n                .deserialize_any(visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            None =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"expect value, not none\",\n            )),\n        }\n    }\n\n    serde::forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char bytes byte_buf enum\n        identifier ignored_any\n    }\n\n    // Refer to the \"Understanding deserializer lifetimes\" page for information\n    // about the three deserialization flavors of strings in Serde.\n    fn deserialize_str\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::trace!(\"call deserialize_str for \u003c{}\u003e\", type_name::\u003cV\u003e());\n        match self.next_value() {\n            Some(v) =\u003e v\n                .deserialize_str(visitor)\n                .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom),\n            None =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"expect value, not none\",\n            )),\n        }\n    }\n\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_str(visitor)\n    }\n\n    fn deserialize_option\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::debug!(\"call deserialize_option for \u003c{}\u003e\", type_name::\u003cV\u003e());\n        match self.next_value() {\n            Some(v) =\u003e {\n                if v.is_null() {\n                    visitor.visit_none()\n                } else {\n                    visitor\n                        .visit_some(v)\n                        .map_err(\u003cSelf::Error as serde::de::Error\u003e::custom)\n                }\n            }\n            _ =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"expect next value\",\n            )),\n        }\n    }\n\n    // In Serde, unit means an anonymous value containing no data.\n    fn deserialize_unit\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.next_value() {\n            Some(_v) =\u003e visitor.visit_unit(),\n            _ =\u003e Err(\u003cSelf::Error as serde::de::Error\u003e::custom(\n                \"there's no enough value\",\n            )),\n        }\n    }\n\n    // Unit struct means a named value containing no data.\n    fn deserialize_unit_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_unit(visitor)\n    }\n\n    // As is done here, serializers are encouraged to treat newtype structs as\n    // insignificant wrappers around the data they contain. That means not\n    // parsing anything other than the contained value.\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::debug!(\"deserialize_newtype_struct: {}\", _name);\n        visitor.visit_newtype_struct(self)\n    }\n\n    // Deserialization of compound types like sequences and maps happens by\n    // passing the visitor an \"Access\" object that gives it the ability to\n    // iterate through the data contained in the sequence.\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_seq(self)\n    }\n\n    // Tuples look just like sequences.\n    fn deserialize_tuple\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        // self.deserialize_any(visitor)\n        visitor.visit_seq(self)\n    }\n\n    // Tuple structs look just like sequences.\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        _len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    // Much like `deserialize_seq` but calls the visitors `visit_map` method\n    // with a `MapAccess` implementation, rather than the visitor's `visit_seq`\n    // method with a `SeqAccess` implementation.\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        // let value = visitor.visit_map(self);\n        // unimplemented!();\n        log::trace!(\"visit map for {}\", type_name::\u003cV::Value\u003e());\n        visitor.visit_map(self)\n    }\n\n    // Structs look just like maps in JSON.\n    //\n    // Notice the `fields` parameter - a \"struct\" in the Serde data model means\n    // that the `Deserialize` implementation is required to know what the fields\n    // are before even looking at the input data. Any key-value pairing in which\n    // the fields cannot be known ahead of time is probably a map.\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        _name: \u0026'static str,\n        _fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        log::debug!(\"name: {_name}, fields: {_fields:?}\");\n        self.deserialize_map(visitor)\n    }\n}\n","traces":[{"line":28,"address":[2189120,2189216],"length":1,"stats":{"Line":2},"fn_name":"from\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e"},{"line":30,"address":[3800066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[3788304,3789904,3788259,3789104,3787504,3789059],"length":1,"stats":{"Line":0},"fn_name":"next_key_seed\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos::impls::SyncBlock\u003e, core::marker::PhantomData\u003ctaos_query::helpers::describe::{impl#4}::deserialize::Meta\u003e\u003e"},{"line":56,"address":[3789134,3788334,3788423,3787623,3789223,3787534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3787667,3789267,3788467],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[3788704,3787904,3788529,3787729,3789329,3789549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[3787996,3788796,3789641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[3788046,3789691,3789649,3788004,3788846,3788804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[2191242,2190429,2189658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[2193936,2196160,2193894,2193132,2191680,2196865,2195424,2196129,2197601,2193168,2192377,2194672,2195388,2192416,2196896,2198337,2194633,2197632],"length":1,"stats":{"Line":0},"fn_name":"next_value_seed\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, core::marker::PhantomData\u003ctaos_query::common::ty::Ty\u003e\u003e"},{"line":70,"address":[2197738,2193961,2193186,2196266,2194781,2194042,2193270,2195449,2191786,2194697,2196921,2191705,2192525,2192441,2197002,2195530,2197657,2196185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2193388,2194981,2195642,2191898,2196460,2195120,2194074,2197034,2197850,2192119,2193470,2192560,2197196,2197770,2197114,2194816,2194236,2194154,2191818,2196298,2194899,2195562,2197335,2194375,2192725,2192643,2192864,2193305,2197932,2193614,2195863,2195724,2198071,2191980,2196378,2196599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2197254,2197990,2197546,2193528,2195782,2193077,2192334,2192783,2195333,2193832,2196074,2192038,2194294,2196518,2196810,2194590,2198282,2195039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2200848,2198800,2200432,2198718,2199232,2200356,2199150,2199557,2198368,2200762,2200032,2199632,2201172,2199957],"length":1,"stats":{"Line":5},"fn_name":"next_element_seed\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, core::marker::PhantomData\u003calloc::string::String\u003e\u003e"},{"line":88,"address":[2200525,2198824,2199656,2200941,2200056,2199325,2198392,2200125,2199256,2198893,2200872,2199725,2198461,2200456],"length":1,"stats":{"Line":12},"fn_name":null},{"line":89,"address":[2200284,2201100,2200331,2198545,2198638,2199070,2199788,2200737,2199388,2201007,2198672,2200191,2200690,2199928,2201147,2199481,2199104,2200597,2198977,2199881,2199528],"length":1,"stats":{"Line":18},"fn_name":null},{"line":90,"address":[2200635,2201045,2199015,2199426,2199826,2200229,2198583],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[2199349,2200149,2200549,2198485,2199749,2200965,2198917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[2201312,2201376,2201248],"length":1,"stats":{"Line":2},"fn_name":"deserialize_tuple\u003ctaos_query::iter::RowInBlock\u003ctaos_query::tests::Block\u003e, serde::de::impls::{impl#173}::deserialize::TupleVisitor\u003calloc::string::String, \u0026str, u8\u003e\u003e"},{"line":228,"address":[2201395,2201331,2201267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[2203220,2202031,2202612,2202004,2201440,2202048,2202656,2203247,2202639],"length":1,"stats":{"Line":0},"fn_name":"deserialize_map\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, taos_query::helpers::describe::{impl#4}::deserialize::MetaVisitor\u003e"},{"line":253,"address":[2202392,2202866,2203000,2202070,2201650,2201784,2202678,2202179,2201571,2201462,2202258,2202787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[2201703,2202311,2202919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[2203264,2204625,2203952,2203910,2203937,2204598],"length":1,"stats":{"Line":0},"fn_name":"deserialize_struct\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e, taos_query::helpers::topic::_::{impl#0}::deserialize::__Visitor\u003e"},{"line":272,"address":[2204112,2204194,2203309,2203506,2203424,2203655,2204343,2203997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[2204262,2203574],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":65},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","database.rs"],"content":"use chrono::NaiveDateTime;\nuse paste::paste;\nuse serde::{Deserialize, Serialize};\n\nuse std::{fmt::Display, str::FromStr};\n\nuse crate::common::Precision;\n\n#[derive(Debug, Default, PartialEq, Eq, Serialize, Deserialize)]\npub struct DatabaseProperties {\n    pub vgroups: Option\u003cu64\u003e,\n    pub replica: Option\u003cu16\u003e,\n    pub quorum: Option\u003cu16\u003e,\n    pub days: Option\u003cu16\u003e,\n    pub keep: Option\u003cString\u003e,\n    #[serde(rename = \"cache(MB)\")]\n    pub cache: Option\u003cu32\u003e,\n    pub blocks: Option\u003cu32\u003e,\n    pub minrows: Option\u003cu32\u003e,\n    pub maxrows: Option\u003cu32\u003e,\n    #[serde(rename = \"wallevel\")]\n    pub wal: Option\u003cu8\u003e,\n    pub fsync: Option\u003cu32\u003e,\n    pub comp: Option\u003cu8\u003e,\n    pub cachelast: Option\u003cu8\u003e,\n    pub precision: Option\u003cPrecision\u003e,\n    pub update: Option\u003cu8\u003e,\n}\n\nmacro_rules! _prop_builder {\n    ($($f:ident)*, $ty:ty) =\u003e {\n        $(pub fn $f(mut self, $f: $ty) -\u003e Self {\n            self.$f = Some($f);\n            self\n        })*\n    };\n}\nimpl DatabaseProperties {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    _prop_builder!(vgroups, u64);\n    _prop_builder!(cache blocks minrows maxrows fsync, u32);\n    _prop_builder!(replica quorum days, u16);\n    _prop_builder!(wal comp cachelast update, u8);\n    _prop_builder!(precision, Precision);\n    _prop_builder!(keep, String);\n}\n\nimpl Display for DatabaseProperties {\n    #[inline]\n    #[allow(unused_assignments)]\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let mut has_wrote = false;\n\n        macro_rules! _write_if {\n            ($($f:ident) *) =\u003e {\n                $(if let Some($f) = \u0026self.$f {\n                    if has_wrote {\n                        write!(f, \" {} {}\", paste!(stringify!([\u003c$f:upper\u003e])), $f)?;\n                    } else {\n                        write!(f, \"{} {}\", paste!(stringify!([\u003c$f:upper\u003e])), $f)?;\n                        has_wrote = true;\n                    }\n                })*\n            };\n            ('str $($s:ident) *) =\u003e {\n                $(if let Some($s) = \u0026self.$s {\n                    if has_wrote {\n                        write!(f, \" {} '{}'\", paste!(stringify!([\u003c$s:upper\u003e])), $s)?;\n                    } else {\n                        write!(f, \"{} '{}'\", paste!(stringify!([\u003c$s:upper\u003e])), $s)?;\n                        has_wrote = true;\n                    }\n                })*\n            };\n            ($($f:ident) *; 'str $($s:ident) *) =\u003e {\n                _write_if!($($f) *);\n                _write_if!('str $($s) *)\n            };\n            ($($f:ident) *; 'str $($s:ident) *; $($f2:ident) *) =\u003e {\n                _write_if!($($f) *; 'str $($s) *);\n                _write_if!($($f2) *)\n            };\n        }\n\n        // todo: keep now may fail\n        _write_if!(vgroups replica quorum days keep cache blocks minrows\n                   maxrows wal fsync comp cachelast; 'str precision; update);\n        Ok(())\n    }\n}\n\nimpl FromStr for DatabaseProperties {\n    type Err = anyhow::Error;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        // CREATE DATABASE log REPLICA 1 QUORUM 1 DAYS 10 KEEP 30 CACHE 1 BLOCKS 3 MINROWS 100 MAXROWS 4096 WAL 1 FSYNC 3000 COMP 2 CACHELAST 0 PRECISION 'us' UPDATE 0\n        use nom::branch::alt;\n        use nom::character::complete::*;\n        use nom::character::complete::{multispace0, multispace1};\n        use nom::character::streaming;\n        use nom::multi::many0;\n        use nom::sequence::*;\n        use nom::{bytes::complete::tag, IResult};\n\n        let mut repr = Self::new();\n\n        fn parse_name(s: \u0026str) -\u003e IResult\u003c\u0026str, \u0026str\u003e {\n            preceded(\n                tuple((multispace0, tag(\"CREATE DATABASE\"), multispace1)),\n                alphanumeric1,\n            )(s)\n        }\n\n        let s = parse_name(s).map(|s| s.0).unwrap_or(s);\n\n        fn parse_props(s: \u0026str) -\u003e IResult\u003c\u0026str, Vec\u003c(\u0026str, \u0026str)\u003e\u003e {\n            many0(separated_pair(\n                preceded(multispace0, alphanumeric1),\n                streaming::char(' '),\n                alt((\n                    alphanumeric1,\n                    delimited(char('\\''), alphanumeric1, char('\\'')),\n                )),\n            ))(s)\n        }\n\n        if let Ok((_s, props)) = dbg!(parse_props(s)) {\n            for (prop, value) in props {\n                macro_rules! _parse {\n                    ($($($f:ident) +, $t:ident);*) =\u003e {\n                        paste::paste! {\n                            match prop.to_lowercase() {\n                                $($(s if s == stringify!($f) =\u003e {\n                                    repr = repr.$f($t::from_str(value)?);\n                                },)*)*\n                                _ =\u003e (),\n                            }\n                        }\n                    }\n                }\n                _parse!(vgroups, u64;\n                        cache blocks minrows maxrows fsync, u32;\n                        replica quorum days, u16;\n                        wal comp cachelast  update, u8;\n                        keep, String;\n                        precision, Precision);\n            }\n            Ok(repr)\n        } else {\n            Ok(repr)\n        }\n    }\n}\n\n#[test]\nfn db_prop_from_str() {\n    let s = \"REPLICA 1 QUORUM 1 DAYS 10 KEEP 30 CACHE 1 BLOCKS 3 MINROWS 100 MAXROWS 4096 WAL 1 FSYNC 3000 COMP 2 CACHELAST 0 PRECISION 'us' UPDATE 0\";\n\n    let db = DatabaseProperties::from_str(s).unwrap();\n\n    let t = db.to_string();\n\n    dbg!(db);\n\n    assert_eq!(s, t);\n}\n\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct DatabaseRepr {\n    pub name: String,\n    #[serde(flatten)]\n    pub props: DatabaseProperties,\n}\n\n/// A show database representation struct.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct ShowDatabase {\n    pub name: String,\n    pub created_time: Option\u003cNaiveDateTime\u003e,\n    pub ntables: Option\u003cusize\u003e,\n    #[serde(flatten)]\n    pub props: DatabaseProperties,\n    pub status: Option\u003cString\u003e,\n}\n\nunsafe impl Send for ShowDatabase {}\n","traces":[{"line":32,"address":[8413306,8412384,8412576,8413008,8412320,8412944,8412176,8412512,8413072,8413120,8412448,8412256,8412816,8412736,8412656,8412880],"length":1,"stats":{"Line":14},"fn_name":"vgroups"},{"line":33,"address":[8412898,8412193,8412399,8413088,8412676,8412271,8412463,8413026,8413147,8412596,8412335,8412962,8412834,8413259,8412527,8412756],"length":1,"stats":{"Line":15},"fn_name":null},{"line":34,"address":[2381307,2380834,2380761,2381260,2381490,2380633,2381132,2380505,2381068,2380994,2381196,2380569,2380697,2380432,2380914],"length":1,"stats":{"Line":14},"fn_name":null},{"line":35,"address":[8412939,8413003,8412875,8413114,8412567,8412439,8412721,8412239,8412503,8412375,8413301,8412801,8412311,8413222,8412641,8413067],"length":1,"stats":{"Line":14},"fn_name":null},{"line":39,"address":[8383552],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":40,"address":[8383560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[8383584],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":55,"address":[8383629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8383637,8384055,8392735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[2361216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[2361744,2362354],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":108,"address":[2361805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[8406464],"length":1,"stats":{"Line":1},"fn_name":"parse_name"},{"line":117,"address":[8393499,8393550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[8406672],"length":1,"stats":{"Line":1},"fn_name":"parse_props"},{"line":130,"address":[2362155,2362914,2374611,2362380],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2374508,2363196,2364089,2362986],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[8394975,8395640,8406281,8406074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[2374532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[2363048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[2224757,2224752],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":160,"address":[2381543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[2381578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[2381659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[2381707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[2382669,2382553],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":48},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","describe.rs"],"content":"use std::{\n    fmt,\n    ops::{Deref, DerefMut},\n    str::FromStr,\n};\n\nuse serde::{\n    de::{self, MapAccess, SeqAccess, Visitor},\n    Deserialize, Deserializer, Serialize,\n};\n\nuse crate::common::Ty;\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]\npub struct Described {\n    pub field: String,\n    #[serde(rename = \"type\")]\n    pub ty: Ty,\n    pub length: usize,\n}\n\nimpl Described {\n    /// Represent the data type in sql.\n    ///\n    /// For example: \"INT\", \"VARCHAR(100)\".\n    pub fn sql_repr(\u0026self) -\u003e String {\n        let ty = self.ty;\n        if ty.is_var_type() {\n            format!(\"{} {}({})\", self.field, ty, self.length)\n        } else {\n            format!(\"{} {}\", self.field, self.ty)\n        }\n    }\n}\n#[derive(Debug, Serialize, PartialEq, Eq, Clone)]\n#[serde(tag = \"note\")]\npub enum ColumnMeta {\n    Column(Described),\n    Tag(Described),\n}\n\nimpl Deref for ColumnMeta {\n    type Target = Described;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        match self {\n            ColumnMeta::Column(v) =\u003e v,\n            ColumnMeta::Tag(v) =\u003e v,\n        }\n    }\n}\n\nimpl DerefMut for ColumnMeta {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        match self {\n            ColumnMeta::Column(v) =\u003e v,\n            ColumnMeta::Tag(v) =\u003e v,\n        }\n    }\n}\nunsafe impl Send for ColumnMeta {}\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for ColumnMeta {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        enum Meta {\n            Field,\n            Type,\n            Length,\n            Note,\n        }\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Meta {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cMeta, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Meta;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`field`, `type`, `length` or `note`\")\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cMeta, E\u003e\n                    where\n                        E: de::Error,\n                    {\n                        match value.to_lowercase().as_str() {\n                            \"field\" =\u003e Ok(Meta::Field),\n                            \"type\" =\u003e Ok(Meta::Type),\n                            \"length\" =\u003e Ok(Meta::Length),\n                            \"note\" =\u003e Ok(Meta::Note),\n                            _ =\u003e Err(de::Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct MetaVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for MetaVisitor {\n            type Value = ColumnMeta;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct ColumnMeta\")\n            }\n\n            fn visit_seq\u003cV\u003e(self, mut seq: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n            where\n                V: SeqAccess\u003c'de\u003e,\n            {\n                let field = dbg!(seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(0, \u0026self))?);\n                let ty = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(1, \u0026self))\n                    .and_then(|s| Ty::from_str(s).map_err(de::Error::custom))?;\n                let length = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(2, \u0026self))?;\n                let note: String = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(3, \u0026self))?;\n                let desc = Described { field, ty, length };\n                if note.is_empty() {\n                    Ok(ColumnMeta::Column(desc))\n                } else {\n                    Ok(ColumnMeta::Tag(desc))\n                }\n            }\n\n            fn visit_map\u003cV\u003e(self, mut map: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                let mut field = None;\n                let mut ty = None;\n                let mut length = None;\n                let mut note = None;\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Meta::Field =\u003e {\n                            if field.is_some() {\n                                return Err(de::Error::duplicate_field(\"field\"));\n                            }\n                            field = Some(map.next_value()?);\n                        }\n                        Meta::Type =\u003e {\n                            if ty.is_some() {\n                                return Err(de::Error::duplicate_field(\"type\"));\n                            }\n                            let t: Ty = map.next_value()?;\n                            ty = Some(t);\n                        }\n                        Meta::Length =\u003e {\n                            if length.is_some() {\n                                return Err(de::Error::duplicate_field(\"length\"));\n                            }\n                            length = Some(map.next_value()?);\n                        }\n                        Meta::Note =\u003e {\n                            if note.is_some() {\n                                return Err(de::Error::duplicate_field(\"note\"));\n                            }\n                            let t: String = map.next_value()?;\n                            note = Some(t.is_empty() || t == \"Column\")\n                        }\n                    }\n                }\n                let field = field.ok_or_else(|| de::Error::missing_field(\"field\"))?;\n                let ty = ty.ok_or_else(|| de::Error::missing_field(\"type\"))?;\n                let length = length.ok_or_else(|| de::Error::missing_field(\"length\"))?;\n                let desc = Described { field, ty, length };\n                let note = note.ok_or_else(|| de::Error::missing_field(\"note\"))?;\n                if note {\n                    Ok(ColumnMeta::Column(desc))\n                } else {\n                    Ok(ColumnMeta::Tag(desc))\n                }\n            }\n        }\n\n        const FIELDS: \u0026[\u0026str] = \u0026[\"field\", \"type\", \"length\", \"note\"];\n        deserializer.deserialize_struct(\"ColumnMeta\", FIELDS, MetaVisitor)\n    }\n}\nimpl ColumnMeta {\n    pub fn field(\u0026self) -\u003e \u0026str {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) =\u003e desc.field.as_str(),\n        }\n    }\n    pub fn ty(\u0026self) -\u003e Ty {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) =\u003e desc.ty,\n        }\n    }\n    pub fn length(\u0026self) -\u003e usize {\n        match self {\n            ColumnMeta::Column(desc) | ColumnMeta::Tag(desc) =\u003e desc.length,\n        }\n    }\n    pub fn note(\u0026self) -\u003e \u0026str {\n        match self {\n            ColumnMeta::Tag(_) =\u003e \"TAG\",\n            _ =\u003e \"\",\n        }\n    }\n    pub fn is_tag(\u0026self) -\u003e bool {\n        matches!(self, ColumnMeta::Tag(_))\n    }\n}\n\n#[test]\nfn serde_meta() {\n    let meta = ColumnMeta::Column(Described {\n        field: \"name\".to_string(),\n        ty: Ty::BigInt,\n        length: 8,\n    });\n\n    let a = serde_json::to_string(\u0026meta).unwrap();\n\n    let d: ColumnMeta = serde_json::from_str(\u0026a).unwrap();\n\n    assert_eq!(meta, d);\n}\n//erive(Debug, Clone, Deserialize)]\n// pub struct ColumnMeta {\n//     pub name: String,\n//     pub type_: Ty,\n//     pub bytes: i16,\n// }\n// #[derive(Debug)]\n// pub struct TaosQueryData {\n//     pub column_meta: Vec\u003cColumnMeta\u003e,\n//     pub rows: Vec\u003cVec\u003cField\u003e\u003e,\n// }\n\n// #[derive(Debug)]\n// pub struct TaosDescribe {\n//     pub cols: Vec\u003cColumnMeta\u003e,\n//     pub tags: Vec\u003cColumnMeta\u003e,\n// }\n\n// impl TaosDescribe {\n//     pub fn names(\u0026self) -\u003e Vec\u003c\u0026String\u003e {\n//         self.cols\n//             .iter()\n//             .chain(self.tags.iter())\n//             .map(|t| \u0026t.name)\n//             .collect_vec()\n//     }\n\n//     pub fn col_names(\u0026self) -\u003e Vec\u003c\u0026String\u003e {\n//         self.cols.iter().map(|t| \u0026t.name).collect_vec()\n//     }\n//     pub fn tag_names(\u0026self) -\u003e Vec\u003c\u0026String\u003e {\n//         self.tags.iter().map(|t| \u0026t.name).collect_vec()\n//     }\n// }\n// impl FromStr for Ty {\n//     type Err = \u0026'static str;\n//     fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n//         match s.to_lowercase().as_str() {\n//             \"timestamp\" =\u003e Ok(Ty::Timestamp),\n//             \"bool\" =\u003e Ok(Ty::Bool),\n//             \"tinyint\" =\u003e Ok(Ty::TinyInt),\n//             \"smallint\" =\u003e Ok(Ty::SmallInt),\n//             \"int\" =\u003e Ok(Ty::Int),\n//             \"bigint\" =\u003e Ok(Ty::BigInt),\n//             \"tinyint unsigned\" =\u003e Ok(Ty::UTinyInt),\n//             \"smallint unsigned\" =\u003e Ok(Ty::USmallInt),\n//             \"int unsigned\" =\u003e Ok(Ty::UInt),\n//             \"bigint unsigned\" =\u003e Ok(Ty::UBigInt),\n//             \"float\" =\u003e Ok(Ty::Float),\n//             \"double\" =\u003e Ok(Ty::Double),\n//             \"binary\" =\u003e Ok(Ty::Binary),\n//             \"nchar\" =\u003e Ok(Ty::NChar),\n//             _ =\u003e Err(\"not a valid data type string\"),\n//         }\n//     }\n// }\n// impl From\u003cTaosQueryData\u003e for TaosDescribe {\n//     fn from(rhs: TaosQueryData) -\u003e Self {\n//         let (cols, tags): (Vec\u003c_\u003e, Vec\u003c_\u003e) = rhs\n//             .rows\n//             .iter()\n//             .partition(|row| row[3] != Field::Binary(\"TAG\".into()));\n//         Self {\n//             cols: cols\n//                 .into_iter()\n//                 .map(|row| ColumnMeta {\n//                     name: row[0].to_string(),\n//                     type_: Ty::from_str(\u0026row[1].to_string()).expect(\"from describe\"),\n//                     bytes: *row[2].as_int().unwrap() as _,\n//                 })\n//                 .collect_vec(),\n//             tags: tags\n//                 .into_iter()\n//                 .map(|row| ColumnMeta {\n//                     name: row[0].to_string(),\n//                     type_: Ty::from_str(\u0026row[1].to_string()).expect(\"from describe\"),\n//                     bytes: *row[2].as_int().unwrap() as _,\n//                 })\n//                 .collect_vec(),\n//         }\n//     }\n// }\n// impl TaosQueryData {\n//     /// Total rows count of query result\n//     pub fn rows(\u0026self) -\u003e usize {\n//         self.rows.len()\n//     }\n// }\n\n// #[derive(Debug, PartialEq, Clone)]\n// pub enum Field {\n//     Null,        // 0\n//     Bool(bool),  // 1\n//     TinyInt(i8), // 2\n//     SmallInt(i16),\n//     Int(i32),\n//     BigInt(i64),\n//     Float(f32),\n//     Double(f64),\n//     Binary(BString),\n//     Timestamp(Timestamp),\n//     NChar(String),\n//     UTinyInt(u8),\n//     USmallInt(u16),\n//     UInt(u32),\n//     UBigInt(u64), // 14\n//     Json(serde_json::Value),\n// }\n\n// impl fmt::Display for Field {\n//     fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n//         match self {\n//             Field::Null =\u003e write!(f, \"NULL\"),\n//             Field::Bool(v) =\u003e write!(f, \"{}\", v),\n//             Field::TinyInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::SmallInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::Int(v) =\u003e write!(f, \"{}\", v),\n//             Field::BigInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::Float(v) =\u003e write!(f, \"{}\", v),\n//             Field::Double(v) =\u003e write!(f, \"{}\", v),\n//             Field::Binary(v) =\u003e write!(f, \"{}\", v),\n//             Field::NChar(v) =\u003e write!(f, \"{}\", v),\n//             Field::Timestamp(v) =\u003e write!(f, \"{}\", v),\n//             Field::UTinyInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::USmallInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::UInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::UBigInt(v) =\u003e write!(f, \"{}\", v),\n//             Field::Json(v) =\u003e write!(f, \"{}\", v),\n//         }\n//     }\n// }\n\n// impl Field {\n//     pub fn as_bool(\u0026self) -\u003e Option\u003c\u0026bool\u003e {\n//         match self {\n//             Field::Bool(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_tiny_int(\u0026self) -\u003e Option\u003c\u0026i8\u003e {\n//         match self {\n//             Field::TinyInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_small_int(\u0026self) -\u003e Option\u003c\u0026i16\u003e {\n//         match self {\n//             Field::SmallInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_int(\u0026self) -\u003e Option\u003c\u0026i32\u003e {\n//         match self {\n//             Field::Int(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_big_int(\u0026self) -\u003e Option\u003c\u0026i64\u003e {\n//         match self {\n//             Field::BigInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_float(\u0026self) -\u003e Option\u003c\u0026f32\u003e {\n//         match self {\n//             Field::Float(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_double(\u0026self) -\u003e Option\u003c\u0026f64\u003e {\n//         match self {\n//             Field::Double(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_binary(\u0026self) -\u003e Option\u003c\u0026BStr\u003e {\n//         match self {\n//             Field::Binary(v) =\u003e Some(v.as_ref()),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_nchar(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n//         match self {\n//             Field::NChar(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n\n//     /// BINARY or NCHAR typed string reference\n//     pub fn as_string(\u0026self) -\u003e Option\u003cString\u003e {\n//         match self {\n//             Field::Binary(v) =\u003e Some(v.to_string()),\n//             Field::NChar(v) =\u003e Some(v.to_string()),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_timestamp(\u0026self) -\u003e Option\u003c\u0026Timestamp\u003e {\n//         match self {\n//             Field::Timestamp(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_raw_timestamp(\u0026self) -\u003e Option\u003ci64\u003e {\n//         match self {\n//             Field::Timestamp(v) =\u003e Some(v.as_raw_timestamp()),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_tiny_int(\u0026self) -\u003e Option\u003c\u0026u8\u003e {\n//         match self {\n//             Field::UTinyInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_samll_int(\u0026self) -\u003e Option\u003c\u0026u16\u003e {\n//         match self {\n//             Field::USmallInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_int(\u0026self) -\u003e Option\u003c\u0026u32\u003e {\n//         match self {\n//             Field::UInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n//     pub fn as_unsigned_big_int(\u0026self) -\u003e Option\u003c\u0026u64\u003e {\n//         match self {\n//             Field::UBigInt(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n\n//     pub fn as_json(\u0026self) -\u003e Option\u003c\u0026serde_json::Value\u003e {\n//         match self {\n//             Field::Json(v) =\u003e Some(v),\n//             _ =\u003e None,\n//         }\n//     }\n\n//     pub fn data_type(\u0026self) -\u003e Ty {\n//         match self {\n//             Field::Null =\u003e Ty::Null,\n//             Field::Bool(_v) =\u003e Ty::Bool,\n//             Field::TinyInt(_v) =\u003e Ty::TinyInt,\n//             Field::SmallInt(_v) =\u003e Ty::SmallInt,\n//             Field::Int(_v) =\u003e Ty::Int,\n//             Field::BigInt(_v) =\u003e Ty::BigInt,\n//             Field::Float(_v) =\u003e Ty::Float,\n//             Field::Double(_v) =\u003e Ty::Double,\n//             Field::Binary(_v) =\u003e Ty::Binary,\n//             Field::NChar(_v) =\u003e Ty::NChar,\n//             Field::Timestamp(_v) =\u003e Ty::Timestamp,\n//             Field::UTinyInt(_v) =\u003e Ty::UTinyInt,\n//             Field::USmallInt(_v) =\u003e Ty::USmallInt,\n//             Field::UInt(_v) =\u003e Ty::UInt,\n//             Field::UBigInt(_v) =\u003e Ty::UBigInt,\n//             Field::Json(_v) =\u003e Ty::Json,\n//         }\n//     }\n// }\n\n// pub trait IntoField {\n//     fn into_field(self) -\u003e Field;\n// }\n\n// macro_rules! _impl_primitive_type {\n//     ($ty:ty, $target:ident, $v:expr) =\u003e {\n//         impl IntoField for $ty {\n//             fn into_field(self) -\u003e Field {\n//                 Field::$target(self)\n//             }\n//         }\n//         paste! {\n//             #[test]\n//             fn [\u003ctest_ $ty:snake\u003e]() {\n//                 let v: $ty = $v;\n//                 assert_eq!(v.clone().into_field(), Field::$target(v));\n//             }\n//         }\n//     };\n// }\n\n// _impl_primitive_type!(bool, Bool, true);\n// _impl_primitive_type!(i8, TinyInt, 0);\n// _impl_primitive_type!(i16, SmallInt, 0);\n// _impl_primitive_type!(i32, Int, 0);\n// _impl_primitive_type!(i64, BigInt, 0);\n// _impl_primitive_type!(u8, UTinyInt, 0);\n// _impl_primitive_type!(u16, USmallInt, 0);\n// _impl_primitive_type!(u32, UInt, 0);\n// _impl_primitive_type!(u64, UBigInt, 0);\n// _impl_primitive_type!(f32, Float, 0.);\n// _impl_primitive_type!(f64, Double, 0.);\n// _impl_primitive_type!(BString, Binary, \"A\".into());\n// _impl_primitive_type!(String, NChar, \"A\".into());\n// // _impl_primitive_type!(serde_json::Value, Json, );\n\n// impl IntoField for \u0026BStr {\n//     fn into_field(self) -\u003e Field {\n//         self.to_owned().into_field()\n//     }\n// }\n// impl IntoField for \u0026str {\n//     fn into_field(self) -\u003e Field {\n//         self.to_owned().into_field()\n//     }\n// }\n\n// #[cfg(test)]\n// mod test {\n//     use crate::test::taos;\n//     use crate::*;\n\n//     #[tokio::test]\n//     #[proc_test_catalog::test_catalogue]\n//     /// Test describe sql\n//     async fn test_describe() -\u003e Result\u003c(), Error\u003e {\n//         let db = stdext::function_name!()\n//             .replace(\"::{{closure}}\", \"\")\n//             .replace(\"::\", \"_\");\n//         println!(\"{}\", db);\n//         let taos = taos()?;\n//         let desc = taos.describe(\"log.dn\").await?;\n//         assert_eq!(desc.cols.len(), 15);\n//         assert_eq!(desc.tags.len(), 2);\n//         Ok(())\n//     }\n// }\n","traces":[{"line":26,"address":[3292352],"length":1,"stats":{"Line":0},"fn_name":"sql_repr"},{"line":27,"address":[3292382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[3292859,3292389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[3292444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3292418,3292692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[3292864],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":46,"address":[3292877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[3292895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[3292915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[3292944],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"},{"line":55,"address":[3292957,3293009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3292975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[3292995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[3341360,3341280],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[3341472,3341424],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003cserde::de::value::StrDeserializer\u003cserde::de::value::Error\u003e\u003e"},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[3293024],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":85,"address":[3293051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3341504,3341991,3342507,3342032],"length":1,"stats":{"Line":1},"fn_name":"visit_str\u003cserde::de::value::Error\u003e"},{"line":92,"address":[3342159,3342075,3341631,3341547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[3341718,3342246,3341647,3342175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[3341690,3342218,3342325,3341797,3342281,3341753],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[3341818,3341769,3341862,3342390,3342346,3342297],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[3341886,3341941,3341834,3342362,3342414,3342465],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[3342495,3341902,3342430,3341975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[3341489,3341445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[3293088],"length":1,"stats":{"Line":0},"fn_name":"expecting"},{"line":112,"address":[3293115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[3342560,3345387,3343707],"length":1,"stats":{"Line":0},"fn_name":"visit_seq\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":119,"address":[3342878,3342782,3342901,3343253,3342837,3342676,3342602,3343194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[3342821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[3342851,3342774,3353584,3353596,3343178,3343208],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":122,"address":[3343960,3343700,3343937,3344080,3343775,3343896,3343849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3345408,3343841,3345420],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":125,"address":[3345480,3343910,3345456,3344094,3344064],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":126,"address":[3344238,3344164,3344349,3344049,3344285,3344451,3344326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3344299,3345520,3345532,3344230,3344435,3344465],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":129,"address":[3344715,3344420,3344513,3344970,3344619,3344738,3344674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3344954,3344688,3344611,3344984,3345568,3345580],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}\u003cserde_json::de::SeqAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":132,"address":[3344840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3345218,3345073,3344935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[3345220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[3345105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[3346920,3348800,3350203,3352229,3345616,3348774],"length":1,"stats":{"Line":1},"fn_name":"visit_map\u003cserde_json::de::MapAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":144,"address":[3345646,3348822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[3348855,3345679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[3345684,3348863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[3348875,3345696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[3349126,3351088,3345717,3347758,3345928,3348896,3345781,3348960],"length":1,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[3349140,3345942,3347239,3350532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[3352205,3348750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[3348269,3347241,3351666,3350534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[3348295,3351692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[3348365,3351685,3351758,3348629,3348288,3352078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[3347269,3350565,3351397,3348033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[3351423,3348059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[3351584,3348203,3348129,3348052,3351416,3351507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[3348175,3351553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[3347957,3351305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[3347767,3351097,3350579,3347283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[3351123,3347793],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[3347967,3351116,3351315,3347786,3351191,3347863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3350605,3347309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[3350658,3347362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[3350860,3350726,3347432,3350651,3347355,3347546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[3347656,3350986,3347530,3351077,3350844,3347747],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[3346172,3349174,3352256,3345976,3352260,3352308,3352304,3349383],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}\u003cserde_json::de::MapAccess\u003cserde_json::read::StrRead\u003e\u003e"},{"line":179,"address":[3346301,3352400,3352356,3346387,3352352,3349352,3346147,3352404,3349614,3349528],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":180,"address":[3349900,3346481,3349578,3352452,3346351,3352496,3346653,3349708,3352500,3352448],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":181,"address":[3349785,3346538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[3350112,3349872,3346845,3350018,3352596,3346625,3352544,3352548,3352592,3346771],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}\u003ctaos_query::de::RecordDeserializer\u003c\u0026taos_query::iter::QueryRowIter\u003ctaos_query::tests::Block\u003e\u003e\u003e"},{"line":183,"address":[3347101,3350384,3346827,3350094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[3347103,3350386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[3350277,3346994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[3341294,3341377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[3293152],"length":1,"stats":{"Line":0},"fn_name":"field"},{"line":197,"address":[3293166,3293194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[3293185,3293201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[3293248],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":202,"address":[3293288,3293261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3293294,3293279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[3293328],"length":1,"stats":{"Line":0},"fn_name":"length"},{"line":207,"address":[3293341,3293368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[3293359,3293374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[3293408],"length":1,"stats":{"Line":0},"fn_name":"note"},{"line":212,"address":[3293417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[3293423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[3293445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[3293488],"length":1,"stats":{"Line":0},"fn_name":"is_tag"},{"line":218,"address":[3293497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[3296058,3295488,3296016],"length":1,"stats":{"Line":3},"fn_name":"serde_meta"},{"line":224,"address":[3295520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[3295495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[3295662,3295618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[3295776,3295700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[3295818,3295939,3295970],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":42,"coverable":102},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","mod.rs"],"content":"mod database;\nmod describe;\nmod topic;\n\npub use database::*;\npub use describe::*;\npub use topic::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","helpers","topic.rs"],"content":"use chrono::NaiveDateTime;\nuse paste::paste;\nuse serde::{Deserialize, Serialize};\n\nuse std::{fmt::Display, str::FromStr};\n\nuse crate::common::{Precision, Timestamp};\n\n/// Information for `show topics` record.\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct Topic {\n    topic_name: String,\n    db_name: String,\n    create_time: Timestamp,\n    sql: String,\n}\n\nimpl Topic {\n    /// Topic name.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.topic_name\n    }\n\n    /// Database name of the topic.\n    pub fn db_name(\u0026self) -\u003e \u0026str {\n        \u0026self.db_name\n    }\n\n    /// Created time of the topic\n    pub fn create_time(\u0026self) -\u003e NaiveDateTime {\n        self.create_time.to_naive_datetime()\n    }\n\n    /// The create sql for the topic\n    pub fn sql(\u0026self) -\u003e \u0026str {\n        \u0026self.sql\n    }\n\n    /// Check if the topic is a database-scope topic, otherwise is table-scope topic.\n    pub fn is_db_topic(\u0026self) -\u003e bool {\n        self.sql.contains(\"as database\")\n    }\n\n    pub fn is_stable_topic(\u0026self) -\u003e bool {\n        self.sql.contains(\"as stable\")\n    }\n}\n","traces":[{"line":20,"address":[2385296],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":21,"address":[2385305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[2385344],"length":1,"stats":{"Line":0},"fn_name":"db_name"},{"line":26,"address":[2385353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[2385392],"length":1,"stats":{"Line":0},"fn_name":"create_time"},{"line":31,"address":[2385409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[2385440],"length":1,"stats":{"Line":0},"fn_name":"sql"},{"line":36,"address":[2385449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2385488],"length":1,"stats":{"Line":0},"fn_name":"is_db_topic"},{"line":41,"address":[2385497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2385568],"length":1,"stats":{"Line":0},"fn_name":"is_stable_topic"},{"line":45,"address":[2385577],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","insert","mod.rs"],"content":"use std::fmt::Debug;\n\npub trait Insertable: Debug {\n    type Error;\n    fn insert(\u0026self, sql: \u0026str) -\u003e Result\u003cusize, Self::Error\u003e;\n\n    fn insert_raw(\u0026self, table: \u0026str, raw: \u0026[u8]) -\u003e Result\u003cusize, Self::Error\u003e;\n\n    fn insert_named\u003c'a\u003e(\u0026self, table: \u0026str, fields: [\u0026dyn IntoNamedField\u003c'a\u003e]);\n\n    // fn insert_many\u003cT: Any\u003e(\u0026self, table: \u0026str, records: \u0026[dyn Any]) -\u003e Result\u003cusize, Self::Error\u003e;\n\n    // fn insert_progressive(\u0026self, stable: \u0026str, ) -\u003e Inserter;\n}\n\npub trait IntoField: Debug {}\n\nimpl IntoField for i32 {}\nimpl IntoField for f32 {}\nimpl IntoField for f64 {}\n\npub trait IntoNamedField\u003c'a\u003e: IntoField {\n    fn name(\u0026'a self) -\u003e \u0026'a str;\n}\nimpl\u003cT: IntoField\u003e IntoField for (\u0026str, T) {}\n\nimpl\u003c'a, T: IntoField\u003e IntoNamedField\u003c'a\u003e for (\u0026str, T) {\n    fn name(\u0026'a self) -\u003e \u0026'a str {\n        self.0\n    }\n}\n\n/// Insert macros.\n///\n/// insert! {\n///    \"ts\" =\u003e [\"2022-10-10T10:10:10.000\", \"2022-10-10T10:10:11\", \"2022-10-10T10:10:12\"],\n///    \"n\" =\u003e [0, 1, 2],\n///    \"f\" =\u003e [0.1, 0.2, 0.3],\n///    \"g\" =\u003e [\"abc\", \"def\", \"desc\"]: VarChar,\n/// }\n// macro_rules! {\n//     ($conn:expr, $sql:expr, $raw: )\n// }\n\n#[test]\nfn obj() {\n    fn t1(_fields: \u0026[\u0026dyn IntoField]) {}\n\n    let v = vec![\u002610 as _, \u00260.0 as _];\n    t1(\u0026v);\n\n    fn insert_named\u003c'a\u003e(_fields: \u0026[\u0026dyn IntoNamedField\u003c'a\u003e]) {}\n\n    let v = vec![\u0026(\"a\", 0) as _, \u0026(\"b\", 0.0) as _];\n    insert_named(\u0026v);\n\n    for e in v {\n        dbg!(e.name());\n    }\n}\n","traces":[{"line":28,"address":[2640704,2640688],"length":1,"stats":{"Line":2},"fn_name":"name\u003ci32\u003e"},{"line":29,"address":[2640709,2640693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[2207808,2209101,2209049],"length":1,"stats":{"Line":3},"fn_name":"obj"},{"line":47,"address":[2209136,2209149],"length":1,"stats":{"Line":2},"fn_name":"t1"},{"line":49,"address":[2207815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2207926,2208005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2209181,2209168],"length":1,"stats":{"Line":2},"fn_name":"insert_named"},{"line":54,"address":[2208022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2208204,2208124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2208211,2209044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[2208516],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","iter","mod.rs"],"content":"use super::*;\n\npub struct CellIter\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    row: usize,\n    col: usize,\n}\n\nimpl\u003c'b, T: BlockExt\u003e Iterator for CellIter\u003c'b, T\u003e {\n    type Item = (\u0026'b Field, BorrowedValue\u003c'b\u003e);\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let col = self.col;\n        if col \u003c self.block.field_count() {\n            self.col += 1;\n            Some(unsafe { self.block.cell_unchecked(self.row, col) })\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RowInBlock\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    row: usize,\n}\n\nimpl\u003c'b, T\u003e IntoIterator for RowInBlock\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = (\u0026'b Field, BorrowedValue\u003c'b\u003e);\n\n    type IntoIter = CellIter\u003c'b, T\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        CellIter {\n            block: self.block,\n            row: self.row,\n            col: 0,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct RowsIter\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    row: usize,\n}\n\nimpl\u003c'b, T\u003e RowsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: \u0026'b T) -\u003e Self {\n        Self { block, row: 0 }\n    }\n}\n\nimpl\u003c'b, T\u003e Iterator for RowsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = RowInBlock\u003c'b, T\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let row = self.row;\n\n        if row \u003c self.block.num_of_rows() {\n            self.row += 1;\n            Some(RowInBlock {\n                block: self.block,\n                row,\n            })\n        } else {\n            None\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct IntoRowsIter\u003cT: BlockExt\u003e {\n    block: Rc\u003cT\u003e,\n    row: usize,\n}\n\nimpl\u003cT\u003e IntoRowsIter\u003cT\u003e\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: T) -\u003e Self {\n        Self {\n            block: Rc::new(block),\n            row: 0,\n        }\n    }\n}\n\npub struct QueryRowIter\u003cT: BlockExt\u003e {\n    block: Rc\u003cT\u003e,\n    row: usize,\n}\n\nimpl\u003c'b, T\u003e IntoIterator for \u0026'b QueryRowIter\u003cT\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = (\u0026'b Field, BorrowedValue\u003c'b\u003e);\n\n    type IntoIter = CellIter\u003c'b, T\u003e;\n\n    fn into_iter(self) -\u003e Self::IntoIter {\n        CellIter {\n            block: \u0026self.block,\n            row: self.row,\n            col: 0,\n        }\n    }\n}\n\nimpl\u003cT\u003e Iterator for IntoRowsIter\u003cT\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = QueryRowIter\u003cT\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        let row = self.row;\n\n        if row \u003c self.block.num_of_rows() {\n            self.row += 1;\n            Some(QueryRowIter {\n                block: self.block.clone(),\n                row,\n            })\n        } else {\n            None\n        }\n    }\n}\n\npub struct ColsIter\u003c'b, T: BlockExt\u003e {\n    block: \u0026'b T,\n    col: usize,\n}\nimpl\u003c'b, T\u003e ColsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    pub(crate) fn new(block: \u0026'b T) -\u003e Self {\n        Self { block, col: 0 }\n    }\n}\n\nimpl\u003c'b, T\u003e Iterator for ColsIter\u003c'b, T\u003e\nwhere\n    T: BlockExt,\n{\n    type Item = BorrowedColumn\u003c'b\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.col \u003e= self.block.field_count() {\n            return None;\n        }\n\n        let v = unsafe { self.block.get_col_unchecked(self.col) };\n        self.col += 1;\n        Some(v)\n    }\n}\n","traces":[{"line":12,"address":[3737888],"length":1,"stats":{"Line":2},"fn_name":"next\u003ctaos::impls::SyncBlock\u003e"},{"line":13,"address":[3737912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[3737964,3737926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[3737971,3738030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[3738010,3738065],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[3737960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[3738528],"length":1,"stats":{"Line":2},"fn_name":"into_iter\u003ctaos::impls::SyncBlock\u003e"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[3737152],"length":1,"stats":{"Line":2},"fn_name":"new\u003ctaos::impls::SyncBlock\u003e"},{"line":67,"address":[3738096],"length":1,"stats":{"Line":2},"fn_name":"next\u003ctaos::impls::SyncBlock\u003e"},{"line":68,"address":[2182110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2182161,2182240,2182124],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[2182242,2182168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[2182210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2182207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3738153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[3737200],"length":1,"stats":{"Line":0},"fn_name":"new\u003ctaos::impls::SyncBlock\u003e"},{"line":94,"address":[3737207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[2182336],"length":1,"stats":{"Line":0},"fn_name":"into_iter\u003ctaos_query::tests::Block\u003e"},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[3737066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[2182448],"length":1,"stats":{"Line":0},"fn_name":"next\u003ctaos_query::tests::Block\u003e"},{"line":129,"address":[2182462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2182539,2182505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[2182592,2182546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2182632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2182580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2182530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2182688],"length":1,"stats":{"Line":0},"fn_name":"new\u003ctaos_query::tests::Block\u003e"},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":38},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","lib.rs"],"content":"//! This is the common query traits/types for TDengine connectors.\n//!\n#![cfg_attr(nightly, feature(const_slice_from_raw_parts))]\n#![cfg_attr(nightly, feature(const_slice_index))]\n\nuse futures::stream::TryStreamExt;\nuse itertools::Itertools;\nuse mdsn::IntoDsn;\npub use mdsn::{Address, Dsn, DsnError};\nuse serde::de::{value::Error as DeError, DeserializeOwned};\nuse std::{fmt::Debug, marker::PhantomData, rc::Rc};\n\npub mod common;\nmod de;\npub mod helpers;\nmod insert;\n\nmod iter;\npub(crate) mod util;\n\npub use iter::*;\n\nuse async_trait::async_trait;\nuse common::*;\nuse helpers::*;\n\npub enum CodecOpts {\n    Raw,\n    Parquet,\n}\n\npub trait BlockCodec {\n    fn encode(\u0026self, _codec: CodecOpts) -\u003e Vec\u003cu8\u003e;\n    fn decode(from: \u0026[u8], _codec: CodecOpts) -\u003e Self;\n}\n\ntype DeserializeIter\u003c'b, B, T\u003e =\n    std::iter::Map\u003cRowsIter\u003c'b, B\u003e, fn(RowInBlock\u003c'b, B\u003e) -\u003e Result\u003cT, DeError\u003e\u003e;\n\n/// Trait to define a data `Block` to fetch records bulky.\n///\n/// If query performance is not your main concern, you can just use the deserialize method from result set.\npub trait BlockExt: Debug + Sized {\n    /// A block should container number of rows.\n    fn num_of_rows(\u0026self) -\u003e usize;\n\n    /// Fields can be queried from a block.\n    fn fields(\u0026self) -\u003e \u0026[Field];\n\n    /// Number of fields.\n    fn field_count(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n\n    fn precision(\u0026self) -\u003e Precision;\n\n    fn is_null(\u0026self, row: usize, col: usize) -\u003e bool;\n\n    /// Get field without column index check.\n    ///\n    /// # Safety\n    ///\n    /// This should not be called manually, please use [get_field](#method.get_field).\n    unsafe fn get_field_unchecked(\u0026self, col: usize) -\u003e \u0026Field {\n        self.fields().get_unchecked(col)\n    }\n\n    /// Get field of one column.\n    fn get_field(\u0026self, col: usize) -\u003e Option\u003c\u0026Field\u003e {\n        self.fields().get(col)\n    }\n\n    /// # Safety\n    ///\n    /// **DO NOT** call it directly.\n    unsafe fn cell_unchecked(\u0026self, row: usize, col: usize) -\u003e (\u0026Field, BorrowedValue);\n\n    unsafe fn get_col_unchecked(\u0026self, col: usize) -\u003e BorrowedColumn;\n\n    /// Query by rows.\n    fn iter_rows(\u0026self) -\u003e RowsIter\u003c'_, Self\u003e {\n        RowsIter::new(self)\n    }\n\n    /// Consume self into rows.\n    fn into_iter_rows(self) -\u003e IntoRowsIter\u003cSelf\u003e {\n        IntoRowsIter::new(self)\n    }\n\n    /// Columns iterator with borrowed data from block.\n    fn columns_iter(\u0026self) -\u003e ColsIter\u003c'_, Self\u003e {\n        ColsIter::new(self)\n    }\n\n    fn to_records(\u0026self) -\u003e Vec\u003cVec\u003cValue\u003e\u003e {\n        self.iter_rows()\n            .map(|row| row.into_iter().map(|(f, v)| v.into_value()).collect_vec())\n            .collect_vec()\n    }\n\n    /// Deserialize a row to a record type(primitive type or a struct).\n    ///\n    /// Any record could borrow data from the block, so that \u0026[u8], \u0026[str] could be used as record element (if valid).\n    fn deserialize\u003c'b, T\u003e(\u0026'b self) -\u003e DeserializeIter\u003c'b, Self, T\u003e\n    where\n        T: serde::de::Deserialize\u003c'b\u003e,\n    {\n        self.iter_rows().map(|row| {\n            let de = de::RecordDeserializer::from(row);\n            T::deserialize(de)\n        })\n    }\n\n    /// Deserialize a row to a record type(primitive type or a struct).\n    ///\n    /// Any record could borrow data from the block, so that \u0026[u8], \u0026[str] could be used as record element (if valid).\n    fn deserialize_into\u003cT\u003e(\n        self,\n    ) -\u003e std::iter::Map\u003cIntoRowsIter\u003cSelf\u003e, fn(QueryRowIter\u003cSelf\u003e) -\u003e Result\u003cT, DeError\u003e\u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.into_iter_rows().map(|row| {\n            let de = de::RecordDeserializer::from(\u0026row);\n            T::deserialize(de)\n        })\n    }\n\n    /// Shortcut version to `.deserialize_into.collect::\u003cVec\u003cT\u003e\u003e()`\n    fn deserialize_into_vec\u003cT\u003e(self) -\u003e Vec\u003cResult\u003cT, DeError\u003e\u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.deserialize_into().collect()\n    }\n\n    /// Rows as [futures::stream::Stream].\n    fn rows_stream(\u0026self) -\u003e futures::stream::Iter\u003cRowsIter\u003c'_, Self\u003e\u003e {\n        futures::stream::iter(Self::iter_rows(self))\n    }\n\n    /// Owned version to rows stream.\n    fn into_rows_stream(self) -\u003e futures::stream::Iter\u003cIntoRowsIter\u003cSelf\u003e\u003e {\n        futures::stream::iter(Self::into_iter_rows(self))\n    }\n\n    /// Rows stream to deserialized record.\n    fn deserialize_stream\u003c'b, T\u003e(\u0026'b self) -\u003e futures::stream::Iter\u003cDeserializeIter\u003c'b, Self, T\u003e\u003e\n    where\n        T: serde::de::Deserialize\u003c'b\u003e,\n    {\n        futures::stream::iter(Self::deserialize(self))\n    }\n}\n\npub trait Fetchable\nwhere\n    Self: Sized,\n    for\u003c'r\u003e \u0026'r mut Self: Iterator,\n    for\u003c'b, 'r\u003e \u003c\u0026'r mut Self as Iterator\u003e::Item: BlockExt,\n{\n    // type Block: for\u003c'b\u003e BlockExt;\n\n    fn affected_rows(\u0026self) -\u003e i32;\n\n    fn precision(\u0026self) -\u003e Precision;\n\n    fn fields(\u0026self) -\u003e \u0026[Field];\n\n    fn num_of_fields(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n\n    fn summary(\u0026self) -\u003e (usize, usize);\n\n    fn blocks_iter(\u0026mut self) -\u003e \u0026mut Self {\n        self\n    }\n\n    fn to_rows_vec(\u0026mut self) -\u003e Vec\u003cVec\u003cValue\u003e\u003e {\n        self.rows_iter()\n            .map(|row| row.into_iter().map(|(_, v)| v.into_value()).collect())\n            .collect()\n    }\n\n    fn rows_iter\u003c'r\u003e(\n        \u0026'r mut self,\n    ) -\u003e std::iter::FlatMap\u003c\n        \u0026'r mut Self,\n        IntoRowsIter\u003c\u003c\u0026'r mut Self as Iterator\u003e::Item\u003e,\n        fn(\u003c\u0026'r mut Self as Iterator\u003e::Item) -\u003e IntoRowsIter\u003c\u003c\u0026'r mut Self as Iterator\u003e::Item\u003e,\n    \u003e {\n        self.flat_map(|block| block.into_iter_rows())\n    }\n\n    fn deserialize\u003cT\u003e(\n        \u0026mut self,\n    ) -\u003e std::iter::FlatMap\u003c\n        \u0026mut Self,\n        Vec\u003cResult\u003cT, DeError\u003e\u003e,\n        fn(\u003c\u0026mut Self as Iterator\u003e::Item) -\u003e Vec\u003cResult\u003cT, DeError\u003e\u003e,\n    \u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        self.flat_map(|block| block.deserialize_into_vec())\n    }\n}\n\n/// The synchronous query trait for TDengine connection.\npub trait Queryable\u003c'q\u003e: Debug\nwhere\n    for\u003c'r\u003e \u0026'r mut Self::ResultSet: Iterator,\n    for\u003c'b, 'r\u003e \u003c\u0026'r mut Self::ResultSet as Iterator\u003e::Item: BlockExt,\n{\n    type Error: Debug + From\u003cserde::de::value::Error\u003e;\n    // type B: for\u003c'b\u003e BlockExt\u003c'b, 'b\u003e;\n    type ResultSet: Fetchable;\n\n    fn query\u003cT: AsRef\u003cstr\u003e\u003e(\u0026'q self, sql: T) -\u003e Result\u003cSelf::ResultSet, Self::Error\u003e;\n\n    fn exec\u003cT: AsRef\u003cstr\u003e\u003e(\u0026'q self, sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n        self.query(sql).map(|res| res.affected_rows() as _)\n    }\n\n    fn exec_many\u003cT: AsRef\u003cstr\u003e, I: IntoIterator\u003cItem = T\u003e\u003e(\n        \u0026'q self,\n        input: I,\n    ) -\u003e Result\u003cusize, Self::Error\u003e {\n        input\n            .into_iter()\n            .map(|sql| self.exec(sql))\n            .try_fold(0, |mut acc, aff| {\n                acc += aff?;\n                Ok(acc)\n            })\n    }\n\n    fn query_one\u003cT: AsRef\u003cstr\u003e, O: DeserializeOwned\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cOption\u003cO\u003e, Self::Error\u003e {\n        self.query(sql)?\n            .deserialize::\u003cO\u003e()\n            .next()\n            .map_or(Ok(None), |v| v.map(Some).map_err(Into::into))\n    }\n\n    fn create_topic(\n        \u0026'q self,\n        name: impl AsRef\u003cstr\u003e,\n        sql: impl AsRef\u003cstr\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let (name, sql) = (name.as_ref(), sql.as_ref());\n        let query = format!(\"create topic if not exists {name} as {sql}\");\n\n        self.query(\u0026query)?;\n        Ok(())\n    }\n\n    fn create_topic_as_database(\n        \u0026'q self,\n        name: impl AsRef\u003cstr\u003e,\n        db: impl std::fmt::Display,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let name = name.as_ref();\n        let query = format!(\"create topic if not exists {name} as database {db}\");\n\n        self.exec(\u0026query)?;\n        Ok(())\n    }\n\n    fn databases(\u0026'q self) -\u003e Result\u003cVec\u003cShowDatabase\u003e, Self::Error\u003e {\n        self.query(\"show databases\")?\n            .deserialize()\n            .try_collect()\n            .map_err(Into::into)\n    }\n\n    /// Topics information by `show topics` sql.\n    ///\n    /// ## Compatibility\n    ///\n    /// This is a 3.x-only API.\n    fn topics(\u0026'q self) -\u003e Result\u003cVec\u003cTopic\u003e, Self::Error\u003e {\n        self.query(\"show topics\")?\n            .deserialize()\n            .try_collect()\n            .map_err(Into::into)\n    }\n\n    fn describe(\u0026'q self, table: \u0026str) -\u003e Result\u003cDescribe, Self::Error\u003e {\n        Ok(Describe(\n            self.query(format!(\"describe {table}\"))?\n                .deserialize()\n                .try_collect()?,\n        ))\n    }\n}\n\npub trait AsyncFetchable\nwhere\n    Self: Sized + Send,\n    Self::BlockStream: futures::stream::Stream + Send,\n    \u003cSelf::BlockStream as futures::stream::Stream\u003e::Item: BlockExt + Send,\n{\n    type BlockStream;\n    // type Block: for\u003c'b\u003e BlockExt;\n\n    fn affected_rows(\u0026self) -\u003e i32;\n\n    fn precision(\u0026self) -\u003e Precision;\n\n    fn fields(\u0026self) -\u003e \u0026[Field];\n\n    fn num_of_fields(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n\n    fn summary(\u0026self) -\u003e (usize, usize);\n\n    fn blocks_iter(\u0026mut self) -\u003e \u0026mut Self {\n        self\n    }\n\n    fn block_stream(\u0026mut self) -\u003e Self::BlockStream;\n\n    fn into_blocks(mut self) -\u003e Self::BlockStream {\n        self.block_stream()\n    }\n\n    /// Records is a row-based 2-dimension matrix of values.\n    fn to_records(\u0026mut self) -\u003e Vec\u003cVec\u003cValue\u003e\u003e {\n        futures::executor::block_on_stream(Box::pin(self.block_stream()))\n            .flat_map(|block| block.to_records())\n            .collect()\n    }\n\n    fn deserialize_stream\u003cT\u003e(\n        \u0026mut self,\n    ) -\u003e futures::stream::FlatMap\u003c\n        \u003cSelf as AsyncFetchable\u003e::BlockStream,\n        futures::stream::Iter\u003cstd::vec::IntoIter\u003cResult\u003cT, DeError\u003e\u003e\u003e,\n        fn(\n            \u003cSelf::BlockStream as futures::stream::Stream\u003e::Item,\n        ) -\u003e futures::stream::Iter\u003cstd::vec::IntoIter\u003cResult\u003cT, DeError\u003e\u003e\u003e,\n    \u003e\n    where\n        T: serde::de::DeserializeOwned,\n    {\n        // self.blocks_iter()\n        use futures::stream::StreamExt;\n        self.block_stream()\n            .flat_map(|block| futures::stream::iter(block.deserialize_into_vec::\u003cT\u003e()))\n    }\n}\n\n/// The synchronous query trait for TDengine connection.\n#[async_trait]\npub trait AsyncQueryable\u003c'q\u003e: Send + Sync\nwhere\n    \u003cSelf::AsyncResultSet as AsyncFetchable\u003e::BlockStream: 'q + futures::stream::Stream,\n    for\u003c'b\u003e \u003c\u003cSelf::AsyncResultSet as AsyncFetchable\u003e::BlockStream as futures::stream::Stream\u003e::Item:\n        BlockExt + Send,\n{\n    type Error: Debug + From\u003cserde::de::value::Error\u003e + Send;\n    // type B: for\u003c'b\u003e BlockExt\u003c'b, 'b\u003e;\n    type AsyncResultSet: AsyncFetchable;\n\n    async fn query\u003cT: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cSelf::AsyncResultSet, Self::Error\u003e;\n\n    async fn exec\u003cT: AsRef\u003cstr\u003e + Send\u003e(\u0026'q self, sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n        let sql = sql.as_ref();\n        log::trace!(\"exec sql: {sql}\");\n        self.query(sql).await.map(|res| res.affected_rows() as _)\n    }\n\n    async fn exec_many\u003cT, I\u003e(\u0026'q self, input: I) -\u003e Result\u003cusize, Self::Error\u003e\n    where\n        T: AsRef\u003cstr\u003e + Send,\n        I::IntoIter: Send,\n        I: IntoIterator\u003cItem = T\u003e + Send,\n    {\n        let mut aff = 0;\n        for sql in input {\n            aff += self.exec(sql).await?;\n        }\n        Ok(aff)\n    }\n\n    /// To conveniently get first row of the result, useful for queries like\n    ///\n    /// - `select count(*) from ...`\n    /// - `select last(*) from ...`\n    ///\n    /// Type `T` could be `Vec\u003ctaos::query::common::Value\u003e`, a tuple, or a struct with serde support.\n    ///\n    /// ## Example\n    ///\n    /// ```rust,ignore\n    /// let count: u32 = taos.query_one(\"select count(*) from table1\")?.unwrap_or(0);\n    ///\n    /// let one: (i32, String, Timestamp) =\n    ///    taos.query_one(\"select c1,c2,c3 from table1 limit 1\")?.unwrap_or_default();\n    /// ```\n    async fn query_one\u003cT: AsRef\u003cstr\u003e + Send, O: DeserializeOwned + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cOption\u003cO\u003e, Self::Error\u003e {\n        use futures::StreamExt;\n        self.query(sql)\n            .await?\n            .deserialize_stream::\u003cO\u003e()\n            .take(1)\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .await\n            .into_iter()\n            .next()\n            .map_or(Ok(None), |v| v.map(Some).map_err(Into::into))\n    }\n\n    async fn create_topic\u003cN: AsRef\u003cstr\u003e + Send, S: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        name: N,\n        sql: S,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let (name, sql) = (name.as_ref(), sql.as_ref());\n        let query = format!(\"create topic if not exists {name} as {sql}\");\n\n        self.query(query).await?;\n        Ok(())\n    }\n\n    async fn create_topic_as_database(\n        \u0026'q self,\n        name: impl AsRef\u003cstr\u003e + Send + 'async_trait,\n        db: impl std::fmt::Display + Send + 'async_trait,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        let name = name.as_ref();\n        let query = format!(\"create topic if not exists {name} as database {db}\");\n\n        self.exec(\u0026query).await?;\n        Ok(())\n    }\n\n    async fn databases(\u0026'q self) -\u003e Result\u003cVec\u003cShowDatabase\u003e, Self::Error\u003e {\n        use futures::stream::TryStreamExt;\n        Ok(self\n            .query(\"show databases\")\n            .await?\n            .deserialize_stream()\n            .try_collect()\n            .await?)\n    }\n\n    /// Topics information by `show topics` sql.\n    ///\n    /// ## Compatibility\n    ///\n    /// This is a 3.x-only API.\n    async fn topics(\u0026'q self) -\u003e Result\u003cVec\u003cTopic\u003e, Self::Error\u003e {\n        Ok(self\n            .query(\"show topics\")\n            .await?\n            .deserialize_stream()\n            .try_collect()\n            .await?)\n    }\n\n    async fn describe(\u0026'q self, table: \u0026str) -\u003e Result\u003cDescribe, Self::Error\u003e {\n        Ok(Describe(\n            self.query(format!(\"describe {table}\"))\n                .await?\n                .deserialize_stream()\n                .try_collect()\n                .await?,\n        ))\n    }\n\n    fn exec_sync\u003cT: AsRef\u003cstr\u003e + Send\u003e(\u0026'q self, sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n        futures::executor::block_on(self.exec(sql))\n    }\n\n    fn query_sync\u003cT: AsRef\u003cstr\u003e + Send\u003e(\n        \u0026'q self,\n        sql: T,\n    ) -\u003e Result\u003cSelf::AsyncResultSet, Self::Error\u003e {\n        futures::executor::block_on(self.query(sql))\n    }\n}\n\npub trait FromDsn: Sized + 'static {\n    type Err: std::error::Error;\n\n    /// Validate or hygienize the DSN.\n    ///\n    /// ## Error\n    ///\n    /// When there're multi addresses, validate all addresses for connection,\n    /// and filter success addresses. When all addresses of DSN are invalid,\n    /// return last error. When success, it will return a pair of DSN and\n    /// filtered addresses.\n    fn hygienize(dsn: Dsn) -\u003e Result\u003c(Dsn, Vec\u003cAddress\u003e), DsnError\u003e;\n\n    /// Generate a connection object from DSN.\n    fn from_dsn\u003cT: IntoDsn\u003e(dsn: T) -\u003e Result\u003cSelf, Self::Err\u003e;\n\n    /// Is the connection available?\n    fn ping(dsn: \u0026Dsn) -\u003e Result\u003c(), Self::Err\u003e;\n}\n\n/// This is how we manage connections.\npub struct Manager\u003cT: FromDsn\u003e {\n    dsn: Dsn,\n    marker: PhantomData\u003cT\u003e,\n}\n\nimpl\u003cT: FromDsn\u003e Default for Manager\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self {\n            dsn: Dsn {\n                driver: \"taos\".to_string(),\n                ..Default::default()\n            },\n            marker: Default::default(),\n        }\n    }\n}\n\nimpl\u003cT: FromDsn + Send + Sync\u003e Manager\u003cT\u003e {\n    /// Build a connection manager from a DSN.\n    #[inline]\n    pub fn new(dsn: Dsn) -\u003e Result\u003cSelf, DsnError\u003e {\n        let (dsn, _) = T::hygienize(dsn)?;\n\n        Ok(Self {\n            dsn,\n            marker: PhantomData,\n        })\n    }\n\n    /// Parse a DSN format from str.\n    #[inline]\n    pub fn parse(dsn: impl AsRef\u003cstr\u003e) -\u003e Result\u003cSelf, DsnError\u003e {\n        let dsn = Dsn::parse(dsn)?;\n        Self::new(dsn)\n    }\n\n    #[inline]\n    pub fn from_dsn(dsn: impl IntoDsn) -\u003e Result\u003cSelf, DsnError\u003e {\n        let dsn = dsn.into_dsn()?;\n        Self::new(dsn)\n    }\n\n    /// Open a connection to TDengine.\n    #[inline]\n    pub fn connect(\u0026self) -\u003e Result\u003cT, \u003cT as FromDsn\u003e::Err\u003e {\n        T::from_dsn(\u0026self.dsn)\n    }\n\n    #[cfg(feature = \"r2d2\")]\n    #[inline]\n    pub fn into_pool(self) -\u003e Result\u003cPool\u003cT\u003e, r2d2::Error\u003e {\n        r2d2::Pool::new(self)\n    }\n\n    #[cfg(feature = \"r2d2\")]\n    #[inline]\n    pub fn into_pool_with_builder(\n        self,\n        builder: r2d2::Builder\u003cSelf\u003e,\n    ) -\u003e Result\u003cPool\u003cT\u003e, r2d2::Error\u003e {\n        builder.build(self)\n    }\n}\n\n#[cfg(feature = \"r2d2\")]\npub type Pool\u003cT\u003e = r2d2::Pool\u003cManager\u003cT\u003e\u003e;\n\n#[cfg(feature = \"r2d2\")]\nimpl\u003cT: FromDsn + Send + Sync + 'static\u003e r2d2::ManageConnection for Manager\u003cT\u003e {\n    type Connection = T;\n    type Error = \u003cT as FromDsn\u003e::Err;\n\n    #[inline]\n    fn connect(\u0026self) -\u003e Result\u003cSelf::Connection, Self::Error\u003e {\n        self.connect()\n    }\n\n    #[inline]\n    fn is_valid(\u0026self, _: \u0026mut Self::Connection) -\u003e Result\u003c(), Self::Error\u003e {\n        \u003cT as FromDsn\u003e::ping(\u0026self.dsn)\n    }\n\n    #[inline]\n    fn has_broken(\u0026self, _: \u0026mut Self::Connection) -\u003e bool {\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use serde::forward_to_deserialize_any;\n    use std::marker::PhantomData;\n\n    use super::*;\n    #[derive(Debug)]\n    struct Conn;\n\n    #[derive(Debug)]\n    struct Value\u003c's\u003e(\u0026's str);\n\n    struct Deserializer;\n\n    impl\u003c'de\u003e serde::de::Deserializer\u003c'de\u003e for Deserializer {\n        type Error = serde::de::value::Error;\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_i32(1)\n        }\n\n        forward_to_deserialize_any! {\n            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n            seq bytes byte_buf map unit_struct newtype_struct\n            tuple_struct struct tuple enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, 's: 'de\u003e serde::de::Deserializer\u003c'de\u003e for Value\u003c's\u003e {\n        type Error = serde::de::value::Error;\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_i32(1)\n        }\n\n        forward_to_deserialize_any! {\n            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char unit option\n            seq byte_buf map unit_struct newtype_struct\n            tuple_struct struct tuple enum identifier ignored_any\n        }\n\n        fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_borrowed_str(self.0)\n        }\n        fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            self.deserialize_str(visitor)\n        }\n        fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: serde::de::Visitor\u003c'de\u003e,\n        {\n            const V: u32 = 0x0f0f0f0f;\n            let v: \u0026[u8; 4] = unsafe { std::mem::transmute(\u0026V) };\n            visitor.visit_borrowed_bytes(v)\n        }\n    }\n\n    #[derive(Debug)]\n    struct MyResultSet\u003c'q\u003e(PhantomData\u003c\u0026'q u8\u003e);\n\n    #[derive(Debug)]\n    struct Block\u003c'r, 'q\u003e(PhantomData\u003c(\u0026'r u8, \u0026'q u8)\u003e);\n\n    impl\u003c'b, 'r, 'q\u003e BlockExt for Block\u003c'r, 'q\u003e {\n        fn num_of_rows(\u0026self) -\u003e usize {\n            1\n        }\n\n        fn fields(\u0026self) -\u003e \u0026[Field] {\n            static mut FIELDS: Vec\u003cField\u003e = Vec::new();\n            unsafe {\n                if FIELDS.len() == 0 {\n                    FIELDS.push(Field::new(\"ts\", Ty::Timestamp, 8));\n                    FIELDS.push(Field::new(\"bin10\", Ty::VarChar, 10));\n                    FIELDS.push(Field::new(\"int32\", Ty::Int, 4));\n                }\n                \u0026FIELDS\n            }\n        }\n\n        fn precision(\u0026self) -\u003e Precision {\n            Precision::Microsecond\n        }\n\n        fn is_null(\u0026self, _row: usize, _col: usize) -\u003e bool {\n            false\n        }\n\n        fn field_count(\u0026self) -\u003e usize {\n            3\n        }\n\n        unsafe fn cell_unchecked(\u0026self, _row: usize, col: usize) -\u003e (\u0026Field, BorrowedValue) {\n            match col {\n                0 =\u003e (\n                    self.get_field_unchecked(col) as _,\n                    BorrowedValue::Timestamp(crate::Timestamp::Milliseconds(0)),\n                ),\n                2 =\u003e (self.get_field_unchecked(col) as _, BorrowedValue::Int(32)),\n                1 =\u003e (\n                    self.get_field_unchecked(col) as _,\n                    BorrowedValue::VarChar(\"str\"),\n                ),\n                _ =\u003e (self.get_field_unchecked(col) as _, BorrowedValue::Int(32)),\n            }\n        }\n\n        unsafe fn get_col_unchecked(\u0026self, _col: usize) -\u003e BorrowedColumn {\n            todo!()\n        }\n    }\n\n    impl\u003c'r, 'q\u003e Iterator for \u0026'r mut MyResultSet\u003c'q\u003e {\n        type Item = Block\u003c'r, 'q\u003e;\n\n        fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n            static mut AVAILABLE: bool = true;\n            if unsafe { AVAILABLE } {\n                unsafe { AVAILABLE = false };\n\n                Some(Block(PhantomData))\n            } else {\n                None\n            }\n        }\n    }\n\n    impl\u003c'r, 'q\u003e crate::Fetchable for MyResultSet\u003c'q\u003e {\n        fn fields(\u0026self) -\u003e \u0026[Field] {\n            todo!()\n        }\n\n        fn precision(\u0026self) -\u003e Precision {\n            todo!()\n        }\n\n        fn summary(\u0026self) -\u003e (usize, usize) {\n            todo!()\n        }\n\n        fn affected_rows(\u0026self) -\u003e i32 {\n            todo!()\n        }\n    }\n\n    #[derive(Debug)]\n    struct Error;\n\n    impl\u003c'q\u003e Queryable\u003c'q\u003e for Conn {\n        type Error = anyhow::Error;\n\n        type ResultSet = MyResultSet\u003c'q\u003e;\n\n        fn query\u003cT: AsRef\u003cstr\u003e\u003e(\u0026'q self, _sql: T) -\u003e Result\u003cMyResultSet, Self::Error\u003e {\n            Ok(MyResultSet(PhantomData))\n        }\n\n        fn exec\u003cT: AsRef\u003cstr\u003e\u003e(\u0026self, _sql: T) -\u003e Result\u003cusize, Self::Error\u003e {\n            Ok(1)\n        }\n    }\n    #[test]\n    fn query_deserialize() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut rs = conn.query(\"abc\").unwrap();\n\n        for record in rs.deserialize::\u003c(i32, String, u8)\u003e() {\n            dbg!(record.unwrap());\n        }\n    }\n    #[test]\n    fn block_deserialize_borrowed() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n        for block in \u0026mut set {\n            for record in block.deserialize::\u003c(i32, \u0026str, u8)\u003e() {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[test]\n    fn block_deserialize_borrowed_bytes() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        for block in \u0026mut set {\n            for record in block.deserialize::\u003c(String, \u0026str, u8)\u003e() {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[tokio::test]\n    async fn block_deserialize_borrowed_bytes_stream() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        use futures::stream::*;\n\n        for block in \u0026mut set {\n            for record in block\n                .deserialize_stream::\u003c(String, \u0026str, u8)\u003e()\n                .next()\n                .await\n            {\n                dbg!(record.unwrap());\n            }\n        }\n    }\n    #[test]\n    fn with_iter() {\n        let conn = Conn;\n\n        let aff = conn.exec(\"nothing\").unwrap();\n        assert_eq!(aff, 1);\n\n        let mut set = conn.query(\"abc\").unwrap();\n\n        for block in \u0026mut set {\n            // todo\n            for row in block.iter_rows() {\n                for value in row {\n                    println!(\"{:?}\", value);\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":51,"address":[3759920],"length":1,"stats":{"Line":0},"fn_name":"field_count\u003ctaos::impls::SyncBlock\u003e"},{"line":52,"address":[3759929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[3329088],"length":1,"stats":{"Line":2},"fn_name":"get_field_unchecked\u003ctaos_query::tests::Block\u003e"},{"line":65,"address":[3329107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[3329168],"length":1,"stats":{"Line":0},"fn_name":"get_field\u003ctaos_query::tests::Block\u003e"},{"line":70,"address":[3329187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[3329248],"length":1,"stats":{"Line":2},"fn_name":"iter_rows\u003ctaos_query::tests::Block\u003e"},{"line":82,"address":[3329257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[3329296],"length":1,"stats":{"Line":0},"fn_name":"into_iter_rows\u003ctaos_query::tests::Block\u003e"},{"line":87,"address":[3329300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3329328],"length":1,"stats":{"Line":0},"fn_name":"columns_iter\u003ctaos_query::tests::Block\u003e"},{"line":92,"address":[3329337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3329376],"length":1,"stats":{"Line":0},"fn_name":"to_records\u003ctaos_query::tests::Block\u003e"},{"line":96,"address":[3329408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[2814112,2814165,2814224,2814254],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::Block\u003e"},{"line":104,"address":[3329584,3329488],"length":1,"stats":{"Line":2},"fn_name":"deserialize\u003ctaos_query::tests::Block, (i32, \u0026str, u8)\u003e"},{"line":108,"address":[2814464,2814336],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003ctaos_query::tests::Block, (i32, \u0026str, u8)\u003e"},{"line":109,"address":[2814401,2814529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[2814411,2814539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[3329808,3329872,3329744,3329680],"length":1,"stats":{"Line":0},"fn_name":"deserialize_into\u003ctaos_query::tests::Block, (i32, alloc::string::String, u8)\u003e"},{"line":123,"address":[2814959,2815167,2815008,2815375,2814800,2815216,2814751,2814592],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::Block, (i32, alloc::string::String, u8)\u003e"},{"line":124,"address":[2814844,2815260,2815052,2814636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[2814681,2815305,2815097,2814889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[3329936,3330000,3330128,3330064],"length":1,"stats":{"Line":0},"fn_name":"deserialize_into_vec\u003ctaos_query::tests::Block, taos_query::helpers::describe::ColumnMeta\u003e"},{"line":134,"address":[3330078,3330142,3329950,3330014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[3330192],"length":1,"stats":{"Line":0},"fn_name":"rows_stream\u003ctaos_query::tests::Block\u003e"},{"line":139,"address":[3330201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[3330256],"length":1,"stats":{"Line":0},"fn_name":"into_rows_stream\u003ctaos_query::tests::Block\u003e"},{"line":144,"address":[3330260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[3330320],"length":1,"stats":{"Line":0},"fn_name":"deserialize_stream\u003ctaos_query::tests::Block, (alloc::string::String, \u0026str, u8)\u003e"},{"line":152,"address":[3330339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[3330384],"length":1,"stats":{"Line":0},"fn_name":"num_of_fields\u003ctaos_query::tests::MyResultSet\u003e"},{"line":171,"address":[3330393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[3330416],"length":1,"stats":{"Line":0},"fn_name":"blocks_iter\u003ctaos_query::tests::MyResultSet\u003e"},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[3330432],"length":1,"stats":{"Line":0},"fn_name":"to_rows_vec\u003ctaos_query::tests::MyResultSet\u003e"},{"line":181,"address":[3330450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2815424,2815616,2815584,2815462],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::MyResultSet\u003e"},{"line":186,"address":[3330512],"length":1,"stats":{"Line":0},"fn_name":"rows_iter\u003ctaos_query::tests::MyResultSet\u003e"},{"line":193,"address":[2815680,2815689],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos_query::tests::MyResultSet\u003e"},{"line":196,"address":[3330704,3330656,3330608,3330560],"length":1,"stats":{"Line":1},"fn_name":"deserialize\u003ctaos_query::tests::MyResultSet, taos_query::helpers::topic::Topic\u003e"},{"line":206,"address":[2815728,2815792,2815760,2815824,2815808,2815776,2815744,2815840],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}\u003ctaos_query::tests::MyResultSet, (i32, alloc::string::String, u8)\u003e"},{"line":222,"address":[3778352],"length":1,"stats":{"Line":0},"fn_name":"exec\u003ctaos::Taos, alloc::string::String\u003e"},{"line":223,"address":[3414185,3414176],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos::Taos, alloc::string::String\u003e"},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[3330981,3330752],"length":1,"stats":{"Line":0},"fn_name":"databases\u003ctaos_query::tests::Conn\u003e"},{"line":274,"address":[3330955,3330788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[3331237,3331008],"length":1,"stats":{"Line":0},"fn_name":"topics\u003ctaos_query::tests::Conn\u003e"},{"line":286,"address":[3331044,3331211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[3331264,3331914],"length":1,"stats":{"Line":0},"fn_name":"describe\u003ctaos_query::tests::Conn\u003e"},{"line":293,"address":[3331765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[3331868,3331304,3331627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[3331836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[3759584],"length":1,"stats":{"Line":0},"fn_name":"num_of_fields\u003ctaos::impls::ResultSet\u003e"},{"line":317,"address":[3759593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[3759456],"length":1,"stats":{"Line":0},"fn_name":"blocks_iter\u003ctaos::impls::ResultSet\u003e"},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[3759472,3759541],"length":1,"stats":{"Line":0},"fn_name":"into_blocks\u003ctaos::impls::ResultSet\u003e"},{"line":329,"address":[3759489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[3759200],"length":1,"stats":{"Line":0},"fn_name":"to_records\u003ctaos::impls::ResultSet\u003e"},{"line":334,"address":[3759388,3759225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[3406032,3406060],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos::impls::ResultSet\u003e"},{"line":339,"address":[3759744,3759680,3759616],"length":1,"stats":{"Line":0},"fn_name":"deserialize_stream\u003ctaos::impls::ResultSet, taos_query::helpers::describe::ColumnMeta\u003e"},{"line":353,"address":[3759635,3759763,3759699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[3406160,3406190,3406352,3406286,3406256,3406382],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ctaos::impls::ResultSet, taos_query::helpers::database::ShowDatabase\u003e"},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[3411442,3410743,3411145,3411001,3412662,3410688],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}\u003ctaos::Taos\u003e"},{"line":451,"address":[3412270,3412485,3411205,3412145,3411377,3411498,3411814,3411919,3411867,3412070,3411599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[3410881,3411272,3410963,3411399,3411453,3411533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[3411738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[3412209,3410899,3411946,3412092],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[3412453],"length":1,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[3406761,3406448,3406503,3406905,3407202,3408422],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}\u003ctaos::Taos\u003e"},{"line":465,"address":[3408245,3407137,3407574,3408030,3407359,3407627,3407830,3407679,3407258,3407905,3406965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[3406641,3407293,3407159,3407032,3406723,3407213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[3407498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[3407706,3407969,3406659,3407852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[3408213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[3409400,3408783,3408519,3408927,3410653,3408464],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}\u003ctaos::Taos\u003e"},{"line":474,"address":[3410350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[3409070,3408657,3409772,3408742,3410229,3409411,3409825,3409877,3410028,3410476,3410104,3409015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[3409696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[3410051,3410168,3409904,3408675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[3410444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[1846160],"length":1,"stats":{"Line":2},"fn_name":"num_of_rows"},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[1846176],"length":1,"stats":{"Line":2},"fn_name":"fields"},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[1846191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":686,"address":[1846285,1846219],"length":1,"stats":{"Line":4},"fn_name":null},{"line":687,"address":[1846302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":688,"address":[1846357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[1846259],"length":1,"stats":{"Line":2},"fn_name":null},{"line":694,"address":[1846448],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":695,"address":[1846457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[1846480],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[1846512],"length":1,"stats":{"Line":2},"fn_name":"field_count"},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[1846528],"length":1,"stats":{"Line":2},"fn_name":"cell_unchecked"},{"line":707,"address":[1846579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":708,"address":[1846946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[1846644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":710,"address":[1846903],"length":1,"stats":{"Line":2},"fn_name":null},{"line":712,"address":[1846669,1846853],"length":1,"stats":{"Line":4},"fn_name":null},{"line":713,"address":[1846816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":714,"address":[1846694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[1846781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":717,"address":[1846715,1846622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[1846976],"length":1,"stats":{"Line":0},"fn_name":"get_col_unchecked"},{"line":729,"address":[1847024],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[1847033,1847047],"length":1,"stats":{"Line":3},"fn_name":null},{"line":732,"address":[1847049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":734,"address":[1847056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":736,"address":[1847042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":742,"address":[1847088],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":746,"address":[1847136],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":750,"address":[1847184],"length":1,"stats":{"Line":0},"fn_name":"summary"},{"line":754,"address":[1847232],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":767,"address":[3331952,3332000],"length":1,"stats":{"Line":2},"fn_name":"query\u003calloc::string::String\u003e"},{"line":768,"address":[3332019,3331972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":771,"address":[3332048],"length":1,"stats":{"Line":1},"fn_name":"exec\u003c\u0026str\u003e"},{"line":772,"address":[3332074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":776,"address":[1849006,1848990,1847792],"length":1,"stats":{"Line":3},"fn_name":"query_deserialize"},{"line":779,"address":[1847799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[1848003,1847860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[1848059,1847952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[1848372,1849001,1848071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[1848294,1848399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[1849040],"length":1,"stats":{"Line":3},"fn_name":"block_deserialize_borrowed"},{"line":792,"address":[1849047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":793,"address":[1849102,1849224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":795,"address":[1849185,1849277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":796,"address":[1849505,1849289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":797,"address":[1849368,1849510,1850132],"length":1,"stats":{"Line":3},"fn_name":null},{"line":798,"address":[1849574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":803,"address":[1850144,1851337],"length":1,"stats":{"Line":3},"fn_name":"block_deserialize_borrowed_bytes"},{"line":806,"address":[1850151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":807,"address":[1850212,1850355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":809,"address":[1850411,1850304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":811,"address":[1850645,1850423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":812,"address":[1851363,1850508,1850650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":813,"address":[1850676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":818,"address":[1851723,1851383,1851696,1851376],"length":1,"stats":{"Line":6},"fn_name":"block_deserialize_borrowed_bytes_stream"},{"line":821,"address":[3332577,3332341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":822,"address":[3332771,3332634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":824,"address":[3332728,3332835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":828,"address":[1851490,1851403],"length":1,"stats":{"Line":3},"fn_name":null},{"line":829,"address":[3334315,3333000,3333654,3333172,3333363,3333097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[3332395,3333049,3333331,3333136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[3333560,3333681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[1852564,1851760],"length":1,"stats":{"Line":3},"fn_name":"with_iter"},{"line":842,"address":[1851767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":843,"address":[1851932,1851816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":845,"address":[1851893,1851985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":847,"address":[1851997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":849,"address":[1852345,1852076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":850,"address":[1852350,1852240,1852590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[1852406,1852473],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":65,"coverable":233},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","inline_bytes.rs"],"content":"use std::fmt;\n\n#[repr(C)]\n#[repr(packed(1))]\npub struct InlineBytes\u003cT = u16\u003e {\n    len: T,\n    data: [u8; 0],\n}\n\nmacro_rules! _impl_inline_lines {\n    ($($ty:ty) *) =\u003e {\n        $(\n\n            impl fmt::Debug for InlineBytes\u003c$ty\u003e {\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.debug_struct(\"InlineBytes\")\n                        .field(\"len\", \u0026self.len())\n                        .field(\"data\", \u0026self.as_bytes())\n                        .finish()\n                }\n            }\n\n            impl fmt::Display for InlineBytes\u003c$ty\u003e {\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.write_str(\u0026self.printable())\n                }\n            }\n\n            impl AsRef\u003c[u8]\u003e for InlineBytes\u003c$ty\u003e {\n                fn as_ref(\u0026self) -\u003e \u0026[u8] {\n                    self.as_bytes()\n                }\n            }\n\n            impl InlineBytes\u003c$ty\u003e {\n                #[inline]\n                pub fn from_ptr\u003c'a\u003e(ptr: *const u8) -\u003e \u0026'a Self {\n                    unsafe { std::mem::transmute::\u003c*const u8, \u0026InlineBytes\u003c$ty\u003e\u003e(ptr) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n                    unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n                }\n\n                #[inline]\n                pub fn printable(\u0026self) -\u003e String {\n                    String::from_utf8(self.as_bytes().iter().flat_map(|b| b.escape_ascii().into_iter()).collect()).expect(\"\")\n                }\n\n                #[inline]\n                pub const fn len(\u0026self) -\u003e usize {\n                    self.len as _\n                }\n\n                #[inline]\n                pub fn encode(v: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\n                    let len = v.len() as $ty;\n                    let mut vec = Vec::with_capacity(v.len() + std::mem::size_of::\u003c$ty\u003e());\n                    vec.extend(len.to_le_bytes());\n                    vec.extend(v);\n                    vec\n                }\n            }\n        )*\n    };\n}\n_impl_inline_lines!(u8 u16 u32 u64 usize);\n\nmacro_rules! _impl_test_inline_lines {\n    ($ty:ty, $bytes:literal) =\u003e {{\n        let bytes = $bytes;\n        let inline = InlineBytes::\u003c$ty\u003e::from_ptr(bytes.as_ptr());\n        dbg!(inline);\n        assert_eq!(inline.len(), 4);\n        assert_eq!(inline.as_ref(), b\"abcd\");\n        assert_eq!(inline.to_string(), \"abcd\");\n        assert_eq!(InlineBytes::\u003c$ty\u003e::encode(b\"abcd\"), bytes);\n    }};\n}\n\n#[test]\nfn test_inline_lines() {\n    _impl_test_inline_lines!(u8, b\"\\x04abcd\");\n    _impl_test_inline_lines!(u16, b\"\\x04\\x00abcd\");\n    _impl_test_inline_lines!(u32, b\"\\x04\\x00\\x00\\x00abcd\");\n    _impl_test_inline_lines!(u64, b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcd\");\n}\n","traces":[{"line":15,"address":[2759360,2762128,2761216,2763040,2760288],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":16,"address":[2759487,2762255,2761343,2759379,2759422,2762190,2762147,2760307,2763102,2763059,2761278,2760350,2760415,2763167,2761235],"length":1,"stats":{"Line":12},"fn_name":null},{"line":17,"address":[2762175,2759407,2761263,2763087,2760335],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[2759462,2760390,2761318,2763142,2762230],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[2759684,2761540,2760612,2760480,2761408,2762320,2763364,2762452,2763232,2759552],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":25,"address":[2761433,2761512,2759656,2763336,2760505,2762345,2763257,2762424,2759577,2760584],"length":1,"stats":{"Line":8},"fn_name":null},{"line":30,"address":[2759728,2760656,2761584,2762496,2763408],"length":1,"stats":{"Line":4},"fn_name":"as_ref"},{"line":31,"address":[2759737,2761593,2760665,2763417,2762505],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[2759776,2761632,2762544,2763456,2760704],"length":1,"stats":{"Line":4},"fn_name":"from_ptr"},{"line":38,"address":[2762553,2763465,2759785,2761641,2760713],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[2763952,2764048,2764240,2764144,2764336],"length":1,"stats":{"Line":4},"fn_name":"as_bytes"},{"line":43,"address":[2764254,2764158,2764062,2764350,2763966],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[2763488,2761664,2760736,2762576,2759808],"length":1,"stats":{"Line":4},"fn_name":"printable"},{"line":48,"address":[2760774,2762614,2759846,2763526,2761702],"length":1,"stats":{"Line":12},"fn_name":null},{"line":52,"address":[2760000,2763680,2760928,2761856,2762768],"length":1,"stats":{"Line":4},"fn_name":"len"},{"line":53,"address":[2762773,2760005,2763685,2760933,2761861],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[2762104,2763696,2761189,2763928,2762784,2760944,2761872,2763016,2760252,2760016],"length":1,"stats":{"Line":4},"fn_name":"encode"},{"line":58,"address":[2760978,2762818,2760050,2761906,2763730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[2761921,2763740,2760996,2762828,2760065],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[2761065,2761989,2763861,2762041,2762897,2760188,2763809,2760133,2761122,2762949],"length":1,"stats":{"Line":8},"fn_name":null},{"line":61,"address":[2762083,2763907,2761168,2760231,2762995],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2401269,2401264],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":84,"address":[2765644,2764439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[2765899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[2767337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[2768775],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","inline_str.rs"],"content":"use std::fmt;\n\nuse super::Inlinable;\n\n#[repr(C)]\n#[repr(packed(1))]\npub struct InlineStr\u003cT = u16\u003e {\n    len: T,\n    data: [u8; 0],\n}\n// #[repr(C)]\n// #[repr(packed(1))]\n// struct InlineStr\u003cT: AsUsize\u003e {\n//     len: T,\n//     data: [u8; 0],\n// }\n\n// pub trait AsUsize: Copy {\n//     fn as_usize(\u0026self) -\u003e usize;\n// }\n\n// impl AsUsize for u8 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u16 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u32 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl AsUsize for u64 {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n// impl AsUsize for usize {\n//     fn as_usize(\u0026self) -\u003e usize {\n//         *self as _\n//     }\n// }\n\n// impl\u003cT: AsUsize\u003e InlineStr\u003cT\u003e {\n//     #[inline]\n//     pub fn from_ptr\u003c'a\u003e(ptr: *const u8) -\u003e \u0026'a Self {\n//         unsafe { std::mem::transmute::\u003c*const u8, \u0026Self\u003e(ptr) }\n//     }\n//     #[inline]\n//     #[rustversion::attr(nightly, const)]\n//     pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n//         unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n//     }\n//     #[inline]\n//     #[rustversion::attr(nightly, const)]\n//     pub fn as_str(\u0026self) -\u003e \u0026str {\n//         unsafe { std::str::from_utf8_unchecked(self.as_bytes()) }\n//     }\n\n//     #[inline]\n//     #[allow(unaligned_references)]\n//     pub fn len(\u0026self) -\u003e usize {\n//         self.len.as_usize()\n//     }\n// }\n\nmacro_rules! _impl_inline_str {\n    ($($ty:ty) *) =\u003e {\n        $(\n\n            impl fmt::Debug for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.debug_struct(\"InlineStr\")\n                        .field(\"len\", \u0026self.len())\n                        .field(\"data\", \u0026self.as_str())\n                        .finish()\n                }\n            }\n\n            impl fmt::Display for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    f.write_str(self.as_str())\n                }\n            }\n\n            impl AsRef\u003cstr\u003e for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn as_ref(\u0026self) -\u003e \u0026str {\n                    self.as_str()\n                }\n            }\n\n            impl Inlinable for InlineStr\u003c$ty\u003e {\n                #[inline]\n                fn write_inlined\u003cW: std::io::Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n                    let l = wtr.write(\u0026self.len.to_le_bytes())?;\n                    Ok(l + wtr.write(self.as_bytes())?)\n                }\n\n                #[inline]\n                fn read_inlined\u003cR: std::io::Read\u003e(_: R) -\u003e std::io::Result\u003cSelf\u003e {\n                    Err(std::io::Error::new(std::io::ErrorKind::Other, \"can't read into a inlined string\"))\n                }\n            }\n\n            impl InlineStr\u003c$ty\u003e {\n                #[inline]\n                pub fn from_ptr\u003c'a\u003e(ptr: *const u8) -\u003e \u0026'a Self {\n                    unsafe { std::mem::transmute::\u003c*const u8, \u0026InlineStr\u003c$ty\u003e\u003e(ptr) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n                    unsafe { std::slice::from_raw_parts(self.data.as_ptr(), self.len()) }\n                }\n                #[inline]\n                #[rustversion::attr(nightly, const)]\n                pub fn as_str(\u0026self) -\u003e \u0026str {\n                    unsafe { std::str::from_utf8_unchecked(self.as_bytes()) }\n                }\n\n                #[inline]\n                pub const fn len(\u0026self) -\u003e usize {\n                    self.len as _\n                }\n            }\n        )*\n    };\n}\n_impl_inline_str!(u8 u16 u32 u64 usize);\n\nmacro_rules! _impl_test_inline_str {\n    ($ty:ty, $bytes:literal, $print:literal) =\u003e {{\n        let bytes = $bytes;\n        let inline = InlineStr::\u003c$ty\u003e::from_ptr(bytes.as_ptr());\n        dbg!(inline);\n        assert_eq!(inline.len(), 4);\n        assert_eq!(inline.as_ref(), \"abcd\");\n        assert_eq!(format!(\"{}\", inline), \"abcd\");\n        assert_eq!(inline.inlined(), bytes);\n        assert_eq!(inline.printable_inlined(), $print);\n    }};\n}\n\n#[test]\nfn test_inline_str() {\n    _impl_test_inline_str!(u8, b\"\\x04abcd\", \"\\\\x04abcd\");\n    _impl_test_inline_str!(u16, b\"\\x04\\x00abcd\", \"\\\\x04\\\\x00abcd\");\n    _impl_test_inline_str!(u32, b\"\\x04\\x00\\x00\\x00abcd\", \"\\\\x04\\\\x00\\\\x00\\\\x00abcd\");\n    _impl_test_inline_str!(\n        u64,\n        b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcd\",\n        \"\\\\x04\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00abcd\"\n    );\n}\n","traces":[{"line":80,"address":[2445216,2444848,2446320,2445952,2445584],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":81,"address":[2444867,2445603,2445646,2445278,2444910,2445235,2444975,2446014,2446382,2446447,2445971,2445711,2445343,2446339,2446079],"length":1,"stats":{"Line":12},"fn_name":null},{"line":82,"address":[2445999,2445631,2444895,2445263,2446367],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2444950,2445686,2445318,2446422,2446054],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[2446144,2446512,2445776,2445040,2445408],"length":1,"stats":{"Line":4},"fn_name":"fmt"},{"line":91,"address":[2445427,2446163,2446531,2445795,2445059],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[2445120,2446592,2445488,2446224,2445856],"length":1,"stats":{"Line":4},"fn_name":"as_ref"},{"line":98,"address":[2446233,2445497,2445865,2446601,2445129],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[2186702,2186148,2187280,2186720,2187812,2185072,2186176,2187252,2185599,2185616],"length":1,"stats":{"Line":4},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":105,"address":[2186802,2185107,2185152,2187315,2187362,2187504,2185291,2186394,2185698,2185840,2186755,2186255,2186211,2186944,2185651],"length":1,"stats":{"Line":8},"fn_name":null},{"line":106,"address":[2186670,2186103,2185567,2187482,2186657,2187207,2187579,2187019,2185915,2186372,2187220,2187780,2186469,2187767,2185366,2185269,2185554,2185818,2186922,2186116],"length":1,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[2446272,2445904,2445168,2446640,2445536],"length":1,"stats":{"Line":4},"fn_name":"from_ptr"},{"line":118,"address":[2446281,2445545,2445177,2446649,2445913],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[2446688,2447008,2447168,2447328,2446848],"length":1,"stats":{"Line":4},"fn_name":"as_bytes"},{"line":123,"address":[2446702,2447342,2447182,2446862,2447022],"length":1,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[2447264,2446784,2446944,2447424,2447104],"length":1,"stats":{"Line":4},"fn_name":"as_str"},{"line":128,"address":[2447433,2446793,2446953,2447273,2447113],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[2445568,2445936,2446672,2445200,2446304],"length":1,"stats":{"Line":4},"fn_name":"len"},{"line":133,"address":[2445205,2446309,2446677,2445941,2445573],"length":1,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[2187840,2187845],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":156,"address":[2448829,2447501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[2449330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[2451137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[2452959],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-query","src","util","mod.rs"],"content":"mod inline_bytes;\nmod inline_str;\n\nuse std::{\n    io::{Read, Write},\n    mem::size_of,\n};\n\npub use inline_bytes::InlineBytes;\npub use inline_str::InlineStr;\n\npub trait InlinableWrite: Write {\n    #[inline]\n    /// Write `usize` length as little endian `N` bytes.\n    fn write_len_with_width\u003cconst N: usize\u003e(\u0026mut self, len: usize) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026len.to_le_bytes()[0..N])?;\n        Ok(N)\n    }\n\n    #[inline]\n    /// Write a [u8] value to writer.\n    fn write_u8(\u0026mut self, value: u8) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026[value])?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u16] value to writer.\n    fn write_u16(\u0026mut self, value: u16) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u32] value to writer.\n    fn write_u32(\u0026mut self, value: u32) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u64] value to writer.\n    fn write_u64(\u0026mut self, value: u64) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write a [u128] value to writer.\n    fn write_u128(\u0026mut self, value: u128) -\u003e std::io::Result\u003cusize\u003e {\n        self.write(\u0026value.to_le_bytes())?;\n        Ok(1)\n    }\n\n    #[inline]\n    /// Write inlined bytes to writer with specific length width `N`.\n    ///\n    /// The inlined bytes are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    ///  ## Safety\n    ///\n    ///  Write inlined bytes may not be safe if the input bytes length overflows to the width.\n    ///  For example, write `256` bytes with length width `1` is not safe.\n    fn write_inlined_bytes\u003cconst N: usize\u003e(\u0026mut self, bytes: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        let l = self.write(\u0026bytes.len().to_le_bytes()[0..N])?;\n        Ok(l + self.write(bytes)?)\n    }\n\n    #[inline]\n    /// Write inlined string with specific length width `N`.\n    fn write_inlined_str\u003cconst N: usize\u003e(\u0026mut self, s: \u0026str) -\u003e std::io::Result\u003cusize\u003e {\n        self.write_inlined_bytes::\u003cN\u003e(s.as_bytes())\n    }\n\n    #[inline]\n    /// Write an inlinable object.\n    fn write_inlinable\u003cT: Inlinable\u003e(\u0026mut self, value: \u0026T) -\u003e std::io::Result\u003cusize\u003e {\n        value.write_inlined(self)\n    }\n}\n\nimpl\u003cT\u003e InlinableWrite for T where T: Write {}\n\nmacro_rules! _impl_read_exact {\n    ($ty: ty, $N: literal) =\u003e {\n        paste::paste! {\n            fn [\u003cread_ $ty\u003e](\u0026mut self) -\u003e std::io::Result\u003c$ty\u003e {\n                let mut bytes = [0; $N];\n                self.read_exact(\u0026mut bytes)?;\n                Ok($ty::from_le_bytes(bytes))\n            }\n        }\n    };\n}\npub trait InlinableRead: Read {\n    #[inline]\n    /// Read `N` bytes as `usize`.\n    ///\n    /// Only 1/2/4/8 is valid as `N`.\n    fn read_len_with_width\u003cconst N: usize\u003e(\u0026mut self) -\u003e std::io::Result\u003cusize\u003e {\n        let mut bytes: [u8; N] = [0; N];\n        self.read_exact(\u0026mut bytes)?;\n        let len = match N {\n            1 =\u003e bytes[0] as usize,\n            2 =\u003e unsafe { *std::mem::transmute::\u003c*const u8, *const u16\u003e(bytes.as_ptr()) as usize },\n            4 =\u003e unsafe { *std::mem::transmute::\u003c*const u8, *const u32\u003e(bytes.as_ptr()) as usize },\n            8 =\u003e unsafe { *std::mem::transmute::\u003c*const u8, *const u64\u003e(bytes.as_ptr()) as usize },\n            _ =\u003e unreachable!(),\n        };\n        Ok(len)\n    }\n\n    fn read_f32(\u0026mut self) -\u003e std::io::Result\u003cf32\u003e {\n        let mut bytes = [0; 4];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(f32::from_le_bytes(bytes))\n    }\n\n    fn read_f64(\u0026mut self) -\u003e std::io::Result\u003cf64\u003e {\n        let mut bytes = [0; 8];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(f64::from_le_bytes(bytes))\n    }\n\n    fn read_u8(\u0026mut self) -\u003e std::io::Result\u003cu8\u003e {\n        let mut bytes = [0; 1];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u8::from_le_bytes(bytes))\n    }\n    fn read_u16(\u0026mut self) -\u003e std::io::Result\u003cu16\u003e {\n        let mut bytes = [0; 2];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u16::from_le_bytes(bytes))\n    }\n\n    fn read_u32(\u0026mut self) -\u003e std::io::Result\u003cu32\u003e {\n        let mut bytes = [0; 4];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u32::from_le_bytes(bytes))\n    }\n\n    fn read_u64(\u0026mut self) -\u003e std::io::Result\u003cu64\u003e {\n        let mut bytes = [0; 8];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u64::from_le_bytes(bytes))\n    }\n\n    fn read_u128(\u0026mut self) -\u003e std::io::Result\u003cu128\u003e {\n        let mut bytes = [0; 16];\n        self.read_exact(\u0026mut bytes)?;\n        Ok(u128::from_le_bytes(bytes))\n    }\n\n    #[inline]\n    /// Read inlined bytes with specific length width `N`.\n    ///\n    /// The inlined bytes are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    fn read_inlined_bytes\u003cconst N: usize\u003e(\u0026mut self) -\u003e std::io::Result\u003cVec\u003cu8\u003e\u003e {\n        let len = self.read_len_with_width::\u003cN\u003e()?;\n        let mut buf = Vec::with_capacity(len);\n        unsafe { buf.set_len(len) };\n        self.read_exact(\u0026mut buf)?;\n        Ok(buf)\n    }\n\n    #[inline]\n    /// Read inlined string with specific length width `N`.\n    ///\n    /// The inlined string are constructed as:\n    ///\n    /// ```text\n    /// +--------------+-----------------+\n    /// | len: N bytes | data: len bytes |\n    /// +--------------+-----------------+\n    /// ```\n    ///\n    fn read_inlined_str\u003cconst N: usize\u003e(\u0026mut self) -\u003e std::io::Result\u003cString\u003e {\n        self.read_inlined_bytes::\u003cN\u003e().and_then(|vec| {\n            String::from_utf8(vec)\n                .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))\n        })\n    }\n\n    #[inline]\n    /// Read some bytes into inlinable object.\n    fn read_inlinable\u003cT: Inlinable\u003e(\u0026mut self) -\u003e std::io::Result\u003cT\u003e {\n        T::read_inlined(self)\n    }\n}\n\nimpl\u003cT\u003e InlinableRead for T where T: Read {}\n\n/// If one struct could be serialized/flattened to bytes array, we call it **inlinable**.\npub trait Inlinable: Sized {\n    /// Read inlined bytes into object.\n    fn read_inlined\u003cR: Read\u003e(reader: R) -\u003e std::io::Result\u003cSelf\u003e;\n\n    /// Write inlined bytes to a writer.\n    fn write_inlined\u003cW: Write\u003e(\u0026self, wtr: W) -\u003e std::io::Result\u003cusize\u003e;\n\n    #[inline]\n    /// Get inlined bytes as vector.\n    fn inlined(\u0026self) -\u003e Vec\u003cu8\u003e {\n        let mut buf = Vec::new();\n        self.write_inlined(\u0026mut buf)\n            .expect(\"write to vec should always be success\");\n        buf\n    }\n\n    #[inline]\n    /// Get inlined bytes as printable string, all the bytes will displayed with escaped ascii code.\n    fn printable_inlined(\u0026self) -\u003e String {\n        self.inlined().escape_ascii().to_string()\n    }\n}\n\nimpl Inlinable for u8 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u8(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u8()\n    }\n}\n\nimpl Inlinable for u16 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u16(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u16()\n    }\n}\n\nimpl Inlinable for u32 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u32(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u32()\n    }\n}\n\nimpl Inlinable for u64 {\n    #[inline]\n    fn write_inlined\u003cW: Write\u003e(\u0026self, mut wtr: W) -\u003e std::io::Result\u003cusize\u003e {\n        wtr.write_u64(*self)\n    }\n\n    #[inline]\n    fn read_inlined\u003cR: Read\u003e(mut reader: R) -\u003e std::io::Result\u003cSelf\u003e {\n        reader.read_u64()\n    }\n}\n\n#[test]\nfn inlined_bytes() -\u003e std::io::Result\u003c()\u003e {\n    let s = \"abcd\";\n    let mut vec: Vec\u003cu8\u003e = Vec::new();\n    let bytes = vec.write_inlined_bytes::\u003c1\u003e(s.as_bytes())?;\n    assert_eq!(bytes, 5);\n    assert_eq!(\u0026vec, b\"\\x04abcd\");\n\n    let r = vec.as_slice().read_inlined_str::\u003c1\u003e()?;\n    assert_eq!(r, \"abcd\");\n    Ok(())\n}\n","traces":[{"line":15,"address":[1910384,1910656],"length":1,"stats":{"Line":1},"fn_name":"write_len_with_width\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, 4\u003e"},{"line":16,"address":[1910609,1910881,1910701,1910429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[1910587,1910859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[1910928,1911088],"length":1,"stats":{"Line":1},"fn_name":"write_u8\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":23,"address":[1911112,1910952,1911204,1911044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[1911023,1911183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1911248],"length":1,"stats":{"Line":0},"fn_name":"write_u16\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":30,"address":[1911398,1911280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1911376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[1911440,1911632],"length":1,"stats":{"Line":0},"fn_name":"write_u32\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":37,"address":[1911478,1911670,1911589,1911781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[1911567,1911759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[1911824],"length":1,"stats":{"Line":0},"fn_name":"write_u64\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":44,"address":[1911981,1911866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[1911959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[1913456,1912496,1912016,1912976],"length":1,"stats":{"Line":3},"fn_name":"write_inlined_bytes\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, 2\u003e"},{"line":71,"address":[1913040,1913722,1912762,1912282,1913242,1913520,1912560,1912080],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[1912942,1913763,1912323,1912446,1913422,1913886,1912261,1912926,1913221,1913902,1913406,1913701,1912741,1913283,1912462,1912803],"length":1,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[1913936,1914048],"length":1,"stats":{"Line":0},"fn_name":"write_inlined_str\u003c\u0026mut \u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, 2\u003e"},{"line":78,"address":[1914030,1914142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[1914224,1914160],"length":1,"stats":{"Line":0},"fn_name":"write_inlinable\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e, taos_query::common::field::Field\u003e"},{"line":84,"address":[1914259,1914195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[2803632,2804560,2805024,2804096],"length":1,"stats":{"Line":3},"fn_name":"read_len_with_width\u003c\u0026mut \u0026[u8], 2\u003e"},{"line":107,"address":[2803659,2805051,2804587,2804123],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[2804145,2803681,2805073,2803781,2804242,2804709,2805173,2804609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[2803751,2804679,2805143,2804212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[2805465,2804534,2805001,2803852,2804313,2804780,2805244,2804073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[2805429,2804965,2804498,2804037,2804318,2804785,2803857,2805249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[2804458,2804344,2804925,2805389,2803997,2804811,2803883,2805275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[2805298,2804367,2803906,2804834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[2805363,2803971,2804432,2804899],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[2805488,2805680],"length":1,"stats":{"Line":1},"fn_name":"read_u8\u003c\u0026[u8]\u003e"},{"line":132,"address":[2805704,2805512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[2805813,2805621,2805534,2805726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[2805784,2805856,2805592,2805664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[2805872],"length":1,"stats":{"Line":0},"fn_name":"read_u16\u003c\u0026[u8]\u003e"},{"line":137,"address":[2805896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[2806008,2805918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2806052,2805976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2806256,2806064],"length":1,"stats":{"Line":1},"fn_name":"read_u32\u003c\u0026[u8]\u003e"},{"line":143,"address":[2806088,2806280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[2806110,2806302,2806196,2806388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[2806168,2806431,2806360,2806239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[2807470,2806942,2808032,2807998,2806448,2808526,2807504,2806976],"length":1,"stats":{"Line":3},"fn_name":"read_inlined_bytes\u003c\u0026mut \u0026[u8], 2\u003e"},{"line":172,"address":[2806564,2807092,2808062,2807006,2807534,2808148,2806478,2807620],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[2807602,2806546,2808130,2807074],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[2806610,2808194,2807138,2807666],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[2806667,2806868,2807723,2808251,2808452,2807924,2807195,2807396],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[2807304,2808360,2806776,2807832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":190,"address":[2808688,2808560,2808624],"length":1,"stats":{"Line":2},"fn_name":"read_inlined_str\u003c\u0026[u8], 1\u003e"},{"line":191,"address":[2808752,2808832,2808912,2808642,2808578,2808706],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003c\u0026[u8], 1\u003e"},{"line":192,"address":[2808926,2808846,2808766],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[2809056,2808999,2809120,2808992,2809063,2809127],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c\u0026[u8], 1\u003e"},{"line":199,"address":[2809184],"length":1,"stats":{"Line":0},"fn_name":"read_inlinable\u003c\u0026[u8], taos_query::common::field::Field\u003e"},{"line":200,"address":[2809201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[2077972,2077840],"length":1,"stats":{"Line":6},"fn_name":"inlined\u003ctaos_query::common::raw::inner::RawBlock\u003e"},{"line":217,"address":[2077867],"length":1,"stats":{"Line":6},"fn_name":null},{"line":218,"address":[2077927,2077888],"length":1,"stats":{"Line":12},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[2078147,2078000],"length":1,"stats":{"Line":5},"fn_name":"printable_inlined\u003ctaos_query::common::raw::inner::RawBlock\u003e"},{"line":226,"address":[2078019,2078097],"length":1,"stats":{"Line":10},"fn_name":null},{"line":232,"address":[2810624,2810680],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":233,"address":[2810645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[2810760,2810704],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":245,"address":[2810725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2810784,2810839],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":257,"address":[2810805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[2810920,2810864],"length":1,"stats":{"Line":0},"fn_name":"write_inlined\u003c\u0026mut alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":269,"address":[2810885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[2810944,2810953],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":280,"address":[2950151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[2950178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[2950328,2950497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[2950696,2950405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[2950594,2950788,2950750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[2950761,2950842,2951077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[2951261,2951217,2950998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[2951223],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":48,"coverable":105},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","benches","is_null.rs"],"content":"#![feature(test)]\n\nextern crate test;\nuse bitvec::prelude::*;\n\nunsafe fn is_null_bit_slice(ptr: *const u8, row: usize) -\u003e bool {\n    let len = 1;\n    let slice = std::slice::from_raw_parts(ptr, len);\n    let is_nulls: \u0026BitSlice\u003cu8, Msb0\u003e = \u0026BitSlice::from_slice_unchecked(slice);\n    is_nulls[row]\n}\n\nunsafe fn is_null(ptr: *const u8, row: usize) -\u003e bool {\n    macro_rules! is_null {\n        ($bm:expr, $row:expr) =\u003e {\n            *$bm.offset($row as isize \u003e\u003e 3) \u003e\u003e (7 - ($row \u0026 7)) \u0026 0x1 == 1\n        };\n    }\n    is_null!(ptr, row)\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn test() {\n        let ptr = [0b11110000; 1].as_ptr();\n        for i in 0..8 {\n            assert_eq!(\n                unsafe { is_null_bit_slice(ptr, i) },\n                unsafe { is_null(ptr, i) },\n                \" in row: {}\",\n                i\n            );\n        }\n    }\n\n    #[bench]\n    fn bench_bit_slice(b: \u0026mut Bencher) {\n        let slice = [0b1010101; 6];\n        b.iter(|| {\n            for i in 0..8 {\n                let _ = unsafe { is_null_bit_slice(slice.as_ptr(), i) };\n            }\n        })\n    }\n\n    #[bench]\n    fn bench_macro(b: \u0026mut Bencher) {\n        let slice = [0b1010101; 6];\n        b.iter(|| {\n            for i in 0..8 {\n                let _ = unsafe { is_null(slice.as_ptr(), i) };\n            }\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","build.rs"],"content":"use std::env;\nuse std::ffi::OsString;\nuse std::fmt::Display;\n\nfn get_env(name: \u0026str) -\u003e Option\u003cOsString\u003e {\n    let var = env::var_os(name);\n    println!(\"cargo:rerun-if-env-changed={}\", name);\n\n    match var {\n        Some(ref v) =\u003e println!(\"{} = {}\", name, v.to_string_lossy()),\n        None =\u003e println!(\"{} unset\", name),\n    }\n\n    var\n}\n\nfn version2features\u003cV: Into\u003cVersion\u003e\u003e(version: V) -\u003e Vec\u003c\u0026'static str\u003e {\n    let version = version.into();\n    let mut feats = Vec::new();\n    if version.mainline == 3 {\n        feats.push(\"v3\");\n        feats.push(\"tmq\");\n        feats.push(\"fetch_raw_block\");\n        feats.push(\"fetch_block_s\");\n    } else if version.mainline == 2 {\n        feats.push(\"v2\");\n        if version \u003e= Version::new(2, 4, 0, 4) {\n            feats.push(\"result_block\");\n        }\n        if version \u003e= Version::new(2, 4, 0, 0) {\n            feats.push(\"json_tag\");\n            feats.push(\"set_config\");\n            feats.push(\"is_update_query\");\n            feats.push(\"reset_db\");\n            feats.push(\"sml\");\n            feats.push(\"parse_time\");\n        }\n    } else {\n        panic!(\"unsupported TDengine client version {version}\")\n    }\n    feats\n}\nfn taos_version() -\u003e String {\n    let lib_env = \"TAOS_LIBRARY_PATH\";\n    if let Some(path) = get_env(lib_env) {\n        println!(\"cargo:rustc-link-search={}\", path.to_string_lossy());\n    }\n    if cfg!(target_os = \"windows\") {\n        println!(\"cargo:rustc-link-search=C:\\\\TDengine\\\\driver\");\n    }\n    let lib_name = if cfg!(target_os = \"windows\") {\n        \"taos.dll\"\n    } else if cfg!(target_os = \"linux\") {\n        \"libtaos.so\"\n    } else if cfg!(target_os = \"darwin\") {\n        \"libtaos.dylib\"\n    } else {\n        unreachable!(\"the current os is not supported\");\n    };\n    let lib = unsafe { libloading::Library::new(lib_name).unwrap() };\n    let version = unsafe {\n        let version: libloading::Symbol\u003cunsafe extern \"C\" fn() -\u003e *const std::os::raw::c_char\u003e =\n            lib.get(b\"taos_get_client_info\\0\").unwrap();\n        std::ffi::CStr::from_ptr(version()).to_string_lossy()\n    };\n    println!(\"cargo:rustc-cfg=taos_version=\\\"v{}\\\"\", version);\n    let parsed_version = Version::parse(\u0026version).expect(\"invalid version of taos\");\n    for feat in version2features(parsed_version) {\n        println!(\"cargo:rustc-cfg=taos_{feat}\");\n    }\n    return version.to_string();\n}\n\n#[derive(Debug, PartialEq, PartialOrd)]\nstruct Version {\n    mainline: u8,\n    major: u8,\n    minor: u8,\n    patch: u8,\n}\n\nimpl Display for Version {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let Version {\n            mainline,\n            major,\n            minor,\n            patch,\n        } = self;\n        f.write_fmt(format_args!(\"{mainline}.{major}.{minor}.{patch}\"))\n    }\n}\n\nimpl Version {\n    fn new(mainline: u8, major: u8, minor: u8, patch: u8) -\u003e Self {\n        Self {\n            mainline,\n            major,\n            minor,\n            patch,\n        }\n    }\n    fn parse(version: \u0026str) -\u003e Result\u003cSelf, Box\u003cdyn std::error::Error\u003e\u003e {\n        let version_items: Vec\u003c_\u003e = version.split('.').collect();\n        let items = version_items.len();\n        if items == 0 || items \u003e 4 {\n            Err(\"parse version error: {version}\")?\n        }\n\n        let mainline = version_items[0].parse()?;\n        let major = version_items\n            .get(1)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n        let minor = version_items\n            .get(2)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n        let patch = version_items\n            .get(3)\n            .and_then(|s| s.parse().ok())\n            .unwrap_or_default();\n\n        Ok(Self::new(mainline, major, minor, patch))\n    }\n}\n\nfn main() {\n    taos_version();\n    println!(\"cargo:rustc-link-lib=taos\");\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","ffi.rs"],"content":"use std::os::raw::*;\nuse taos_macros::c_cfg;\n\nuse crate::types::*;\n\npub type TAOS = c_void;\npub type TAOS_STMT = c_void;\npub type TAOS_RES = c_void;\npub type TAOS_STREAM = c_void;\npub type TAOS_SUB = c_void;\npub type TAOS_ROW = *mut *mut c_void;\n\npub type taos_subscribe_cb =\n    unsafe extern \"C\" fn(sub: *mut TAOS_SUB, res: *mut TAOS_RES, param: *mut c_void, code: c_int);\n\npub type taos_stream_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut TAOS_RES, row: TAOS_ROW);\n\npub type taos_stream_close_cb = unsafe extern \"C\" fn(param: *mut c_void);\n\nextern \"C\" {\n    pub fn taos_cleanup();\n\n    pub fn taos_options(option: TSDB_OPTION, arg: *const c_void, ...) -\u003e c_int;\n\n    pub fn taos_get_client_info() -\u003e *const c_char;\n\n    pub fn taos_data_type(type_: c_int) -\u003e *const c_char;\n}\n\n#[c_cfg(taos_parse_time)]\nextern \"C\" {\n    pub fn taos_parse_time(\n        time_str: *const c_char,\n        time: *mut i64,\n        len: i32,\n        time_precision: Precision,\n        daylight: i8, // if in daylight saving time (DST) { 1 } else { 0 }\n    ) -\u003e i32;\n}\n\nextern \"C\" {\n    pub fn taos_connect(\n        ip: *const c_char,\n        user: *const c_char,\n        pass: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e *mut TAOS;\n\n    pub fn taos_connect_auth(\n        ip: *const c_char,\n        user: *const c_char,\n        auth: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e *mut TAOS;\n\n    pub fn taos_close(taos: *mut TAOS);\n\n}\n\npub type taos_async_fetch_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut c_void, rows: c_int);\n\npub type taos_async_query_cb =\n    unsafe extern \"C\" fn(param: *mut c_void, res: *mut c_void, code: c_int);\n\nextern \"C\" {\n    pub fn taos_fetch_rows_a(res: *mut TAOS_RES, fp: taos_async_fetch_cb, param: *mut c_void);\n\n    pub fn taos_query_a(\n        taos: *mut TAOS,\n        sql: *const c_char,\n        fp: taos_async_query_cb,\n        param: *mut c_void,\n    );\n}\n\nextern \"C\" {\n    pub fn taos_load_table_info(taos: *mut TAOS, tableNameList: *const c_char) -\u003e c_int;\n\n    pub fn taos_stmt_init(taos: *mut TAOS) -\u003e *mut TAOS_STMT;\n\n    pub fn taos_stmt_prepare(stmt: *mut TAOS_STMT, sql: *const c_char, length: c_ulong) -\u003e c_int;\n\n    pub fn taos_stmt_set_tbname_tags(\n        stmt: *mut TAOS_STMT,\n        name: *const c_char,\n        tags: *mut TaosBind,\n    ) -\u003e c_int;\n\n    pub fn taos_stmt_set_tbname(stmt: *mut TAOS_STMT, name: *const c_char) -\u003e c_int;\n\n    pub fn taos_stmt_set_sub_tbname(stmt: *mut TAOS_STMT, name: *const c_char) -\u003e c_int;\n\n    pub fn taos_stmt_is_insert(stmt: *mut TAOS_STMT, insert: *mut c_int) -\u003e c_int;\n\n    pub fn taos_stmt_num_params(stmt: *mut TAOS_STMT, nums: *mut c_int) -\u003e c_int;\n\n    pub fn taos_stmt_get_param(\n        stmt: *mut TAOS_STMT,\n        idx: c_int,\n        type_: *mut c_int,\n        bytes: *mut c_int,\n    ) -\u003e c_int;\n\n    pub fn taos_stmt_bind_param(stmt: *mut TAOS_STMT, bind: *const TaosBind) -\u003e c_int;\n\n    pub fn taos_stmt_bind_param_batch(stmt: *mut TAOS_STMT, bind: *const TaosMultiBind) -\u003e c_int;\n\n    pub fn taos_stmt_bind_single_param_batch(\n        stmt: *mut TAOS_STMT,\n        bind: *const TaosMultiBind,\n        colIdx: c_int,\n    ) -\u003e c_int;\n\n    pub fn taos_stmt_add_batch(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_execute(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_affected_rows(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_use_result(stmt: *mut TAOS_STMT) -\u003e *mut TAOS_RES;\n\n    pub fn taos_stmt_close(stmt: *mut TAOS_STMT) -\u003e c_int;\n\n    pub fn taos_stmt_errstr(stmt: *mut TAOS_STMT) -\u003e *const c_char;\n}\n\nextern \"C\" {\n    pub fn taos_query(taos: *mut TAOS, sql: *const c_char) -\u003e *mut TAOS_RES;\n\n    pub fn taos_fetch_row(res: *mut TAOS_RES) -\u003e TAOS_ROW;\n\n    pub fn taos_result_precision(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_free_result(res: *mut TAOS_RES);\n\n    pub fn taos_field_count(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_num_fields(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_affected_rows(res: *mut TAOS_RES) -\u003e c_int;\n\n    pub fn taos_fetch_fields(res: *mut TAOS_RES) -\u003e *mut TAOS_FIELD;\n\n    pub fn taos_select_db(taos: *mut TAOS, db: *const c_char) -\u003e c_int;\n\n    pub fn taos_print_row(\n        str_: *mut c_char,\n        row: TAOS_ROW,\n        fields: *mut TAOS_FIELD,\n        num_fields: c_int,\n    ) -\u003e c_int;\n\n    pub fn taos_stop_query(res: *mut TAOS_RES);\n\n    pub fn taos_is_null(res: *mut TAOS_RES, row: i32, col: i32) -\u003e bool;\n\n    pub fn taos_is_update_query(res: *mut TAOS_RES) -\u003e bool;\n\n    pub fn taos_fetch_block(res: *mut TAOS_RES, rows: *mut TAOS_ROW) -\u003e c_int;\n\n    pub fn taos_fetch_lengths(res: *mut TAOS_RES) -\u003e *mut c_int;\n\n    pub fn taos_validate_sql(taos: *mut TAOS, sql: *const c_char) -\u003e c_int;\n\n    pub fn taos_reset_current_db(taos: *mut TAOS);\n\n    pub fn taos_get_server_info(taos: *mut TAOS) -\u003e *mut c_char;\n\n    pub fn taos_errstr(tres: *mut TAOS_RES) -\u003e *mut c_char;\n\n    pub fn taos_errno(tres: *mut TAOS_RES) -\u003e c_int;\n\n}\n\n#[c_cfg(taos_v3)]\nextern \"C\" {\n    pub fn taos_get_column_data_offset(res: *mut TAOS_RES, col: i32) -\u003e *mut i32;\n\n    pub fn taos_fetch_raw_block(res: *mut TAOS_RES, num: *mut i32, data: *mut *mut c_void)\n        -\u003e c_int;\n\n    pub fn taos_fetch_raw_block_a(res: *mut TAOS_RES, fp: taos_async_fetch_cb, param: *mut c_void);\n\n    pub fn taos_get_raw_block(taos: *mut TAOS_RES) -\u003e *mut c_void;\n}\n\n#[c_cfg(taos_result_block)]\nextern \"C\" {\n    pub fn taos_result_block(res: *mut TAOS_RES) -\u003e *mut TAOS_ROW;\n}\n\n#[cfg(taos_fetch_block_s)]\nextern \"C\" {\n    pub fn taos_fetch_block_s(\n        res: *mut TAOS_RES,\n        num_of_rows: *mut c_int,\n        rows: *mut TAOS_ROW,\n    ) -\u003e c_int;\n}\n\n#[cfg(not(taos_fetch_block_s))]\n#[no_mangle]\npub unsafe extern \"C\" fn taos_fetch_block_s(\n    res: *mut TAOS_RES,\n    num_of_rows: *mut c_int,\n    rows: *mut TAOS_ROW,\n) -\u003e c_int {\n    *num_of_rows = taos_fetch_block(res, rows);\n    return 0;\n}\n\nextern \"C\" {\n    pub fn taos_subscribe(\n        taos: *mut TAOS,\n        restart: c_int,\n        topic: *const c_char,\n        sql: *const c_char,\n        fp: Option\u003ctaos_subscribe_cb\u003e,\n        param: *mut c_void,\n        interval: c_int,\n    ) -\u003e *mut TAOS_SUB;\n\n    pub fn taos_consume(tsub: *mut TAOS_SUB) -\u003e *mut TAOS_RES;\n\n    pub fn taos_unsubscribe(tsub: *mut TAOS_SUB, keep_progress: c_int);\n}\n\nextern \"C\" {\n    pub fn taos_open_stream(\n        taos: *mut TAOS,\n        sql: *const c_char,\n        fp: Option\u003ctaos_stream_cb\u003e,\n        stime: i64,\n        param: *mut c_void,\n        callback: Option\u003ctaos_stream_close_cb\u003e,\n    ) -\u003e *mut TAOS_STREAM;\n\n    pub fn taos_close_stream(stream: *mut TAOS_STREAM);\n}\n","traces":[{"line":31,"address":[8095165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[8095136],"length":1,"stats":{"Line":0},"fn_name":"taos_parse_time"},{"line":191,"address":[8095241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8095232],"length":1,"stats":{"Line":0},"fn_name":"taos_result_block"}],"covered":0,"coverable":4},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","into_c_str.rs"],"content":"use std::borrow::Cow;\nuse std::ffi::{c_void, CStr, CString};\nuse std::os::raw::c_char;\n\n/// Helper trait to auto convert Rust strings to CStr.\npub trait IntoCStr\u003c'a\u003e {\n    fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e;\n}\n\nmacro_rules! _impl_for_raw {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoCStr\u003c'a\u003e for $t {\n            fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n                Cow::from(self)\n            }\n        }\n    };\n}\n_impl_for_raw!(CString);\n_impl_for_raw!(\u0026'a CStr);\n_impl_for_raw!(\u0026'a CString);\n\nmacro_rules! _impl_for_ref {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoCStr\u003c'a\u003e for \u0026'a $t {\n            fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n                self.as_c_str().into_c_str()\n            }\n        }\n    };\n}\n_impl_for_ref!(\u0026CString);\n_impl_for_ref!(\u0026\u0026CString);\n\nimpl\u003c'a\u003e IntoCStr\u003c'a\u003e for \u0026\u0026'a CStr {\n    fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n        Cow::from(*self)\n    }\n}\n\nimpl\u003c'a\u003e IntoCStr\u003c'a\u003e for String {\n    fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n        let v = self.into_bytes();\n        Cow::from(unsafe { CString::from_vec_unchecked(v) })\n    }\n}\n\nmacro_rules! _impl_for_str {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoCStr\u003c'a\u003e for \u0026'a $t {\n            fn into_c_str(self) -\u003e Cow\u003c'a, CStr\u003e {\n                self.to_owned().into_c_str()\n            }\n        }\n    };\n}\n\n_impl_for_str!(String);\n_impl_for_str!(str);\n_impl_for_str!(\u0026str);\n\npub struct NullableCStr\u003c'a\u003e(Option\u003cCow\u003c'a, CStr\u003e\u003e);\n\nimpl\u003c'a\u003e NullableCStr\u003c'a\u003e {\n    pub fn as_ptr(\u0026self) -\u003e *const c_char {\n        match self.0.as_ref() {\n            Some(c) =\u003e c.as_ptr(),\n            None =\u003e std::ptr::null(),\n        }\n    }\n}\n\npub trait IntoNullableCStr\u003c'a\u003e {\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e;\n}\n\nimpl\u003c'a, T\u003e IntoNullableCStr\u003c'a\u003e for T\nwhere\n    T: IntoCStr\u003c'a\u003e,\n{\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(Some(self.into_c_str()))\n    }\n}\n\nimpl\u003c'a, T\u003e IntoNullableCStr\u003c'a\u003e for Option\u003cT\u003e\nwhere\n    T: IntoCStr\u003c'a\u003e,\n{\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(self.map(IntoCStr::into_c_str))\n    }\n}\n\nimpl\u003c'a, T\u003e IntoNullableCStr\u003c'a\u003e for \u0026'a Option\u003cT\u003e\nwhere\n    \u0026'a T: IntoCStr\u003c'a\u003e,\n{\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(self.as_ref().map(|c| c.into_c_str()))\n    }\n}\n\nimpl\u003c'a\u003e IntoNullableCStr\u003c'a\u003e for () {\n    fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n        NullableCStr(None)\n    }\n}\n\nimpl\u003c'a, T\u003e From\u003cT\u003e for NullableCStr\u003c'a\u003e\nwhere\n    T: IntoNullableCStr\u003c'a\u003e,\n{\n    fn from(rhs: T) -\u003e NullableCStr\u003c'a\u003e {\n        rhs.into_nullable_c_str()\n    }\n}\n\nmacro_rules! _impl_for_ptr {\n    ($t:ty) =\u003e {\n        impl\u003c'a\u003e IntoNullableCStr\u003c'a\u003e for $t {\n            fn into_nullable_c_str(self) -\u003e NullableCStr\u003c'a\u003e {\n                NullableCStr(if self.is_null() {\n                    None\n                } else {\n                    Some(Cow::from(unsafe { CStr::from_ptr(self as _) }))\n                })\n            }\n        }\n    };\n}\n\n_impl_for_ptr!(*const i8);\n_impl_for_ptr!(*mut i8);\n_impl_for_ptr!(*const u8);\n_impl_for_ptr!(*mut u8);\n_impl_for_ptr!(*mut c_void);\n\n#[cfg(test)]\nmod test_into_c_str {\n    use std::{\n        borrow::Borrow,\n        ffi::{CStr, CString},\n    };\n\n    use super::*;\n\n    fn from_c_str\u003c'a\u003e(_: impl IntoCStr\u003c'a\u003e) {}\n\n    #[test]\n    fn c_str_to_c_str() {\n        let s = CStr::from_bytes_with_nul(b\"abc\\0\").unwrap();\n        from_c_str(\u0026s);\n        from_c_str(s);\n    }\n    #[test]\n    fn c_string_to_c_str() {\n        let s = CString::new(\"abc\").unwrap();\n        from_c_str(\u0026s);\n        from_c_str(s);\n    }\n    #[test]\n    fn str_to_c_str() {\n        let s = \"abc\";\n        from_c_str(\u0026s);\n        from_c_str(s);\n    }\n    #[test]\n    fn string_to_c_str() {\n        let s = String::from(\"abc\");\n        from_c_str(\u0026s);\n        from_c_str(s.as_str());\n        from_c_str(s);\n    }\n\n    #[test]\n    fn option_string_to_c_str() {\n        let s = Some(String::from(\"abc\"));\n        let _ = s.borrow().into_nullable_c_str();\n        let _ = s.as_ref().into_nullable_c_str();\n        let _ = s.into_nullable_c_str();\n    }\n    #[test]\n    fn option_cstring_to_c_str() {\n        let s = Some(CString::new(\"abc\").unwrap());\n        let _ = s.borrow().into_nullable_c_str();\n        let _ = s.as_ref().into_nullable_c_str();\n        let _ = s.into_nullable_c_str();\n    }\n}\n","traces":[{"line":13,"address":[8062448],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":14,"address":[8128753,8128709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[8128768,8128848],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":27,"address":[8128786,8128866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8062400],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":37,"address":[8062420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[8092928],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":43,"address":[8092942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[8092983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[8093072],"length":1,"stats":{"Line":0},"fn_name":"into_c_str"},{"line":52,"address":[8115799,8115872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[8115584],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":66,"address":[8115593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[8115662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[8115655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[3446912],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str\u003calloc::string::String\u003e"},{"line":100,"address":[3446944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[8115728],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str"},{"line":106,"address":[8115735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[3454864],"length":1,"stats":{"Line":0},"fn_name":"from\u003c\u0026core::option::Option\u003calloc::string::String\u003e\u003e"},{"line":115,"address":[3454881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8115920,8116272,8116448,8116096],"length":1,"stats":{"Line":0},"fn_name":"into_nullable_c_str"},{"line":123,"address":[8116304,8116480,8116092,8116540,8116128,8116188,8116620,8115952,8116364,8116444,8116268,8116012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8115993,8116169,8116521,8116345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8116580,8116153,8115977,8116228,8116404,8116052,8116329,8116505],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","lib.rs"],"content":"#![feature(const_slice_from_raw_parts)]\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\n#![allow(unused_variables)]\n\nuse std::{ffi::CStr, marker::PhantomData, ops::Deref, os::raw::*, sync::Arc};\n\nuse into_c_str::IntoCStr;\nuse once_cell::sync::OnceCell;\nuse taos_error::{Code, Error};\nuse taos_query::common::{Field, Ty};\n\npub(crate) mod types;\npub use types::*;\npub mod ffi;\nuse ffi::*;\n\nmod set_config;\npub use set_config::*;\n\npub use ffi::taos_options;\n\nmod schemaless;\npub use schemaless::*;\n\nmod tmq;\npub use tmq::*;\n\nmacro_rules! err_or {\n    ($res:ident, $code:expr, $ret:expr) =\u003e {\n        unsafe {\n            let code: Code = { $code }.into();\n            if code.success() {\n                Ok($ret)\n            } else {\n                Err(Error::new(code, $res.err_as_str()))\n            }\n        }\n    };\n\n    ($res:ident, $code:expr) =\u003e {{\n        err_or!($res, $code, ())\n    }};\n    ($code:expr, $ret:expr) =\u003e {\n        unsafe {\n            let code: Code = { $code }.into();\n            if code.success() {\n                Ok($ret)\n            } else {\n                Err(Error::from_code(code))\n            }\n        }\n    };\n\n    ($code:expr) =\u003e {\n        err_or!($code, ())\n    };\n}\n\n#[derive(Debug)]\n#[repr(transparent)]\npub struct RawTaos(*mut TAOS);\n\nimpl Drop for RawTaos {\n    fn drop(\u0026mut self) {\n        self.close()\n    }\n}\n\nimpl RawTaos {\n    /// Client version.\n    pub fn version() -\u003e \u0026'static CStr {\n        unsafe { CStr::from_ptr(taos_get_client_info()) }\n    }\n\n    #[inline]\n    pub fn connect(\n        host: *const c_char,\n        user: *const c_char,\n        pass: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let ptr = unsafe { taos_connect(host, user, pass, db, port) };\n        let null = std::ptr::null_mut();\n        let code = unsafe { taos_errno(null) };\n        if code != 0 {\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            let err = Error::new(code, err);\n            log::trace!(\"error: {err}\");\n        }\n\n        if ptr.is_null() {\n            let null = std::ptr::null_mut();\n            let code = unsafe { taos_errno(null) };\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            Err(Error::new(code, err))\n        } else {\n            Ok(RawTaos(ptr))\n        }\n    }\n    #[inline]\n    pub fn connect_auth(\n        host: *const c_char,\n        user: *const c_char,\n        auth: *const c_char,\n        db: *const c_char,\n        port: u16,\n    ) -\u003e Result\u003cSelf, Error\u003e {\n        let ptr = unsafe { taos_connect_auth(host, user, auth, db, port) };\n        if ptr.is_null() {\n            let null = std::ptr::null_mut();\n            let code = unsafe { taos_errno(null) };\n            let err = unsafe { CStr::from_ptr(taos_errstr(null)) }\n                .to_string_lossy()\n                .to_string();\n            Err(Error::new(code, err))\n        } else {\n            Ok(RawTaos(ptr))\n        }\n    }\n\n    #[inline]\n    pub fn as_ptr(\u0026self) -\u003e *mut TAOS {\n        self.0\n    }\n\n    #[inline]\n    pub fn query\u003c'a, S: IntoCStr\u003c'a\u003e\u003e(\u0026self, sql: S) -\u003e Result\u003cDroppableRawRes, Error\u003e {\n        RawRes::from_ptr(unsafe { taos_query(self.as_ptr(), sql.into_c_str().as_ptr()) })\n            .map(DroppableRawRes::new)\n    }\n\n    #[inline]\n    pub fn query_a(\u0026self, sql: *const i8, fp: taos_async_query_cb, param: *mut c_void) {\n        unsafe { taos_query_a(self.as_ptr(), sql, fp, param) }\n    }\n\n    #[inline]\n    pub fn validate_sql(self, sql: *const c_char) -\u003e Result\u003c(), Error\u003e {\n        let code: Code = unsafe { taos_validate_sql(self.as_ptr(), sql) }.into();\n        if code.success() {\n            return Ok(());\n        } else {\n            let err = unsafe { taos_errstr(std::ptr::null_mut()) };\n            let err = unsafe { std::str::from_utf8_unchecked(CStr::from_ptr(err).to_bytes()) };\n            return Err(Error::new(code, err));\n        }\n    }\n\n    #[inline]\n    pub fn reset_current_db(\u0026self) {\n        unsafe { taos_reset_current_db(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn server_version(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(taos_get_server_info(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn load_table_info(\u0026self, list: *const c_char) -\u003e Result\u003c(), Error\u003e {\n        err_or!(taos_load_table_info(self.as_ptr(), list))\n    }\n\n    #[inline]\n    pub fn close(\u0026mut self) {\n        unsafe { taos_close(self.as_ptr()) }\n    }\n}\n\n#[derive(Debug)]\npub struct RawRes {\n    ptr: *mut TAOS_RES,\n    fields: OnceCell\u003cVec\u003cField\u003e\u003e,\n}\n\nunsafe impl Send for RawRes {}\nunsafe impl Sync for RawRes {}\n\n#[derive(Debug)]\npub struct DroppableRawRes {\n    raw: Arc\u003cRawRes\u003e,\n}\n\nimpl Deref for DroppableRawRes {\n    type Target = RawRes;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.raw\n    }\n}\n\nimpl DroppableRawRes {\n    pub fn new(raw: RawRes) -\u003e Self {\n        Self { raw: Arc::new(raw) }\n    }\n\n    pub fn from_ptr_with_code(ptr: *mut TAOS_RES, code: Code) -\u003e Result\u003cSelf, Error\u003e {\n        RawRes::from_ptr_with_code(ptr, code).map(Self::new)\n    }\n\n    pub fn raw(\u0026self) -\u003e Arc\u003cRawRes\u003e {\n        self.raw.clone()\n    }\n}\n\npub type VGroupId = i32;\n\nimpl Drop for DroppableRawRes {\n    fn drop(\u0026mut self) {\n        if let Some(raw) = Arc::get_mut(\u0026mut self.raw) {\n            raw.free_result();\n        } else {\n            log::error!(\"there's other result pointer in-use, please check\");\n            // todo: safely drop result pointer.\n            // panic!(\"there's other result pointer in-use, please check\");\n        }\n    }\n}\n\nimpl RawRes {\n    #[inline]\n    pub fn as_ptr(\u0026self) -\u003e *mut TAOS_RES {\n        self.ptr\n    }\n\n    #[inline]\n    pub fn errno(\u0026self) -\u003e Code {\n        unsafe { taos_errno(self.as_ptr()) \u0026 0xffff }.into()\n    }\n    #[inline]\n    pub fn errstr(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(taos_errstr(self.as_ptr())) }\n    }\n    #[inline]\n    pub fn err_as_str(\u0026self) -\u003e \u0026'static str {\n        unsafe {\n            std::str::from_utf8_unchecked(CStr::from_ptr(taos_errstr(self.as_ptr())).to_bytes())\n        }\n    }\n\n    #[inline]\n    pub fn from_ptr(ptr: *mut TAOS_RES) -\u003e Result\u003cRawRes, Error\u003e {\n        let raw = unsafe { Self::from_ptr_unchecked(ptr) };\n        let code = raw.errno();\n        raw.with_code(code)\n    }\n\n    #[inline]\n    pub const unsafe fn from_ptr_unchecked(ptr: *mut TAOS_RES) -\u003e RawRes {\n        RawRes {\n            ptr,\n            fields: OnceCell::new(),\n        }\n    }\n\n    #[inline]\n    pub fn from_ptr_with_code(ptr: *mut TAOS_RES, code: Code) -\u003e Result\u003cRawRes, Error\u003e {\n        unsafe { RawRes::from_ptr_unchecked(ptr) }.with_code(code)\n    }\n\n    #[inline]\n    fn with_code(self, code: Code) -\u003e Result\u003cSelf, Error\u003e {\n        if code.success() {\n            Ok(self)\n        } else {\n            Err(Error::new(code, self.err_as_str()))\n        }\n    }\n\n    #[inline]\n    pub fn num_fields(\u0026self) -\u003e usize {\n        self.fields().len()\n    }\n    #[inline]\n    pub fn fields\u003c'any\u003e(\u0026self) -\u003e \u0026[Field] {\n        let fields = self.fields.get_or_init(|| {\n            let len = unsafe { taos_num_fields(self.as_ptr()) };\n            from_raw_fields(unsafe { taos_fetch_fields(self.as_ptr()) }, len as usize)\n        });\n        \u0026fields\n    }\n\n    pub fn fetch_fields(\u0026self) -\u003e Vec\u003cField\u003e {\n        let len = unsafe { taos_num_fields(self.as_ptr()) };\n        from_raw_fields(unsafe { taos_fetch_fields(self.as_ptr()) }, len as usize)\n    }\n\n    #[inline]\n    pub fn fetch_lengths(\u0026self) -\u003e *const i32 {\n        unsafe { taos_fetch_lengths(self.as_ptr()) }\n    }\n    #[inline]\n    unsafe fn fetch_lengths_raw(\u0026self) -\u003e *const i32 {\n        taos_fetch_lengths(self.as_ptr())\n    }\n\n    #[inline]\n    pub fn fetch_block(\u0026self) -\u003e Result\u003cOption\u003c(TAOS_ROW, i32, *const i32)\u003e, Error\u003e {\n        let block = Box::into_raw(Box::new(std::ptr::null_mut()));\n        let mut num = 0;\n        err_or!(\n            self,\n            taos_fetch_block_s(self.as_ptr(), \u0026mut num, block),\n            if num \u003e 0 {\n                Some((*block, num, self.fetch_lengths_raw()))\n            } else {\n                None\n            }\n        )\n    }\n\n    #[inline]\n    pub fn get_column_data_offset(\u0026self, col: usize) -\u003e *const i32 {\n        unsafe { taos_get_column_data_offset(self.as_ptr(), col as i32) }\n    }\n\n    #[inline]\n    pub fn fetch_raw_block(\u0026self) -\u003e Result\u003c(*mut u8, u32), Error\u003e {\n        let block = Box::into_raw(Box::new(std::ptr::null_mut()));\n        let mut num = 0;\n        err_or!(\n            self,\n            taos_fetch_raw_block(self.as_ptr(), \u0026mut num as _, block),\n            (*block as _, num as _)\n        )\n    }\n\n    #[inline]\n    pub fn is_update_query(\u0026self) -\u003e bool {\n        unsafe { taos_is_update_query(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn is_null(\u0026self, row: i32, col: i32) -\u003e bool {\n        unsafe { taos_is_null(self.as_ptr(), row, col) }\n    }\n\n    #[inline]\n    pub fn stop_query(\u0026self) {\n        unsafe { taos_stop_query(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn select_db(\u0026self, db: *const i8) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_select_db(self.as_ptr(), db))\n    }\n\n    #[inline]\n    pub fn affected_rows(\u0026self) -\u003e i32 {\n        unsafe { taos_affected_rows(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn field_count(\u0026self) -\u003e i32 {\n        unsafe { taos_field_count(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn free_result(\u0026mut self) {\n        unsafe { taos_free_result(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn precision(\u0026self) -\u003e Precision {\n        unsafe { taos_result_precision(self.as_ptr()) }.into()\n    }\n\n    #[inline]\n    pub fn fetch_row(\u0026self) -\u003e TAOS_ROW {\n        unsafe { taos_fetch_row(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn fetch_rows_a(\u0026self, fp: taos_async_fetch_cb, param: *mut c_void) {\n        unsafe { taos_fetch_rows_a(self.as_ptr(), fp, param) }\n    }\n\n    #[inline]\n    pub fn block(\u0026self) -\u003e *mut *mut c_void {\n        unsafe { taos_result_block(self.as_ptr()).read() }\n    }\n\n    #[inline]\n    pub fn tmq_topic_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        unsafe {\n            let c = tmq_get_topic_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n    #[inline]\n    pub fn tmq_vgroup_id(\u0026self) -\u003e Option\u003cVGroupId\u003e {\n        unsafe {\n            let c = tmq_get_vgroup_id(self.as_ptr());\n            if c == -1 {\n                None\n            } else {\n                Some(c)\n            }\n        }\n    }\n\n    #[inline]\n    pub fn tmq_table_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        unsafe {\n            let c = tmq_get_table_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n    #[inline]\n    pub fn tmq_db_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        unsafe {\n            let c = tmq_get_db_name(self.as_ptr());\n            if c.is_null() {\n                None\n            } else {\n                CStr::from_ptr(c).to_str().ok()\n            }\n        }\n    }\n}\n\npub mod into_c_str;\npub mod stmt;\n\n// #[derive(Debug, Clone, Copy)]\n// #[repr(C)]\n// enum BlockVer {\n//     V2 = 0,\n//     V3,\n// }\n// #[derive(Debug, Clone, Copy)]\n// #[repr(C)]\n\n// enum BlockCodec {\n//     Bytes,\n// }\n\n// #[derive(Debug)]\n// enum BlockType\u003c'a\u003e {\n//     V2(*mut *mut c_void),\n//     Bytes(Cow\u003c'a, [u8]\u003e),\n// }\n\n// struct RawCodec\u003c'a\u003e {\n//     version: BlockVer,\n//     method: BlockCodec,\n//     precision: Precision,\n//     fields: Cow\u003c'a, [Field]\u003e,\n// }\n\n// #[derive(Debug)]\n// pub struct RawBlock\u003c'a\u003e {\n//     version: BlockVer,\n//     codec: BlockCodec,\n//     precision: Precision,\n//     fields: Cow\u003c'a, [Field]\u003e,\n//     num_of_rows: usize,\n//     data: BlockType\u003c'a\u003e,\n// }\n\n// impl\u003c'a\u003e RawBlock\u003c'a\u003e {\n//     fn precision(\u0026self) -\u003e Precision {\n//         self.precision\n//     }\n\n//     fn to_bytes(\u0026self) -\u003e Cow\u003c[u8]\u003e {\n//         todo!()\n//     }\n\n//     fn write\u003cT: Write\u003e(\u0026self, mut wtr: T) -\u003e std::io::Result\u003cusize\u003e {\n//         wtr.write(\u0026self.to_bytes())\n//     }\n\n//     fn write_all\u003cT: Write\u003e(\u0026self, mut wtr: T) -\u003e std::io::Result\u003cusize\u003e {\n//         wtr.write(\u0026self.to_bytes())\n//     }\n// }\n","traces":[{"line":65,"address":[8102144],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":66,"address":[8102149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[8053616],"length":1,"stats":{"Line":0},"fn_name":"version"},{"line":73,"address":[8053620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[3857520,3857970],"length":1,"stats":{"Line":0},"fn_name":"connect"},{"line":84,"address":[3857663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[3857751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[3857767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[3858522,3857788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[3857824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[3858038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[3858105,3858273,3858353,3858191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[3858553,3858602,3858999,3857801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[3858650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[3858663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[3858685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[3858879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[3858575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[8055616,8055184],"length":1,"stats":{"Line":0},"fn_name":"connect_auth"},{"line":114,"address":[8055297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8055390,8055333,8055795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[8055438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[8055451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[8055473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[8055684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[8055363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[3857504],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":129,"address":[3857509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[3898496,3898839,3898863],"length":1,"stats":{"Line":0},"fn_name":"query\u003c\u0026str\u003e"},{"line":134,"address":[3898746,3898639,3898560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[3859040],"length":1,"stats":{"Line":0},"fn_name":"query_a"},{"line":140,"address":[3859079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8055936,8056369],"length":1,"stats":{"Line":0},"fn_name":"validate_sql"},{"line":145,"address":[8056039,8055976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[8056081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[8056166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8056194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[8056223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[8056318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[8056416],"length":1,"stats":{"Line":0},"fn_name":"reset_current_db"},{"line":157,"address":[8056425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8056464],"length":1,"stats":{"Line":0},"fn_name":"server_version"},{"line":162,"address":[8056473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[8056544],"length":1,"stats":{"Line":0},"fn_name":"load_table_info"},{"line":167,"address":[8056699,8056586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[8056720],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":172,"address":[8056729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8056768],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":194,"address":[8056777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[8056800],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":200,"address":[8056807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[8056864],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code"},{"line":204,"address":[8056887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[8056928],"length":1,"stats":{"Line":0},"fn_name":"raw"},{"line":208,"address":[8056937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8102160],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":216,"address":[8102172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[8102216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[8102223,8102357,8102308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[3856688],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":229,"address":[3856693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[3856624],"length":1,"stats":{"Line":0},"fn_name":"errno"},{"line":234,"address":[3856633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8057040],"length":1,"stats":{"Line":0},"fn_name":"errstr"},{"line":238,"address":[8057049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[3855120],"length":1,"stats":{"Line":0},"fn_name":"err_as_str"},{"line":243,"address":[3855129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[3856864,3857065,3857034],"length":1,"stats":{"Line":0},"fn_name":"from_ptr"},{"line":249,"address":[3856886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[3856911,3856962],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[3856969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[3856320],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_unchecked"},{"line":258,"address":[3856344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[3856416],"length":1,"stats":{"Line":0},"fn_name":"from_ptr_with_code"},{"line":264,"address":[3856443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[3857152,3857439],"length":1,"stats":{"Line":0},"fn_name":"with_code"},{"line":269,"address":[3857437,3857259,3857178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[3857300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[3857385,3857270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[8058000],"length":1,"stats":{"Line":0},"fn_name":"num_fields"},{"line":278,"address":[8058009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[3856704],"length":1,"stats":{"Line":0},"fn_name":"fields"},{"line":282,"address":[3856716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[8130560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[8130594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[3856744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[8058112],"length":1,"stats":{"Line":0},"fn_name":"fetch_fields"},{"line":290,"address":[8058144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[8058178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[3856064],"length":1,"stats":{"Line":0},"fn_name":"fetch_lengths"},{"line":296,"address":[3856073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[3856272],"length":1,"stats":{"Line":0},"fn_name":"fetch_lengths_raw"},{"line":300,"address":[3856281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[3855248],"length":1,"stats":{"Line":0},"fn_name":"fetch_block"},{"line":305,"address":[3855415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[3855439],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[3855486,3855714,3855796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[3855447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[3855554,3855573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[3855588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[3855561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[3856496],"length":1,"stats":{"Line":0},"fn_name":"get_column_data_offset"},{"line":320,"address":[3856515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[8059008],"length":1,"stats":{"Line":0},"fn_name":"fetch_raw_block"},{"line":325,"address":[8059175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[8059199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[8059246,8059337,8059387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[8059207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[8059321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[8059440],"length":1,"stats":{"Line":0},"fn_name":"is_update_query"},{"line":336,"address":[8059449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[3856784],"length":1,"stats":{"Line":0},"fn_name":"is_null"},{"line":341,"address":[3856809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[8059568],"length":1,"stats":{"Line":0},"fn_name":"stop_query"},{"line":346,"address":[8059577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[8059616],"length":1,"stats":{"Line":0},"fn_name":"select_db"},{"line":351,"address":[8059664,8059802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[3856016],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":356,"address":[3856025],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[8059888],"length":1,"stats":{"Line":0},"fn_name":"field_count"},{"line":361,"address":[8059897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[8059936],"length":1,"stats":{"Line":0},"fn_name":"free_result"},{"line":366,"address":[8059945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[3857088],"length":1,"stats":{"Line":0},"fn_name":"precision"},{"line":371,"address":[3857097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[8060048],"length":1,"stats":{"Line":0},"fn_name":"fetch_row"},{"line":376,"address":[8060057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[8060096],"length":1,"stats":{"Line":0},"fn_name":"fetch_rows_a"},{"line":381,"address":[8060125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[3856560],"length":1,"stats":{"Line":0},"fn_name":"block"},{"line":386,"address":[3856569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8060240],"length":1,"stats":{"Line":0},"fn_name":"tmq_topic_name"},{"line":392,"address":[8060249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[8060285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[8060327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[8060361,8060310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8060400],"length":1,"stats":{"Line":0},"fn_name":"tmq_vgroup_id"},{"line":403,"address":[8060409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8060455,8060442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8060447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8060461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[3856112],"length":1,"stats":{"Line":0},"fn_name":"tmq_table_name"},{"line":415,"address":[3856121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[3856157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[3856199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[3856182,3856233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[3855856],"length":1,"stats":{"Line":0},"fn_name":"tmq_db_name"},{"line":426,"address":[3855865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[3855901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[3855943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[3855977,3855926],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":154},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","schemaless.rs"],"content":"use crate::{TAOS, TAOS_RES};\nuse std::os::raw::*;\n\n///\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum SchemalessProtocol {\n    #[non_exhaustive]\n    Unknown = 0,\n    Line,\n    Telnet,\n    Json,\n}\npub type TSDB_SML_PROTOCOL_TYPE = SchemalessProtocol;\npub const TSDB_SML_UNKNOWN_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Unknown;\npub const TSDB_SML_LINE_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Line;\npub const TSDB_SML_TELNET_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Telnet;\npub const TSDB_SML_JSON_PROTOCOL: SchemalessProtocol = SchemalessProtocol::Json;\n\n/// Timestamp precision to parse from schemaless input.\n///\n/// Accepted timestamp precision options are:\n/// - NonConfigured: let the parse detect precision from input\n/// - Hours/minutes/seconds/milliseconds/microseconds/nanoseconds: specified precision to use\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum SchemalessPrecision {\n    NonConfigured = 0,\n    Hours,\n    Minutes,\n    Seconds,\n    Milliseconds,\n    Microseconds,\n    Nanoseconds,\n}\npub type TSDB_SML_TIMESTAMP_TYPE = SchemalessPrecision;\npub const TSDB_SML_TIMESTAMP_NOT_CONFIGURED: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::NonConfigured;\npub const TSDB_SML_TIMESTAMP_HOURS: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Hours;\npub const TSDB_SML_TIMESTAMP_MINUTES: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Minutes;\npub const TSDB_SML_TIMESTAMP_SECONDS: TSDB_SML_TIMESTAMP_TYPE = TSDB_SML_TIMESTAMP_TYPE::Seconds;\npub const TSDB_SML_TIMESTAMP_MILLISECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Milliseconds;\npub const TSDB_SML_TIMESTAMP_MICROSECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Microseconds;\npub const TSDB_SML_TIMESTAMP_NANOSECONDS: TSDB_SML_TIMESTAMP_TYPE =\n    TSDB_SML_TIMESTAMP_TYPE::Nanoseconds;\n\nextern \"C\" {\n    pub fn taos_schemaless_insert(\n        taos: *mut TAOS,\n        lines: *mut *mut c_char,\n        numLines: c_int,\n        protocol: SchemalessProtocol,\n        precision: TSDB_SML_TIMESTAMP_TYPE,\n    ) -\u003e *mut TAOS_RES;\n}\n\n#[test]\n#[cfg(taos_v2)] // TODO: SML in v3 is unimplemented.\nfn test_sml() {\n    use std::ptr;\n    unsafe {\n        let null = ptr::null();\n        let mut lines = [\n            b\"st,t1=4i64,t3=\\\"t4\\\",t2=5f64,t4=5f64 c1=3i64,c3=L\\\"a, abc\\\",c2=true,c4=5f64,c5=5f64,c6=7u64 1626006933640000000\\0\\0\" as *const u8 as *mut c_char\n        ];\n        let taos = crate::taos_connect(ptr::null(), ptr::null(), null, null, 0);\n        let res = crate::taos_query(taos, b\"create database _rs_sml_\\0\" as *const u8 as _);\n        crate::taos_free_result(res);\n        let _ = crate::taos_query(taos, b\"use _rs_sml_\\0\" as *const u8 as _);\n\n        let res = crate::taos_schemaless_insert(\n            taos,\n            \u0026mut lines as _,\n            1,\n            SchemalessProtocol::Line,\n            TSDB_SML_TIMESTAMP_TYPE::NonConfigured,\n        );\n        assert!(crate::taos_errno(res) == 0);\n        crate::taos_free_result(res);\n        let res = crate::taos_query(taos, b\"select * from st\\0\" as *const u8 as _);\n\n        crate::taos_free_result(res);\n        assert!(!taos.is_null());\n        crate::taos_close(taos);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","set_config.rs"],"content":"use std::os::raw::*;\n\npub const SET_CONF_RET_SUCC: SET_CONF_RET_CODE = SET_CONF_RET_CODE::Succ;\npub const SET_CONF_RET_ERR_PART: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrPart;\npub const SET_CONF_RET_ERR_INNER: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrInner;\npub const SET_CONF_RET_ERR_JSON_INVALID: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrJsonInvalid;\npub const SET_CONF_RET_ERR_JSON_PARSE: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrJsonParse;\npub const SET_CONF_RET_ERR_ONLY_ONCE: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrOnlyOnce;\npub const SET_CONF_RET_ERR_TOO_LONG: SET_CONF_RET_CODE = SET_CONF_RET_CODE::ErrTooLong;\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct SetConfRet {\n    pub code: SET_CONF_RET_CODE,\n    pub msg: [c_char; 1024usize],\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone, PartialEq)]\npub enum SET_CONF_RET_CODE {\n    Succ = 0,\n    ErrPart = -1,\n    ErrInner = -2,\n    ErrJsonInvalid = -3,\n    ErrJsonParse = -4,\n    ErrOnlyOnce = -5,\n    ErrTooLong = -6,\n}\n\nextern \"C\" {\n    pub fn taos_set_config(config: *const c_char) -\u003e SetConfRet;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","bind.rs"],"content":"use taos_query::common::{itypes::IsValue, Ty};\n\nuse crate::{BindFrom, TaosBind, TaosBindV2, TaosBindV3};\n\nfn box_into_raw\u003cT\u003e(v: T) -\u003e *mut T {\n    Box::into_raw(Box::new(v))\n}\n\nimpl\u003cT\u003e From\u003c\u0026T\u003e for TaosBindV2\nwhere\n    T: IsValue,\n{\n    #[inline(always)]\n    fn from(v: \u0026T) -\u003e Self {\n        macro_rules! as_is {\n            () =\u003e {\n                Self::from_primitive(v)\n            };\n        }\n\n        match T::TY {\n            Ty::Null =\u003e Self::null(),\n            Ty::Bool =\u003e as_is!(),\n            Ty::TinyInt =\u003e as_is!(),\n            Ty::SmallInt =\u003e as_is!(),\n            Ty::Int =\u003e as_is!(),\n            Ty::BigInt =\u003e as_is!(),\n            Ty::UTinyInt =\u003e as_is!(),\n            Ty::USmallInt =\u003e as_is!(),\n            Ty::UInt =\u003e as_is!(),\n            Ty::UBigInt =\u003e as_is!(),\n            Ty::Float =\u003e as_is!(),\n            Ty::Double =\u003e as_is!(),\n            Ty::Timestamp =\u003e Self::from_timestamp(v.as_timestamp()),\n            Ty::VarChar =\u003e Self::from_varchar(v.as_var_char()),\n            Ty::NChar =\u003e Self::from_nchar(v.as_nchar()),\n            Ty::Json =\u003e todo!(),\n            _ =\u003e Self::null(),\n        }\n    }\n}\n\nimpl\u003cT\u003e From\u003c\u0026T\u003e for TaosBindV3\nwhere\n    T: IsValue,\n{\n    #[inline(always)]\n    fn from(v: \u0026T) -\u003e Self {\n        macro_rules! as_is {\n            () =\u003e {\n                Self::from_primitive(v)\n            };\n        }\n\n        match T::TY {\n            Ty::Null =\u003e Self::null(),\n            Ty::Bool =\u003e as_is!(),\n            Ty::TinyInt =\u003e as_is!(),\n            Ty::SmallInt =\u003e as_is!(),\n            Ty::Int =\u003e as_is!(),\n            Ty::BigInt =\u003e as_is!(),\n            Ty::UTinyInt =\u003e as_is!(),\n            Ty::USmallInt =\u003e as_is!(),\n            Ty::UInt =\u003e as_is!(),\n            Ty::UBigInt =\u003e as_is!(),\n            Ty::Float =\u003e as_is!(),\n            Ty::Double =\u003e as_is!(),\n            Ty::Timestamp =\u003e Self::from_timestamp(v.as_timestamp()),\n            Ty::VarChar =\u003e Self::from_varchar(v.as_var_char()),\n            Ty::NChar =\u003e Self::from_nchar(v.as_nchar()),\n            Ty::Json =\u003e todo!(),\n            _ =\u003e Self::null(),\n        }\n    }\n}\n\npub trait ToBind: IsValue {\n    fn to_bind(\u0026self) -\u003e TaosBind {\n        macro_rules! as_is {\n            () =\u003e {\n                TaosBind::from_primitive(self)\n            };\n        }\n\n        if self.is_null() {\n            return TaosBind::null();\n        }\n\n        match Self::TY {\n            Ty::Null =\u003e TaosBind::null(),\n            Ty::Bool =\u003e as_is!(),\n            Ty::TinyInt =\u003e as_is!(),\n            Ty::SmallInt =\u003e as_is!(),\n            Ty::Int =\u003e as_is!(),\n            Ty::BigInt =\u003e as_is!(),\n            Ty::UTinyInt =\u003e as_is!(),\n            Ty::USmallInt =\u003e as_is!(),\n            Ty::UInt =\u003e as_is!(),\n            Ty::UBigInt =\u003e as_is!(),\n            Ty::Float =\u003e as_is!(),\n            Ty::Double =\u003e as_is!(),\n            Ty::Timestamp =\u003e TaosBind::from_timestamp(self.as_timestamp()),\n            Ty::VarChar =\u003e TaosBind::from_varchar(self.as_var_char()),\n            Ty::NChar =\u003e TaosBind::from_nchar(self.as_nchar()),\n            Ty::Json =\u003e todo!(),\n            _ =\u003e TaosBind::null(),\n        }\n    }\n}\n\nimpl\u003cT: IsValue\u003e ToBind for T {}\n\n#[cfg(test)]\nmod tests_v2 {\n    use std::ffi::CStr;\n\n    use taos_query::common::itypes::IVarChar;\n\n    use super::*;\n    use crate::TaosBindV2 as TaosBind;\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false] {\n            let bind = TaosBind::from(\u0026v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const bool).read() };\n            assert!(v1 == v);\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n    #[test]\n    fn bind_var_char() {\n        for v in [IVarChar::from(\"abc\")].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n\n            let v1 =\n                unsafe { std::str::from_utf8(std::slice::from_raw_parts(bind.buffer() as _, 3)) }\n                    .unwrap();\n\n            dbg!(v1);\n            assert!(v1 == v.as_str());\n        }\n    }\n}\n#[cfg(test)]\nmod tests_v3 {\n    use std::ffi::CStr;\n\n    use crate::TaosBindV3 as TaosBind;\n    use taos_query::common::itypes::IVarChar;\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer() as *const bool).read() };\n            assert!(v1.eq(v));\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer() as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n    #[test]\n    fn bind_var_char() {\n        for v in [IVarChar::from(\"abc\")].iter() {\n            let bind = TaosBind::from(v);\n            dbg!(\u0026bind);\n            let v1 =\n                unsafe { std::str::from_utf8(std::slice::from_raw_parts(bind.buffer() as _, 3)) }\n                    .unwrap();\n\n            dbg!(v1);\n            assert!(v1 == v.as_str());\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":67},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","mod.rs"],"content":"use crate::{ffi::*, into_c_str::IntoCStr, RawRes, RawTaos};\n\nuse std::{ffi::CStr, os::raw::*};\n\nuse taos_error::{Code, Error};\nuse taos_query::common::{itypes::ITimestamp, Ty};\n\nuse crate::types::*;\n\nmod bind;\nmod multi;\n\n#[derive(Debug)]\npub struct RawStmt(*mut TAOS_STMT);\n\nimpl Drop for RawStmt {\n    fn drop(\u0026mut self) {\n        let _ = self.close();\n    }\n}\n\nimpl RawStmt {\n    #[inline(always)]\n    fn ok(\u0026self, code: impl Into\u003cCode\u003e) -\u003e Result\u003c(), Error\u003e {\n        let code = code.into();\n\n        if code.success() {\n            Ok(())\n        } else {\n            Err(Error::from_string(self.err_as_str()))\n        }\n    }\n\n    #[inline]\n    pub unsafe fn as_ptr(\u0026self) -\u003e *mut TAOS_STMT {\n        self.0\n    }\n\n    #[inline]\n    pub fn errstr(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(taos_stmt_errstr(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn err_as_str(\u0026self) -\u003e String {\n        unsafe {\n            CStr::from_ptr(taos_stmt_errstr(self.as_ptr()))\n                .to_string_lossy()\n                .to_string()\n        }\n    }\n\n    #[inline]\n    pub fn from_raw_taos(taos: \u0026RawTaos) -\u003e RawStmt {\n        RawStmt(unsafe { taos_stmt_init(taos.as_ptr()) })\n    }\n    #[inline]\n    pub fn close(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_close(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn prepare\u003c'c\u003e(\u0026mut self, sql: impl IntoCStr\u003c'c\u003e) -\u003e Result\u003c(), Error\u003e {\n        let sql = sql.into_c_str();\n        self.ok(unsafe {\n            taos_stmt_prepare(self.as_ptr(), sql.as_ptr(), sql.to_bytes().len() as _)\n        })\n    }\n\n    pub fn set_tbname_tags_v3\u003c'a\u003e(\n        \u0026mut self,\n        name: impl IntoCStr\u003c'a\u003e,\n        tags: \u0026[TaosBind],\n    ) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe {\n            taos_stmt_set_tbname_tags(\n                self.as_ptr(),\n                name.into_c_str().as_ptr(),\n                tags.as_ptr() as _,\n            )\n        })\n    }\n\n    #[inline]\n    pub fn set_tbname\u003c'c\u003e(\u0026mut self, name: impl IntoCStr\u003c'c\u003e) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe { taos_stmt_set_tbname(self.as_ptr(), name.into_c_str().as_ptr()) })\n    }\n\n    #[inline]\n    pub fn set_sub_tbname\u003c'c\u003e(\u0026mut self, name: impl IntoCStr\u003c'c\u003e) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe { taos_stmt_set_sub_tbname(self.as_ptr(), name.into_c_str().as_ptr()) })\n    }\n\n    #[inline]\n    pub fn use_result(\u0026mut self) -\u003e RawRes {\n        unsafe { RawRes::from_ptr_unchecked(taos_stmt_use_result(self.as_ptr())) }\n    }\n\n    #[inline]\n    pub fn affected_rows(\u0026self) -\u003e i32 {\n        unsafe { taos_stmt_affected_rows(self.as_ptr()) }\n    }\n\n    #[inline]\n    pub fn execute(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_execute(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn add_batch(\u0026self) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_add_batch(self.as_ptr()))\n    }\n\n    #[inline]\n    pub fn is_insert(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n        let mut is_insert = 0;\n        err_or!(\n            self,\n            taos_stmt_is_insert(self.as_ptr(), \u0026mut is_insert as _),\n            is_insert != 0\n        )\n    }\n\n    #[inline]\n    pub fn num_params(\u0026self) -\u003e Result\u003cusize, Error\u003e {\n        let mut num = 0i32;\n        err_or!(\n            self,\n            taos_stmt_num_params(self.as_ptr(), \u0026mut num as _),\n            num as usize\n        )\n    }\n\n    #[inline]\n    pub fn get_param(\u0026mut self, idx: i32) -\u003e Result\u003c(Ty, i32), Error\u003e {\n        let (mut type_, mut bytes) = (0, 0);\n        err_or!(\n            self,\n            taos_stmt_get_param(self.as_ptr(), idx, \u0026mut type_ as _, \u0026mut bytes as _),\n            ((type_ as u8).into(), bytes)\n        )\n    }\n    #[inline]\n    pub fn bind_param(\u0026mut self, bind: \u0026[TaosBind]) -\u003e Result\u003c(), Error\u003e {\n        err_or!(self, taos_stmt_bind_param(self.as_ptr(), bind.as_ptr()))\n    }\n\n    #[inline]\n    pub fn bind_param_batch(\u0026mut self, bind: \u0026[TaosMultiBind]) -\u003e Result\u003c(), Error\u003e {\n        err_or!(\n            self,\n            taos_stmt_bind_param_batch(self.as_ptr(), bind.as_ptr())\n        )\n    }\n\n    #[inline]\n    pub fn bind_single_param_batch(\u0026self, bind: \u0026TaosMultiBind, col: i32) -\u003e Result\u003c(), Error\u003e {\n        self.ok(unsafe {\n            taos_stmt_bind_single_param_batch(self.as_ptr(), bind as *const _ as _, col)\n        })\n    }\n}\n\n#[test]\nfn test_tbname_tags() -\u003e Result\u003c(), Error\u003e {\n    use std::ptr::null;\n    let host = null();\n    let user = null();\n    let pass = null();\n    let db = null();\n    let port = 0;\n    let taos = RawTaos::connect(host, user, pass, db, port)?;\n    taos.query(\"drop database if exists stt1\")?;\n    taos.query(\"create database if not exists stt1 keep 36500\")?;\n    taos.query(\"use stt1\")?;\n    taos.query(\n        \"create stable if not exists st1(ts timestamp, v int) tags(t1 int, t2 bool)\"\n    )?;\n\n    let mut stmt = RawStmt::from_raw_taos(\u0026taos);\n    let sql = \"insert into ? using st1 tags(?, ?) values(?, ?)\";\n    stmt.prepare(sql)?;\n\n    let tags = vec![TaosBind::from(\u00261i32), TaosBind::from(\u0026true)];\n    println!(\"tags: {tags:#?}\");\n    let tbname = \"tb1\";\n    stmt.set_tbname_tags_v3(\u0026tbname, \u0026tags)?;\n    println!(\"bind\");\n\n    // todo: get_param not implemented in taosc 3.0\n    // let p = stmt.get_param(0)?;\n    // dbg!(p);\n\n    let params = vec![TaosBind::from(\u0026ITimestamp(0)), TaosBind::from(\u00260i32)];\n    stmt.bind_param(\u0026params)?;\n    println!(\"add batch\");\n\n    stmt.add_batch()?;\n    stmt.execute()?;\n\n    assert!(stmt.affected_rows() == 1);\n\n    let res = taos.query(\"select count(*) from st1\")?;\n\n    taos.query(\"drop database stt1\")?;\n    Ok(())\n}\n","traces":[{"line":17,"address":[8102448],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":18,"address":[8102460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[8133933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[8134009,8133943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[8134016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[8133963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[8131376],"length":1,"stats":{"Line":0},"fn_name":"as_ptr"},{"line":36,"address":[8131381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[8131392],"length":1,"stats":{"Line":0},"fn_name":"errstr"},{"line":41,"address":[8131401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[8131472,8131633],"length":1,"stats":{"Line":0},"fn_name":"err_as_str"},{"line":47,"address":[8131504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8131680],"length":1,"stats":{"Line":0},"fn_name":"from_raw_taos"},{"line":55,"address":[8131689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8131744],"length":1,"stats":{"Line":0},"fn_name":"close"},{"line":59,"address":[8131782,8131900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[8131952],"length":1,"stats":{"Line":0},"fn_name":"use_result"},{"line":96,"address":[8131984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[8132048],"length":1,"stats":{"Line":0},"fn_name":"affected_rows"},{"line":101,"address":[8132057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[8132096],"length":1,"stats":{"Line":0},"fn_name":"execute"},{"line":106,"address":[8132134,8132252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[8132304],"length":1,"stats":{"Line":0},"fn_name":"add_batch"},{"line":111,"address":[8132342,8132460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8132512],"length":1,"stats":{"Line":0},"fn_name":"is_insert"},{"line":116,"address":[8132550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[8132665,8132691,8132592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[8132558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[8132657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8132752],"length":1,"stats":{"Line":0},"fn_name":"num_params"},{"line":126,"address":[8132790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8132930,8132902,8132832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[8132798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[8132897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8132992],"length":1,"stats":{"Line":0},"fn_name":"get_param"},{"line":136,"address":[8133041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8133254,8133116,8133217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[8133073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8133179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8133312],"length":1,"stats":{"Line":0},"fn_name":"bind_param"},{"line":145,"address":[8133376,8133520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[8133568],"length":1,"stats":{"Line":0},"fn_name":"bind_param_batch"},{"line":150,"address":[8133687,8133776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[8133632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[8133824],"length":1,"stats":{"Line":0},"fn_name":"bind_single_param_batch"},{"line":158,"address":[8134023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[8133877],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":65},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","stmt","multi.rs"],"content":"use taos_query::common::{\n    itypes::{IsPrimitive, IsValue},\n    Ty,\n};\n\nuse crate::{BindFrom, TaosBind, TaosBindV2, TaosMultiBind};\n\nfn box_into_raw\u003cT\u003e(v: T) -\u003e *mut T {\n    Box::into_raw(Box::new(v))\n}\n\n// impl\u003cT\u003e From\u003cT\u003e for TaosMultiBind\n// where\n//     T: IsValue,\n// {\n//     #[inline(always)]\n//     fn from(v: T) -\u003e Self {\n//         macro_rules! as_is {\n//             () =\u003e {{\n//                 let mut param = Self::new(T::TY);\n//                 param.buffer_length = T::TY.fixed_length();\n//                 param.buffer = box_into_raw(v) as _;\n//                 param.length = box_into_raw(param.buffer_length) as _;\n//                 param\n//             }};\n//             ($v:expr) =\u003e {{\n//                 let mut param = Self::new(T::TY);\n//                 param.buffer_length = T::TY.fixed_length();\n//                 param.buffer = box_into_raw($v) as _;\n//                 param.length = box_into_raw(param.buffer_length) as _;\n//                 param\n//             }};\n//         }\n\n//         match T::TY {\n//             Ty::Null =\u003e Self::null(),\n//             Ty::Bool =\u003e as_is!(),\n//             Ty::TinyInt =\u003e as_is!(),\n//             Ty::SmallInt =\u003e as_is!(),\n//             Ty::Int =\u003e as_is!(),\n//             Ty::BigInt =\u003e as_is!(),\n//             Ty::UTinyInt =\u003e as_is!(),\n//             Ty::USmallInt =\u003e as_is!(),\n//             Ty::UInt =\u003e as_is!(),\n//             Ty::UBigInt =\u003e as_is!(),\n//             Ty::Float =\u003e as_is!(),\n//             Ty::Double =\u003e as_is!(),\n//             Ty::Timestamp =\u003e {\n//                 as_is!(v.as_timestamp())\n//             }\n//             Ty::VarChar =\u003e Self::from_varchar(v.as_var_char()),\n//             Ty::NChar =\u003e Self::from_nchar(v.as_nchar()),\n//             Ty::Json =\u003e todo!(),\n//             _ =\u003e Self::null(),\n//         }\n//     }\n// }\n\n#[cfg(test)]\nmod tests {\n    use crate::{TaosBind, TaosBindV2};\n\n    #[test]\n    fn bind_bool() {\n        for v in [true, false].iter() {\n            let bind = TaosBindV2::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const bool).read() };\n            assert!(v1.eq(v));\n        }\n    }\n\n    #[test]\n    fn bind_i8() {\n        for v in [0i8, 1i8].iter() {\n            let bind = TaosBindV2::from(v);\n            dbg!(\u0026bind);\n            let v1 = unsafe { (bind.buffer as *const i8).read() };\n            assert!(v1.eq(v));\n        }\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","tmq.rs"],"content":"use std::{borrow::Cow, fmt::Display, os::raw::*};\n\nuse taos_macros::c_cfg;\n\nuse crate::ffi::TAOS_RES;\n\n#[repr(transparent)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\npub struct tmq_resp_err_t(i32);\n\nimpl PartialEq\u003ci32\u003e for tmq_conf_res_t {\n    fn eq(\u0026self, other: \u0026i32) -\u003e bool {\n        self == other\n    }\n}\n\nimpl tmq_resp_err_t {\n    pub fn ok_or(self, s: impl Into\u003cCow\u003c'static, str\u003e\u003e) -\u003e Result\u003c(), taos_error::Error\u003e {\n        match self {\n            Self(0) =\u003e Ok(()),\n            _ =\u003e Err(taos_error::Error::from_string(s.into())),\n        }\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_t {\n    _unused: [u8; 0],\n}\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_conf_t {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_list_t {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct tmq_message_t {\n    _unused: [u8; 0],\n}\n\n#[repr(C)]\npub enum tmq_conf_res_t {\n    Unknown = -2,\n    Invalid = -1,\n    Ok = 0,\n}\n\nimpl tmq_conf_res_t {\n    pub fn ok(self, k: \u0026str, v: \u0026str) -\u003e Result\u003c(), taos_error::Error\u003e {\n        match self {\n            Self::Ok =\u003e Ok(()),\n            Self::Invalid =\u003e Err(taos_error::Error::from_string(format!(\n                \"Invalid key value pair ({k}, {v})\"\n            ))),\n            Self::Unknown =\u003e Err(taos_error::Error::from_string(format!(\"Unknown key {k}\"))),\n        }\n    }\n}\n\npub type tmq_commit_cb =\n    unsafe extern \"C\" fn(tmq: *mut tmq_t, resp: tmq_resp_err_t, param: *mut c_void);\n\n// TMQ streaming/consuming API.\n#[c_cfg(taos_tmq)]\nextern \"C\" {\n    pub fn tmq_list_new() -\u003e *mut tmq_list_t;\n    pub fn tmq_list_append(arg1: *mut tmq_list_t, arg2: *const c_char) -\u003e i32;\n    pub fn tmq_list_destroy(list: *mut tmq_list_t);\n    pub fn tmq_list_get_size(list: *const tmq_list_t) -\u003e i32;\n    pub fn tmq_list_to_c_array(list: *const tmq_list_t) -\u003e *mut *mut c_char;\n\n    pub fn tmq_consumer_new(\n        conf: *mut tmq_conf_t,\n        errstr: *mut c_char,\n        errstr_len: i32,\n    ) -\u003e *mut tmq_t;\n\n    pub fn tmq_err2str(err: tmq_resp_err_t) -\u003e *const c_char;\n\n    pub fn tmq_subscribe(tmq: *mut tmq_t, topic_list: *mut tmq_list_t) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_subscription(tmq: *mut tmq_t, topic_list: *mut *mut tmq_list_t) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_consumer_poll(tmq: *mut tmq_t, blocking_time: i64) -\u003e *mut TAOS_RES;\n\n    pub fn tmq_consumer_close(tmq: *mut tmq_t) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_commit_sync(tmq: *mut tmq_t, msg: *const TAOS_RES) -\u003e tmq_resp_err_t;\n\n    pub fn tmq_commit_async(\n        tmq: *mut tmq_t,\n        msg: *const TAOS_RES,\n        cb: tmq_commit_cb,\n        param: *mut c_void,\n    );\n\n    pub fn tmq_get_topic_name(res: *mut TAOS_RES) -\u003e *const c_char;\n    pub fn tmq_get_table_name(res: *mut TAOS_RES) -\u003e *const c_char;\n    pub fn tmq_get_db_name(res: *mut TAOS_RES) -\u003e *const c_char;\n    pub fn tmq_get_vgroup_id(res: *mut TAOS_RES) -\u003e i32;\n}\n\n// TMQ Conf API\n#[c_cfg(taos_tmq)]\nextern \"C\" {\n    pub fn tmq_conf_new() -\u003e *mut tmq_conf_t;\n\n    pub fn tmq_conf_destroy(conf: *mut tmq_conf_t);\n\n    pub fn tmq_conf_set(\n        conf: *mut tmq_conf_t,\n        key: *const c_char,\n        value: *const c_char,\n    ) -\u003e tmq_conf_res_t;\n\n    pub fn tmq_conf_set_auto_commit_cb(\n        conf: *mut tmq_conf_t,\n        cb: tmq_commit_cb,\n        param: *mut c_void,\n    );\n}\n","traces":[{"line":12,"address":[8046096],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":13,"address":[8046110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[3759040],"length":1,"stats":{"Line":0},"fn_name":"ok_or\u003c\u0026str\u003e"},{"line":19,"address":[3759084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[3759104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[3759123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8046144],"length":1,"stats":{"Line":0},"fn_name":"ok"},{"line":57,"address":[8046185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8046274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[8046246,8046294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[8046220,8046529],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","types","field.rs"],"content":"use std::ffi::CStr;\n\n// use super::Ty;\nuse taos_query::common::{Field, Ty};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct TAOS_FIELD {\n    pub name: [u8; 65usize],\n    pub type_: u8,\n    #[cfg(taos_v2)]\n    pub bytes: i16,\n    #[cfg(not(taos_v2))]\n    pub bytes: i32,\n}\n\nimpl TAOS_FIELD {\n    pub fn name(\u0026self) -\u003e \u0026CStr {\n        unsafe { CStr::from_ptr(self.name.as_ptr() as _) }\n    }\n    pub fn type_(\u0026self) -\u003e Ty {\n        self.type_.into()\n    }\n\n    pub fn bytes(\u0026self) -\u003e u32 {\n        self.bytes as _\n    }\n}\n\nimpl Into\u003cField\u003e for \u0026TAOS_FIELD {\n    fn into(self) -\u003e Field {\n        Field::new(\n            self.name()\n                .to_str()\n                .expect(\"invalid utf-8 field name\")\n                .to_string(),\n            self.type_(),\n            self.bytes(),\n        )\n    }\n}\n\npub fn from_raw_fields\u003c'a\u003e(ptr: *const TAOS_FIELD, len: usize) -\u003e Vec\u003cField\u003e {\n    unsafe { std::slice::from_raw_parts(ptr, len) }\n        .into_iter()\n        .map(Into::into)\n        .collect()\n}\n","traces":[{"line":18,"address":[8086592],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":19,"address":[8086601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[8086656],"length":1,"stats":{"Line":0},"fn_name":"type_"},{"line":22,"address":[8086665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[8086688],"length":1,"stats":{"Line":0},"fn_name":"bytes"},{"line":26,"address":[8086693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[8086975,8087006,8086704],"length":1,"stats":{"Line":0},"fn_name":"into"},{"line":33,"address":[8086742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8086854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[8086905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[8087024],"length":1,"stats":{"Line":0},"fn_name":"from_raw_fields"},{"line":44,"address":[8087074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","src","types","mod.rs"],"content":"use std::{\n    any::{Any, TypeId},\n    borrow::Cow,\n    fmt::Debug,\n    intrinsics::transmute,\n    mem::ManuallyDrop,\n    os::raw::*,\n    ptr,\n};\n\nmod field;\nuse derive_more::Deref;\npub use field::*;\npub use taos_query::common::{Precision, Ty};\n\nuse taos_query::common::{itypes::*, BorrowedColumn, Column, Timestamp};\n\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub enum TSDB_OPTION {\n    Locale = 0,\n    Charset,\n    Timezone,\n    ConfigDir,\n    ShellActivityTimer,\n    MaxOptions,\n}\npub const TSDB_OPTION_LOCALE: TSDB_OPTION = TSDB_OPTION::Locale;\npub const TSDB_OPTION_CHARSET: TSDB_OPTION = TSDB_OPTION::Charset;\npub const TSDB_OPTION_TIMEZONE: TSDB_OPTION = TSDB_OPTION::Timezone;\npub const TSDB_OPTION_CONFIGDIR: TSDB_OPTION = TSDB_OPTION::ConfigDir;\npub const TSDB_OPTION_SHELL_ACTIVITY_TIMER: TSDB_OPTION = TSDB_OPTION::ShellActivityTimer;\npub const TSDB_MAX_OPTIONS: TSDB_OPTION = TSDB_OPTION::MaxOptions;\n\n#[repr(C)]\n#[derive(Clone)]\npub struct TaosBindV2 {\n    pub buffer_type: c_int,\n    pub buffer: *mut c_void,\n    pub buffer_length: usize,\n    pub length: *mut usize,\n    pub is_null: *mut c_int,\n    pub is_unsigned: c_int,\n    pub error: *mut c_int,\n    pub u: TaosBindUnionV2,\n    pub allocated: c_uint,\n}\n\nimpl Debug for TaosBindV2 {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"TaosBindV2\")\n            .field(\"buffer_type\", \u0026self.buffer_type)\n            .field(\"buffer\", \u0026self.buffer)\n            .field(\"buffer_length\", \u0026self.buffer_length)\n            .field(\"length\", \u0026self.length)\n            .field(\"is_null\", \u0026self.is_null)\n            .field(\"is_unsigned\", \u0026self.is_unsigned)\n            .field(\"error\", \u0026self.error)\n            .field(\"allocated\", \u0026self.allocated)\n            .finish()\n    }\n}\n#[repr(C)]\n#[derive(Copy, Clone)]\npub union TaosBindUnionV2 {\n    pub ts: i64,\n    pub b: i8,\n    pub v1: i8,\n    pub v2: i16,\n    pub v4: i32,\n    pub v8: i64,\n    pub f4: f32,\n    pub f8: f64,\n    pub bin: *mut c_uchar,\n    pub nchar: *mut c_char,\n}\n#[repr(C)]\n#[derive(Debug, Clone)]\npub struct TaosMultiBind {\n    pub buffer_type: c_int,\n    pub buffer: *const c_void,\n    pub buffer_length: usize,\n    pub length: *const i32,\n    pub is_null: *const c_char,\n    pub num: c_int,\n}\n\nimpl TaosMultiBind {\n    pub fn new(ty: Ty) -\u003e Self {\n        Self {\n            buffer_type: ty as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: std::ptr::null_mut(),\n            is_null: std::ptr::null_mut(),\n            num: 1,\n        }\n    }\n}\nimpl BindFrom for TaosBindV3 {\n    #[inline]\n    fn null() -\u003e Self {\n        Self(TaosMultiBind {\n            buffer_type: Ty::Null as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: std::ptr::null_mut(),\n            is_null: std::ptr::null_mut(),\n            num: 1 as _,\n        })\n    }\n\n    fn from_primitive\u003cT: IsValue\u003e(v: \u0026T) -\u003e Self {\n        let mut param = TaosMultiBind::new(T::TY);\n        param.buffer_length = T::TY.fixed_length();\n        param.buffer = v as *const T as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0) as _;\n        Self(param)\n    }\n\n    fn from_timestamp(v: i64) -\u003e Self {\n        let mut param = TaosMultiBind::new(Ty::Timestamp);\n        param.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        param.buffer = box_into_raw(v) as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n\n    fn from_varchar(v: \u0026str) -\u003e Self {\n        let mut param = TaosMultiBind::new(Ty::VarChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n\n    fn from_nchar(v: \u0026str) -\u003e Self {\n        let mut param = TaosMultiBind::new(Ty::NChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param.is_null = box_into_raw(0i8) as _;\n        Self(param)\n    }\n}\n\n#[derive(Debug, Deref)]\n#[repr(transparent)]\npub struct TaosBindV3(TaosMultiBind);\n\n#[cfg(taos_v3)]\npub type TaosBind = TaosBindV3;\n#[cfg(not(taos_v3))]\npub type TaosBind = TaosBindV2;\n\nimpl TaosBindV2 {\n    #[inline]\n    pub fn new(buffer_type: Ty) -\u003e Self {\n        let buffer: *mut c_void = ptr::null_mut();\n        let length: *mut usize = ptr::null_mut();\n        let is_null: *mut c_int = ptr::null_mut();\n        let error: *mut c_int = ptr::null_mut();\n        TaosBindV2 {\n            buffer_type: buffer_type as _,\n            buffer,\n            buffer_length: 0,\n            length,\n            is_null,\n            is_unsigned: 0,\n            error,\n            allocated: 1,\n            u: TaosBindUnionV2 { ts: 0 },\n        }\n    }\n\n    pub(crate) fn buffer(\u0026self) -\u003e *const c_void {\n        self.buffer\n    }\n\n    fn ty(\u0026self) -\u003e Ty {\n        Ty::from(self.buffer_type)\n    }\n\n    #[inline]\n    unsafe fn free(\u0026mut self) {\n        if self.ty() == Ty::Json \u0026\u0026 !self.buffer.is_null() {\n            Vec::from_raw_parts(self.buffer as _, *self.length, *self.length);\n        }\n        if !self.length.is_null() {\n            Box::from_raw(self.length);\n        }\n        if !self.is_null.is_null() {\n            Box::from_raw(self.is_null);\n        }\n        if !self.error.is_null() {\n            Box::from_raw(self.error);\n        }\n    }\n}\n\npub trait BindFrom: Sized {\n    fn null() -\u003e Self;\n    fn from_primitive\u003cT: IsValue\u003e(v: \u0026T) -\u003e Self;\n    fn from_timestamp(v: i64) -\u003e Self;\n    fn from_varchar(v: \u0026str) -\u003e Self;\n    fn from_nchar(v: \u0026str) -\u003e Self;\n    fn from_binary(v: \u0026str) -\u003e Self {\n        Self::from_varchar(v)\n    }\n}\n\nfn box_into_raw\u003cT\u003e(v: T) -\u003e *mut T {\n    Box::into_raw(Box::new(v))\n}\n\nimpl BindFrom for TaosBindV2 {\n    #[inline]\n    fn null() -\u003e Self {\n        let mut null = Self::new(Ty::Null);\n        let v = Box::new(1i8);\n        null.is_null = Box::into_raw(v) as _;\n        null\n    }\n    fn from_timestamp(v: i64) -\u003e Self {\n        let mut param = Self::new(Ty::Timestamp);\n        param.buffer_length = std::mem::size_of::\u003ci64\u003e();\n        param.buffer = box_into_raw(v) as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_varchar(v: \u0026str) -\u003e Self {\n        let mut param = Self::new(Ty::VarChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_nchar(v: \u0026str) -\u003e Self {\n        let mut param = Self::new(Ty::NChar);\n        param.buffer_length = v.len();\n        param.buffer = v.as_ptr() as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n\n    fn from_primitive\u003cT: IsValue\u003e(v: \u0026T) -\u003e Self {\n        let mut param = Self::new(T::TY);\n        param.buffer_length = T::TY.fixed_length();\n        param.buffer = v as *const T as _;\n        param.length = box_into_raw(param.buffer_length) as _;\n        param\n    }\n}\n\nimpl Drop for TaosBindV2 {\n    fn drop(\u0026mut self) {\n        unsafe { self.free() }\n    }\n}\n\npub trait ToMultiBind {\n    fn to_multi_bind(\u0026self) -\u003e TaosMultiBind;\n}\n\n// impl\u003cT\u003e From\u003cT\u003e for TaosBind\n// where\n//     T: IValue + Any,\n// {\n//     fn from(value: T) -\u003e Self {\n//         match T::TY {\n//             Ty::Null =\u003e Self::null(),\n//             Ty::Bool =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026bool = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_bool(*inner)\n//             }\n//             Ty::TinyInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i8 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_tiny_int(*inner)\n//             }\n//             Ty::SmallInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i16 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_small_int(*inner)\n//             }\n//             Ty::Int =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i32 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_int(*inner)\n//             }\n//             Ty::BigInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_big_int(*inner)\n//             }\n\n//             Ty::UTinyInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u8 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_tiny_int_unsigned(*inner)\n//             }\n//             Ty::USmallInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u16 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_small_int_unsigned(*inner)\n//             }\n//             Ty::UInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u32 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_int_unsigned(*inner)\n//             }\n//             Ty::UBigInt =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026u64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_big_int_unsigned(*inner)\n//             }\n//             Ty::Float =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026f32 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_float(*inner)\n//             }\n//             Ty::Double =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026f64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_double(*inner)\n//             }\n//             Ty::Timestamp =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026i64 = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_timestamp(*inner)\n//             }\n//             Ty::VarChar =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026String = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_varchar(inner)\n//             }\n//             Ty::NChar =\u003e {\n//                 let inner = value.into_inner();\n//                 let inner: \u0026String = unsafe { std::mem::transmute(\u0026inner) };\n//                 Self::from_nchar(inner)\n//             }\n//             Ty::Json =\u003e todo!(),\n//             _ =\u003e Self::null(),\n//         }\n//     }\n// }\n\n// impl\u003cT\u003e From\u003cVec\u003cT\u003e\u003e for TaosMultiBind\n// where\n//     T: IValue,\n// {\n//     fn from(_: Vec\u003cT\u003e) -\u003e Self {\n//         todo!()\n//     }\n// }\n\nimpl TaosMultiBind {\n    pub(crate) fn nulls(n: usize) -\u003e Self {\n        TaosMultiBind {\n            buffer_type: Ty::Null as _,\n            buffer: std::ptr::null_mut(),\n            buffer_length: 0,\n            length: n as _,\n            is_null: std::ptr::null_mut(),\n            num: n as _,\n        }\n    }\n    pub(crate) fn from_primitives\u003cT: IValue\u003e(nulls: Vec\u003cbool\u003e, values: \u0026[T]) -\u003e Self {\n        TaosMultiBind {\n            buffer_type: T::TY as _,\n            buffer: values.as_ptr() as _,\n            buffer_length: std::mem::size_of::\u003cT\u003e(),\n            length: values.len() as _,\n            is_null: ManuallyDrop::new(nulls).as_ptr() as _,\n            num: values.len() as _,\n        }\n    }\n    pub(crate) fn from_raw_timestamps(nulls: Vec\u003cbool\u003e, values: \u0026[i64]) -\u003e Self {\n        TaosMultiBind {\n            buffer_type: Ty::Timestamp as _,\n            buffer: values.as_ptr() as _,\n            buffer_length: std::mem::size_of::\u003ci64\u003e(),\n            length: values.len() as _,\n            is_null: ManuallyDrop::new(nulls).as_ptr() as _,\n            num: values.len() as _,\n        }\n    }\n\n    pub(crate) fn from_binary_vec(values: \u0026[Option\u003cimpl AsRef\u003c[u8]\u003e\u003e]) -\u003e Self {\n        let mut buffer_length = 0;\n        let num = values.len();\n        let mut nulls = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { nulls.set_len(num) };\n        nulls.fill(false);\n        let mut length: ManuallyDrop\u003cVec\u003ci32\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(num));\n        unsafe { length.set_len(num) };\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                length[i] = v.len() as _;\n                if v.len() \u003e buffer_length {\n                    buffer_length = v.len();\n                }\n            } else {\n                nulls[i] = true;\n            }\n        }\n        let buffer_size = buffer_length * values.len();\n        let mut buffer: ManuallyDrop\u003cVec\u003cu8\u003e\u003e = ManuallyDrop::new(Vec::with_capacity(buffer_size));\n        unsafe { buffer.set_len(buffer_size) };\n        buffer.fill(0);\n        for (i, v) in values.iter().enumerate() {\n            if let Some(v) = v {\n                let v = v.as_ref();\n                unsafe {\n                    let dst = buffer.as_mut_ptr().add(buffer_length * i);\n                    std::intrinsics::copy_nonoverlapping(v.as_ptr(), dst, v.len());\n                }\n            }\n        }\n        TaosMultiBind {\n            buffer_type: Ty::VarChar as _,\n            buffer: buffer.as_ptr() as _,\n            buffer_length,\n            length: length.as_ptr() as _,\n            is_null: nulls.as_ptr() as _,\n            num: num as _,\n        }\n    }\n    pub(crate) fn from_string_vec(values: \u0026[Option\u003cimpl AsRef\u003cstr\u003e\u003e]) -\u003e Self {\n        let values: Vec\u003c_\u003e = values\n            .iter()\n            .map(|f| {\n                f.as_ref()\n                    .map(|s| dbg!(s.as_ref().to_string()).into_bytes())\n            })\n            .collect();\n        let mut s = Self::from_binary_vec(\u0026values);\n        s.buffer_type = Ty::NChar as _;\n        s\n    }\n\n    pub(crate) fn buffer(\u0026self) -\u003e *const c_void {\n        self.buffer\n    }\n}\n\nimpl Drop for TaosMultiBind {\n    fn drop(\u0026mut self) {\n        let ty = Ty::from(self.buffer_type as u8);\n        // if ty == Ty::VarChar || ty == Ty::NChar {\n        //     let len = self.buffer_length * self.num as usize;\n        //     unsafe { Vec::from_raw_parts(self.buffer as *mut u8, len, len as _) };\n        //     unsafe { Vec::from_raw_parts(self.length as *mut i32, self.num as _, self.num as _) };\n        // }\n        unsafe { Vec::from_raw_parts(self.is_null as *mut i8, self.num as _, self.num as _) };\n    }\n}\n\nimpl\u003c'c\u003e From\u003c\u0026'c Column\u003e for TaosMultiBind {\n    fn from(col: \u0026'c Column) -\u003e Self {\n        match col {\n            Column::Null(n) =\u003e Self::nulls(*n),\n            Column::Bool(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::TinyInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::SmallInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Int(nulls, values) =\u003e Self::from_primitives(nulls.clone().into_bools(), values),\n            Column::BigInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UTinyInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::USmallInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::UBigInt(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Float(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Double(nulls, values) =\u003e {\n                Self::from_primitives(nulls.clone().into_bools(), values)\n            }\n            Column::Timestamp(nulls, values) =\u003e {\n                Self::from_raw_timestamps(nulls.clone().into_bools(), values)\n            }\n            Column::Binary(values) =\u003e Self::from_binary_vec(values),\n            Column::NChar(values) =\u003e Self::from_string_vec(values),\n            Column::Json(_, _) =\u003e todo!(),\n            Column::VarChar(_, _) =\u003e todo!(),\n            Column::VarBinary(_, _) =\u003e todo!(),\n            Column::Decimal(_, _) =\u003e todo!(),\n            Column::Blob(_, _) =\u003e todo!(),\n            // _ =\u003e unreachable!(),\n        }\n    }\n}\n\nimpl\u003c'b\u003e From\u003cBorrowedColumn\u003c'b\u003e\u003e for TaosMultiBind {\n    fn from(col: BorrowedColumn\u003c'b\u003e) -\u003e Self {\n        use BorrowedColumn::*;\n        match col {\n            Null(n) =\u003e Self::nulls(n),\n            Bool(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            TinyInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            SmallInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Int(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            BigInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UTinyInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            USmallInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            UBigInt(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Float(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Double(nulls, values) =\u003e TaosMultiBind::from_primitives(nulls.into_bools(), values),\n            Timestamp(nulls, values) =\u003e {\n                TaosMultiBind::from_raw_timestamps(nulls.into_bools(), values)\n            }\n            Binary(values) =\u003e TaosMultiBind::from_binary_vec(\u0026values),\n            NChar(values) =\u003e TaosMultiBind::from_string_vec(\u0026values),\n            _ =\u003e unreachable!(),\n        }\n    }\n}\n\n// impl\u003c'b, 'c\u003e From\u003c\u0026'c BorrowedColumn\u003c'b\u003e\u003e for MultiBind\u003c'c\u003e {\n//     fn from(col: \u0026'c BorrowedColumn\u003c'b\u003e) -\u003e Self {\n//         match col {\n//             BorrowedColumn::Null(n) =\u003e MultiBind::nulls(*n),\n//             BorrowedColumn::Bool(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::TinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::SmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Int(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::BigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UTinyInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::USmallInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::UBigInt(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Float(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Double(nulls, values) =\u003e MultiBind::from_primitives(nulls, values),\n//             BorrowedColumn::Timestamp(nulls, values) =\u003e {\n//                 MultiBind::from_raw_timestamps(nulls, values)\n//             }\n//             BorrowedColumn::Binary(values) =\u003e MultiBind::from_binary_vec(values),\n//             BorrowedColumn::NChar(values) =\u003e MultiBind::from_string_vec(values),\n//             _ =\u003e unreachable!(),\n//         }\n//     }\n// }\n\n// impl\u003cT\u003e From\u003cVec\u003cT\u003e\u003e for TaosMultiBind {\n//     fn from(_: Vec\u003cT\u003e) -\u003e Self {\n//         todo!()\n//     }\n// }\n","traces":[{"line":50,"address":[8136144],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":51,"address":[8136284,8136328,8136504,8136372,8136460,8136416,8136240,8136163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[8136236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[8136280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[8136324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[8136368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[8136412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[8136456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[8136500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[8136576],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":91,"address":[8136597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[8136784],"length":1,"stats":{"Line":0},"fn_name":"null"},{"line":103,"address":[8136927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8137008,8137254],"length":1,"stats":{"Line":0},"fn_name":"from_timestamp"},{"line":123,"address":[8137038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[8137107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[8137116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[8137142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[8137173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[8137201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[8137280,8137559],"length":1,"stats":{"Line":0},"fn_name":"from_varchar"},{"line":132,"address":[8137323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[8137354,8137422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[8137427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[8137449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[8137480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[8137506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8137879,8137600],"length":1,"stats":{"Line":0},"fn_name":"from_nchar"},{"line":141,"address":[8137643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[8137674,8137742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[8137747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[8137769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[8137800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[8137826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[8137920],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":162,"address":[8137988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[8138027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[8138075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[8138122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[8138161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[8138165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[8138240],"length":1,"stats":{"Line":0},"fn_name":"buffer"},{"line":180,"address":[8138245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[8138256],"length":1,"stats":{"Line":0},"fn_name":"ty"},{"line":184,"address":[8138265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[8138288],"length":1,"stats":{"Line":0},"fn_name":"free"},{"line":189,"address":[8138302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[8138413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[8138459,8138392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[8138491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[8138470,8138523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[8138555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[8138534,8138587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[8138603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[8103040,8103088],"length":1,"stats":{"Line":0},"fn_name":"from_binary\u003ctaos_sys::types::TaosBindV2\u003e"},{"line":211,"address":[8103109,8103061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[8103136,8103248,8103360],"length":1,"stats":{"Line":0},"fn_name":"box_into_raw\u003ci64\u003e"},{"line":216,"address":[8103329,8103227,8103451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[8138640,8138841],"length":1,"stats":{"Line":0},"fn_name":"null"},{"line":222,"address":[8138657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[8138798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[8138803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[8139030,8138864],"length":1,"stats":{"Line":0},"fn_name":"from_timestamp"},{"line":228,"address":[8138891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[8138950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[8138958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[8138988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[8139056,8139256],"length":1,"stats":{"Line":0},"fn_name":"from_varchar"},{"line":236,"address":[8139093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[8139118,8139182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[8139186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[8139212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[8139280,8139480],"length":1,"stats":{"Line":0},"fn_name":"from_nchar"},{"line":244,"address":[8139317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[8139342,8139406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[8139410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[8139436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[8102048],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":262,"address":[8102053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[8139504],"length":1,"stats":{"Line":0},"fn_name":"nulls"},{"line":371,"address":[8139621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[8108806,8104385,8105366,8107814,8108310,8108336,8108279,8106358,8106327,8107840,8103472,8103942,8105831,8105888,8106384,8107318,8106801,8105862,8104416,8107783,8105335,8106832,8104432,8104880,8107344,8106848,8103968,8104849,8103911,8105392,8108775,8107287,8104896],"length":1,"stats":{"Line":0},"fn_name":"from_primitives\u003cu32\u003e"},{"line":376,"address":[8103536,8107408,8104496,8106448,8106912,8104960,8105456,8104032,8107904,8105952,8108400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[8104976,8104512,8107424,8103552,8106464,8105968,8104048,8106928,8105472,8107920,8108416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[8103629,8107501,8104117,8107997,8105053,8106533,8106045,8104581,8108493,8105549,8107005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[8108666,8107522,8108514,8108170,8108018,8103802,8104138,8104602,8103650,8105570,8105226,8107674,8106218,8106066,8105722,8104742,8105074,8107178,8104278,8106694,8106554,8107026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[8107204,8105252,8103828,8108196,8106244,8105748,8104768,8107700,8106720,8108692,8104304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[8140134,8140103,8139664],"length":1,"stats":{"Line":0},"fn_name":"from_raw_timestamps"},{"line":386,"address":[8139728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[8139744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[8139821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[8139994,8139842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[8140020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[8110992,8108832],"length":1,"stats":{"Line":0},"fn_name":"from_binary_vec\u003c\u0026[u8]\u003e"},{"line":396,"address":[8108898,8111058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[8108910,8111070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[8108918,8111078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[8111236,8109076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[8109122,8111282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8109176,8111336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[8111494,8109334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[8111739,8111516,8109356,8109579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[8109776,8111936,8109627,8111787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[8111824,8109664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[8112004,8109844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[8112080,8109890,8109920,8112050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[8112072,8109912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[8109744,8111904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[8112093,8109933,8109544,8109957,8111704,8112117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[8109941,8112101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[8110131,8112291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[8110177,8112337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[8112399,8110239,8110453,8112613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[8110495,8112655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[8112693,8110533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[8112759,8110599,8112864,8110704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[8112914,8110754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[8112956,8110448,8112608,8110796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[8110854,8113014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[8113059,8110899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[8113424,8113152,8113373,8113645],"length":1,"stats":{"Line":0},"fn_name":"from_string_vec\u003c\u0026str\u003e"},{"line":437,"address":[8113205,8113477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[8113696,8113776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c\u0026str\u003e"},{"line":440,"address":[8113813,8113733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[8113906,8114640,8114690,8113856],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003calloc::string::String\u003e"},{"line":444,"address":[8113614,8113540,8113268,8113342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[8113626,8113354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[8140160],"length":1,"stats":{"Line":0},"fn_name":"buffer"},{"line":450,"address":[8140165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[8102064],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":456,"address":[8102078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[8102098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[8141579,8140176,8141545],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":468,"address":[8140223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[8140372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[8140409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[8143583,8140444,8143433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[8140471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[8143411,8143261,8140506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[8140533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[8143239,8143089,8140568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[8140595,8142917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[8140657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[8140692,8142745,8142895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[8140999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[8142133,8141034,8141971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[8141061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[8141787,8141949,8141096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[8141123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[8141158,8141765,8141603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[8141185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[8141389,8141220,8141560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[8140719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[8142723,8142573,8140754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[8140781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[8142401,8142551,8140816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[8140890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[8142189,8140925,8142345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[8140843,8142391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[8140952,8142179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[8147384,8146679,8143616],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":519,"address":[8143661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[8143975,8147139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[8144005,8147127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[8147083,8144191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[8147039,8144377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[8146995,8144563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[8146951,8144749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[8145649,8146570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[8146529,8145835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[8146488,8146021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[8146177,8146423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[8144935,8146907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[8145121,8146863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[8145385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[8145531,8146722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[8146734,8145307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[8146582,8145571],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":199},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","info.rs"],"content":"use taos_sys::ffi::taos_get_client_info;\n\nuse std::ffi::CStr;\n\n#[test]\nfn test_server_info() {\n    let info = unsafe { CStr::from_ptr(taos_get_client_info()) }.to_string_lossy();\n    println!(\"{}\", dbg!(\u0026info));\n    assert!(info.contains(\".\"))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","query_a.rs"],"content":"use std::{ffi::*, os::raw::c_int};\n\n#[test]\n#[cfg(taos_v2)]\nfn test_query_a() {\n    use taos_sys::*;\n\n    use std::sync::mpsc::channel;\n    use std::sync::mpsc::Sender;\n    pub struct CallbackArg {\n        pub sender: Sender\u003ci32\u003e,\n    }\n    pub unsafe extern \"C\" fn async_query_callback(\n        param: *mut c_void,\n        res: *mut c_void,\n        code: c_int,\n    ) {\n        assert!(code == 0);\n        let _ = RawRes::from_ptr(res);\n        let param = param as *mut CallbackArg;\n        let args = Box::from_raw(param);\n\n        let CallbackArg { sender } = *args;\n\n        sender.send(12).unwrap();\n    }\n\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )\n    .expect(\"connect\");\n    let (sender, receiver) = channel();\n    let args = CallbackArg { sender };\n    let args = Box::new(args);\n    taos.query_a(\n        b\"show databases\\0\" as *const u8 as _,\n        async_query_callback,\n        Box::into_raw(args) as *mut c_void,\n    );\n    let msg = receiver.recv().unwrap();\n    println!(\"received: {msg}\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","raw_block.rs"],"content":"// todo: some const functions are not available for stable Rust.\n#![feature(const_slice_from_raw_parts)]\n#![feature(const_slice_index)]\n\nuse once_cell::unsync::OnceCell;\nuse taos_query::{\n    common::{Column, Field, Timestamp, Ty, Value},\n    BlockExt,\n};\nuse taos_sys::Precision;\n\nuse core::slice;\nuse std::{\n    fmt::Debug,\n    mem::transmute,\n    mem::{size_of, transmute_copy},\n    ops::Deref,\n};\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\n#[repr(packed(2))] // use packed(2) because it's int16_t in raw block.\npub struct ColSchema {\n    ty: Ty,\n    len: u32,\n}\n\n#[test]\nfn col_schema() {\n    let col = ColSchema {\n        ty: Ty::BigInt,\n        len: 1,\n    };\n    let bytes: [u8; 6] = unsafe { transmute_copy(\u0026col) };\n    dbg!(\u0026bytes);\n\n    let bytes: [u8; 6] = [4, 0, 1, 0, 0, 0];\n    let col2: ColSchema = unsafe { transmute_copy(\u0026bytes) };\n    dbg!(col2);\n}\n#[test]\nfn test_bin() {\n    let v: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    let ptr = v.as_ptr();\n\n    let v_u16 = unsafe { *transmute::\u003c*const u8, *const u16\u003e(ptr) };\n    println!(\"{v_u16:#x?}: {:?}\", v_u16.to_le_bytes());\n    #[derive(Debug, Clone, Copy)]\n    #[repr(packed)]\n    #[allow(dead_code)]\n    struct A {\n        a: u16,\n        b: u32,\n    }\n    println!(\"A size: {}\", std::mem::size_of::\u003cA\u003e());\n    let a: \u0026A = unsafe { transmute::\u003c*const u8, *const A\u003e(ptr).as_ref().unwrap() };\n    println!(\"{a:#x?}\");\n}\n\npub struct RawBlock {\n    data: Vec\u003cu8\u003e,\n    len: usize,\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: Vec\u003c(Ty, isize, isize)\u003e,\n}\n\nimpl RawBlock {\n    pub unsafe fn copy_from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -\u003e Self {\n        let len = *transmute::\u003c*const u8, *const u32\u003e(data) as usize + 4;\n        Self {\n            data: slice::from_raw_parts(data, len).into(),\n            len,\n            rows,\n            cols,\n            precision,\n            offsets: Vec::new(),\n        }\n    }\n}\n\n/// Raw data block format:\n///\n/// ```text,ignore\n/// +--------------+----------+---------------+-----------+-----------------------+-----------------+\n/// | total length | group id | col_schema... | length... | (bitmap or offsets    | col data)   ... |\n/// |  4 bytes     | 8 bytes  | (2 + 4) * cols| 4 * cols  | (row+7)/8 or 4 * rows | length[col] ... |\n/// +--------------+----------+---------------+-----------+-----------------------+-----------------+\n/// ```\n///\n/// The length of bitmap is decided by number of rows of this data block, and the length of each column data is\n/// recorded in the first segment, next to the struct header\n#[derive(Debug)]\npub struct InnerBlock {\n    data: *const u8,\n    len: usize,\n    rows: usize,\n    cols: usize,\n    precision: Precision,\n    offsets: OnceCell\u003cVec\u003c(Ty, isize, isize)\u003e\u003e,\n}\n\nimpl InnerBlock {\n    /// From raw data block.\n    pub unsafe fn from_ptr(\n        data: *const u8,\n        rows: usize,\n        cols: usize,\n        precision: Precision,\n    ) -\u003e Self {\n        let len = *transmute::\u003c*const u8, *const u32\u003e(data) as usize + 4;\n        Self {\n            data,\n            len,\n            rows,\n            cols,\n            precision,\n            offsets: OnceCell::new(),\n        }\n    }\n\n    /// The whole block slice length.\n    pub const fn len(\u0026self) -\u003e usize {\n        unsafe { *transmute::\u003c*const u8, *const u32\u003e(self.as_ptr()) as usize + 4 }\n    }\n\n    /// The group id of the raw block.\n    pub const fn group_id(\u0026self) -\u003e u64 {\n        unsafe { *std::mem::transmute::\u003c*const u8, *const u64\u003e(self.as_ptr()) }\n    }\n\n    /// Inner block as bytes slice.\n    pub const fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        unsafe { slice::from_raw_parts(self.data, self.len) }\n    }\n\n    /// Raw data block bytes.\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n        self.as_bytes().to_owned()\n    }\n\n    /// Pointer to raw block data slice.\n    const fn as_ptr(\u0026self) -\u003e *const u8 {\n        self.data\n    }\n\n    /// Offset to column schema start position.\n    const fn schema_offset(\u0026self) -\u003e isize {\n        // 4 = block data length.\n        // 8 = group id.\n        4 + 8\n    }\n\n    /// Offset to lengths start position.\n    const fn lengths_offset(\u0026self) -\u003e isize {\n        // 6 == size_of::\u003cColumnSchema\u003e()\n        self.schema_offset() + self.cols as isize * 6\n    }\n\n    /// Offset to column data start position.\n    const fn data_offset(\u0026self) -\u003e isize {\n        self.lengths_offset() + self.cols as isize * 4\n    }\n\n    /// Pointer to specific offset.\n    const unsafe fn offset(\u0026self, count: isize) -\u003e *const u8 {\n        self.as_ptr().offset(count)\n    }\n\n    /// Length of each bitmap block.\n    const fn bitmap_len(\u0026self) -\u003e usize {\n        (self.rows + 7) / 8\n    }\n\n    /// A lazy-init-ed index to each column.\n    ///\n    /// For each column, the index is a 3-element tuple:\n    ///\n    /// 0. Column data type represented as [Ty]\n    /// 1. Offset to column data start position relative to the block front.\n    ///   - For var-type, it's a `rows` length `i32` vector contains the offsets to each row.\n    ///   - For non-var-type, it's the is-null bitmap.\n    /// 2. Offset to the start position of real column data.\n    fn column_offsets(\u0026self) -\u003e \u0026[(Ty, isize, isize)] {\n        self.offsets.get_or_init(|| {\n            let lengths = self.lengths();\n            let mut data_offset = self.data_offset();\n            self.schemas()\n                .iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    assert!(data_offset \u003c self.len() as isize);\n                    if col.ty.is_var_type() {\n                        let o = (col.ty, data_offset, data_offset + 4 * self.rows as isize);\n                        data_offset = o.2 + lengths[i] as isize;\n                        o\n                    } else {\n                        let o = (\n                            col.ty,\n                            data_offset,\n                            data_offset + self.bitmap_len() as isize,\n                        );\n                        data_offset = o.2 + lengths[i] as isize;\n\n                        assert!(data_offset \u003c self.len() as isize);\n                        o\n                    }\n                })\n                .collect()\n        })\n    }\n\n    /// Column schema extractor.\n    #[inline]\n    pub const fn schemas(\u0026self) -\u003e \u0026[ColSchema] {\n        unsafe {\n            let ptr = self.offset(self.schema_offset());\n            slice::from_raw_parts(ptr as *mut ColSchema, self.cols)\n        }\n    }\n    /// Get column data type.\n    #[inline]\n    pub const fn get_type_of(\u0026self, col: usize) -\u003e Ty {\n        self.get_schema_of(col).ty\n    }\n\n    /// Get column schema which includes data type and bytes length.\n    #[inline]\n    pub const fn get_schema_of(\u0026self, col: usize) -\u003e \u0026ColSchema {\n        unsafe { self.schemas().get_unchecked(col) }\n    }\n\n    #[inline]\n    /// Lengths for each column raw data.\n    const fn lengths(\u0026self) -\u003e \u0026[i32] {\n        unsafe {\n            let ptr = self.offset(self.lengths_offset());\n            slice::from_raw_parts(ptr as *mut i32, self.cols)\n        }\n    }\n\n    #[inline]\n    /// Get one value at `(row, col)` of the block.\n    pub unsafe fn get_unchecked(\u0026self, row: usize, col: usize) -\u003e Value {\n        let (ty, o1, o2) = self.column_offsets().get_unchecked(col);\n\n        macro_rules! is_null {\n            ($bm:expr, $row:expr) =\u003e {{\n                (*$bm.offset($row as isize \u003e\u003e 3) \u003e\u003e (7 - ($row \u0026 7)) as u8) \u0026 0x1 == 1\n            }};\n        }\n\n        macro_rules! _primitive_value {\n            ($ty:ident, $native:ty) =\u003e {{\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003c$native\u003e()) as isize)\n                        as *const $native);\n                    Value::$ty(v)\n                }\n            }};\n        }\n\n        match ty {\n            Ty::Null =\u003e Value::Null,\n            Ty::Bool =\u003e _primitive_value!(Bool, bool),\n            Ty::TinyInt =\u003e _primitive_value!(TinyInt, i8),\n            Ty::SmallInt =\u003e _primitive_value!(SmallInt, i16),\n            Ty::Int =\u003e _primitive_value!(Int, i32),\n            Ty::BigInt =\u003e _primitive_value!(BigInt, i64),\n            Ty::Float =\u003e _primitive_value!(Float, f32),\n            Ty::Double =\u003e _primitive_value!(Double, f64),\n            Ty::VarChar =\u003e {\n                //\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    Value::VarChar(\n                        std::str::from_utf8_unchecked(slice::from_raw_parts(\n                            ptr.offset(2),\n                            len as usize,\n                        ))\n                        .to_string(),\n                    )\n                }\n            }\n            Ty::Timestamp =\u003e {\n                let ptr = self.offset(*o1);\n                if is_null!(ptr, row) {\n                    Value::Null\n                } else {\n                    let v = *(self.offset(o2 + (row * size_of::\u003ci64\u003e()) as isize) as *const i64);\n                    Value::Timestamp(Timestamp::new(v, self.precision))\n                }\n            }\n            Ty::NChar =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    \n                    Value::NChar(\n                        slice::from_raw_parts(ptr.offset(2) as *mut char, len as usize / 4)\n                            .into_iter()\n                            .collect(),\n                    )\n                }\n            }\n            Ty::UTinyInt =\u003e _primitive_value!(UTinyInt, u8),\n            Ty::USmallInt =\u003e _primitive_value!(USmallInt, u16),\n            Ty::UInt =\u003e _primitive_value!(UInt, u32),\n            Ty::UBigInt =\u003e _primitive_value!(UBigInt, u64),\n            Ty::Json =\u003e {\n                let offset =\n                    *transmute::\u003c*const u8, *const i32\u003e(self.offset(o1 + row as isize * 4));\n                if offset \u003c 0 {\n                    Value::Null\n                } else {\n                    let ptr = self.offset(o2 + offset as isize);\n                    let len: i16 = *(ptr as *mut i16);\n                    debug_assert!(self.len() as isize \u003e= o1 + row as isize * 4 + len as isize);\n                    let chars_len = len / 4;\n                    let chars_ptr = ptr.offset(2) as *mut char;\n                    let chars = slice::from_raw_parts(chars_ptr, chars_len as usize);\n                    let json: String = chars.into_iter().collect();\n\n                    serde_json::from_str(\u0026json)\n                        .ok()\n                        .map(Value::Json)\n                        .unwrap_or(Value::Null)\n                }\n            }\n            ty =\u003e unreachable!(\"unsupported type: {ty}\"),\n        }\n    }\n}\n\n#[test]\nfn raw_block() -\u003e Result\u003c(), taos_error::Error\u003e {\n    use taos_sys::*;\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )?;\n    let rs = taos.query(\"show databases\")?;\n    let fields = rs.fields();\n    let precision = rs.precision();\n    let field_count = rs.field_count();\n    let (ptr, rows) = rs.fetch_raw_block()?;\n\n    let inner = unsafe { InnerBlock::from_ptr(ptr, rows as _, field_count as _, precision) };\n    let gid = inner.group_id();\n    println!(\"group id: {gid}\");\n\n    for i in 0..field_count {\n        let col = inner.get_schema_of(i as _);\n        let field = \u0026fields[i as usize];\n        println!(\"{field:?}, {col:#x?}\");\n    }\n\n    let schemas = inner.schemas();\n    dbg!(schemas);\n    let lengths = inner.lengths();\n    dbg!(lengths);\n    let offsets = inner.column_offsets();\n    dbg!(offsets);\n\n    dbg!(unsafe { inner.get_unchecked(0, field_count as usize - 1) });\n    for row in 0..dbg!(rows) as usize {\n        for col in 0..field_count as usize {\n            println!(\"({row}, {col}): \");\n            let v = unsafe { inner.get_unchecked(row, col) };\n            dbg!(v);\n        }\n    }\n    Ok(())\n}\n\n// impl BlockExt for InnerBlock {\n//     fn num_of_rows(\u0026self) -\u003e usize {\n//         todo!()\n//     }\n\n//     fn fields(\u0026self) -\u003e \u0026[Field] {\n//         todo!()\n//     }\n\n//     fn precision(\u0026self) -\u003e Precision {\n//         todo!()\n//     }\n\n//     fn is_null(\u0026self, row: usize, col: usize) -\u003e bool {\n//         todo!()\n//     }\n\n//     unsafe fn cell_unchecked(\n//         \u0026self,\n//         row: usize,\n//         col: usize,\n//     ) -\u003e (\u0026Field, taos_query::common::BorrowedValue) {\n//         todo!()\n//     }\n\n//     unsafe fn get_col_unchecked(\u0026self, col: usize) -\u003e taos_query::common::BorrowedColumn {\n//         todo!()\n//     }\n// }\n\n#[test]\nfn inner_block() {\n    use taos_query::common::Timestamp::Milliseconds;\n    use taos_sys::Precision::Millisecond;\n    let bytes = b\"5\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\t\\x00\\x08\\x00\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x08\\x00\\x00\\x00\\x0b\\x00\\x01\\x00\\x00\\x00\\x0c\\x00\\x02\\x00\\x00\\x00\\r\\x00\\x04\\x00\\x00\\x00\\x0e\\x00\\x08\\x00\\x00\\x00\\x06\\x00\\x04\\x00\\x00\\x00\\x07\\x00\\x08\\x00\\x00\\x00\\x08\\x00f\\x00\\x00\\x00\\n\\x00\\x92\\x01\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x00\\xf2=\\xc3u\\x81\\x01\\x00\\x00\\xdaA\\xc3u\\x81\\x01\\x00\\x00@\\x01\\x00@\\xff\\x00@\\xff\\xff\\x00\\x00@\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00@\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00@\\x01\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x03\\x00abc\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x14\\x00\\x9bm\\x00\\x00\\x1d`\\x00\\x00\\x1e\\xd1\\x01\\x00pe\\x00\\x00nc\\x00\\x00\\x00\\x00\\x00\\x00\";\n    let rows = 2;\n    let cols = 14;\n    let precision = Millisecond;\n\n    let block = unsafe { InnerBlock::from_ptr(bytes.as_ptr(), rows, cols, precision) };\n\n    assert_eq!(block.as_bytes(), bytes);\n    assert_eq!(block.len(), bytes.len());\n\n    use Value::*;\n    let values = vec![\n        vec![\n            Timestamp(Milliseconds(1655538138610)),\n            Bool(true),\n            Value::TinyInt(-1),\n            SmallInt(-1),\n            Int(-1),\n            BigInt(-1),\n            UTinyInt(1),\n            USmallInt(1),\n            UInt(1),\n            UBigInt(1),\n            Float(0.0),\n            Double(0.0),\n            VarChar(\"abc\".to_string()),\n            NChar(\"\".to_string()),\n        ],\n        {\n            Some(Timestamp(Milliseconds(1655538139610)))\n                .into_iter()\n                .chain(std::iter::repeat(Value::Null).take(14))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        },\n    ];\n    assert!(block.cols == 14);\n\n    for row in 0..rows {\n        for col in 0..block.cols {\n            let v = unsafe { block.get_unchecked(row, col) };\n            assert_eq!(v, values[row][col]);\n        }\n    }\n}\n\n#[test]\nfn raw_block_full_test() -\u003e Result\u003c(), taos_error::Error\u003e {\n    use taos_sys::*;\n    let taos = RawTaos::connect(\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        std::ptr::null(),\n        0,\n    )?;\n\n    let _ = taos.query(\"drop database if exists _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"create database if not exists _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"use _rs_ts_raw_block_full_\")?;\n    let _ = taos.query(\"create stable stb1 (ts timestamp,vb bool,vi8 tinyint,vi16 smallint,\\\n        vi32 int,vi64 bigint, vu8 tinyint unsigned,vu16 smallint unsigned,vu32 int unsigned,vu64 bigint unsigned,\\\n        vf float,vd double,vv varchar(100), vn nchar(100)) tags(tj json)\")?;\n\n    let _ = taos.query(\n        \"insert into tb1 using stb1 tags(NULL) values\\\n        (now,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\",\n    )?;\n    let _ = taos.query(\n        \"insert into tb2 using stb1 tags('{\\\"a\\\":\\\"\\\"}') values\\\n        (now,true,-1,-1,-1,-1, 1,1,1,1,0.0,0.0,'abc', '')\\\n        (now+1s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)\",\n    )?;\n    let rs = taos.query(\"select * from tb2 order by tbname\")?;\n    let fields = rs.fields();\n    let precision = rs.precision();\n    let field_count = rs.field_count();\n    let (ptr, rows) = rs.fetch_raw_block()?;\n\n    let inner = unsafe { InnerBlock::from_ptr(ptr, rows as _, field_count as _, precision) };\n    let gid = inner.group_id();\n    println!(\"group id: {gid}\");\n\n    use std::ascii::escape_default;\n\n    pub fn show_buf\u003cB: AsRef\u003c[u8]\u003e\u003e(buf: B) -\u003e String {\n        String::from_utf8(\n            buf.as_ref()\n                .iter()\n                .map(|b| escape_default(*b))\n                .flatten()\n                .collect(),\n        )\n        .unwrap()\n    }\n\n    dbg!(inner.len());\n    dbg!(inner.as_bytes());\n    let bytes = inner.to_vec();\n    println!(\"{}\", show_buf(bytes));\n\n    for i in 0..field_count {\n        let col = inner.get_schema_of(i as _);\n        let field = \u0026fields[i as usize];\n        println!(\"{field:?}, {col:#x?}\");\n    }\n\n    let schemas = inner.schemas();\n    dbg!(schemas);\n    let lengths = inner.lengths();\n    dbg!(lengths);\n    let offsets = inner.column_offsets();\n    dbg!(offsets);\n\n    dbg!(unsafe { inner.get_unchecked(0, field_count as usize - 1) });\n    for row in 0..dbg!(rows) as usize {\n        for col in 0..field_count as usize {\n            println!(\"({row}, {col}): \");\n            let v = unsafe { inner.get_unchecked(row, col) };\n\n            dbg!(v);\n        }\n    }\n    Ok(())\n}\n\n#[test]\nfn char_size() {\n    assert_eq!(size_of::\u003cchar\u003e(), 4);\n}\n","traces":[{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":84},{"path":["/","home","huolinhe","Projects","taosdata","taosx","taos-sys","tests","time.rs"],"content":"use taos_sys::{ffi::*, *};\n\n#[test]\n#[cfg(taos_parse_time)]\nfn test_parse_time() {\n    use std::ffi::CString;\n    let s = CString::new(\"1970-01-01 00:00:00\").unwrap();\n    let mut time = 0i64;\n    unsafe {\n        taos_options(\n            TSDB_OPTION_TIMEZONE,\n            b\"Europe/Landon\\0\" as *const u8 as *const _,\n        )\n    };\n    let res = unsafe {\n        taos_parse_time(\n            s.as_ptr(),\n            \u0026mut time as _,\n            s.to_bytes().len() as _,\n            Precision::Microsecond,\n            0,\n        )\n    };\n    assert_eq!(res, 0, \"success\");\n    assert_eq!(time, 0, \"parse time\");\n\n    let s = CString::new(\"1970-01-01 08:00:00\").unwrap(); // CST +8\n                                                          // timezone could be set multiple times\n    unsafe {\n        taos_options(\n            TSDB_OPTION_TIMEZONE,\n            b\"Asia/Shanghai\\0\" as *const u8 as *const _,\n        )\n    };\n    let res = unsafe {\n        taos_parse_time(\n            s.as_ptr(),\n            \u0026mut time as _,\n            s.to_bytes().len() as _,\n            Precision::Microsecond,\n            0,\n        )\n    };\n    assert_eq!(res, 0, \"success\");\n    assert_eq!(time, 0, \"parse time\");\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>